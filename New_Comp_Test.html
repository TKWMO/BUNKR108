<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <script>
        // Ensure callers can safely reference window.normalizeGreek (and common misspellings/variants)
        // before the real implementation is defined. These are safe passthroughs and will be
        // overwritten by the real implementations later in the file.
        try {
            // One-time-notifying fallback: returns the input unchanged but warns once if used.
            let __ng_warned = false;
            const fallback = function (s) {
                if (!__ng_warned) {
                    try { console.warn('[notice] normalizeGreek fallback used before real implementation was parsed.'); } catch (e) {}
                    __ng_warned = true;
                }
                return s;
            };
            if (!window.normalizeGreek) window.normalizeGreek = fallback;
            // Common variants/misspellings observed in older scripts or third-party snippets
            if (!window.normalizegreek) window.normalizegreek = window.normalizeGreek;
            if (!window.normalizedGreek) window.normalizedGreek = window.normalizeGreek;
            if (!window.normalizedgreek) window.normalizedgreek = window.normalizeGreek;
        } catch (e) { /* noop in restrictive environments */ }
    </script>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <!-- Open Graph / Twitter preview metadata for link sharing -->
    <meta property="og:title" content="BUNKR 108 — AI-powered Study Interface" />
    <meta name="twitter:title" content="BUNKR 108 — AI-powered Study Interface" />
    <meta name="description" content="BUNKR 108 — AI-powered Study Interface for generating and reviewing multiple-choice questions locally in your browser." />
    <meta name="twitter:description" content="AI-powered, client-side MCQ generator and study tool. Run locally in your browser." />
    <meta property="og:description" content="AI-powered, client-side MCQ generator and study tool. Run locally in your browser." />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="BUNKR 108" />
    <meta name="twitter:card" content="summary" />
    <title>BUNKR 108 — AI-powered Study Interface</title>
    <!-- KaTeX for rendering LaTeX/math in quiz items and AI outputs -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="" crossorigin="anonymous">
    <script>
        // Lightweight dynamic loader for KaTeX + auto-render. Usage: window.renderMathIn(element, opts)
        (function(){
            if(window.renderMathIn) return;
            window.__katexReady = false; window.__katexQueue = [];
            function loadScript(url){ return new Promise((res,rej)=>{ const s=document.createElement('script'); s.src=url; s.async=true; s.onload=res; s.onerror=()=>rej(new Error('load failed '+url)); document.head.appendChild(s); }); }
            function _flush(){ try{ while(window.__katexQueue && window.__katexQueue.length){ const job = window.__katexQueue.shift(); try{ if(window.renderMathInElement) renderMathInElement(job.el, job.opts||{}); else if(window.katex && job.el) { /* best-effort: render inline $...$ by replacing via katex.renderToString is too invasive; prefer auto-render */ } }catch(e){ console.warn('katex render failed', e); } } }catch(e){ console.warn('katex flush error', e); } }
            async function _load(){ if(window.katex && window.renderMathInElement){ window.__katexReady = true; _flush(); return; } try{ await loadScript('https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js'); await loadScript('https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js'); window.__katexReady = true; _flush(); }catch(e){ console.warn('KaTeX load failed', e); }
            }
            // Safe render wrapper: decides whether to enable single-$ inline delimiters
            function _looksLikeMathBetweenDollar(s){
                // s is the content between $...$
                // Heuristic: require either a backslash (\command) or math-operator/special char
                try{
                    if(!s || typeof s !== 'string') return false;
                    if(/\\[a-zA-Z]+/.test(s)) return true; // \frac, \alpha, etc.
                    if(/[=+\-\^_{}<>\/]/.test(s)) return true;
                    // presence of digits with letters/operators suggests math (e.g., 2x, x^2)
                    if(/[0-9].*[a-zA-Z]|[a-zA-Z].*[0-9]/.test(s)) return true;
                    return false;
                }catch(e){ return false; }
            }
            window.renderMathIn = function(el, opts){ try{ if(!el) return; const job = { el: el, opts: opts }; if(window.__katexReady && window.renderMathInElement){ try{
                        // Determine delimiters: always include display delimiters, but only include single-$
                        // when the content shows math-like patterns between $...$ to avoid false positives
                        const defaultDelims = [{left:'$$',right:'$$',display:true},{left:'\\[',right:'\\]',display:true},{left:'\\(',right:'\\)',display:false}];
                        let useDollar = false;
                        try{
                            const text = (el.textContent || el.innerText || '');
                            // find $...$ pairs
                            const re = /\$(.+?)\$/gs;
                            let m;
                            while((m = re.exec(text)) !== null){ if(_looksLikeMathBetweenDollar(m[1])){ useDollar = true; break; } }
                        }catch(e){}
                        const delims = defaultDelims.slice();
                        if(useDollar){ delims.push({left:'$',right:'$',display:false}); }
                        renderMathInElement(el, Object.assign({delimiters: delims}, opts||{}));
                    }catch(e){ console.warn('renderMathInElement failed', e); } } else { window.__katexQueue.push(job); _load(); } }catch(e){ console.warn('renderMathIn wrapper failed', e); } };
        })();
    </script>
    <style>
        :root {
            --bg: #070b12;
            --ink: #e9f0f7;
            --muted: #9fb0c5;
            --panel: #0c1320aa;
            .flex-wrap {
                flex-wrap: wrap
            }
            --stroke: #1f2a44aa;
            --brand: #6aa9ff;
            --ok: #22c55e;
            --bad: #ef4444;
            --glass-blur: 14px;
            --depth: 0 12px 30px rgba(0, 0, 0, .35), inset 0 1px 0 rgba(255, 255, 255, .04);
            /* Themeable lighting + buttons */
            --glow1: rgba(74, 144, 255, .20);
            --glow2: rgba(112, 220, 255, .14);
            --glow3: rgba(130, 100, 255, .16);
            --btnTop: rgba(96, 165, 250, .35);
            --btnBottom: rgba(24, 60, 120, .65);
            --btnBorder: #1f3a64;
        }

        * {
            box-sizing: border-box
        }

        html,
            .flex-wrap {
                flex-wrap: wrap
            }
        body {
            height: 100%
        }

        body {
            margin: 0;
            color: var(--ink);
            font: 16px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Helvetica, Arial;
            overflow-x: hidden;
            background: #060a12;
            
        }

        /* fixed animated gradient layer (doesn't reset on scroll) */
        .bg-anim {
            position: fixed;
            /* Use viewport-based insets to avoid percent-based shrink on tab restore */
            top: -25vh; left: -25vw; right: -25vw; bottom: -25vh;
            z-index: -1;
            pointer-events: none;
            transform: translateZ(0);
            will-change: transform;
            filter: blur(60px) saturate(130%);
            background:
                radial-gradient(1100px 700px at 12% 18%, var(--glow1), transparent 90%),
                radial-gradient(900px 600px at 88% 12%, var(--glow2), transparent 92%),
                radial-gradient(900px 650px at 45% 88%, var(--glow3), transparent 90%);
            animation: bgDrift 22s ease-in-out infinite alternate;
        }
        /* Lighter effect on small screens to save battery/GPU */
        @media (max-width: 640px){
            .bg-anim{ filter: blur(40px) saturate(120%); }
        }

        /* Custom button colors */
        .btn#skipBtn {
            background: linear-gradient(180deg, var(--btnTop), var(--btnBottom));
            border-color: var(--btnBorder);
        }

        .btn#skipBtn:hover {
            filter: brightness(1.08);
        }

        .btn#submitBtn {
            background: linear-gradient(180deg, rgba(34, 197, 94, .6), rgba(16, 83, 44, .9));
            border-color: #22c55e;
        }

        .btn#submitBtn:hover {
            background: linear-gradient(180deg, rgba(54, 217, 114, .7), rgba(26, 93, 54, .95));
        }

        @keyframes bgDrift {
            0% {
                transform: translate3d(-1%, -1%, 0) scale(1.02);
            }

            50% {
                transform: translate3d(1%, 2%, 0) scale(1.035);
            }

            100% {
                transform: translate3d(3%, -1%, 0) scale(1.02);
            }
        }

        @media (prefers-reduced-motion: reduce) {
            .bg-anim {
                animation: none;
            }
        }

        .container {
            max-width: 1100px;
            margin: 24px auto;
            padding: 0 16px
        }

        /* When a quiz is running, hide the Random/Daily quiz controls to avoid accidental navigation */
        body.quiz-running #dailyQuizBtn,
        body.quiz-running #randomQuizBtn,
        body.quiz-running #randomGearWrap {
            display: none !important;
        }

            /* Ensure main column can shrink so its children (cards) can fill available width */
            .quizgrid .col:first-child { min-width: 0; }
        @media (max-width: 640px){ .container{ margin: 16px auto; padding: 0 12px; } }

        .card {
            background: var(--panel);
            border: 1px solid var(--stroke);
            border-radius: 18px;
            box-shadow: var(--depth);
            -webkit-backdrop-filter: blur(var(--glass-blur));
            backdrop-filter: blur(var(--glass-blur));
        }

        .pad {
            padding: 18px
        }

        h1 {
            margin: 0 0 6px;
            font-size: 26px;
            text-shadow: 0 1px 0 rgba(0, 0, 0, .35)
        }

        .hint {
            color: var(--muted);
            font-size: 13px
        }

        .row {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: stretch; /* ensure columns match height */
        }

        .col {
            flex: 1 1 300px;
            display: flex;
            flex-direction: column;
            min-height: 0; /* allow children to shrink */
        }

        textarea {
            width: 100%;
            height: 320px; /* base height */
            max-height: none;
            color: var(--ink);
            background: linear-gradient(180deg, rgba(14, 20, 32, .65), rgba(10, 16, 28, .55));
            border: 1px solid rgba(60, 80, 120, .35);
            border-radius: 14px;
            padding: 12px;
            resize: none; /* prevent manual extension */
            overflow: auto; /* allow scrolling */
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, .08)
        }
        @media (max-width: 640px){ textarea{ height: 220px; } }

        /* File input styling */
        .file-input{
            display:flex; align-items:center; gap:8px; width:100%;
            background: linear-gradient(180deg, rgba(14, 20, 32, .65), rgba(10, 16, 28, .55));
            border: 1px solid rgba(60, 80, 120, .35);
            border-radius: 10px; padding: 6px 8px;
        }
        .file-input input[type=file]{ display:none }
        .file-input .choose-btn{
            display:inline-block; padding:6px 10px; border-radius:8px;
            background: linear-gradient(180deg, var(--btnTop), var(--btnBottom));
            border: 1px solid var(--btnBorder); color: var(--ink); font-weight: 700; cursor:pointer;
            font-size: 13px; line-height: 1; box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
        }
          /* Let the Choose File button size to its text content while avoiding layout shifts
              - flex: 0 0 auto keeps it its intrinsic width
              - filename area uses flex:1 so it absorbs variable text (long filenames)
          */
          .file-input .choose-btn{ flex: 0 0 auto; width: auto; min-width: 0; padding:6px 10px; box-sizing: border-box; white-space:nowrap }
          /* Ensure filename area flexes and truncates gracefully when needed */
          .file-input .filename{ flex: 1 1 auto; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap }
          @media (max-width: 760px){ .file-input .choose-btn{ padding:8px 12px } }
        @media (max-width: 640px){ .file-input .choose-btn{ min-height: 44px; display:flex; align-items:center; } }
        .file-input .filename{ flex:1 1 auto; color: var(--muted); font-size: 12px; overflow:hidden; text-overflow: ellipsis; white-space:nowrap }

        .options-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 0px;
            margin-bottom: 10px;
            align-items: center
        }

        /* Theme the checkboxes inside option pills */
        .pill input[type="checkbox"]{ accent-color: var(--brand); }
    .pill input[type="checkbox"]:focus-visible{ outline: 2px solid var(--brand); outline-offset: 2px; border-radius: 4px }

    /* Theme the quiz answer radio bullets to match accent */
    .choice input[type="radio"]{ accent-color: var(--brand); }

        .pill {
            padding: 6px 10px;
            border: 1px solid var(--btnBorder);
            background: linear-gradient(180deg, var(--btnTop), rgba(10, 16, 28, .7));
            border-radius: 999px;
            white-space: nowrap
        }

        /* Align the right column (Options + AI) with the top of the parent panel/header */
        #setup .row.mt-10{ margin-top: 0 } /* remove extra spacer pushing both cols down */
    #setup .row > .col:nth-child(2){ margin-top: -56px } /* lift options to top of parent card */
    /* Push designated bottom modules to the column bottom so both columns meet at the same baseline */
    #setup .row > .col .ai-file-panel, #setup .row > .col .saved-card { margin-top: auto }
    @media (max-width: 900px){ #setup .row > .col:nth-child(2){ margin-top: 0 } }

        /* Paste area wrapper to host the Index button */
        .paste-wrap{ position: relative }
        .paste-wrap .index-btn{
            position:absolute; right:10px; bottom:10px; z-index:2;
            padding:8px 12px; border-radius:999px; font-weight:800; font-size:12px; cursor:pointer;
            border:1px solid var(--btnBorder);
            background: linear-gradient(180deg, var(--btnTop), var(--btnBottom));
            color: var(--ink); box-shadow: var(--depth);
        }
        .paste-wrap .index-btn.saved{ pointer-events:none; filter:brightness(1.05) }

        /* Saved MCQs module styles */
    .saved-card{ position:relative; z-index: 10000; margin-top:10px; padding:10px; border-radius:12px; border:1px solid var(--btnBorder); background: linear-gradient(180deg, rgba(16,25,40,.75), rgba(10,16,28,.75)); box-shadow: var(--depth) }
    .saved-header{ display:flex; align-items:center; justify-content:space-between; gap:8px }
    /* Dropdown list container (overlay). Use fixed + very high z-index so nothing overlaps. */
    /* Use absolute so it scrolls with content, portal to body to avoid clipping; keep very high z-index */
    .saved-menu{ position:absolute; top: 0; left:0; z-index: 2147483647; width: auto; max-width: 96vw; box-sizing: border-box; max-height: 50vh; overflow:auto; border: 1px solid var(--btnBorder); border-radius: 12px; background: linear-gradient(180deg, rgba(16,25,40,.95), rgba(10,16,28,.95)); box-shadow: 0 10px 24px rgba(0,0,0,.45); display:none }
    .saved-menu.open{ display:block }
    .saved-list{ display:flex; flex-direction:column; gap:8px; padding:8px }
        .saved-item{ display:flex; align-items:center; justify-content:space-between; gap:8px; padding:4px 8px; border-radius:6px; border:1px solid rgba(60,80,120,.35); background: linear-gradient(180deg, rgba(14,20,32,.55), rgba(10,16,28,.55)) }
        .saved-item .si-main{ min-width:0 }
    .saved-item .si-title{ font-weight:700; color:var(--ink); cursor:text; line-height:1.2 }
    .saved-item .si-title[contenteditable="true"]:focus{ outline: 2px solid rgba(96,165,250,.35); outline-offset: 2px; border-radius: 4px }
        .saved-item .si-meta{ color:var(--muted); font-size:11px }
        .saved-item .si-actions{ display:flex; gap:6px; flex-shrink:0; align-items:center }

        /* Saved-row actions (Generate / Validate) and applied visual state */
    .saved-row{ display:flex; align-items:center; justify-content:space-between; padding:4px 6px; border-radius:6px }
    .saved-row .si-actions{ display:flex; gap:8px; align-items:center; flex-shrink:0 }
    .saved-row .si-actions .btn.small{ padding:4px 8px; font-size:11px; min-height:0; height:auto; line-height:1 }
        .saved-row.applied{ box-shadow: 0 6px 18px rgba(106,169,255,0.06), inset 0 1px 0 rgba(255,255,255,0.02); transform: translateY(-1px) }

    /* Persisted selection state for the chosen source used by Generate */
    .saved-row.selected{ box-shadow: 0 10px 30px rgba(106,169,255,0.10); border: 1px solid rgba(106,169,255,0.18); transform: translateY(-1px); }

        .btn {
            appearance: none;
            border: 1px solid rgba(78, 102, 146, .45);
            background: linear-gradient(180deg, rgba(24, 36, 56, .55), rgba(12, 20, 34, .65));
            color: var(--ink);
            padding: 10px 14px;
            border-radius: 14px;
            cursor: pointer;
            font-weight: 700;
            letter-spacing: .2px;
            transition: .12s
        }
        /* Circle wrapper for gear button to visually match the Random Quiz pill */
        .gear-circle{
            display:inline-flex; align-items:center; justify-content:center; overflow:hidden;
            width:36px; height:36px; border-radius:999px; padding:0; box-sizing:border-box;
            border: 1px solid rgba(78, 102, 146, .45);
            background: linear-gradient(180deg, rgba(24, 36, 56, .55), rgba(12, 20, 34, .65));
            color: var(--ink); cursor: pointer; margin-left:6px;
            box-shadow: var(--depth); transition: transform .12s ease, filter .12s ease;
        }
        .gear-circle:hover{ transform: translateY(-1px); filter:brightness(1.06) }
    .gear-circle .gear-btn{ background: transparent; border:0; padding:0; font-size:22px; line-height:0; color:inherit; width:100%; height:100%; border-radius:999px; display:inline-grid; place-items:center }
    /* ensure the inner glyph (font icon or svg) is block-level and scales to the available space */
    .gear-circle .gear-btn > *{ display:block; width:1em; height:1em }
        /* Mobile tap affordance */
    .btn, button, .theme-orb, .choose-btn { -webkit-tap-highlight-color: rgba(255,255,255,.1); }
    .btn.pill{ border-radius:999px; padding-left:14px; padding-right:14px }
    .mt-8{ margin-top:8px }
        @media (max-width: 640px){ .btn{ padding: 12px 14px; min-height: 44px; } }

        /* Compact TOC + Saved textbook styles (tight, minimal within TOC panel) */
    .tb-toc{ height:120px; overflow:auto; padding:8px; border-radius:10px; font-size:13px }
    .tb-log{ height:120px; overflow:auto; padding:10px; border-radius:10px }
        .compact-saved{ margin-top:10px; padding:8px; border-radius:10px; font-size:13px }
        .compact-row{ gap:8px; align-items:center }
    .btn.small{ padding:6px 12px; font-size:13px; border-radius:10px; min-height:36px; display:inline-flex; align-items:center; }
        .compact-select{ font-size:13px; padding:6px 8px }
        .compact-actions button{ margin-left:6px }
        .compact-details{ margin-top:6px; font-size:12px }
        .saved-sample.compact-sample{ margin-top:6px; max-height:84px; overflow:auto; padding:8px; background: linear-gradient(180deg, rgba(8,12,18,.4), rgba(6,10,14,.35)); border-radius:8px }
        .saved-row{ padding:6px; border-radius:8px }

    /* Saved header badge centering */
    .saved-header-left{ align-items:center }
    .saved-badge-wrap{ display:flex; align-items:center; justify-content:center; min-width:28px; height:28px; border-radius:8px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:2px 6px }
    #savedCount{ display:inline-block }

        /* Page-level title displayed above the content card and centered */
        .page-title{
            text-align:center;
            margin: 6px 0 0 0; /* remove bottom gap for content library title */
            font-size:20px;
            font-weight:800;
            color: var(--ink);
            letter-spacing: .4px;
            /* keep it visually separate from card */
            display:block;
        }
    /* Combined chooser + preview (stacked with horizontal divider) */
    .chooser-row{ display:flex; flex-direction:column; gap:12px }
    .chooser-left{ width:100%; }
    .chooser-right{ width:100%; }
    /* Horizontal divider between the top controls and bottom preview */
    .chooser-divider{ height:2px; background: linear-gradient(90deg, rgba(255,255,255,0.03), rgba(110,170,255,0.06), rgba(255,255,255,0.03)); border-radius:3px; margin: 10px 0; box-shadow: 0 2px 8px rgba(106,169,255,0.03), inset 0 1px 0 rgba(255,255,255,0.02); transition: box-shadow .12s ease, transform .12s ease }
    .chooser-divider:hover, .chooser-divider:focus{ box-shadow: 0 4px 18px rgba(106,169,255,0.08), inset 0 1px 0 rgba(255,255,255,0.03); transform: translateY(-1px) }
    @media (min-width: 900px){ .chooser-row{ gap:18px } }

        .btn:hover {
            transform: translateY(-1px)
        }

        .btn.primary {
            border-color: var(--btnBorder);
            background: linear-gradient(180deg, var(--btnTop), var(--btnBottom));
        }

        /* Full-screen ASCII watermark layer (behind UI, above .bg-anim) */
        .ascii-watermark{
            position: fixed; inset: 0; z-index: -1; pointer-events: none;
            display:flex; align-items:center; justify-content:center; /* center base content */
            overflow: hidden; /* clip outside */
            mix-blend-mode: normal;
        }
        .ascii-watermark pre{
            margin:0; padding:0; display:none; white-space: pre; line-height: 1;
            color: rgba(255,255,255,.06);
            text-shadow: 0 1px 0 rgba(0,0,0,.22), 0 0 8px rgba(255,255,255,.025);
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace;
            font-size: 9px; /* smaller characters; cover-fit will keep full screen */
            transform-origin: center center; /* center for cover fit */
            will-change: transform;
            overflow: hidden;
        }
        .ascii-watermark pre .row{ display:block }
        .ascii-watermark .num, .ascii-watermark .fav{ color: rgba(255,255,255,.12); }
        .ascii-watermark canvas{ width:100%; height:100%; display:block }

        /* ASCII watermark removed per user request */

        /* Global top safe area (news bar height etc.) */
        :root{ --topSafeArea: 0px; }

        /* Theme capsule (left side) */
        .theme-capsule{
            position: fixed; left: calc(12px + env(safe-area-inset-left)); top: calc(12px + env(safe-area-inset-top) + var(--topSafeArea)); transform: none;
            display:flex; gap:10px; align-items:center; padding:8px 10px;
            border-radius: 9999px; border: 1px solid rgba(31,42,68,.6);
            background: linear-gradient(180deg, rgba(16,25,40,.65), rgba(10,16,28,.65));
            box-shadow: var(--depth);
            -webkit-backdrop-filter: blur(calc(var(--glass-blur)*.8));
            backdrop-filter: blur(calc(var(--glass-blur)*.8));
            z-index: 5;
        }
        /* Place the background toggle just below the theme capsule */
        #bgToggles{
            position: fixed;
            left: calc(12px + env(safe-area-inset-left));
            top: calc(12px + env(safe-area-inset-top) + 64px + var(--topSafeArea)); /* ~capsule height + gap + safe area */
            z-index: 6; /* above canvas and peers */
            display:flex; gap:8px; align-items:flex-start; flex-direction: column; /* stack toggles vertically */
        }
        @media (max-width: 640px){ .theme-capsule{ left: calc(8px + env(safe-area-inset-left)); top: calc(8px + env(safe-area-inset-top) + var(--topSafeArea)); } }
        @media (max-width: 640px){ #bgToggles{ left: calc(8px + env(safe-area-inset-left)); top: calc(8px + env(safe-area-inset-top) + 72px + var(--topSafeArea)); } }
        .theme-orb{
            --c1: #5aa5ff; --c2: #46d3ff; --c3: #7a66ff; /* default fallbacks */
            width: 40px; height: 40px; border-radius: 50%; cursor: pointer; position: relative; overflow: hidden;
            box-shadow: inset 0 6px 12px rgba(0,0,0,.45), 0 6px 14px rgba(0,0,0,.35);
            border: 1px solid rgba(60,80,120,.6);
            transition: transform .14s ease, box-shadow .12s ease;
            background: conic-gradient(from 0deg, var(--c1), var(--c2), var(--c3));
        }
        @media (max-width: 640px){ .theme-orb{ width: 44px; height: 44px; } }
    /* Orb palette classes to avoid inline styles */
    .orb-ocean { --c1:#5aa5ff; --c2:#46d3ff; --c3:#7a66ff }
    .orb-sunset{ --c1:#ff7a7a; --c2:#ffb84d; --c3:#ffd86b }
    .orb-forest{ --c1:#2bd47a; --c2:#75e68c; --c3:#3fb2a0 }
    .orb-violet{ --c1:#8b5cf6; --c2:#60a5fa; --c3:#22d3ee }
    .orb-ember { --c1:#ff6b6b; --c2:#f59e0b; --c3:#fb923c }
    .orb-greyscale{ --c1:#d4d4d4; --c2:#9ca3af; --c3:#4b5563 }

    /* Utility classes to replace inline styles */
    .mt-6{ margin-top:6px }
    .mt-8{ margin-top:8px }
    .mt-10{ margin-top:10px }
    .mt-12{ margin-top:12px }
    .fs-12{ font-size:12px }
    .fs-14{ font-size:14px }
    .muted{ color: var(--muted) }
    .flex{ display:flex }
    .col{ display:flex; flex-direction:column }
    .center{ justify-content:center; align-items:center }
    .gap-8{ gap:8px }
    .gap-12{ gap:12px }
    .justify-between{ justify-content:space-between }
    .w-68{ width:68px }

    /* Prettier numeric inputs to match theme */
    .pill input[type="number"], input.themed-input[type="number"]{
        height: 30px; border-radius: 8px; background: #0c1526; color: var(--ink);
        border: 1px solid var(--btnBorder); padding: 4px 8px; font-size: 12px;
        box-shadow: inset 0 2px 6px rgba(0,0,0,.25);
    }
    .pill input[type="number"]:focus, input.themed-input[type="number"]:focus{
        outline: 2px solid var(--brand); outline-offset: 2px;
    }
    /* Hide default spinners for a cleaner look */
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button{ -webkit-appearance: none; margin: 0; }
    input[type="number"]{ -moz-appearance: textfield; appearance: textfield; }
        /* News bar styles (glassy) */
        .news-bar{ position: fixed; left:0; right:0; top: 0; z-index: 240; /* below theme capsule (z 5+) */
            width: 100vw; box-sizing: border-box; padding: 0 14px; height: 46px;
            border-bottom: 2px solid rgba(80,100,140,.6); border-radius: 0;
            background: linear-gradient(180deg, rgba(18,26,36,.68), rgba(6,10,14,.56));
            -webkit-backdrop-filter: blur(12px) saturate(120%); backdrop-filter: blur(12px) saturate(120%);
            box-shadow: 0 8px 32px rgba(0,0,0,.55);
            color: #e6eef8; overflow: hidden; white-space: nowrap; font-size:14px; line-height:46px }
        .news-bar::after{ content:''; position:absolute; inset:0; pointer-events:none; background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='160' height='160' viewBox='0 0 160 160'><filter id='n'><feTurbulence baseFrequency='0.9' seed='2' numOctaves='1' stitchTiles='stitch'/><feColorMatrix type='saturate' values='0'/><feComponentTransfer><feFuncA type='table' tableValues='0 0.06'/></feComponentTransfer></filter><rect width='100%' height='100%' filter='url(%23n)' opacity='0.18' /></svg>"); mix-blend-mode: overlay; opacity: .6; }
        .news-row{ position: relative; height: 100%; overflow: hidden; }
        .news-viewport{ position: relative; height: 100%; overflow: hidden; }
        .news-track{ position: absolute; left: 0; top: 0; height: 100%; white-space: nowrap; will-change: transform; }
        /* Increase headline size but keep bar height fixed: tighten gaps and date padding */
        .news-item{ display:inline-flex; gap:6px; align-items:center; color: var(--ink); text-decoration:none; font-size:15px }
        .news-item:hover{ text-decoration: underline }
        .news-date{ color: var(--muted); font-size: 11px; border: 1px solid rgba(60,80,120,.45); padding: 0 6px; border-radius: 999px; background: linear-gradient(180deg, rgba(16,25,40,.55), rgba(10,16,28,.55)); height: 22px; display: inline-flex; align-items: center; }
        .news-sep{ color: rgba(255,255,255,.25); display:inline-block; margin: 0 10px }
    /* Push all in-flow content below the top safe area */
    body{ padding-top: var(--topSafeArea); transition: padding-top .12s ease; }
    /* Content root: keep transform origin stable for any future effects */
    #contentRoot{ transform-origin: top center; transition: transform .15s ease; }
    /* Saved MCQs card should fill its column — use full width and include padding in box sizing */
    .saved-card{ margin-left:0; margin-right:0; width:100%; box-sizing: border-box; }
        /* soft blending layer of the tri-colors */
        .theme-orb::before{
            content:""; position:absolute; inset:-12%; border-radius:50%; pointer-events:none;
            background:
                radial-gradient(62% 58% at 28% 30%, var(--c1), transparent 70%),
                radial-gradient(62% 60% at 72% 30%, var(--c2), transparent 72%),
                radial-gradient(80% 70% at 50% 80%, var(--c3), transparent 74%);
            filter: blur(8px) saturate(115%);
            opacity: .75;
        }
        /* specular highlight */
        .theme-orb::after{
            content:""; position:absolute; inset:0; border-radius:50%; pointer-events:none;
            background: radial-gradient(150% 120% at 30% 20%, rgba(255,255,255,.36), transparent 60%);
        }
        .theme-orb .orb-label{
            position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none;
            font-weight: 800; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,.5), 0 0 10px rgba(0,0,0,.45);
            font-size: 14px; letter-spacing: .2px; transform: translateZ(0); transition: transform .14s ease;
        }
        .theme-orb:hover{ transform: translateY(-1px) scale(1.06); box-shadow: inset 0 6px 12px rgba(0,0,0,.45), 0 10px 20px rgba(0,0,0,.45); }
        .theme-orb:hover .orb-label{ transform: scale(1.08); }
        .theme-orb.active{ outline: 2px solid rgba(255,255,255,.18); outline-offset: 2px; }

        .tag {
            display: inline-block;
            padding: 2px 8px;
            border: 1px solid rgba(70, 90, 130, .5);
            background: linear-gradient(180deg, rgba(16, 25, 40, .7), rgba(10, 16, 28, .7));
            border-radius: 999px;
            color: var(--muted);
            font-size: 12px;
            margin-right: 6px
        }
    /* Compact validator choice rows used in the validation output (no extra gaps) */
    .validator-choice{ margin:0; color:var(--muted); font-size:13px }
    .validator-choice{ padding:8px; border-radius:8px; border:1px solid rgba(70,90,130,.2); background: linear-gradient(180deg, rgba(10,16,24,.45), rgba(8,12,20,.45)); }
    .validator-choice.correct{ border-color: #155e37; background: linear-gradient(180deg, rgba(17,94,55,0.12), rgba(6,30,18,0.06)); color: var(--ink); }
    .validator-choice.wrong{ border-color: #7f1d1d; background: linear-gradient(180deg, rgba(127,29,29,0.08), rgba(40,12,12,0.03)); color: var(--ink); }

        /* quiz layout */
        .quizgrid {
            display: grid;
            /* make main content take all available space and keep sidebar fixed */
            grid-template-columns: 1fr 340px;
            gap: 16px
        }

        @media (max-width: 980px) {
            .quizgrid {
                grid-template-columns: 1fr
            }
        }

        .side {
            border: 1px solid var(--stroke);
            background: linear-gradient(180deg, rgba(14, 21, 34, .65), rgba(9, 15, 26, .6));
            border-radius: 14px;
            padding: 14px;
            -webkit-backdrop-filter: blur(calc(var(--glass-blur)*.8));
            backdrop-filter: blur(calc(var(--glass-blur)*.8));
        }

        .side h3 {
            margin: 0 0 8px;
            font-size: 16px
        }

        .side label {
            display: block;
            font-size: 12px;
            color: var(--muted);
            margin: 6px 0 4px
        }

        .side input,
        .side textarea {
            width: 100%;
            background: #0b1220;
            color: var(--ink);
            border: 1px solid #22324a;
            border-radius: 10px;
            padding: 8px
        }

        .side textarea {
            height: auto; /* allow natural/flex growth */
            max-height: none;
            flex: 1 1 auto; /* fill remaining space in sidebar */
            min-height: 0; /* enable child to shrink within flex container */
            resize: none;
            overflow: auto;
        }

        /* question cards */
        .qcard {
            /* Ensure question cards expand to fill the main column and match the results width */
            display: block; width: 100%; max-width: 100%; box-sizing: border-box;
            border: 1px solid rgba(70, 90, 130, .5);
            background: linear-gradient(180deg, rgba(14, 21, 34, .65), rgba(9, 15, 26, .6));
            border-radius: 16px;
            padding: 14px;
            margin: 12px 0;
            box-shadow: var(--depth)
        }

        .choice {
            display: block;
            margin: 8px 0;
            padding: 12px;
            border: 1px solid rgba(70, 90, 130, .5);
            border-radius: 12px;
            cursor: pointer;
            background: linear-gradient(180deg, rgba(14, 20, 32, .55), rgba(10, 15, 26, .55))
        }

        .choice.correct {
            border-color: #155e37;
            background: linear-gradient(180deg, rgba(11, 30, 21, .7), rgba(6, 20, 14, .65))
        }

        .choice.wrong {
            border-color: #7f1d1d;
            background: linear-gradient(180deg, rgba(26, 15, 16, .7), rgba(18, 10, 12, .65))
        }

        .choice input {
            margin-right: 8px
        }

        .footer {
            margin-top: 18px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px
        }

        .progress {
            height: 10px;
            background: linear-gradient(180deg, rgba(10, 16, 28, .8), rgba(8, 12, 20, .7));
            border: 1px solid rgba(70, 90, 130, .5);
            border-radius: 999px;
            overflow: hidden;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, .35)
        }

        .progress>div {
            height: 100%;
            background: linear-gradient(90deg, var(--brand), #6ee7b7);
            width: 0%
        }

        .hidden {
            display: none
        }

        /* skipped modal */
        .overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, .55);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
            /* Respect notches and home indicators */
            padding: max(8px, env(safe-area-inset-top)) max(8px, env(safe-area-inset-right)) max(8px, env(safe-area-inset-bottom)) max(8px, env(safe-area-inset-left));
        }

        .panel {
            width: min(680px, 90vw);
            max-height: 80vh; /* fallback */
            overflow: auto;
            background: #0f1726;
            border: 1px solid #223048;
            border-radius: 14px;
            padding: 16px
        }
        /* Use dynamic viewport height when supported to avoid iOS address bar jumps */
        @supports (height: 100dvh){ .panel{ max-height: 80dvh; } }

        .list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            gap: 8px
        }

        .chip {
            padding: 8px;
            border-radius: 10px;
            border: 1px solid #2a3648;
            background: #0b1220;
            text-align: center;
            cursor: pointer
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #3b82f6;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            vertical-align: -3px;
            margin-right: 6px
        }

        @keyframes spin {
            to {
                transform: rotate(360deg)
            }
        }
    .key-badge{display:inline-flex;align-items:center;gap:8px;font-size:13px;color:var(--muted)}
    .key-badge .dot{width:10px;height:10px;border-radius:50%;background:#7c7c7c;box-shadow:0 0 0 6px rgba(0,0,0,0.06);box-sizing:border-box;line-height:0;vertical-align:middle}
        .key-badge.ok .dot{background:var(--ok)}
        .key-badge.missing .dot{background:var(--bad)}
        .btn[disabled]{opacity:.6;cursor:not-allowed;transform:none}
    </style>
        <style>
            /* Sticky Notes Dock + Windows */
            :root{ --stickyScale: 1; --stickyTopGap: 8px; --stickyRailW: 280px; }
            .sticky-dock{ position:fixed; right: calc(12px + env(safe-area-inset-right)); top: calc(12px + env(safe-area-inset-top) + 280px + var(--topSafeArea) + var(--stickyTopGap)); z-index:190; display:flex; gap:8px; align-items:center; padding:8px 10px; border-radius:999px; border:1px solid var(--btnBorder); background: linear-gradient(180deg, rgba(16,25,40,.72), rgba(10,16,28,.72)); box-shadow: var(--depth); -webkit-backdrop-filter: blur(8px); backdrop-filter: blur(8px); transform-origin: top right; transform: scaleY(var(--stickyScale)); }
            .sticky-dock .sd-btn{ appearance:none; border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); font-weight:800; font-size:12px; padding:6px 10px; border-radius:999px; cursor:pointer }
            .sticky-dock .sd-btn.small{ font-weight:700; padding:4px 8px; font-size:11px }
            .sticky-dock .sd-btn:hover{ filter:brightness(1.06) }
            .sticky-dock .sd-count{ min-width:20px; height:20px; border-radius:999px; background: rgba(255,255,255,.08); border:1px solid rgba(60,80,120,.45); display:inline-flex; align-items:center; justify-content:center; font-size:12px; color: var(--ink) }
            .sticky-panel{ position:fixed; right: calc(12px + env(safe-area-inset-right)); top: calc(64px + env(safe-area-inset-top) + 280px + var(--topSafeArea) + var(--stickyTopGap)); z-index:191; width: min(420px, 92vw); max-height: 50vh; overflow:auto; padding:10px; border-radius:14px; border:1px solid var(--btnBorder); background: linear-gradient(180deg, rgba(16,25,40,.92), rgba(10,16,28,.92)); box-shadow: var(--depth); transform-origin: top right; transform: scaleY(var(--stickyScale)); }
            .sticky-panel.hidden{ display:none }
            .sticky-panel .row{ display:flex; gap:8px; align-items:center }
            .sticky-panel .sd-input{ flex:1 1 auto; height:32px; border-radius:10px; background:#0c1526; color:var(--ink); border:1px solid var(--btnBorder); padding:6px 10px; font-size:12px }
            #sdClose.sd-btn.small{ width:28px; height:28px; padding:0; border-radius:50%; font-size:16px; line-height:26px; text-align:center; font-weight:900 }
            .sticky-list{ margin-top:8px; display:flex; flex-direction:column; gap:8px }
            .sticky-item{ display:flex; gap:8px; align-items:center; padding:8px; border:1px solid rgba(60,80,120,.35); border-radius:10px; background: linear-gradient(180deg, rgba(14,20,32,.55), rgba(10,16,28,.55)); cursor:pointer }
            .sticky-item:hover{ filter:brightness(1.05) }
            .sticky-dot{ width:12px; height:12px; flex: 0 0 12px; aspect-ratio: 1 / 1; display:inline-block; border-radius:50%; border:1px solid rgba(255,255,255,.12) }
            .sticky-meta{ color: var(--muted); font-size:11px }
            /* Note window */
            .sticky-note{ position:fixed; z-index:195; width:260px; min-width:180px; min-height:160px; border-radius:12px; box-shadow: 0 10px 24px rgba(0,0,0,.45); border:1px solid rgba(60,80,120,.45); background: #121a2a; display:flex; flex-direction:column; overflow:hidden }
            .sticky-note.min{ height:auto }
            .sticky-head{ display:flex; align-items:center; justify-content:space-between; gap:8px; padding:8px 10px; cursor:grab; -webkit-user-select:none; user-select:none; background: linear-gradient(180deg, var(--btnTop), rgba(12,20,34,.65)); border-bottom:1px solid var(--btnBorder) }
            .sticky-title{ flex:1 1 auto; min-width:0; font-size:12px; font-weight:800; color: var(--ink); outline:none; background: transparent; border:0 }
            .sticky-actions{ display:flex; gap:6px; align-items:center; flex-shrink:0; white-space:nowrap }
            .sticky-actions .sa{ appearance:none; border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); font-weight:800; font-size:11px; padding:4px 8px; border-radius:8px; cursor:pointer }
            /* Aesthetic close button: compact circular × */
            .sticky-actions .sa[data-act="close"]{ width:22px; height:22px; padding:0; border-radius:50%; font-size:14px; line-height:20px; text-align:center; font-weight:900; }
            .sticky-actions .sa[data-act="close"]:hover{ filter:brightness(1.1) }
            .sticky-body{ flex:1 1 auto; display:flex }
            .sticky-text{ flex:1 1 auto; padding:8px 10px; border:0; outline:none; resize:none; color: var(--ink); background: linear-gradient(180deg, rgba(16,25,40,.82), rgba(10,16,28,.82)) }
            .sticky-resize{ position:absolute; right:6px; bottom:6px; width:12px; height:12px; cursor:nwse-resize; opacity:.7 }
            .sticky-resize::after{ content:""; position:absolute; inset:0; background: linear-gradient(135deg, rgba(233,240,247,.9) 0 2px, transparent 2px), linear-gradient(135deg, rgba(233,240,247,.6) 0 1px, transparent 1px); background-size: 100% 100%, 70% 70%; background-repeat:no-repeat }
            .sticky-color{ display:flex; gap:6px; align-items:center }
            .sticky-color .dot{ width:12px; height:12px; flex:0 0 12px; aspect-ratio:1 / 1; border-radius:50%; border:1px solid rgba(255,255,255,.12); cursor:pointer }
            /* color themes */
            .c-yellow{ background: #1e1a05; border-color: #635d2a }
            .c-green{ background: #0d1f14; border-color: #25573c }
            .c-pink{ background: #261320; border-color: #6a314f }
            .c-sky{ background: #0e1e2a; border-color: #2d5876 }
            .c-lav{ background: #1a162a; border-color: #4b3a7a }
        </style>

    <style>
    /* UI lock while TOS not accepted */
    .tos-overlay{ position:fixed; inset:0; background: rgba(2,6,12,0.55); -webkit-backdrop-filter: blur(4px); backdrop-filter: blur(4px); z-index:22000; display:flex; align-items:center; justify-content:center; }
    .tos-overlay.hidden{ display:none }
    .tos-unlock-panel{ background: linear-gradient(180deg, rgba(8,12,18,.98), rgba(6,10,14,.98)); border:1px solid rgba(255,255,255,0.04); padding:18px; border-radius:12px; max-width:520px; color:var(--ink); box-shadow: 0 12px 40px rgba(0,0,0,0.6); }
    .tos-unlock-panel p{ color:var(--muted); font-size:13px; margin:0 0 12px }
    .tos-unlock-text{ color:var(--muted); font-size:13px; margin:0 0 12px }
    .tos-unlock-actions{ display:flex; gap:10px; justify-content:center }
    /* Use a root class so we can selectively keep TOS buttons active */
    .tos-locked * { pointer-events: none !important; }
    /* Keep the TOS UI, the modal, and the entire unlock panel (and their children) interactive while locked */
    .tos-locked #tos-box,
    .tos-locked #tosModal,
    .tos-locked #tosModal *,
    .tos-locked #tosBoxView,
    .tos-locked #viewTosBtn,
    .tos-locked #tosOverlay .tos-unlock-panel,
    .tos-locked #tosOverlay .tos-unlock-panel * { pointer-events: auto !important; }
    .tos-locked .page, .tos-locked .card, .tos-locked .api-key-bar, .tos-locked .card.pad { filter: blur(4px) brightness(.96); }
    </style>

    <style>
    /* TOS box styles */
    .tos-box{ margin-top:12px; }
    .tos-box .muted{ color:var(--muted); }
    .tos-box .btn.small{ padding:6px 8px; font-size:12px }
    .tos-box .flex { align-items:center }
    .tos-box .muted strong{ color:inherit }
    .tos-box .right{ margin-left:auto }
    </style>
        <style>
            /* Sticky rail on the right with 5 clip slots */
            .sticky-rail{ position:fixed; top: calc(var(--topSafeArea) + var(--stickyTopGap)); bottom: 0; right: calc(12px + env(safe-area-inset-right)); z-index:189; display:flex; flex-direction:column; gap:10px; pointer-events:none; padding-bottom: 8px; transform-origin: top right; transform: scaleY(var(--stickyScale)); }
            .clip-slot{ width: var(--stickyRailW); min-height: 120px; flex: 1 1 0; border-radius: 12px; border:1px dashed rgba(100,130,180,.55); background: linear-gradient(180deg, rgba(16,25,40,.55), rgba(10,16,28,.55)); box-shadow: inset 0 0 0 1px rgba(255,255,255,.04); opacity:.9; transition: filter .12s ease; pointer-events:none }
            .clip-slot:hover{ filter: brightness(1.06) }
            .clip-slot.slot-hover{ outline: 2px solid var(--brand); outline-offset: 2px }
            .clip-slot.occupied{ border: none; opacity:.94 }
            /* colored outlines to match sticky note color */
            .clip-slot.c-yellow{ outline: 2px solid #635d2a; outline-offset: 2px }
            .clip-slot.c-green{ outline: 2px solid #25573c; outline-offset: 2px }
            .clip-slot.c-pink{ outline: 2px solid #6a314f; outline-offset: 2px }
            .clip-slot.c-sky{ outline: 2px solid #2d5876; outline-offset: 2px }
            .clip-slot.c-lav{ outline: 2px solid #4b3a7a; outline-offset: 2px }
        </style>
        <style>
            /* Boot overlay */
                .boot-overlay{ position:fixed; inset:0; z-index:99999; display:flex; align-items:center; justify-content:center; 
                    /* Palette-aware ambient */
                    background:
                        linear-gradient(180deg, rgba(0,0,0,.55), rgba(0,0,0,.55)),
                        radial-gradient(800px 500px at 20% 25%, var(--glow1), transparent 70%),
                        radial-gradient(700px 450px at 80% 30%, var(--glow2), transparent 75%),
                        radial-gradient(650px 420px at 50% 85%, var(--glow3), transparent 75%);
                    -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px); opacity:1; transition: opacity .6s ease; }
            .boot-overlay.hidden{ opacity:0; pointer-events:none; }
                        .boot-card{ text-align:center; max-width: min(760px, 92vw); padding: 20px; border-radius: 16px; border: 1px solid var(--btnBorder); 
                            /* fallback gradient */
                            background: linear-gradient(180deg, rgba(16,25,40,.55), rgba(10,16,28,.55));
      
                            /* If supported, gently blend brand button colors */
                            background: linear-gradient(180deg, color-mix(in srgb, var(--btnTop) 70%, transparent), color-mix(in srgb, var(--btnBottom) 70%, transparent));
                            box-shadow: var(--depth); }
                .boot-ascii{ text-align:center; margin: 0 0 10px; overflow: hidden; }
                .boot-ascii pre{ display:inline-block; width:max-content; min-width:max-content; max-width:100%; margin:0; padding:0; color: var(--ink); white-space: pre; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace; font-size: clamp(10px, 1.8vw, 18px); line-height: 1.03; letter-spacing: 0; text-shadow: 0 1px 0 rgba(0,0,0,.35); overflow: hidden; transform-origin: left top; }
                /* Slightly reduce bottom spacing under the big ASCII title to make room for animation */
                .boot-ascii pre{ display:inline-block; width:max-content; min-width:max-content; max-width:100%; margin:0 0 6px 0; padding:0; color: var(--ink); white-space: pre; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace; font-size: clamp(10px, 1.8vw, 18px); line-height: 1.03; letter-spacing: 0; text-shadow: 0 1px 0 rgba(0,0,0,.35); overflow: hidden; transform-origin: left top; }
                .boot-ascii pre::-webkit-scrollbar{ width:0; height:0 }
            .boot-sub{ color: var(--muted); font-size: clamp(12px, 3.4vw, 14px); margin-top: 10px; min-height: 1.4em; }
            .boot-phrase{ color: var(--ink); font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace; font-size: clamp(12px, 3.2vw, 16px); line-height: 1.35; min-height: 2.2em; opacity: 0; transition: opacity .35s ease; margin-top: 8px; white-space: normal; }
            .boot-phrase.show{ opacity: 1; }
            .spinner.lg{ width:28px; height:28px; border-width:3px; margin: 10px auto 0; display:inline-block }
                /* Spinner matches active brand */
                .boot-overlay .spinner{ border-color: var(--brand); border-top-color: transparent; }
                /* Hide page scrollbars while booting */
                html.booting, body.booting{ overflow: hidden !important; height: 100%; }

                /* While booting we keep sticky UI visible but non-interactive so the overlay feels modal
                   This leaves notes/dock/rail/title in the visual background but prevents pointer/focus interactions */
                html.booting .sticky-dock,
                html.booting .sticky-panel,
                html.booting .sticky-rail,
                html.booting .sticky-note,
                html.booting #stickyTitleBox {
                    /* Keep visible (no opacity change) but disable pointer and selection */
                    pointer-events: none !important;
                    -webkit-user-select: none !important;
                    user-select: none !important;
                    transform: translateY(6px) scale(.995);
                    transition: transform .18s ease;
                }
            @media (max-width: 640px){ .boot-card{ padding: 16px; } }
        </style>
        <style>
            /* Sticky rail resizer handle */
            .sticky-rail-resizer{
                position:fixed; z-index:211; width:28px; height:28px; border-radius:50%;
                border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom));
                color: var(--ink); cursor: ew-resize; display:flex; align-items:center; justify-content:center;
                right: calc(12px + env(safe-area-inset-right) + var(--stickyRailW) + 8px);
                top: 50%; transform: translateY(-50%);
                box-shadow: var(--depth);
                opacity: 0; transition: opacity .15s ease, filter .12s ease;
            }
            .sticky-rail-resizer::before{ content:'\2190'; /* left arrow */ font-weight:900; font-size:14px; line-height:1; }
            .sticky-rail-resizer:hover{ filter: brightness(1.06); opacity: 1; }
            .sticky-rail-resizer:active{ filter: brightness(1.1); }
            .sticky-rail-resizer:focus{ outline: 2px solid var(--brand); outline-offset: 2px; }
            /* Hide when boot overlay sets inert visuals to avoid confusing focus layering */
            html.booting .sticky-rail-resizer{ pointer-events:none; opacity:.85; transform: translateY(calc(-50% + 6px)) scale(.995); }
            /* Hover zone to reveal resizer */
            .sticky-rail-hoverzone{ position:fixed; z-index:210; pointer-events:auto; opacity:0; width:40px; height:60px; right: calc(12px + env(safe-area-inset-right) + var(--stickyRailW) + 8px); top: 50%; transform: translateY(-50%); }
            .sticky-rail-hoverzone:hover + .sticky-rail-resizer{ opacity: 1; }
            .sticky-rail-resizer:hover, .sticky-rail-resizer:focus{ opacity: 1; }
            /* small fixed-size ASCII animation area that matches spinner footprint */
            .boot-ascii-anim{ display:inline-block; width:28px; height:28px; margin: 10px auto 0; text-align:center; font-family: ui-monospace, 'Courier New', monospace; font-size:12px; line-height:14px; color:var(--muted); }
        </style>
                <style>
                    /* Hide only the root page scrollbar; preserve inner scrollbars */
                    html, body { -ms-overflow-style: none; }
                    html::-webkit-scrollbar, body::-webkit-scrollbar { width: 0 !important; height: 0 !important; }
                </style>
    <style>
      /* ASCII title banner */
    .ascii-title{ text-align:center; margin: 10px 0; overflow: hidden; -webkit-user-select:none; user-select:none; }
      .ascii-title pre{
          display:block; width:100%; margin:0; padding:0; border-radius:0;
          border: none; background: transparent; box-shadow: none;
          color: var(--ink);
          font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace;
          font-size: clamp(10px, 1.6vw, 20px); line-height: 1.03;
          letter-spacing: .3px;
          text-shadow: 0 1px 0 rgba(0,0,0,.35);
          white-space: pre; /* preserve exact ASCII */
          overflow: hidden; /* hide scrollbars entirely */
          overscroll-behavior: contain; /* avoid overscroll glow */
      }
      /* WebKit hide scrollbars on banner */
      #asciiBanner::-webkit-scrollbar { width: 0; height: 0; }
  /* Global API key bar above the main module */
    .api-key-bar {
        width: 100%;
        box-sizing: border-box;
    margin: 0 0 12px 0;
        padding: 10px 12px;
    border: 1px solid rgba(60,80,120,.35);
    border-radius: 12px;
    background: linear-gradient(180deg, rgba(16,25,40,.70), rgba(10,16,28,.70));
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        backdrop-filter: blur(8px);
            display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
  }
        .api-key-bar input[type="password"]{
                            flex: 1 0 520px; min-width: 320px; padding: 8px 10px; border-radius: 10px;
    border: 1px solid #22324a; background:#0b1220; color: var(--ink);
  }

            /* Paste area: center the action button under the textarea */
            .paste-wrap{ display:flex; flex-direction:column; align-items:center; gap:10px; }
            .paste-wrap .index-btn{ margin: 0 auto; padding:8px 12px; border-radius:10px; background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); border:1px solid var(--btnBorder); color:var(--ink); font-weight:700; cursor:pointer }
            .paste-wrap .index-btn.saved{ background: linear-gradient(180deg, rgba(60,160,120,0.12), rgba(30,120,80,0.12)); }
        @media (max-width: 760px){
            .api-key-bar input[type="password"]{ flex: 1 1 100%; min-width: 0; width: 100%; }
            .api-key-bar .spacer{ display:none }
        }
    .api-key-dot{width:12px;height:12px;border-radius:50%;display:inline-block;margin-right:0;background:#7c7c7c;box-shadow:0 0 0 6px rgba(0,0,0,0.06);box-sizing:border-box;line-height:0;vertical-align:middle}
    .api-key-dot.ok{background:var(--ok)}
    .api-key-dot.missing{background:var(--bad)}
  .api-key-bar label{ font-size:12px; color: var(--muted); display:flex; gap:6px; align-items:center }
    .api-key-bar .spacer{ flex:1 1 auto }
            /* Redesigned toggle switch: transform-centered knob to avoid misalignment */
            .switch{ --sw-w: 42px; --sw-h: 22px; --knob: 16px; --pad: 3px; display:inline-flex; align-items:center; gap:6px; cursor:pointer; -webkit-user-select:none; user-select:none; flex: 0 0 auto; white-space: nowrap }
            .switch input{ display:none }
            .switch .slider{
                position: relative; width: var(--sw-w); height: var(--sw-h); border-radius: 999px; box-sizing: border-box;
                background: rgba(60,80,120,.45); border: 1px solid rgba(60,80,120,.65);
                box-shadow: inset 0 1px 2px rgba(0,0,0,.25);
                transition: background .15s ease, border-color .15s ease;
            }
            .switch .slider::after{
                content:''; position:absolute; top: 50%; left: calc(var(--pad) + var(--knob)/2);
                width: var(--knob); height: var(--knob); border-radius:50%; box-sizing: border-box; transform: translate(-50%, -50%);
                background:#e9f0f7; box-shadow: 0 1px 2px rgba(0,0,0,.35);
                transition: left .15s ease, background .15s ease;
            }
            .switch input:checked + .slider{ background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); border-color: var(--btnBorder); }
            .switch input:checked + .slider::after{ left: calc(var(--sw-w) - var(--pad) - var(--knob)/2); }
            .switch:focus-within .slider{ outline: 2px solid rgba(96,165,250,.35); outline-offset: 2px; }

  /* Optional .docx/.pdf generator panel */
  .ai-file-panel{
    margin-top: 10px;
    padding: 12px;
    border: 1px solid rgba(60,80,120,.35);
    border-radius: 12px;
    background: linear-gradient(180deg, rgba(16,25,40,.65), rgba(10,16,28,.65));
        max-width: 100%;
            overflow-x: hidden; /* never overflow parent width */
            overflow-wrap: anywhere;
            word-break: break-word;
  }
    /* Inline AI fixer panel (left column) */
    .ai-fix-panel{
        margin-top: 10px;
        padding: 12px;
        border: 1px solid var(--btnBorder);
        border-radius: 12px;
        background: linear-gradient(180deg, rgba(16,25,40,.70), rgba(10,16,28,.70));
        -webkit-backdrop-filter: blur(calc(var(--glass-blur)*.6));
        backdrop-filter: blur(calc(var(--glass-blur)*.6));
        width: 100%;
    }
    #aiFixPanel .btn-wide{ min-width: 260px; }
    .ai-file-row{ display:flex; flex-wrap:wrap; gap:12px; align-items:center }
    .ai-file-row > * { flex: 0 1 auto }
    /* Keep status column from changing width as messages update */
    .ai-file-status{ color: var(--muted); font-size: 13px; min-width: 240px; width: 240px; max-width: 240px; overflow:hidden; text-overflow: ellipsis; white-space: nowrap }
    /* Ensure filename truncates and does not push layout */
        .file-input{ display:flex; align-items:center; gap:8px; min-width: 0 }
        .file-input .filename{ flex:1 1 auto; overflow:hidden; white-space:nowrap; text-overflow:ellipsis; min-width: 0; max-width: 100% }
        @media (max-width: 760px){
            #aiFileGenBtn{ flex: 1 1 auto; width:auto; max-width:100% }
            .ai-file-status{ width:auto; min-width:160px; flex: 0 0 160px }
        }
    /* Clean scrollbars */
    /* Remove non-standard scrollbar props in Chrome/Safari; keep WebKit track/thumb below */
    *::-webkit-scrollbar { width: 10px; height: 10px; }
    *::-webkit-scrollbar-track { background: rgba(20,28,44,.6); border-radius: 8px; }
    *::-webkit-scrollbar-thumb {
        background: linear-gradient(180deg, rgba(110,150,200,.55), rgba(70,100,160,.55));
        border-radius: 8px;
        border: 1px solid rgba(40,60,90,.5);
    }

        /* Utility classes used to replace inline styles */
        .mt-0{ margin-top:0 }
        .mt-4{ margin-top:4px }
        .mt-6{ margin-top:6px }
        .mt-8{ margin-top:8px }
        .mt-10{ margin-top:10px }
        .mt-12{ margin-top:12px }
        .mb-6{ margin-bottom:6px }
        .mb-8{ margin-bottom:8px }
        .ml-6{ margin-left:6px }
        .ml-8{ margin-left:8px }
        .fs-12{ font-size:12px }
        .fs-14{ font-size:14px }
        .muted{ color: var(--muted) }
        .text-center{ text-align:center }
        .flex{ display:flex }
        .col{ display:flex; flex-direction:column }
        .center{ justify-content:center; align-items:center }
        .gap-8{ gap:8px }
        .gap-12{ gap:12px }
        .justify-between{ justify-content:space-between }
        .justify-start{ justify-content:flex-start }
        .justify-end{ justify-content:flex-end }
        .flex-1{ flex:1 1 auto }
        .flex-1-260{ flex:1 1 260px }
        .minh-320{ min-height:320px }
        .maxw-600{ max-width:600px }
        .maxw-420{ max-width:420px }
        .w-100{ width:100% }
        .btn-wide{ min-width:260px }

        /* Component blocks previously inline-styled */
        #aiValidateOutput2, #resultsAiOutput{
            white-space:pre-wrap;background:#071022;padding:12px;border-radius:10px;border:1px solid #22324a;min-height:36px;color:var(--ink);
            text-align:left;width:100%;box-sizing:border-box;overflow:auto
        }
        #aiPreviewContent{
            white-space:pre-wrap;background:#071022;padding:10px;border-radius:8px;border:1px solid #22324a;max-height:28vh;overflow:auto;margin-top:10px;color:var(--ink)
        }
        #aiFileDebug{
            margin-top:8px;background:#071022;padding:8px;border-radius:8px;border:1px solid #22324a;height:160px;max-height:160px;overflow:auto;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace; font-size:12px; color:var(--muted); width:100%; max-width:100%; box-sizing:border-box; white-space:pre-wrap; overflow-wrap:anywhere; word-break:break-word
        }
        #resultsAiOutput{
            display: flex;
            flex-direction: column;
            gap: 10px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace;
            white-space: pre-wrap;
            width: 100%;
            height: 100%;
            min-height: 200px; /* ensure multi-line space on mobile */
            margin-top: 4px;
            box-sizing: border-box;
        }
    *::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(180deg, rgba(130,170,220,.65), rgba(90,120,180,.65));
    }
    /* Stabilize the AI file gen button width to prevent row reflow on label changes */
    #aiFileGenBtn.ai-fixed { width: 360px; max-width: 360px; flex: 0 0 360px; overflow:hidden }
    .ai-file-panel * { max-width: 100%; box-sizing: border-box }
</style>
    <style>
        /* Bottom-left Ambient Radio Player */
    #radioPlayer{ --rpClockGap: 18px; position:fixed; left: calc(12px + env(safe-area-inset-left)); bottom: calc(12px + env(safe-area-inset-bottom) + var(--rpRaise, 0px)); z-index:180; width: 320px; max-width: 92vw; display:flex; flex-direction: column; gap:8px; padding:10px 12px; box-sizing:border-box;
            background: linear-gradient(180deg, rgba(16,24,38,.9), rgba(10,16,28,.85)); border: 1px solid var(--btnBorder); border-radius: 14px; box-shadow: var(--depth); -webkit-backdrop-filter: blur(10px); backdrop-filter: blur(10px);
        }
    #radioPlayer .rp-btn{ appearance:none; border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); font-weight:700; font-size:12px; padding:6px 10px; border-radius:8px; cursor:pointer; line-height:1 }
        #radioPlayer .rp-btn:hover{ filter: brightness(1.06) }
    #radioPlayer .rp-btn.small{ font-size:11px; padding:4px 8px }
        #radioPlayer .rp-select{ height: 30px; border-radius: 8px; background: #0c1526; color: var(--ink); border:1px solid var(--btnBorder); padding:4px 8px; font-size:12px; flex: 1 1 auto; min-width: 120px }
    #radioPlayer .rp-vol{ flex: 1 1 120px; min-width: 60px; max-width: 100%; height: 6px; appearance: none; background: linear-gradient(90deg, var(--brand) 0%, var(--brand) var(--rpVolPercent, 40%), rgba(255,255,255,0.15) var(--rpVolPercent, 40%), rgba(255,255,255,0.15) 100%); border-radius: 999px; outline: none; accent-color: var(--brand) }
    /* WebKit */
    #radioPlayer .rp-vol::-webkit-slider-runnable-track{ height:6px; background: transparent; border-radius:999px }
    #radioPlayer .rp-vol::-webkit-slider-thumb{ -webkit-appearance:none; appearance:none; width:14px; height:14px; background: var(--ink); border:2px solid var(--brand); border-radius:50%; margin-top:-4px; box-shadow: 0 0 6px rgba(106,169,255,.35) }
    #radioPlayer.playing .rp-vol::-webkit-slider-thumb{ box-shadow: 0 0 8px var(--brand) }
    /* Firefox */
    #radioPlayer .rp-vol::-moz-range-track{ height:6px; background: rgba(255,255,255,0.15); border-radius:999px }
    #radioPlayer .rp-vol::-moz-range-progress{ height:6px; background: var(--brand); border-radius:999px }
    #radioPlayer .rp-vol::-moz-range-thumb{ width:14px; height:14px; background: var(--ink); border:2px solid var(--brand); border-radius:50% }
        #radioPlayer .rp-meta{ min-height: 16px }
        #radioPlayer #rpNow{ color: var(--muted); font-size: 12px; white-space: nowrap; text-overflow: ellipsis; overflow: hidden }
        /* Broadcasting subtext */
        #radioPlayer #rpCast{ color: var(--muted); font-size: 12px }
    /* Keep YouTube audio player from affecting layout */
    /* YouTube container removed */
    /* Generic attempt select styling */
    .attempt-select{ min-width: 160px; height: 34px; border-radius: 10px; padding: 6px 12px; background: linear-gradient(180deg, var(--btnTop), rgba(10,16,28,.72)); color: var(--ink); border: 1px solid var(--btnBorder); box-shadow: inset 0 1px 0 rgba(255,255,255,.06); font-weight: 600 }
    .attempt-select:focus{ outline: 2px solid rgba(96,165,250,.35); outline-offset: 2px }
    /* Subtle custom chevron (no asset) */
    select.attempt-select{ -webkit-appearance: none; -moz-appearance: none; appearance: none; background-position: right 12px center, 0 0; background-repeat: no-repeat; padding-right: 32px }
    select.attempt-select{
        background-image:
            linear-gradient(45deg, rgba(233,240,247,.9) 50%, transparent 50%),
            linear-gradient(-45deg, rgba(233,240,247,.9) 50%, transparent 50%),
            linear-gradient(180deg, rgba(255,255,255,.18), rgba(255,255,255,0));
        background-size: 8px 8px, 8px 8px, 100% 100%;
        background-position: calc(100% - 18px) 48%, calc(100% - 12px) 48%, 0 0;
    }
    /* Custom attempts dropdown (styled open list) */
    .visually-hidden{ position:absolute !important; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0 }
    .attempt-dd{ position:relative; display:inline-flex; align-items:center }
    .attempt-trigger{ appearance:none; border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); padding: 8px 12px; border-radius: 12px; cursor:pointer; font-weight:800; letter-spacing:.2px; box-shadow: inset 0 1px 0 rgba(255,255,255,.06) }
    .attempt-trigger:hover{ filter: brightness(1.06) }
    .attempt-trigger .chev{ margin-left:8px; opacity:.85 }
    .attempt-menu{ position:absolute; top: calc(100% + 6px); left:0; z-index: 20; width: 100%; min-width: 100%; max-width: 92vw; box-sizing: border-box; max-height: 260px; overflow:auto; border: 1px solid var(--btnBorder); border-radius: 12px; background: linear-gradient(180deg, rgba(16,25,40,.95), rgba(10,16,28,.95)); box-shadow: 0 10px 24px rgba(0,0,0,.45); display:none }
    .attempt-dd.open .attempt-menu{ display:block }
    .attempt-option{ padding:8px 12px; cursor:pointer; display:flex; align-items:center; gap:8px; border-bottom: 1px solid rgba(60,80,120,.18) }
    .attempt-option:last-child{ border-bottom: 0 }
    .attempt-option:hover{ background: linear-gradient(180deg, rgba(96,165,250,.18), rgba(24,60,120,.12)) }
    .attempt-option .tag{ margin-right: 6px }
    /* Add a bit more space above the Results/Attempts card */
    #results-card{ margin-top: 12px; width: 100%; max-width: 100%; box-sizing: border-box; }
     /* Narrow scoped layout fixes for the missed-question list so each card
         only sizes to its visible content (matches the parsed preview). */
    #attemptMissedList{ display:flex; flex-direction:column; gap:12px }
    /* Make missed cards fill the available width of the results panel (match Results readout) */
    #attemptMissedList .qcard{ display:block; width:100%; max-width:100%; padding:12px 14px; box-sizing:border-box; margin:6px 0 }
     /* Ensure the hint row inside missed cards wraps and does not force extra height
         (this will apply once inline styles are removed from the renderer). */
    /* Match preview hint styling: keep it simple so missed cards use the same visual as preview cards */
    #attemptMissedList .qcard .hint{ display:block !important; margin-top:6px !important; color:var(--muted) }
    /* ASCII antenna */
    #radioPlayer .ascii-ant{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace; white-space: pre; line-height: 1.05; color: var(--ink); background: rgba(0,0,0,.12); border:1px solid rgba(90,110,140,.25); border-radius:10px; padding:6px 8px; text-align:center; overflow:hidden; max-width:100% }
    #radioPlayer .ascii-ant pre{ margin:0; display:inline-block; text-align:left }
    /* Prevent selection on radio ASCII */
    #radioPlayer .ascii-ant, #radioPlayer .ascii-ant pre, #rpAscii{ -webkit-user-select:none; user-select:none }
    @keyframes waves{ 0%{ opacity: 0 } 50%{ opacity: .95 } 100%{ opacity: 0 } }
    /* Pulse the ASCII block while playing */
    #radioPlayer.playing .ascii-ant pre{ animation: antPulse 1.4s ease-in-out infinite }
    @keyframes antPulse{ 0%{ opacity:.85; text-shadow: 0 0 0 rgba(106,169,255,0) } 50%{ opacity:1; text-shadow: 0 0 8px var(--brand) } 100%{ opacity:.85; text-shadow: 0 0 0 rgba(106,169,255,0) } }
    
    /* ASCII Clock (sits underneath the radio, same width) */
    /* Unboxed appearance: no border/background/shadow */
    #asciiClock{ position:fixed; left: calc(12px + env(safe-area-inset-left)); bottom: calc(12px + env(safe-area-inset-bottom)); z-index:179; box-sizing:border-box; padding:0; border-radius: 0; border:none; background: transparent; box-shadow: none; -webkit-backdrop-filter: none; backdrop-filter: none; display:inline-block }
    /* Clock text size set to 10px */
    #asciiClock pre{ margin:0; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace; white-space: pre; line-height:1; color: var(--ink); letter-spacing: -0.5px; font-size: 10px }
    /* Prevent selection on clock ASCII */
    #asciiClock, #asciiClock pre{ -webkit-user-select:none; user-select:none }
    @keyframes clockBob{ 0%{ transform: translateY(0) } 50%{ transform: translateY(-1px) } 100%{ transform: translateY(0) } }
    #asciiClock.playing pre{ animation: clockBob 3s ease-in-out infinite }
    /* Controls row */
    #radioPlayer .rp-row{ display:flex; align-items:center; gap:8px }
    #radioPlayer .rp-row>*{ flex: 0 0 auto }
    /* Let the volume slider flex within the row even when others are fixed */
    #radioPlayer .rp-row .rp-vol{ flex: 1 1 120px; min-width:60px; max-width:100% }
    /* Skip button styling: match size of main play/pause button */
    #radioPlayer #rpSkip{ flex: 0 0 auto; display:none; padding: 6px 10px; font-weight:700; font-size:12px; line-height:1; border-radius:8px; border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); cursor:pointer }
    #radioPlayer.twilight #rpSkip{ display:inline-block }
    /* Reduce select width when Twilight (Skip visible), let it grow otherwise */
    /* Twilight: let the genre select shrink to fit its visible text */
    #radioPlayer.twilight #rpGenre{ flex: 0 0 auto; width: auto; max-width: 150px; min-width: 0 }
    #radioPlayer.twilight #rpGenre.rp-select{ padding: 3px 6px; font-size: 11px }
    #radioPlayer:not(.twilight) #rpGenre{ flex: 1 1 auto }
    #radioPlayer .rp-gear{ appearance:none; border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); font-weight:700; font-size:11px; padding:4px 8px; border-radius:8px; cursor:pointer; line-height:1 }
    #radioPlayer .rp-gear[hidden]{ display:none }
    #radioPlayer .rp-custom{ display:none; padding:8px; border:1px solid var(--btnBorder); border-radius:10px; background: rgba(0,0,0,.16) }
    #radioPlayer .rp-custom.show{ display:block }
    #radioPlayer .rp-custom .row{ display:flex; gap:8px; align-items:center; margin:6px 0 }
    #radioPlayer .rp-custom label{ width:64px; color: var(--muted); font-size:12px }
    #radioPlayer .rp-custom input, #radioPlayer .rp-custom textarea{ flex:1 1 auto; background:#0c1526; color:var(--ink); border:1px solid var(--btnBorder); border-radius:6px; padding:6px 8px; font-size:12px }
    #radioPlayer .rp-custom textarea{ min-height:52px; resize:vertical }
    #radioPlayer .rp-custom .actions{ display:flex; gap:8px; justify-content:flex-end; margin-top:6px }
    #radioPlayer .rp-hint{ color: var(--muted); font-size:11px; margin-top:4px }
        /* Title row */
        #radioPlayer .rp-title{ display:flex; align-items:center; gap:8px; font-weight:800; color: var(--ink); letter-spacing:.3px; font-size:13px }
        #radioPlayer .rp-title .dot{ width:8px; height:8px; border-radius:50%; background: var(--brand); box-shadow: 0 0 12px var(--brand) }
    #radioPlayer.min .rp-meta, #radioPlayer.min .ascii-ant{ display:none }
    #radioPlayer.min{ padding-top:8px; padding-bottom:8px }
        @media (max-width: 640px){ #radioPlayer{ width: min(92vw, 340px); padding:6px 8px } #radioPlayer .rp-vol{ width: 80px } }
    </style>

</head>
<body>
        <!-- Ambient Radio Player (bottom-left boxed) -->
        <div id="radioPlayer" role="complementary" aria-label="HF Skywave Long-Range Radio">
            <div class="rp-title"><span class="dot"></span> HF Skywave Long-Range Radio <button id="rpToggle" class="rp-btn small" title="Hide/Show">Hide</button></div>
            <div class="rp-meta">
                <div id="rpNow">Radio ready</div>
                <div id="rpCast">Not receiving</div>
            </div>
                                                <div class="ascii-ant" aria-hidden="true"><pre id="rpAscii"></pre></div>
            <div class="rp-row">
                <select id="rpGenre" class="rp-select" title="Genre" aria-label="Genre">
                    <option value="custom">Custom</option>
                </select>
                <button id="rpSkip" class="rp-btn small" title="Skip to next episode">Skip</button>
                <button id="rpGear" class="rp-gear" title="Custom station settings" hidden>⚙︎</button>
                <button id="rpPlay" class="rp-btn" title="Play/Pause" aria-label="Play">▶</button>
                <input id="rpVol" class="rp-vol" type="range" min="0" max="1" step="0.01" value="0.4" title="Volume" aria-label="Volume" />
            </div>
            <div id="rpCustom" class="rp-custom" aria-hidden="true">
                <div class="row"><label for="rpCustName">Name</label><input id="rpCustName" type="text" placeholder="My Custom Station" /></div>
                <div class="row"><label for="rpCustUrls">URLs</label><textarea id="rpCustUrls" placeholder="One or more direct stream URLs (https).\nExample: https://example.com/stream.mp3\nYou can paste multiple, one per line."></textarea></div>
                <div class="rp-hint">Requirements: HTTPS direct stream (MP3/AAC), CORS-friendly, no login. Avoid web pages or shortlinks; use the actual .mp3/.aac stream URL.</div>
                <div class="actions">
                    <button id="rpCustSave" class="rp-btn small">Save</button>
                    <button id="rpCustClear" class="rp-btn small">Clear</button>
                </div>
            </div>
            <audio id="bgRadio" preload="none" crossorigin="anonymous"></audio>
            <!-- Hidden YouTube player container for Twilight Zone playlist -->
            <!-- YouTube integration removed -->
        </div>

        <!-- Random Category Modal -->
        <div id="randomCategoryModal" class="modal hidden" role="dialog" aria-modal="true" aria-label="Random quiz settings">
            <div class="modal-backdrop"></div>
            <div class="modal-panel">
                <div class="modal-header"><h3>Random Quiz — category / search</h3><button id="randomCategoryClose" class="btn">Close</button></div>
                <div class="modal-body">
                    <div class="hint">Narrow the random quiz to pages matching a Wikipedia search. Type a few words, choose from results, and click Save.</div>
                    <div style="margin-top:12px; display:flex; gap:8px; align-items:center">
                        <input id="categorySearch" placeholder="Search Wikipedia (e.g., 'biochemistry enzymes')" style="flex:1; padding:8px; font-size:14px" />
                        <button id="categoryClear" class="btn">Clear</button>
                    </div>
                    <div id="categorySearchResults" aria-live="polite"></div>
                    <div style="margin-top:10px; display:flex; gap:8px; justify-content:flex-end"><button id="categorySaveBtn" class="btn primary">Save</button></div>
                </div>
            </div>
        </div>

        <!-- Blocky ASCII Digital Clock (just above the radio) -->
        <div id="asciiClock" aria-label="Local time clock" title="Local time clock"><pre id="asciiClockPre">00:00</pre></div>
        <!-- Boot overlay shown before the main interface -->
                <div id="bootOverlay" class="boot-overlay" aria-live="polite">
            <div class="boot-card">
                    <div class="boot-ascii" aria-hidden="false" role="img" aria-label="BUNKR 108 title banner">
    <pre id="bootAscii">
_______   __    __  __    __  __    __  _______           __     ______    ______  
|       \ |  \  |  \|  \  |  \|  \  /  \|       \        _/  \   /      \  /      \ 
| $$$$$$$\| $$  | $$| $$\ | $$| $$ /  $$| $$$$$$$\      |   $$  |  $$$$$$\|  $$$$$$\
| $$__/ $$| $$  | $$| $$$\| $$| $$/  $$ | $$__| $$       \$$$$  | $$$\| $$| $$__/ $$
| $$    $$| $$  | $$| $$$$\ $$| $$  $$  | $$    $$        | $$  | $$$$\ $$ >$$    $$
| $$$$$$$\| $$  | $$| $$\$$ $$| $$$$$\  | $$$$$$$\        | $$  | $$\$$\$$|  $$$$$$ 
| $$__/ $$| $$__/ $$| $$ \$$$$| $$ \$$\ | $$  | $$       _| $$_ | $$_\$$$$| $$__/ $$
| $$    $$ \$$    $$| $$  \$$$| $$  \$$\| $$  | $$      |   $$ \ \$$  \$$$ \$$    $$
 \$$$$$$$   \$$$$$$  \$$   \$$ \$$   \$$ \$$   \$$       \$$$$$$  \$$$$$$   \$$$$$$ 
    </pre>
                    </div>
                <!-- ASCII animation (replaces spinner) - keeps same footprint as .spinner.lg -->
                <pre id="bootAsciiAnim" aria-hidden="true" class="boot-ascii-anim">[   ]</pre>
                <div class="boot-sub">Initializing…</div>
                <div id="bootPhrase" class="boot-phrase" role="status"></div>
            </div>
        </div>
        <script>
            // Ensure the Daily button outline animates unless the user prefers reduced motion.
            // Defer until DOMContentLoaded so the element exists when we query it.
            (function(){
                function initOutline(){
                    try{
                        const btn = document.getElementById('dailyQuizBtn');
                        if(!btn) return;
                        const mq = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)');
                        const canAnimate = !(mq && mq.matches);
                        if(canAnimate) btn.classList.add('animate-outline');
                        // keep API key dot above any background layers
                        const dot = btn.querySelector('.api-key-dot'); if(dot) dot.style.zIndex = 4;
                        // respond to changes in preference
                        if(mq && mq.addEventListener) mq.addEventListener('change', e => { if(e.matches) btn.classList.remove('animate-outline'); else btn.classList.add('animate-outline'); });
                        // Leave the button background to CSS so it matches other .btn elements
                    }catch(e){}
                }
                if(document.readyState === 'complete' || document.readyState === 'interactive') setTimeout(initOutline, 0); else document.addEventListener('DOMContentLoaded', initOutline);
            })();
            // On small mobile screens, set default zoom to ~50% for improved fit
            (function(){
                try{
                    var isSmall = Math.min(window.innerWidth, window.innerHeight) <= 640;
                    if(!isSmall) return;
                    var vp = document.querySelector('meta[name="viewport"]');
                    if(!vp) return;
                    var base = 'width=device-width, viewport-fit=cover';
                    vp.setAttribute('content', base + ', initial-scale=0.5, minimum-scale=0.5, maximum-scale=3, user-scalable=yes');
                }catch(e){}
            })();

            // Blocky ASCII Digital Clock
            (function(){
                const pre = document.getElementById('asciiClockPre'); const clockBox = document.getElementById('asciiClock'); if(!pre||!clockBox) return;
                const DIG = {
                    '0':[' ██ ','█  █','█  █','█  █',' ██ '],
                    '1':['  █ ',' ██ ','  █ ','  █ ',' ███'],
                    '2':[' ██ ','█  █','  █ ',' █  ','████'],
                    '3':['███ ','   █',' ██ ','   █','███ '],
                    '4':['█  █','█  █','████','   █','   █'],
                    '5':['████','█   ','███ ','   █','███ '],
                    '6':[' ██ ','█   ','███ ','█  █',' ██ '],
                    '7':['████','   █','  █ ',' █  ',' █  '],
                    '8':[' ██ ','█  █',' ██ ','█  █',' ██ '],
                    '9':[' ██ ','█  █',' ███','   █',' ██ '],
                    ':':['    ',' ██ ','    ',' ██ ','    '],
                    ' ':['    ','    ','    ','    ','    ']
                };
                let tickId=null;
                function two(n){ return (n<10?'0':'')+n; }
                // Lightweight runtime diagnostics: FPS, avg frame ms, event-loop lag, heap, uptime
                const fpsSamples = []; const maxFpsSamples = 60; let lastRaf = performance.now(); let rafRunning = true;
                let avgFrameMs = 0; let fps = 0;
                function rafTick(ts){
                    try{
                        const dt = ts - lastRaf; lastRaf = ts;
                        fpsSamples.push(dt);
                        if(fpsSamples.length>maxFpsSamples) fpsSamples.shift();
                        const sum = fpsSamples.reduce((a,b)=>a+b,0);
                        avgFrameMs = sum / fpsSamples.length;
                        fps = avgFrameMs ? Math.round(1000/avgFrameMs * 10)/10 : 0;
                    }catch(e){}
                    if(rafRunning) requestAnimationFrame(rafTick);
                }
                try{ requestAnimationFrame(rafTick); }catch(e){}

                // Event-loop lag sampler (measured via setTimeout drift)
                let lagSamples = []; const maxLag = 30; let avgLag = 0;
                function sampleLag(){
                    const want = 50; const t0 = performance.now();
                    setTimeout(()=>{
                        const drift = Math.max(0, performance.now() - t0 - want);
                        lagSamples.push(drift);
                        if(lagSamples.length>maxLag) lagSamples.shift();
                        avgLag = Math.round((lagSamples.reduce((a,b)=>a+b,0)/lagSamples.length)*10)/10;
                        // schedule next
                        setTimeout(sampleLag, 250);
                    }, want);
                }
                try{ sampleLag(); }catch(e){}

                const pageStart = performance.timing && performance.timing.navigationStart ? performance.timing.navigationStart : Date.now();

                function fmtMs(n){ return (Math.round(n*10)/10)+"ms" }

                function render(){
                    const d = new Date(); const hh = two(d.getHours()); const mm = two(d.getMinutes());
                    const chars = [hh[0],hh[1], ':', mm[0],mm[1]]; // static colon, no blink
                    // Left block (clock)
                    const left = ['', '', '', '', ''];
                    for(const ch of chars){ const glyph = DIG[ch] || DIG['0']; for(let r=0;r<5;r++){ left[r] += glyph[r] + ' '; } }
                    // Right block (filler details)
                    const rp = document.getElementById('radioPlayer');
                    const genreEl = document.getElementById('rpGenre');
                    const volEl = document.getElementById('rpVol');
                    const isPlaying = !!(rp && rp.classList.contains('playing'));
                    const mode = genreEl ? (genreEl.value === 'twilight' ? 'Twilight' : genreEl.value.charAt(0).toUpperCase()+genreEl.value.slice(1)) : '—';
                    const volPct = volEl ? Math.round((parseFloat(volEl.value||'0')||0)*100) : 0;
                    const wkd = d.toLocaleDateString(undefined, { weekday:'short' });
                    const mon = d.toLocaleDateString(undefined, { month:'short' });
                    const day = d.getDate();
                    const utc = `${two(d.getUTCHours())}:${two(d.getUTCMinutes())}:${two(d.getUTCSeconds())}`;
                    const right = [
                        `Date ${wkd} ${mon} ${two(day)}`,
                        `UTC  ${utc}`,
                        `Mode ${mode}`,
                        `Status ${isPlaying? 'Playing':'Paused'}`,
                        `Vol  ${volPct}%`
                    ];
                    // Diagnostics column (keep 5 rows to match right)
                    const usedMB = (performance && performance.memory && performance.memory.usedJSHeapSize) ? Math.round(performance.memory.usedJSHeapSize/1024/1024) : null;
                    const totalMB = (performance && performance.memory && performance.memory.jsHeapSizeLimit) ? Math.round(performance.memory.jsHeapSizeLimit/1024/1024) : null;
                    const uptimeMs = Date.now() - pageStart; const uptimeS = Math.floor(uptimeMs/1000);
                    const hhU = Math.floor(uptimeS/3600); const mmU = Math.floor((uptimeS%3600)/60); const ssU = uptimeS%60;
                    const uptime = `${hhU.toString().padStart(2,'0')}:${mmU.toString().padStart(2,'0')}:${ssU.toString().padStart(2,'0')}`;
                    // Build diagnostics with explicit label/value columns to ensure consistent alignment
                    const diagLabels = ['FPS', 'Frm', 'Lag', 'Heap', 'Uptime'];
                    const diagVals = [
                        (Math.round(fps*10)/10).toString(),
                        (Math.round(avgFrameMs*10)/10) + 'ms',
                        (avgLag !== null ? avgLag : '0') + 'ms',
                        (usedMB!==null? usedMB+'MB' : 'n/a'),
                        uptime
                    ];
                    const diag = diagLabels.map((lab,i)=> (lab.padEnd(6) + diagVals[i]));
                    // Join clock columns (left + right) and render diagnostics in a third column
                    const sep = ' │ ';
                    const sep2 = ' │ ';
                    // Build main column strings and compute padding so the diag column aligns
                    const mains = [];
                    for(let r=0;r<5;r++){ mains.push(left[r] + sep + right[r]); }
                    const colWidth = Math.max(...mains.map(m=>m.length));
                    const lines = [];
                    for(let r=0;r<5;r++){
                        const pad = Math.max(0, colWidth - mains[r].length);
                        lines.push(mains[r] + ' '.repeat(pad) + sep2 + diag[r]);
                    }
                    pre.textContent = lines.join('\n');
                    // bob while playing like radio
                    try{ if(isPlaying) clockBox.classList.add('playing'); else clockBox.classList.remove('playing'); }catch{}
                }
                // clock uses an rAF-driven loop to allow pausing when tab is hidden
                var _clockRafId = null; var _clockLastTs = 0;
                function clockLoop(ts){
                    try{
                        if(!_clockLastTs) _clockLastTs = ts;
                        var dt = ts - _clockLastTs;
                        if(dt >= 500){ render(); _clockLastTs = ts; }
                    }catch(e){}
                    if(!document.hidden) _clockRafId = requestAnimationFrame(clockLoop);
                }
                function start(){ if(_clockRafId) return; render(); _clockLastTs = 0; _clockRafId = requestAnimationFrame(clockLoop); }
                function stop(){ if(_clockRafId){ cancelAnimationFrame(_clockRafId); _clockRafId=null; } }
                // Keep the clock above radio if the radio size changes (toggle min)
                const rp = document.getElementById('radioPlayer');
                function positionClock(){
                    try{
                        if(rp){
                            // Raise radio by clock height so the clock sits underneath
                            const clkH = clockBox.getBoundingClientRect().height;
                            // Read gap from CSS variable --rpClockGap (px) on the radio, default to 12
                            let gap = 12;
                            try{ const cs = getComputedStyle(rp); const g = cs.getPropertyValue('--rpClockGap'); if(g) gap = parseInt(g)||gap; }catch{}
                            rp.style.setProperty('--rpRaise', (Math.round(clkH) + gap) + 'px');
                        }
                    }catch{}
                }
                start();
                positionClock();
                window.addEventListener('resize', ()=>{ positionClock(); });
                // Update position on radio toggle
                document.getElementById('rpToggle')?.addEventListener('click', ()=> setTimeout(positionClock, 200));
                // Optional: expose for debugging
                try{ window.asciiClock = { start, stop, render }; }catch{}
            })();
        </script>
        <script>
            // Ambient Radio Player logic (royalty-free stations + Twilight Zone YouTube mode)
            (function(){
                const $ = id => document.getElementById(id);
                const wrap = $('radioPlayer'); if(!wrap) return;
                const audio = $('bgRadio'); const playBtn = $('rpPlay'); const vol = $('rpVol'); const genreSel = $('rpGenre'); const now = $('rpNow'); const cast = $('rpCast'); const tog = $('rpToggle'); const skipBtn = $('rpSkip');
                const rpAscii = $('rpAscii');
                // Expose ASCII controls so Twilight (YouTube) can start/stop the animation
                let asciiStart = null, asciiStop = null;
                const gearBtn = $('rpGear');
                const custPanel = $('rpCustom');
                const custName = $('rpCustName');
                const custUrls = $('rpCustUrls');
                const custSave = $('rpCustSave');
                const custClear = $('rpCustClear');
                const hasMS = 'mediaSession' in navigator;

                // YouTube/Twilight integration removed. Stubs and safe placeholders kept for compatibility.
                let ytPlayer = null;
                let ytVol = 0.4;
                let ytApiLoading = false;
                let ytPendingStart = false;
                let ytContainer = null;
                let ytDiv = null;
                function isTwilight(){ return false; }
                function showYT(show) { /* noop - YouTube removed */ }
                function ensureYTApi(cb){ if(cb) cb && cb(); }
                function initYT(){ /* noop - YouTube removed */ }
                function playRandomFromPlaylist(player, ensureShuffle){ /* noop */ }
                function playOrResumeYT(){ /* noop */ }
                function formatTwilightTitle(title){ return 'Twilight Zone (Broadcast)'; }

                // Measure and fit text into the `now` element width using a canvas.
                function measureTextWidth(font, text){
                    try{
                        const c = document.createElement('canvas'); const ctx = c.getContext('2d'); ctx.font = font; return ctx.measureText(text).width;
                    }catch{ return text.length * 7; }
                }

                function getElementFont(el){
                    try{ const s = window.getComputedStyle(el); return `${s.fontWeight} ${s.fontSize} ${s.fontFamily}`; }catch{ return '700 12px system-ui'; }
                }

                function truncateToFit(el, fullText){
                    if(!el) return fullText;
                    try{
                        const ell = '…';
                        const font = getElementFont(el);
                        const maxW = el.clientWidth - 4; // small padding buffer
                        if(measureTextWidth(font, fullText) <= maxW) return fullText;
                        // binary search for maximum chars that fit
                        let lo = 0, hi = fullText.length; let best = '';
                        while(lo <= hi){
                            const mid = Math.floor((lo + hi) / 2);
                            const s = fullText.slice(0, mid).trim() + ell;
                            if(measureTextWidth(font, s) <= maxW){ best = s; lo = mid + 1; } else { hi = mid - 1; }
                        }
                        return best || fullText.slice(0, Math.max(0, Math.floor(el.clientWidth/7))).trim() + ell;
                    }catch{ return fullText; }
                }

                function setNowText(text){
                    try{
                        const full = String(text||'').trim();
                        // Hide when empty
                        if(!full){ if(now){ now.textContent=''; now.title=''; now.style.display='none'; } return; }
                        // Simply set the full text as-is (no truncation or dynamic shrinking)
                        if(now){ now.textContent = full; now.title = full; now.style.display = 'inline-block'; }
                    }catch(e){ try{ now.textContent = String(text||''); }catch{} }
                }

                // Curated public/royalty-free stations (subject to stream availability)
                // Classical: Radio Swiss Classic (public service; non-commercial; metadata via stream)
                // Jazz: Swiss Jazz (public service)
                // Blues: 1.FM Blues (free stream)
                // Bossa: SomaFM Bossa Nova
                const stations = {
                    classical: [
                        { name:'Radio Swiss Classic', urls:['https://stream.srg-ssr.ch/m/rsc_de/mp3_128'] },
                        { name:'Abacus.fm Classical', urls:['https://uk5.internet-radio.com/proxy/abacusclassics?mp=/stream','https://uk6.internet-radio.com/proxy/abacusclassics?mp=/stream'] },
                        { name:'Radio Swiss Classic (alt)', urls:['https://stream.srg-ssr.ch/m/rsc_it/mp3_128','https://stream.srg-ssr.ch/m/rsc_fr/mp3_128'] }
                    ],
                    jazz: [
                        { name:'Radio Swiss Jazz', urls:['https://stream.srg-ssr.ch/m/rsj/mp3_128'] },
                        { name:'Radio Swiss Jazz (alt)', urls:['https://stream.srg-ssr.ch/m/rsj_aacp_96'] },
                        { name:'1.FM - Adore Jazz', urls:['https://strm112.1.fm/adorejazz_mobile_mp3'] }
                    ],
                    // New: Bossa Nova
                    bossa: [
                        { name:'SomaFM: Bossa Nova', urls:['https://ice5.somafm.com/bossa-128-mp3'] }
                    ]
                };

                const KEY = {
                    genre:'rp.genre',
                    idx:'rp.idx',
                    vol:'rp.vol',
                    playing:'rp.playing',
                    customName:'rp.custom.name',
                    customUrls:'rp.custom.urls'
                };

                function parseUrls(text){
                    return (text||'')
                        .split(/\r?\n|,/)
                        .map(s=>s.trim())
                        .filter(s=>/^https:\/\//i.test(s));
                }

                function getCustomStation(){
                    try{
                        // Primary: new custom keys; Fallback: legacy yacht keys
                        const name = (localStorage.getItem(KEY.customName) || localStorage.getItem('rp.yacht.name') || '').trim();
                        const urlsText = (localStorage.getItem(KEY.customUrls) || localStorage.getItem('rp.yacht.urls') || '');
                        const urls = parseUrls(urlsText);
                        if(name && urls.length){ return [{ name, urls }]; }
                    }catch{}
                    return null;
                }

                function isTwilight(){ return genreSel.value==='twilight'; }
                function updateTwilightUI(){
                    const t = isTwilight();
                    try{ wrap.classList.toggle('twilight', t); }catch{}
                    if(skipBtn){ skipBtn.style.display = t ? '' : 'none'; }
                    // When Twilight, shrink the select to its content width to avoid extra blank space
                    try{
                        const sel = genreSel;
                        if(sel){
                            if(t){
                                // Measure selected option text width and set select width accordingly
                                const opt = sel.options[sel.selectedIndex];
                                const span = document.createElement('span'); span.style.visibility='hidden'; span.style.position='absolute'; span.style.whiteSpace='nowrap'; span.style.font = getComputedStyle(sel).font; span.textContent = opt ? opt.text : sel.value;
                                document.body.appendChild(span);
                                const w = Math.min(150, Math.max(64, Math.ceil(span.getBoundingClientRect().width) + 36));
                                sel.style.width = w + 'px';
                                document.body.removeChild(span);
                            } else {
                                sel.style.width = '';
                            }
                        }
                    }catch{}
                }
                function getList(){
                    const g = genreSel.value;
                    if(g==='custom'){
                        const cust = getCustomStation();
                        return cust || [];
                    }
                    return stations[g] || stations.classical;
                }
                function getIdx(){ const list = getList(); let i=0; try{ i = parseInt(localStorage.getItem(KEY.idx)||'0',10);}catch{} return isFinite(i)? (i % list.length + list.length)%list.length : 0; }
                function setIdx(i){ try{ localStorage.setItem(KEY.idx, String(i)); }catch{} }
                function setGenre(g){ try{ localStorage.setItem(KEY.genre, g); }catch{} }
                function setVol(v){ try{ localStorage.setItem(KEY.vol, String(v)); }catch{} }
                function setPlaying(p){ try{ localStorage.setItem(KEY.playing, p?'1':'0'); }catch{} }

                // Hide/Show toggle
                if(tog){
                    tog.addEventListener('click', function(){
                        const min = wrap.classList.toggle('min');
                        tog.textContent = min ? 'Show' : 'Hide';
                    });
                }

                // Receiving/Broadcasting animated ellipsis; message depends on mode
                let castTimer = null, castDots = 0;
                function startCastAnim(){
                    stopCastAnim();
                    // If tab is hidden, defer starting the animation until visible to save CPU
                    if(document.hidden){
                        const resumeOnVisible = function(){ try{ document.removeEventListener('visibilitychange', resumeOnVisible); if(wrap && (wrap.classList.contains('playing') || (audio && !audio.paused && !audio.ended))){ startCastAnim(); } }catch(e){} };
                        document.addEventListener('visibilitychange', resumeOnVisible);
                        return;
                    }
                    // set immediately so UI updates without waiting for first interval
                    castDots = 1;
                    cast.textContent = (isTwilight() ? 'Broadcasting' : 'Receiving skywave signals') + ' .';
                    castTimer = setInterval(()=>{
                        try{
                            castDots = (castDots + 1) % 4; // 0..3
                            const dots = castDots===0? '' : castDots===1? ' .' : castDots===2? ' ..' : ' ...';
                            const base = isTwilight() ? 'Broadcasting' : 'Receiving skywave signals';
                            cast.textContent = base + dots;
                        }catch(e){}
                    }, 600);
                }
                function stopCastAnim(){ if(castTimer){ clearInterval(castTimer); castTimer=null; } cast.textContent = idleText(); }
                function idleText(){ return isTwilight() ? 'Not broadcasting' : 'Not receiving'; }

                let curIdx = 0, curAlt = 0;
                function pick(list, i){ return list[(i % list.length + list.length) % list.length]; }
                function showYT(show){ if(ytContainer){ ytContainer.hidden = !show; ytContainer.setAttribute('aria-hidden', show? 'false':'true'); } }
                function load(i, alt){
                    const list = getList(); if(!list.length){ if(genreSel.value==='custom'){ setNowText('Custom station not set (click ⚙︎)'); } return; }
                    curIdx = (i % list.length + list.length) % list.length; curAlt = Math.max(0, alt|0);
                    const st = pick(list, curIdx);
                    const urls = Array.isArray(st.urls) ? st.urls : (st.url ? [st.url] : []);
                    if(!urls.length){ setNowText(st.name + ' (no source)'); return; }
                    const u = urls[Math.min(curAlt, urls.length-1)];
                    audio.src = u; audio.load();
                    setNowText(st.name + (urls.length>1 ? ` (alt ${curAlt+1}/${urls.length})` : ''));
                    setIdx(curIdx);
                    updateMediaSessionMeta();
                }

                function play(){
                    if(isTwilight()){
                        showYT(true); playOrResumeYT(); startCastAnim(); setPlaying(true);
                        return;
                    }
                    audio.play().then(()=>{ wrap.classList.add('playing'); playBtn.textContent = '⏸'; playBtn.setAttribute('aria-label','Pause'); startCastAnim(); setPlaying(true); if(hasMS){ try{ navigator.mediaSession.playbackState = 'playing'; }catch{} } }).catch(err=>{
                        // Autoplay might be blocked; update UI but don't error spam
                        console.warn('Radio play blocked or failed', err); wrap.classList.remove('playing'); playBtn.textContent='▶'; playBtn.setAttribute('aria-label','Play'); cast.textContent=idleText(); stopCastAnim(); setPlaying(false);
                    });
                }
                function pause(){
                    if(isTwilight()){
                        try{ ytPlayer && ytPlayer.pauseVideo && ytPlayer.pauseVideo(); }catch{}
                        wrap.classList.remove('playing'); playBtn.textContent='▶'; playBtn.setAttribute('aria-label','Play'); cast.textContent=idleText(); stopCastAnim(); setPlaying(false); if(hasMS){ try{ navigator.mediaSession.playbackState = 'paused'; }catch{} }
                        return;
                    }
                    audio.pause(); wrap.classList.remove('playing'); playBtn.textContent='▶'; playBtn.setAttribute('aria-label','Play'); cast.textContent=idleText(); stopCastAnim(); setPlaying(false); if(hasMS){ try{ navigator.mediaSession.playbackState = 'paused'; }catch{} }
                }
                function toggle(){ if(isTwilight()) { if(ytPlayer && ytPlayer.getPlayerState && ytPlayer.getPlayerState()===1) pause(); else play(); } else { if(audio.paused) play(); else pause(); } }

                // Volume
                function applyVol(v){
                    const x = Math.max(0, Math.min(1, parseFloat(v)||0));
                    if(isTwilight()){
                        ytVol = x; try{ ytPlayer && ytPlayer.setVolume && ytPlayer.setVolume(Math.round(x*100)); }catch{}
                    } else {
                        audio.volume = x;
                    }
                    vol.value = String(x); setVol(x);
                    try{ wrap.style.setProperty('--rpVolPercent', (x*100).toFixed(0) + '%'); }catch{}
                }
                vol.addEventListener('input', ()=> applyVol(vol.value));

                // Controls
                playBtn.addEventListener('click', toggle);
                if(skipBtn){
                    skipBtn.addEventListener('click', ()=>{
                        if(!isTwilight()) return;
                        ensureYTApi(()=>{ initYT(); if(ytPlayer){
                            try{
                                const st = ytPlayer.getPlayerState ? ytPlayer.getPlayerState() : -1;
                                if(st!==1){
                                    // If not already playing, start randomly in the playlist
                                    playRandomFromPlaylist(ytPlayer, true);
                                } else {
                                    // Advance to next item (shuffle ensures randomness)
                                    ytPlayer.nextVideo();
                                }
                            }catch{ try{ ytPlayer.playVideo && ytPlayer.playVideo(); }catch{} }
                        }});
                    });
                }
                genreSel.addEventListener('change', ()=>{
                    setGenre(genreSel.value);
                    updateTwilightUI();
                    // Show gear only for Custom
                    if(gearBtn){ gearBtn.hidden = genreSel.value!=='custom'; }
                    // If switching to Twilight, we do not use audio element
                    if(isTwilight()){
                        showYT(true);
                        try{ 
                            // Stop and unload any existing audio stream to avoid bleed-through
                            audio.pause();
                            audio.removeAttribute('src');
                            audio.load();
                        }catch{}
                        if(localStorage.getItem(KEY.playing)==='1') playOrResumeYT(); else { cast.textContent=idleText(); stopCastAnim(); }
                        return;
                    } else {
                        showYT(false);
                        try{ ytPlayer && ytPlayer.pauseVideo && ytPlayer.pauseVideo(); }catch{}
                    }
                    load(0,0);
                    if(localStorage.getItem(KEY.playing)==='1') play();
                });

                // Restore state
                (function init(){
                    // Fallback if stored genre removed
                    try{ const g = localStorage.getItem(KEY.genre); if(g && (stations[g] || g==='custom' || g==='twilight')) genreSel.value = g; else genreSel.value = 'classical'; }catch{ genreSel.value = 'classical'; }
                    updateTwilightUI();
                    if(gearBtn){ gearBtn.hidden = genreSel.value!=='custom'; }
                    try{ const v = localStorage.getItem(KEY.vol); if(v!=null) applyVol(v); else applyVol(vol.value); }catch{ applyVol(vol.value); }
                    if(isTwilight()){
                        showYT(true); ensureYTApi(()=>{ initYT(); });
                        try{ if(localStorage.getItem(KEY.playing)==='1'){ play(); } else { cast.textContent=idleText(); stopCastAnim(); } }catch{ cast.textContent=idleText(); stopCastAnim(); }
                    }else{
                        showYT(false);
                        load(getIdx(), 0);
                        try{ if(localStorage.getItem(KEY.playing)==='1'){ play(); } else { cast.textContent=idleText(); stopCastAnim(); } }catch{ cast.textContent=idleText(); stopCastAnim(); }
                    }
                })();

                // --- Playback stall detection and auto-recovery (audio-only genres; disabled in Twilight mode) ---
                // Track last progress to detect stalls
                let _lastProgTs = Date.now();
                audio.addEventListener('timeupdate', ()=>{ if(!isTwilight()) _lastProgTs = Date.now(); });
                audio.addEventListener('progress', ()=>{ if(!isTwilight()) _lastProgTs = Date.now(); });
                audio.addEventListener('playing', ()=>{ if(!isTwilight()) _lastProgTs = Date.now(); });

                function _shouldBePlaying(){
                    try{ return localStorage.getItem(KEY.playing) === '1'; }catch{ return false; }
                }

                let _resumeCooldownUntil = 0;
                let _resumeAttempt = 0;
                function tryResume(reason){
                    if(isTwilight()) return; // only for audio element
                    if(!_shouldBePlaying()) return;
                    const nowTs = Date.now();
                    if(nowTs < _resumeCooldownUntil) return;
                    _resumeAttempt++;
                    const backoff = Math.min(30000, 1000 * _resumeAttempt);
                    _resumeCooldownUntil = nowTs + backoff;

                    // First, attempt a simple play()
                    try{ audio.play().catch(()=>{}); }catch{}

                    // Re-check shortly; if still stalled, reload then play
                    setTimeout(()=>{
                        if(!_shouldBePlaying()) return;
                        const stalled = audio.paused || ((Date.now() - _lastProgTs) > 5000 && audio.readyState < 3);
                        if(stalled){
                            try{ audio.load(); }catch{}
                            setTimeout(()=>{ if(_shouldBePlaying()){ try{ audio.play().catch(()=>{}); }catch{} } }, 400);
                        } else {
                            // recovered; reset attempts
                            _resumeAttempt = 0; _resumeCooldownUntil = 0;
                        }
                    }, 1500);
                }

                // Respond to potential stall-ish events
                ['stalled','suspend','waiting','emptied'].forEach(ev => {
                    audio.addEventListener(ev, ()=>{
                        if(!isTwilight() && _shouldBePlaying()){
                            // brief delay to allow natural buffering before forcing resume
                            setTimeout(()=> tryResume(ev), 800);
                        }
                    });
                });

                // Watchdog: periodically ensure playback is advancing when it should
                setInterval(()=>{
                    try{
                        if(document.hidden) return; // don't run watchdog while backgrounded
                        if(isTwilight() || !_shouldBePlaying()) return;
                        const stalled = audio.paused || ((Date.now() - _lastProgTs) > 15000 && audio.readyState < 3);
                        if(stalled) tryResume('watchdog');
                    }catch(e){}
                }, 4000);

                // Update metadata when stream updates (limited cross-origin)
                audio.addEventListener('playing', ()=> { if(isTwilight()) return; wrap.classList.add('playing'); startCastAnim(); if(hasMS){ try{ navigator.mediaSession.playbackState = 'playing'; }catch{} } });
                audio.addEventListener('pause',   ()=> { 
                    if(isTwilight()) return;
                    wrap.classList.remove('playing'); 
                    if(_shouldBePlaying()){
                        cast.textContent='Reconnecting…';
                        startCastAnim();
                    } else {
                        cast.textContent='Not receiving';
                        stopCastAnim();
                    }
                    if(hasMS){ try{ navigator.mediaSession.playbackState = 'paused'; }catch{} }
                });
                audio.addEventListener('ended',   ()=> { 
                    if(isTwilight()) return;
                    if(_shouldBePlaying()){
                        // Stream ended unexpectedly; attempt to resume same source
                        tryResume('ended');
                    } else {
                        pause();
                    }
                });

                // Robust UI state sync: some external controllers may change playback
                // without invoking our handlers. Poll actual player state and update UI.
                try{
                    let uiSyncInterval = null;
                    function syncUIState(){
                        try{
                            let playing = false;
                            if(isTwilight()){
                                try{ playing = !!(ytPlayer && ytPlayer.getPlayerState && ytPlayer.getPlayerState()===1); }catch{ playing = false; }
                            } else {
                                playing = !!(audio && !audio.paused && !audio.ended);
                            }
                            if(playing){
                                if(!wrap.classList.contains('playing')){
                                    wrap.classList.add('playing'); playBtn.textContent = '⏸'; playBtn.setAttribute('aria-label','Pause'); startCastAnim();
                                }
                            } else {
                                if(wrap.classList.contains('playing')){
                                    wrap.classList.remove('playing'); playBtn.textContent = '▶'; playBtn.setAttribute('aria-label','Play'); cast.textContent = idleText(); stopCastAnim();
                                }
                            }
                        }catch(e){}
                    }
                    // start/stop UI sync in a visibility-aware way
                    uiSyncInterval = null;
                    function startUiSync(){ if(uiSyncInterval) return; uiSyncInterval = setInterval(syncUIState, 1200); }
                    function stopUiSync(){ if(uiSyncInterval){ clearInterval(uiSyncInterval); uiSyncInterval = null; } }
                    startUiSync();
                    document.addEventListener('visibilitychange', ()=>{
                        try{
                            if(document.visibilityState==='visible'){ setTimeout(syncUIState, 100); startUiSync(); }
                            else { stopUiSync(); }
                        }catch(e){}
                    });
                }catch(e){}
                audio.addEventListener('error',   ()=> {
                    if(isTwilight()) return;
                    setNowText('Stream error'); wrap.classList.remove('playing'); playBtn.textContent='▶'; cast.textContent=idleText(); stopCastAnim();
                    const list = getList(); const st = pick(list, curIdx);
                    const urls = Array.isArray(st.urls) ? st.urls : (st.url ? [st.url] : []);
                    if(curAlt < urls.length-1){
                        // try next alternate URL for the same station
                        load(curIdx, curAlt+1);
                        if(localStorage.getItem(KEY.playing)==='1') play();
                        return;
                    }
                    // try next station in the same genre
                    if(list.length > 1){
                        load(curIdx+1, 0);
                        if(localStorage.getItem(KEY.playing)==='1') play();
                        setNowText((now && now.textContent ? now.textContent : '') + ' (auto)');
                        return;
                    }
                    // try a different genre as last resort; rotate through available genres
                    const order = ['classical','jazz','bossa','custom'];
                    let gi = order.indexOf(genreSel.value); if(gi < 0) gi = 0; gi = (gi + 1) % order.length; genreSel.value = order[gi]; setGenre(order[gi]);
                    load(0, 0);
                    if(localStorage.getItem(KEY.playing)==='1') play();
                    setNowText((now && now.textContent ? now.textContent : '') + ' (auto cross-genre)');
                });
                // when a stream ends or errors, just stay idle (no skip)

                // Re-apply colors on theme change (purely cosmetic)
                document.addEventListener('theme-changed', ()=>{
                    // No-op: CSS vars already drive visuals; this is here if future sync is needed
                });

                // Custom station settings panel
                if(gearBtn && custPanel){
                    gearBtn.addEventListener('click', ()=>{
                        const show = !custPanel.classList.contains('show');
                        custPanel.classList.toggle('show', show);
                        custPanel.setAttribute('aria-hidden', show? 'false':'true');
                        if(show){
                            try{
                                custName.value = (localStorage.getItem(KEY.customName) || localStorage.getItem('rp.yacht.name') || '');
                                custUrls.value = (localStorage.getItem(KEY.customUrls) || localStorage.getItem('rp.yacht.urls') || '');
                            }catch{}
                        }
                    });
                    if(custSave){
                        custSave.addEventListener('click', ()=>{
                            const name = custName.value.trim();
                            const urls = parseUrls(custUrls.value);
                            if(!name || !urls.length){
                                alert('Please enter a Name and at least one HTTPS direct stream URL.');
                                return;
                            }
                            try{
                                localStorage.setItem(KEY.customName, name);
                                localStorage.setItem(KEY.customUrls, urls.join('\n'));
                                // remove legacy keys
                                localStorage.removeItem('rp.yacht.name');
                                localStorage.removeItem('rp.yacht.urls');
                            }catch{}
                            // If currently on custom, reload the custom station
                            if(genreSel.value==='custom'){
                                load(0,0);
                                if(localStorage.getItem(KEY.playing)==='1') play();
                            }
                            custPanel.classList.remove('show');
                            custPanel.setAttribute('aria-hidden','true');
                        });
                    }
                    if(custClear){
                        custClear.addEventListener('click', ()=>{
                            try{ localStorage.removeItem(KEY.customName); localStorage.removeItem(KEY.customUrls); localStorage.removeItem('rp.yacht.name'); localStorage.removeItem('rp.yacht.urls'); }catch{}
                            if(genreSel.value==='custom'){
                                load(0,0);
                                if(localStorage.getItem(KEY.playing)==='1') play();
                            }
                            custPanel.classList.remove('show');
                            custPanel.setAttribute('aria-hidden','true');
                        });
                    }
                }

                // Media Session API: make hardware buttons (AirPods/keyboard media keys) control our player
                function updateMediaSessionMeta(){
                    if(!hasMS) return;
                    try{
                        const list = getList();
                        const st = pick(list, curIdx|0);
                        const genreMap = { classical:'Classical', jazz:'Jazz', bossa:'Bossa Nova', custom:'Custom' };
                        const label = genreMap[genreSel.value] || 'Ambient';
                        navigator.mediaSession.metadata = new MediaMetadata({
                            title: st && st.name ? st.name : 'Ambient Radio',
                            artist: label + ' — Study Focus',
                            album: 'HF Skywave Radio'
                        });
                    }catch{}
                }
                if(hasMS){
                    try{
                        // Use the central play/pause/toggle handlers so UI updates consistently
                        navigator.mediaSession.setActionHandler('play', ()=>{ try{ play(); }catch{} });
                        navigator.mediaSession.setActionHandler('pause', ()=>{ try{ pause(); }catch{} });
                        navigator.mediaSession.setActionHandler('stop', ()=>{ try{ pause(); }catch{} });
                        // We deliberately don’t bind next/previous to avoid accidental station changes
                        navigator.mediaSession.setActionHandler('previoustrack', null);
                        navigator.mediaSession.setActionHandler('nexttrack', null);
                    }catch{}
                }

                // Optional: listen for media-key keyboard events as a fallback
                window.addEventListener('keydown', (e)=>{
                    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
                    // ignore when typing in inputs/textareas/contenteditable
                    if(tag==='input' || tag==='textarea' || (e.target && e.target.isContentEditable)) return;
                    if(e.code==='MediaPlayPause'){
                        e.preventDefault(); try{ toggle(); }catch{}
                    } else if(e.code==='MediaTrackPlay'){
                        e.preventDefault(); try{ play(); }catch{}
                    } else if(e.code==='MediaTrackPause'){
                        e.preventDefault(); try{ pause(); }catch{}
                    }
                }, { passive:false });

                // ---------- ASCII HF Skywave animation ----------
                // Small, efficient ASCII renderer that draws a vertical tower, ground and an "ionosphere" layer.
                // Modes:
                //  - Receiving (default): pulses from edge -> ionosphere -> tower.
                //  - Broadcasting (Twilight): pulses from tower -> ionosphere -> edge.
                (function(){
                    if(!rpAscii) return;

                    // Character grid size, computed to fit container width
                    let COLS = 37;   // initial guess; refined on measure
                    let ROWS = 15;   // compact height
                    let towerX = Math.floor(COLS/2);
                    let groundY = ROWS - 1;
                    let ionoY = 2; // near top
                    let towerTopY = Math.max(ionoY+1, groundY - 7);

                    // Animation state
                    let pulses = []; // { t0:number } spawn time (ms)
                    const duration = 1700; // ms for a pulse to traverse path
                    const spawnEvery = 650; // ms between pulses while playing
                    let lastSpawn = 0;
                    let rafId = null;

                    // Island + water state
                    let islandSeq = [4,8,15,16,23,42];
                    let islandText = '';
                    function updateIslandText(){ islandText = islandSeq.join(' '); }
                    updateIslandText();
                    let lastNumChange = 0; // ms
                    let waterPhase = 0;    // integer phase for horizontal wave shift

                    function clearFrame(){
                        rpAscii.textContent = buildStatic();
                    }

                    function buildStatic(){
                        // Create blank grid
                        const grid = Array.from({length: ROWS}, ()=> Array(COLS).fill(' '));
                        // Water row (bottom)
                        const wave = ['~','~','-','-','_','_'];
                        for(let x=0;x<COLS;x++) grid[groundY][x] = wave[(x + waterPhase) % wave.length];
                        // Ionosphere line
                        for(let x=0;x<COLS;x++) grid[ionoY][x] = '~';
                        // Island (numbers) just above water, centered under tower
                        let txt = islandText;
                        if(txt.length > COLS) txt = txt.slice(0, COLS);
                        const start = Math.max(0, Math.floor((COLS - txt.length)/2));
                        for(let i=0;i<txt.length;i++) grid[groundY-1][start+i] = txt[i];
                        // Tower
                        for(let y=towerTopY; y<=groundY-1; y++) grid[y][towerX] = '|';
                        grid[towerTopY][towerX] = 'A'; // antenna tip
                        // Little base feet
                        if(towerX-1>=0) grid[groundY-1][towerX-1] = '/';
                        if(towerX+1<COLS) grid[groundY-1][towerX+1] = '\\';

                        return grid.map(r => r.join('')).join('\n');
                    }

                    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

                    // Per-pulse randomized path params (receiving): from edge -> ionosphere -> tower top
                    function makePathInbound(){
                        const dir = Math.random() < 0.5 ? -1 : 1; // which edge
                        const edgeX = dir > 0 ? COLS-2 : 1;
                        const edgeY = clamp(Math.round((ionoY + towerTopY)/2) + (Math.random()<0.5?-1:1), 1, groundY-2);
                        const offset = COLS * (0.16 + Math.random()*0.16);
                        const bounceX = clamp(towerX + Math.round(dir * offset), 2, COLS-3);
                        return { dir, edgeX, edgeY, bounceX };
                    }
                    // Per-pulse path for broadcast: from tower top -> ionosphere -> edge
                    function makePathOutbound(){
                        const dir = Math.random() < 0.5 ? -1 : 1;
                        const edgeX = dir > 0 ? COLS-2 : 1;
                        const edgeY = clamp(Math.round((ionoY + towerTopY)/2) + (Math.random()<0.5?-1:1), 1, groundY-2);
                        const offset = COLS * (0.16 + Math.random()*0.16);
                        const bounceX = clamp(towerX + Math.round(dir * offset), 2, COLS-3);
                        return { dir, edgeX, edgeY, bounceX };
                    }

                    // Evaluate pulse position along piecewise path using given path (edge -> ionosphere -> tower top)
                    function pulsePointInbound(p, path){
                        const p0 = {x: path.edgeX, y: path.edgeY};
                        const p1 = {x: path.bounceX, y: ionoY};
                        const p2 = {x: towerX, y: towerTopY};
                        const d01 = Math.hypot(p1.x-p0.x, p1.y-p0.y);
                        const d12 = Math.hypot(p2.x-p1.x, p2.y-p1.y);
                        const T01 = d01/(d01+d12);
                        if(p <= T01){
                            const t = p / T01;
                            return { x: Math.round(lerp(p0.x, p1.x, t)), y: Math.round(lerp(p0.y, p1.y, t)) };
                        }else{
                            const t = (p - T01) / (1 - T01);
                            return { x: Math.round(lerp(p1.x, p2.x, t)), y: Math.round(lerp(p1.y, p2.y, t)) };
                        }
                    }
                    // Outbound path: tower -> ionosphere -> edge
                    function pulsePointOutbound(p, path){
                        const p0 = {x: towerX, y: towerTopY};
                        const p1 = {x: path.bounceX, y: ionoY};
                        const p2 = {x: path.edgeX, y: path.edgeY};
                        const d01 = Math.hypot(p1.x-p0.x, p1.y-p0.y);
                        const d12 = Math.hypot(p2.x-p1.x, p2.y-p1.y);
                        const T01 = d01/(d01+d12);
                        if(p <= T01){
                            const t = p / T01;
                            return { x: Math.round(lerp(p0.x, p1.x, t)), y: Math.round(lerp(p0.y, p1.y, t)) };
                        }else{
                            const t = (p - T01) / (1 - T01);
                            return { x: Math.round(lerp(p1.x, p2.x, t)), y: Math.round(lerp(p1.y, p2.y, t)) };
                        }
                    }

                    function lerp(a,b,t){ return a + (b-a)*t; }

                    function render(nowMs){
                        // Spawn pulses while playing; use wrapper state so Twilight works
                        const isPlaying = !!(wrap && wrap.classList && wrap.classList.contains('playing')) || (!audio.paused && !audio.ended);
                        const useOutbound = isTwilight();
                        if(isPlaying && (nowMs - lastSpawn) >= spawnEvery){
                            pulses.push({ t0: nowMs, path: useOutbound ? makePathOutbound() : makePathInbound(), outbound: useOutbound });
                            lastSpawn = nowMs;
                        }

                        // Advance water and occasionally reshuffle island numbers while playing
                        if(isPlaying){
                            waterPhase = (Math.floor(nowMs / 180)) % 1024; // gentle horizontal drift
                            if(nowMs - lastNumChange > 12000){
                                // rotate numbers for a subtle change
                                islandSeq.push(islandSeq.shift());
                                updateIslandText();
                                lastNumChange = nowMs;
                            }
                        }

                        // Build static frame then overlay dynamic artifacts
                        const baseLines = buildStatic().split('\n');
                        const grid = baseLines.map(l => l.split(''));

                        // Groundwave arcs: draw the same arc visuals for both modes;
                        // the pulse path (inbound vs outbound) determines motion, so
                        // Twilight will effectively be the normal animation reversed.
                        if(isPlaying){
                            const r = Math.floor((nowMs/220)%6)+1; // radius 1..6
                            // Use the same inward-looking marks regardless of mode
                            if(towerX-r>=0 && groundY-2>=0){ grid[groundY-2][towerX-r] = '('; }
                            if(towerX-r-1>=0 && groundY-3>=0){ grid[groundY-3][towerX-r-1] = '('; }
                            if(towerX+r<COLS && groundY-2>=0){ grid[groundY-2][towerX+r] = ')'; }
                            if(towerX+r+1<COLS && groundY-3>=0){ grid[groundY-3][towerX+r+1] = ')'; }
                        }

                        // Draw pulses and faint trails
                        const tnow = nowMs;
                        const newP = [];
                        for(const pl of pulses){
                            const age = tnow - pl.t0;
                            const p = age / duration;
                            if(p >= 1.05){ continue; } // done
                            newP.push(pl);

                            // main head
                            const pt = (pl.outbound ? pulsePointOutbound : pulsePointInbound)(Math.min(1, p), pl.path);
                            putChar(grid, pt.x, pt.y, '*');
                            // trailing points for motion feel
                            const t1 = (pl.outbound ? pulsePointOutbound : pulsePointInbound)(Math.max(0, p-0.08), pl.path); putCharFaint(grid, t1.x, t1.y, '·');
                            const t2 = (pl.outbound ? pulsePointOutbound : pulsePointInbound)(Math.max(0, p-0.16), pl.path); putCharFaint(grid, t2.x, t2.y, '·');

                            // Unified ripple: draw at the ionosphere bounce point so
                            // outbound pulses look like the normal animation reversed.
                            if(p>0.48){
                                const pr = Math.min(1, (p-0.48)/0.52);
                                const cx = (pl.path && typeof pl.path.bounceX !== 'undefined') ? pl.path.bounceX : towerX;
                                const cy = ionoY;
                                const rad = 1 + Math.floor(pr*6);
                                drawRipple(grid, cx, cy, rad, pl.path.dir);
                            }
                        }
                        pulses = newP;

                        // No extra Twilight motif; animation is just the reversed normal path

                        // Theme-colored signals only: color '*', '·', '(', ')', 'o', 'O' with var(--brand)
                        function esc(ch){
                            return ch==='&' ? '&amp;' : ch==='<' ? '&lt;' : ch==='>' ? '&gt;' : ch;
                        }
                        let html = '';
                        for(let y=0;y<grid.length;y++){
                            const row = grid[y];
                            for(let x=0;x<row.length;x++){
                                const ch = row[x];
                                if(ch==='*' || ch==='·' || ch==='(' || ch===')' || ch==='o' || ch==='O') html += `<span style="color: var(--brand)">${esc(ch)}</span>`;
                                else html += esc(ch);
                            }
                            if(y<grid.length-1) html += '\n';
                        }
                        rpAscii.innerHTML = html;

                        rafId = requestAnimationFrame(render);
                    }

                    function putChar(grid,x,y,ch){ if(y>=0&&y<grid.length&&x>=0&&x<grid[0].length) grid[y][x]=ch; }
                    function putCharFaint(grid,x,y,ch){ if(y>=0&&y<grid.length&&x>=0&&x<grid[0].length) grid[y][x]= grid[y][x]===' ' ? ch : grid[y][x]; }
                    function drawRipple(grid, cx, cy, rad, dir){
                        // Draw a small diamond-ish outline at the ionosphere bounce point.
                        // Use subtle dots instead of parentheses so the top animation doesn't show '(' or ')'.
                        const pts = [
                            [cx-rad, cy], [cx+rad, cy],
                            [cx, cy-rad], [cx, cy+rad]
                        ];
                        for(const [x,y] of pts){ putCharFaint(grid,x,y, '·'); }
                        // small diagonals (subtle)
                        putCharFaint(grid, cx+rad-1, cy-1, '·');
                        putCharFaint(grid, cx+rad-1, cy+1, '·');
                        putCharFaint(grid, cx-rad+1, cy-1, '·');
                        putCharFaint(grid, cx-rad+1, cy+1, '·');
                    }

                    function startAscii(){
                        if(rafId!=null) return;
                        lastSpawn = performance.now();
                        rafId = requestAnimationFrame(render);
                    }
                    function stopAscii(){
                        if(rafId!=null){ cancelAnimationFrame(rafId); rafId=null; }
                        pulses.length = 0; clearFrame();
                    }

                    // Wire into audio state
                    audio.addEventListener('playing', startAscii);
                    audio.addEventListener('pause', stopAscii);
                    audio.addEventListener('ended', stopAscii);
                    audio.addEventListener('error', stopAscii);

                    // Expose to outer scope so Twilight (YouTube) can control the ASCII
                    try{
                        asciiStart = function(){ try{ startAscii(); }catch{} try{ wrap.classList.add('playing'); playBtn.textContent='⏸'; playBtn.setAttribute('aria-label','Pause'); startCastAnim(); }catch{} };
                        asciiStop = function(){ try{ stopAscii(); }catch{} try{ wrap.classList.remove('playing'); playBtn.textContent='▶'; playBtn.setAttribute('aria-label','Play'); cast.textContent=idleText(); stopCastAnim(); }catch{} };
                    }catch{}

                    // Fit to container to prevent overflow and draw initial tower
                    function measureAndFit(){
                        try{
                            const box = rpAscii.parentElement; if(!box) return;
                            const maxW = Math.max(60, box.clientWidth - 12);
                            // Measure monospace char width using hidden probe
                            const probe = document.createElement('span');
                            probe.style.visibility = 'hidden';
                            probe.style.position = 'absolute';
                            probe.style.whiteSpace = 'pre';
                            probe.style.fontFamily = getComputedStyle(box).fontFamily;
                            probe.textContent = 'X'.repeat(100);
                            box.appendChild(probe);
                            const chW = Math.max(6, probe.getBoundingClientRect().width / 100);
                            box.removeChild(probe);
                            const targetCols = Math.max(24, Math.min(60, Math.floor(maxW / chW) - 2));
                            COLS = targetCols;
                            ROWS = 15;
                            towerX = Math.floor(COLS/2);
                            groundY = ROWS - 1;
                            ionoY = 2;
                            towerTopY = Math.max(ionoY+1, groundY - 7);
                        }catch(e){ /* keep defaults if measure fails */ }
                    }

                    measureAndFit();
                    clearFrame();
                    // Re-measure on resize to keep within container
                    let resizeT; window.addEventListener('resize', ()=>{ clearTimeout(resizeT); resizeT = setTimeout(()=>{ measureAndFit(); clearFrame(); }, 120); });
                    // If restored state says playing, start animation too
                    if(localStorage.getItem(KEY.playing)==='1' && !audio.paused){ startAscii(); }
                })();
            })();
        </script>
    <div class="bg-anim" aria-hidden="true"></div>

    <!-- Semi-transparent dynamic ASCII watermark background -->
    <div class="ascii-watermark" aria-hidden="true">
        <canvas id="asciiCanvas"></canvas>
        <pre id="asciiWatermark"></pre>
    </div>

    <script>
    // High-performance canvas-based ASCII background renderer
    (function(){
        var FAVORITES = ['4','8','15','16','23','42'];
        var DIGIT_BIAS = 0.6;               // denser numbers
        var FAVORITE_RARITY = 0.008;        // rare favored tokens
        var UPDATE_MS = 90;
        var COLS = 220, ROWS = 64;          // logical grid size
        var BASE = ' .,:;!iIl|?%*#@~=+^/\\_-';

    var canvas = document.getElementById('asciiCanvas');
    var ctx = canvas.getContext('2d', { alpha: true });
    var grid = new Array(ROWS);
        var cellW = 8, cellH = 10;          // pixel cell size; adjusted on resize
        // Brand color (RGB) and base numeric alphas; per-cell jitter adjusts these slightly
        var brandRGB = { r:255, g:255, b:255 };
        var baseAlphaVal = 0.06; // baseline alpha for general chars
        var numAlphaVal  = 0.12; // baseline alpha for digits/favorites
    // Global jitter seed + draw phase (randomized to avoid aligned dark patches after restore)
    var jitterSeed = 1;
    var phaseX = 0.0, phaseY = 0.0; // cell-relative offsets added to glyph draw positions

        function updateCanvasColorsFromTheme(){
            // derive colors from CSS custom properties to mesh with active theme
            var cs = getComputedStyle(document.documentElement);
            var brand = cs.getPropertyValue('--brand').trim() || '#6aa9ff';
            // parse brand as rgb/hex and create two translucent variants
            try{
                var c = brand.startsWith('#') ? hexToRgb(brand) : cssToRgb(brand);
                if(c){
                    brandRGB = { r:c.r, g:c.g, b:c.b };
                }
            }catch(e){}
        }

        function hexToRgb(hex){
            var h = hex.replace('#','');
            if(h.length===3){ h = h[0]+h[0]+h[1]+h[1]+h[2]+h[2]; }
            var num = parseInt(h,16);
            return { r:(num>>16)&255, g:(num>>8)&255, b:num&255 };
        }
        function cssToRgb(str){
            var ctx2 = document.createElement('canvas').getContext('2d');
            ctx2.fillStyle = str; // browser parses any css color
            var v = ctx2.fillStyle; // returns standardized rgb(a)
            var m = v.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
            return m ? { r:+m[1], g:+m[2], b:+m[3] } : null;
        }

        function rand(arr){ return arr[(Math.random()*arr.length)|0]; }
        function randDigit(){ return String((Math.random()*10)|0); }
        function randBase(){ return BASE[(Math.random()*BASE.length)|0]; }

        function initGrid(){
            for(var r=0;r<ROWS;r++){
                var row = new Array(COLS);
                for(var c=0;c<COLS;c++) row[c] = makeCell();
                grid[r] = row;
            }
        }

        function makeCell(){
            if(Math.random() < FAVORITE_RARITY){
                return { ch: rand(FAVORITES), isNum: true };
            }
            var useDigit = Math.random() < DIGIT_BIAS;
            var ch = useDigit ? randDigit() : randBase();
            return { ch: ch, isNum: useDigit };
        }

        function resize(){
            var dpr = window.devicePixelRatio || 1;
            // On mobile, cap DPR to reduce fill rate for better performance/battery
            var smallScreen = Math.min(window.innerWidth, window.innerHeight) <= 768;
            if(smallScreen) dpr = Math.min(dpr, 1.5);
            var w = canvas.clientWidth, h = canvas.clientHeight;
            canvas.width = Math.max(1, (w*dpr)|0);
            canvas.height = Math.max(1, (h*dpr)|0);
            ctx.setTransform(dpr,0,0,dpr,0,0);
            // compute cell size to cover with current COLS/ROWS
            cellW = w / COLS;
            cellH = h / ROWS;
            // choose a monospace-like font size from cell height
            var fontPx = Math.max(6, Math.floor(cellH*0.9));
            ctx.font = fontPx + "px 'Roboto Mono', ui-monospace, Menlo, Monaco, 'Courier New', monospace";
            ctx.textBaseline = 'middle';
        }

        // Small deterministic brightness jitter to avoid blocky patches; varies with a global seed
        function jitterFactor(r,c){
            // 32-bit integer hash (xorshift/mix), returns 0..1
            var rr = (r|0) + (jitterSeed & 0xffff);
            var cc = (c|0) ^ ((jitterSeed>>>16) & 0xffff);
            var x = rr * 374761393 ^ cc * 668265263; x = (x ^ (x>>>13)) * 1274126177; x = x ^ (x>>>16);
            var n = (x >>> 0) / 4294967295; // 0..1
            // Map to a gentle 0.85..1.15 range to keep contrast subtle
            return 0.85 + n * 0.30;
        }
        function rgbaWithAlpha(a){ return 'rgba(' + brandRGB.r + ',' + brandRGB.g + ',' + brandRGB.b + ',' + a + ')'; }

        function drawFull(){
            ctx.clearRect(0,0,canvas.width,canvas.height);
            for(var r=0;r<ROWS;r++){
                for(var c=0;c<COLS;c++){
                    var cell = grid[r][c];
                    var jf = jitterFactor(r,c);
                    var a = (cell.isNum ? numAlphaVal : baseAlphaVal) * jf; if(a > 1) a = 1; if(a < 0) a = 0;
                    ctx.fillStyle = rgbaWithAlpha(a);
                    var offX = 0.1 + phaseX; if(offX < 0) offX = 0; if(offX > 0.3) offX = 0.3;
                    var offY = 0.54 + phaseY; if(offY < 0.35) offY = 0.35; if(offY > 0.75) offY = 0.75;
                    ctx.fillText(cell.ch, c*cellW + cellW*offX, r*cellH + cellH*offY);
                }
            }
        }

        // Adaptive rAF loop (reduced mutation budget, visibility-aware)
        var rafId = null, lastTs = 0, changeAccumulator = 0;
        var changesPerSecond = (function(){
            try{
                if(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) return 1500;
                var small = Math.min(window.innerWidth, window.innerHeight) <= 768;
                return small ? 2000 : 4000;
            }catch(e){ return 2000; }
        })();
        var maxPerFrame = Math.max(200, Math.min(700, Math.floor(changesPerSecond/5)));

        function frame(ts){
            if(!lastTs) lastTs = ts;
            var dt = ts - lastTs; // ms
            lastTs = ts;
            // accumulate how many cells to mutate this frame
            changeAccumulator += (changesPerSecond * dt) / 500;
            var toMutate = Math.min(maxPerFrame, changeAccumulator | 0);
            if(toMutate > 0){
                changeAccumulator -= toMutate;
                for(var i=0;i<toMutate;i++){
                    var r = (Math.random()*ROWS)|0;
                    var c = (Math.random()*COLS)|0;
                    var cell = grid[r][c] = makeCell();
                    var x = c*cellW, y = r*cellH;
                    // Clear a slightly larger rect to avoid any AA overhang causing ghosting/doubling
                    ctx.clearRect(x - 2, y - 2, cellW + 4, cellH + 4);
                    var jf = jitterFactor(r,c);
                    var a = (cell.isNum ? numAlphaVal : baseAlphaVal) * jf; if(a > 1) a = 1; if(a < 0) a = 0;
                    ctx.fillStyle = rgbaWithAlpha(a);
                    var offX = 0.1 + phaseX; if(offX < 0) offX = 0; if(offX > 0.3) offX = 0.3;
                    var offY = 0.54 + phaseY; if(offY < 0.35) offY = 0.35; if(offY > 0.75) offY = 0.75;
                    ctx.fillText(cell.ch, x + cellW*offX, y + cellH*offY);
                }
            }
            // simple adaptive tuning based on dt
            var targetMs = 16.7;
            if(dt > targetMs*1.2) { changesPerSecond = Math.max(800, Math.floor(changesPerSecond * 0.92)); }
            else if(dt < targetMs*0.7) { changesPerSecond = Math.min(12000, Math.floor(changesPerSecond * 1.03)); }
            // schedule next frame only when page is visible to avoid burning CPU in background
            if(!document.hidden) rafId = requestAnimationFrame(frame);
        }

    function reseedVisuals(){
        jitterSeed = (Math.random()*0x7fffffff)|0;
        // small phase shift per resume so the global grid doesn’t anchor to the same subpixel origin
        phaseX = (Math.random()*0.20) - 0.10; // [-0.10, +0.10] of a cell width
        phaseY = (Math.random()*0.20) - 0.10; // [-0.10, +0.10] of a cell height
    }
    function start(){ updateCanvasColorsFromTheme(); reseedVisuals(); initGrid(); resize(); drawFull(); rafId = requestAnimationFrame(frame); }
        function onResize(){ cancelAnimationFrame(rafId); rafId = null; resize(); drawFull(); lastTs = 0; changeAccumulator = 0; rafId = requestAnimationFrame(frame); }

        var reduce = false; try{ reduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches; }catch(e){}
    if(reduce){ changesPerSecond = 1500; }
        // On small screens, start with a lower mutation budget to keep frames smooth
        try{
            var smallScreenInit = Math.min(window.innerWidth, window.innerHeight) <= 768;
            if(smallScreenInit){ changesPerSecond = Math.min(changesPerSecond, 3000); maxPerFrame = Math.min(maxPerFrame, 450); }
        }catch(e){}

        // Optional external controls
        window.__asciiBg = {
            start: function(){ if(!rafId){ start(); setHidden(false); try{ localStorage.setItem('__asciiBg','on'); }catch(e){} } },
            stop: function(){ if(rafId){ cancelAnimationFrame(rafId); rafId=null; } try{ localStorage.setItem('__asciiBg','off'); }catch(e){} },
            isRunning: function(){ return !!rafId; }
        };

        function setHidden(hide){
            try{
                var layer = document.querySelector('.ascii-watermark');
                if(layer){ layer.style.display = hide ? 'none' : ''; }
            }catch(e){}
        }

        window.addEventListener('load', function(){
            var pref = 'on'; try{ pref = localStorage.getItem('__asciiBg')||'on'; }catch(e){}
            if(pref === 'off'){ setHidden(true); }
            else { start(); }
            // Pause background animation when tab is hidden to free CPU
            try{
                document.addEventListener('visibilitychange', function(){
                    try{
                        if(document.hidden){ if(rafId){ cancelAnimationFrame(rafId); rafId = null; } }
                        else { if(!rafId){ lastTs = 0; changeAccumulator = 0; reseedVisuals(); rafId = requestAnimationFrame(frame); } }
                    }catch(e){}
                });
            }catch(e){}
            // listen for theme changes via click on orbs to update colors
            var orbs = document.querySelectorAll('.theme-capsule .theme-orb');
            orbs.forEach(function(o){ o.addEventListener('click', function(){ updateCanvasColorsFromTheme(); }); });
            // also respond to a custom theme change event so programmatic theme sets update the canvas
            try{ document.addEventListener('theme-changed', function(){ updateCanvasColorsFromTheme(); }); }catch(e){}
        });
        window.addEventListener('resize', onResize);
        // When returning to the tab, some browsers “shrink” fixed layers until a reflow; fix both layers
        function refreshGlowLayer(){ try{
            var glow = document.querySelector('.bg-anim'); if(!glow) return;
            // restart CSS animation to force reflow
            var prev = glow.style.animationName; glow.style.animationName = 'none';
            void glow.offsetWidth; // force reflow
            glow.style.animationName = '';
            // also reapply positional CSS to ensure viewport-calculated insets take effect
            glow.style.top = '-25vh'; glow.style.left = '-25vw'; glow.style.right = '-25vw'; glow.style.bottom = '-25vh';
        }catch(e){} }
        document.addEventListener('visibilitychange', function(){
            if(document.hidden){ if(rafId) cancelAnimationFrame(rafId); rafId = null; }
            else {
                // Resume animations based on user preference (not current rAF state)
                try{
                    var pref = localStorage.getItem('__asciiBg') || 'on';
                    if(pref !== 'off'){
                        refreshGlowLayer();
                        reseedVisuals(); initGrid(); onResize();
                    }
                }catch(e){
                    // Best-effort resume
                    refreshGlowLayer(); reseedVisuals(); initGrid(); onResize();
                }
            }
        });
        window.addEventListener('pageshow', function(){ refreshGlowLayer(); reseedVisuals(); initGrid(); onResize(); });
    })();
    </script>

    <!-- Sticky Notes Dock (top-right) -->
    <div id="stickyDock" class="sticky-dock" role="toolbar" aria-label="Sticky notes">
        <button id="sdNew" class="sd-btn" title="New note">New</button>
        <button id="sdList" class="sd-btn" title="All notes">All</button>
        <button id="sdClearAll" class="sd-btn" title="Clear all notes">Clear all</button>
        <span id="sdCount" class="sd-count" title="Saved notes">0</span>
    </div>
    <div id="stickyPanel" class="sticky-panel hidden" role="region" aria-label="All sticky notes">
        <div class="row">
            <input id="sdSearch" class="sd-input" type="search" placeholder="Search notes (title/text)…" />
            <button id="sdClose" class="sd-btn small" title="Close" aria-label="Close">×</button>
        </div>
        <div id="sdListWrap" class="sticky-list"></div>
    </div>

    <!-- Sticky rail: 4 clip points for pinning notes on the right -->
    <div id="stickyRail" class="sticky-rail" aria-label="Sticky clip rail">
        <div class="clip-slot" data-slot="0" title="Clip slot 1"></div>
        <div class="clip-slot" data-slot="1" title="Clip slot 2"></div>
        <div class="clip-slot" data-slot="2" title="Clip slot 3"></div>
        <div class="clip-slot" data-slot="3" title="Clip slot 4"></div>
    </div>
    <div id="stickyRailHoverzone" class="sticky-rail-hoverzone" aria-hidden="true"></div>
    <!-- Rail width resizer handle -->
    <button id="stickyRailResizer" class="sticky-rail-resizer" aria-label="Resize sticky tabs" title="Drag to resize sticky tabs width" aria-controls="stickyRail" data-min="220" data-max="520"></button>


        <script>
            // Boot overlay controller: cycles phrases, then fades into the app
                            (function(){
                                // Only show boot overlay on initial page load (per-tab)
                                var overlay = document.getElementById('bootOverlay');
                                try{
                                    var skip = sessionStorage.getItem('__bootPlayed') === '1';
                                    if(skip){ if(overlay && overlay.parentNode){ overlay.parentNode.removeChild(overlay); } return; }
                                }catch(e){}
                                // Prevent page scroll while boot overlay is visible
                                try{ document.documentElement.classList.add('booting'); document.body.classList.add('booting'); }catch(e){}
                                // Make sticky UI inert (non-focusable / non-interactive) while boot overlay runs
                                try{ if(typeof setStickyInert === 'function') setStickyInert(true); }catch(e){}
                                // Mark as played for this session
                                try{ sessionStorage.setItem('__bootPlayed','1'); }catch(e){}
                // Small ASCII animation for the boot card (replaces spinner)
                var _bootAnimId = null;
                var _bootAnimFrames = ['[   ]','[.  ]','[.. ]','[...]','[.. ]','[.  ]'];
                function startBootAnim(){ var el=document.getElementById('bootAsciiAnim'); if(!el) return; var i=0; _bootAnimId = setInterval(function(){ el.textContent = _bootAnimFrames[i%_bootAnimFrames.length]; i++; }, 220); }
                function stopBootAnim(){ try{ if(_bootAnimId) clearInterval(_bootAnimId); _bootAnimId=null; var el=document.getElementById('bootAsciiAnim'); if(el) el.textContent='[   ]'; }catch(e){} }
                var phrases = [
    "[BOOT] Don’t tell me what I can’t do… initializing.",
    "[FETCH] We have to go back… requesting previous state.",
    "[HANDSHAKE] See you in another life, brother… establishing session.",
    "[TASK] Everything happens for a reason… scheduling job.",
    "[CRON/108] Push the button… next run in 108 minutes.",
    "[VALIDATE] The numbers are bad… checksum failing: 4 8 15 16 23 42.",
    "[ROUTE] Destiny calls… recalculating path.",
    "[FAILSAFE] System failure imminent… engage protocol.",
    "[ORIENT] Orientation video loading… buffering truths.",
    "[PROTOCOL] Initiative guidelines applied… compliance passing.",
    "[I/O] The Hatch is opening… streaming secrets.",
    "[TIMER] 108 minutes remain… watchdog armed.",
    "[INPUT] Enter the code… awaiting six integers.",
    "[REBOOT] Station reboot complete… services restored.",
    "[VARIANTS] What if we’re the variables… enabling A/B routes.",
    "[IMMUTABLE] There is no reset… write-once mode set.",
    "[MERGE] Everything that rises must converge… resolving branches.",
    "[LOCK] The past can’t be changed… git history protected.",
    "[BOUND] You can’t escape the Island… sandbox enforced.",
    "[GUARD] The light must be protected… rate limiter engaged.",
    "[CHOICE] Fate vs. free will… prompting user decision.",
    "[POLICY] You’re not supposed to leave… egress blocked by rule.",
    "[SECRET] What lies in the shadow of the statue… decrypting payload.",
    "[RETRO] You all, everybody… broadcasting to subscribers.",
    "[WATCH] Monsters are real… anomaly detector online.",
    "[SEED] I made my own luck… seeding RNG.",
    "[CACHE] I remember… warm cache restored.",
    "[TIME] Time’s not a straight line… enabling jitter buffer.",
    "[INTENT] We were brought here for a reason… classifier confident.",
    "[HOME] There is no place like home… redirecting to root.",
    "[RELEASE] You can let go now… freeing resources.",
    "[INBOUND] They’re coming… opening inbound ports.",
    "[CYCLE] The end is the beginning… restarting event loop.",
    "[PING] 815 responding… round-trip stable.",
    "[TRIGGER] Button 42 pressed… executing failsafe.",
    "[MAP] Reconstructing flight path 815… plotting vectors.",
    "[CAST] Oceanic check-in… session tokens refreshed.",
    "[GUARDIAN] Smoke on the stack… firewall tightening.",
    "[LAMBDA] The Moth emerges… escalating privileges.",
    "[SYNC] See you in another timeline… state sync complete."
                ];
                overlay = overlay || document.getElementById('bootOverlay');
                if(!overlay) return;
                var phraseEl = document.getElementById('bootPhrase');
                var subEl = overlay.querySelector('.boot-sub');
                // Fit ASCII title to boot card width by scaling
                function fitBootAscii(){
                    try{
                        var pre = document.getElementById('bootAscii'); if(!pre) return;
                        var container = pre.parentElement; if(!container) return;
                        // prepare for measurement
                        var priorDisplay = pre.style.display;
                        pre.style.display = 'inline-block';
                        pre.style.transform = 'none';
                        pre.style.transformOrigin = '50% 0%';
                        container.style.height = 'auto';
                        // Measure natural width (max-content) while unscaled
                        // leave horizontal slack to avoid rounding overflow and shadow bleed
                        var cw = (container.clientWidth || container.offsetWidth || 0) - 10;
                        var naturalRect = pre.getBoundingClientRect();
                        var naturalWidth = naturalRect.width || (pre.scrollWidth || 1);
                        var scale = Math.min(1, cw / naturalWidth);
                        // Apply a stronger fudge factor to guarantee fit
                        scale = Math.max(0.1, Math.min(1, scale * 0.975));
                        pre.style.transform = 'scale(' + scale + ')';
                        var rect = pre.getBoundingClientRect();
                        // Reserve slightly more than measured to avoid clipping bottom row
                        container.style.height = Math.ceil(rect.height + 10) + 'px';
                        // Keep inline-block to preserve measured scrollWidth behavior
                        pre.style.display = 'inline-block';
                        // Safety pass: if rect width still exceeds container width, correct using rect-based ratio
                        var rw = pre.getBoundingClientRect().width;
                        var cw2 = (container.clientWidth || container.offsetWidth || 0) - 10;
                        if(rw > cw2){
                            var scale2 = Math.max(0.1, scale * (cw2 / rw) * 0.98);
                            pre.style.transform = 'scale(' + scale2 + ')';
                            var rect2 = pre.getBoundingClientRect();
                            container.style.height = Math.ceil(rect2.height + 10) + 'px';
                            scale = scale2; rect = rect2; // use final values
                        }
                        // Final centering: translateX so the scaled rect is centered inside container
                        var cRect = container.getBoundingClientRect();
                        var desiredLeft = (cRect.width - rect.width) / 2;
                        var currentLeft = rect.left - cRect.left;
                        var dx = desiredLeft - currentLeft;
                        pre.style.transform = 'translateX(' + dx.toFixed(2) + 'px) scale(' + scale + ')';
                    }catch(e){}
                }
                var i = 0, elapsed = 0;
                var total = 30000 + Math.random()*15000; // 30–45s

                function durationFor(text){
                    var len = (text||'').length;
                    // Base + per-char time; clamped to reasonable reading window
                    var ms = 1400 + len*55; // ~0.055s per char
                    if(ms < 2200) ms = 2200; // min 2.2s
                    if(ms > 7200) ms = 7200; // max 7.2s
                    return ms;
                }

                function showNext(){
                    if(!overlay) return;
                    var text = phrases[i % phrases.length];
                    var seg = durationFor(text);
                    if(elapsed + seg > total){ seg = Math.max(1400, total - elapsed); }
                    if(seg <= 0){ endBoot(); return; }
                    phraseEl.classList.remove('show');
                    // fade out then swap
                    setTimeout(function(){ phraseEl.textContent = text; phraseEl.classList.add('show'); }, 180);
                    elapsed += seg;
                    i++;
                    setTimeout(function(){
                        if(elapsed >= total) { endBoot(); }
                        else { showNext(); }
                    }, seg);
                }

                function endBoot(){
                    if(!overlay) return;
                    subEl.textContent = 'Ready.';
                                overlay.classList.add('hidden');
                                setTimeout(function(){ 
                                    if(overlay && overlay.parentNode){ overlay.parentNode.removeChild(overlay); }
                             overlay = null; 
                                                         try{ document.documentElement.classList.remove('booting'); document.body.classList.remove('booting'); }catch(e){}
                                                         // Restore sticky interactivity now that boot is finished
                                                         try{ if(typeof setStickyInert === 'function') setStickyInert(false); }catch(e){}
                                                         // stop ASCII animation
                                                         try{ if(typeof stopBootAnim === 'function') stopBootAnim(); }catch(e){}
                                                         // After boot ends, ensure sticky notes layout is computed and reflowed
                                                         try{ if(typeof layoutAllSlots === 'function') { layoutAllSlots(); } }catch(e){}
                                }, 650);
                }

                // Start sequence after a brief tick so initial paint happens
                setTimeout(function(){
                    subEl.textContent = 'Loading modules…';
                    fitBootAscii();
                    try{ if(typeof startBootAnim === 'function') startBootAnim(); }catch(e){}
                    showNext();
                }, 120);
                // Keep API key dots updated: green when key present, red when missing
                function updateApiDots(){
                    try{
                        let key = null;
                        if(typeof getEffectiveGemKey === 'function'){
                            key = getEffectiveGemKey();
                        }
                        if(!key){ try{ key = localStorage.getItem('gemini.key'); }catch{} }
                        const randomDot = document.getElementById('randomKeyDot');
                        const dailyDot = document.getElementById('dailyKeyDot');
                        if(randomDot){ randomDot.classList.remove('missing','present'); randomDot.classList.add(key ? 'present' : 'missing'); }
                        if(dailyDot){ dailyDot.classList.remove('missing','present'); dailyDot.classList.add(key ? 'present' : 'missing'); }
                        // enable/disable gear button when key absent OR when API key is disabled via toggle
                        try{
                            const gear = document.getElementById('randomGearBtn');
                            const enabledToggle = document.getElementById('globalGemEnable');
                            const enabled = !!(enabledToggle && enabledToggle.checked);
                            const ok = !!key && enabled;
                            if(gear){
                                gear.disabled = !ok;
                                gear.setAttribute('aria-disabled', (!ok) ? 'true' : 'false');
                                gear.classList.toggle('disabled', !ok);
                                if(!ok){ gear.setAttribute('tabindex','-1'); } else { gear.removeAttribute('tabindex'); }
                            }
                        }catch(e){}
                    }catch(e){}
                }
                // update now and on storage events or input changes
                try{ updateApiDots(); window.addEventListener('storage', (e)=>{ if(e.key === 'gemini.key') updateApiDots(); }); const gk = document.getElementById('globalGemKey'); if(gk) gk.addEventListener('input', ()=>{ setTimeout(updateApiDots,10); }); const ge = document.getElementById('globalGemEnable'); if(ge) ge.addEventListener('change', ()=>{ setTimeout(updateApiDots,10); }); }catch(e){}
                // Re-fit after fonts are ready in case metrics shift
                try{ if(document.fonts && document.fonts.ready){ document.fonts.ready.then(function(){ fitBootAscii(); }); } }catch(e){}
                window.addEventListener('resize', function(){ if(!overlay) return; fitBootAscii(); });
            })();
        </script>


    <!-- Theme capsule: 6 tricolor orbs with numeric overlays controlling background and button colors -->
    <div class="theme-capsule" id="themeCapsule" aria-label="Theme colors">
       <div class="theme-orb orb-ocean" data-theme="ocean" title="Ocean"></div>
       <div class="theme-orb orb-sunset" data-theme="sunset" title="Sunset"></div>
        <div class="theme-orb orb-forest" data-theme="forest" title="Forest"></div>
       <div class="theme-orb orb-violet" data-theme="violet" title="Violet"></div>
       <div class="theme-orb orb-ember" data-theme="ember" title="Ember"></div>
    <div class="theme-orb orb-greyscale" data-theme="greyscale" title="Greyscale"></div>
    </div>
    <div class="mt-8 flex gap-8" id="bgToggles">
    <button id="asciiBgToggle" class="btn pill" title="Toggle animated ASCII background">Turn off animated background</button>
    <div class="news-inline">
      <button id="newsToggle" class="btn pill" title="Enable or disable the top news bar">Disable news</button>
      <!-- Collapsible side pill for news sources: toggle expands into a horizontal pill containing options -->
      <div id="newsSideMenu" class="news-side-menu" aria-hidden="false">
          <button id="newsMenuToggle" class="btn pill news-menu-toggle" aria-expanded="false" aria-controls="newsSideMenuContent" title="Show news options">+</button>
          <div id="newsSideMenuContent" class="news-side-menu-content" role="menu" aria-hidden="true">
              <div class="news-side-pill" role="presentation">
                  <button class="btn small news-source-opt" data-source="pubmed" id="newsSourcePubMed" role="menuitem">PubMed</button>
                  <button class="btn small news-source-opt" data-source="arxiv" id="newsSourceArxiv" role="menuitem">arXiv</button>
              </div>
          </div>
      </div>
    </div>
    <style id="newsSideMenuStyles">
    /* Side-extending pill menu (left edge) */
    /* place inline next to other controls (e.g. #newsToggle) so it aligns horizontally */
    .news-side-menu{ position:relative; left:auto; top:auto; transform:none; display:inline-flex; align-items:center; gap:8px; pointer-events:auto }
     /* Make the small plus toggle visually match the nearby Disable news button (size + vertical alignment)
         This is intentionally narrow and only updates the toggle itself so overall layout is unchanged. */
     .news-menu-toggle{ border-radius:999px; border:1px solid rgba(255,255,255,0.06); background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); color:var(--ink); font-size:14px; display:inline-flex; align-items:center; justify-content:center; cursor:pointer; padding:10px 14px; line-height:1; align-self:center; margin:0 }
    .news-side-menu-content{ transform-origin:left center; transform:scaleX(0); transition:transform 220ms cubic-bezier(.2,.9,.2,1), opacity 180ms ease; opacity:0; display:flex; align-items:center; }
    .news-side-menu.expanded .news-side-menu-content{ transform:scaleX(1); opacity:1 }
    .news-side-pill{ display:flex; flex-direction:row; gap:8px; align-items:center; padding:6px 10px; border-radius:999px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); box-shadow: 0 6px 18px rgba(0,0,0,0.35); }
    /* Make the inner buttons capsule shaped (pills) and align horizontally */
    .news-side-pill .btn{ border-radius:999px; padding:8px 12px; white-space:nowrap; font-weight:700; box-shadow: inset 0 1px 0 rgba(255,255,255,0.02); background:transparent; }
    /* Make toggle visually change to minus when expanded via JS (no extra close button) */
    .news-menu-toggle:focus, .news-side-pill .btn:focus{ outline: 3px solid rgba(96,165,250,0.18); outline-offset:3px }
    @media (max-width:720px){ .news-side-menu{ left:6px } .news-side-pill{ padding:6px 8px } }
    /* Inline wrapper so the Disable news button and the + toggle sit side-by-side */
    .news-inline{ display:inline-flex; gap:8px; align-items:center }
    </style>
    <script>
    (function(){
        const menu = document.getElementById('newsSideMenu');
        const toggle = document.getElementById('newsMenuToggle');
        const content = document.getElementById('newsSideMenuContent');
        if(!menu || !toggle || !content) return;
        function expand(){
            menu.classList.add('expanded');
            toggle.setAttribute('aria-expanded','true');
            content.setAttribute('aria-hidden','false');
            toggle.textContent = '−';
        }
        function collapse(){
            menu.classList.remove('expanded');
            toggle.setAttribute('aria-expanded','false');
            content.setAttribute('aria-hidden','true');
            toggle.textContent = '+';
        }
        toggle.addEventListener('click', ()=>{ menu.classList.contains('expanded') ? collapse() : expand(); });
        // Close on Escape when expanded
        document.addEventListener('keydown', (ev)=>{ if(ev.key === 'Escape' && menu.classList.contains('expanded')){ collapse(); toggle.focus(); } });
        // If a menu item is clicked, collapse after action
        document.querySelectorAll('#newsSideMenu .news-source-opt').forEach(b=> b.addEventListener('click', ()=>{ collapse(); toggle.focus(); }));
        // Initialize collapsed
        collapse();
    })();
    </script>
    <button id="dailyQuizBtn" class="btn pill" title="Generate a daily random quiz" data-label="Daily Random Quiz" aria-label="Daily Random Quiz"><span id="dailyKeyDot" class="api-key-dot missing" aria-hidden="true"></span></button>
        <span class="random-controls">
            <button id="randomQuizBtn" class="btn pill" title="Generate a random quiz now" data-label="Random Quiz" aria-label="Random Quiz"><span id="randomKeyDot" class="api-key-dot missing" aria-hidden="true"></span></button>
            <span class="gear-badge" id="randomGearWrap"><span class="gear-circle" aria-hidden="true"><button id="randomGearBtn" class="gear-btn" title="Random quiz settings" aria-label="Random quiz settings">⚙︎</button></span></span>
        </span>
    </div>

    <!-- Top News Bar (NPR) - full width at very top -->
    <div id="newsBar" class="news-bar" role="region" aria-label="Top news headlines">
        <div id="newsRow" class="news-row"></div>
    </div>
    <div id="contentRoot" class="container mt-6">
    
        <script>
        // Unified Top Safe Area manager + NPR headlines fetcher
        (function(){
            const FEED = 'https://feeds.npr.org/1001/rss.xml';
            // Multiple CORS-safe proxy strategies (try in order)
            const PROXIES = [
                (u)=> `https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`,
                (u)=> `https://cors.isomorphic-git.org/${u}`,
                (u)=> `https://r.jina.ai/https://${u.replace(/^https?:\/\//,'')}`,
                (u)=> `https://r.jina.ai/http://${u.replace(/^https?:\/\//,'')}`,
            ];
            const PREF_KEY = '__newsBarPref'; // 'on' | 'off'
            const CACHE_KEY = '__newsCacheV2';
            const MAX_AGE_MS = 24 * 60 * 60 * 1000; // 24h rolling window
            const REFRESH_MS = 60 * 60 * 1000; // hourly updates
            const newsBar = document.getElementById('newsBar');
            const newsRow = document.getElementById('newsRow');
            const toggleBtn = document.getElementById('newsToggle');
            // Fixed ticker speed (px per second)
            const FIXED_NEWS_TICKER_SPEED = 48; // change this number to adjust scroll speed
            let tickerRAF = 0, tickerX = 0, tickerSpeed = FIXED_NEWS_TICKER_SPEED;
            let trackA = null, trackB = null;
            let itemsState = [];

            // Top offset manager computes and sets --topSafeArea so all fixed UI moves in sync
            function computeTopSafeArea(){
                let h = 0;
                try{
                    if(newsBar && newsBar.style.display !== 'none'){
                        const r = newsBar.getBoundingClientRect();
                        h = Math.max(0, Math.ceil(r.height));
                    }
                }catch{}
                // Sync both variables so either stylesheet path honors the offset
                document.documentElement.style.setProperty('--topSafeArea', h + 'px');
                document.documentElement.style.setProperty('--newsOffset', h + 'px');
                // Update sticky scaling tied to the safe area
                computeStickyScale();
                return h;
            }

            // -- Daily Random Quiz: fetch a random Wikipedia topic once per 24h, then ask Gemini to create a 10-question, 4-choice quiz
            const DAILY_TOPIC_KEY = '__dailyTopic'; // stores {topic, fetchedAt}
            const DAILY_QUIZ_KEY = '__dailyQuiz'; // stores generated quiz JSON

            // accept optional AbortSignal as first parameter
            async function fetchRandomWikipediaTitle(signal){
                // Use Wikipedia REST random endpoint to get a random page title
                try{
                    // If caller provided a search query via global preference, use search API instead
                    try{ var savedCategory = localStorage.getItem('random.category'); }catch{};
                    if(savedCategory && savedCategory.length){
                        // Use opensearch to find matches, fall back to random when no results
                        const qs = encodeURIComponent(savedCategory);
                        const url = `https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch=${qs}&utf8=&format=json&origin=*`;
                        const r = await fetch(url, signal ? { signal } : undefined);
                        if(r && r.ok){ const d = await r.json(); if(d && d.query && Array.isArray(d.query.search) && d.query.search.length){ return d.query.search[0].title; } }
                        // fallback to random if search failed
                    }
                    const resp = await fetch('https://en.wikipedia.org/api/rest_v1/page/random/title', signal ? { signal } : undefined);
                    if(!resp.ok) throw new Error('random title fetch failed');
                    const data = await resp.json(); // {items: [{id, key, title}] } or {title: '...'} depending on API
                    // handle shape variations
                    if(data && data.title) return data.title;
                    if(Array.isArray(data) && data.length && data[0].title) return data[0].title;
                    if(data && data.items && data.items[0] && data.items[0].title) return data.items[0].title;
                    // fallback: use Special:Random redirect hack
                    const r = await fetch('https://en.wikipedia.org/wiki/Special:Random', signal ? { redirect: 'follow', signal } : { redirect: 'follow' });
                    const final = r.url; const parts = final.split('/'); return decodeURIComponent(parts[parts.length-1].replace(/_/g,' '));
                }catch(e){ console.warn('Random wiki title failed', e); throw e; }
            }

            function getDailyTopic(){
                try{
                    const raw = localStorage.getItem(DAILY_TOPIC_KEY);
                    if(!raw) return null;
                    const obj = JSON.parse(raw);
                    if(!obj || !obj.topic || !obj.fetchedAt) return null;
                    const age = Date.now() - obj.fetchedAt;
                    if(age > 24*60*60*1000) return null;
                    return obj.topic;
                }catch(e){ return null; }
            }

            function saveDailyTopic(topic){ try{ localStorage.setItem(DAILY_TOPIC_KEY, JSON.stringify({ topic, fetchedAt: Date.now() })); }catch(e){} }

            // accept optional AbortSignal as third parameter
            async function askGeminiForQuiz(topic, apiKey, signal){
                // returns { questions: [{q, choices:[a,b,c,d], answerIndex}] }
                if(!topic) throw new Error('No topic');
                // Check for SDK availability and API key
                try{
                    if(!window.GoogleGenerativeAI) {
                        try{ const mod = await import('https://esm.run/@google/generative-ai'); window.GoogleGenerativeAI = mod.GoogleGenerativeAI; }catch(e){ throw new Error('Gemini SDK load failed'); }
                    }
                    const AI = window.GoogleGenerativeAI;
                    const client = apiKey ? new AI(apiKey) : null;
                    if(!client) throw new Error('No Gemini API key provided');
                    const model = client.getGenerativeModel({ model: 'gemini-2.5-flash' });

                    const prompt = `Create a JSON array of 10 multiple-choice questions about the following Wikipedia topic: "${topic}". `+
                        `Each item should be an object with fields: "question" (string), "choices" (array of 4 strings), and "answerIndex" (0-3 index of correct choice). `+
                        `Avoid using the exact phrasing from Wikipedia; make the questions educational and reasonably challenging for someone with general knowledge. Return ONLY valid JSON.`;

                    // Use the SDK's generateContent API (newer SDKs use generateContent)
                    // If a signal is provided, race the SDK call with a promise that rejects on abort
                    const genPromise = model.generateContent({ contents: [{ role: 'user', parts: [{ text: prompt }] }] });
                    let resp;
                    if(signal && signal.aborted){ throw new DOMException('Aborted', 'AbortError'); }
                    if(signal){
                        resp = await Promise.race([
                            genPromise,
                            new Promise((_, rej) => { signal.addEventListener('abort', ()=> rej(new DOMException('Aborted', 'AbortError')), { once: true }); })
                        ]);
                    } else {
                        resp = await genPromise;
                    }

                    // Robust extraction of text from multiple possible response shapes
                    let text = '';
                    try{
                        if(resp && typeof resp === 'object'){
                            // Common: resp.response.text() helper
                            if(resp.response && typeof resp.response.text === 'function'){
                                text = String((await resp.response.text()) || '');
                            } else if(resp.output && Array.isArray(resp.output) && resp.output.length){
                                // Older shape: output -> [{ content: [{ text: '...' }] }]
                                const out0 = resp.output[0];
                                if(out0 && out0.content && Array.isArray(out0.content)){
                                    text = out0.content.map(c=> c?.text || (typeof c === 'string' ? c : '')).join('\n');
                                } else {
                                    text = JSON.stringify(resp.output);
                                }
                            } else if(resp.response && resp.response.outputs && Array.isArray(resp.response.outputs)){
                                // Newer REST-like shape
                                text = resp.response.outputs.map(o=> (o.content||[]).map(c=>c.text||'').join('')).join('\n');
                            } else {
                                text = JSON.stringify(resp);
                            }
                        } else {
                            text = String(resp || '');
                        }
                    }catch(e){ text = JSON.stringify(resp); }

                    // Find first JSON substring in the returned text
                    const m = String(text).match(/\{[\s\S]*\}|\[[\s\S]*\]/);
                    if(!m) throw new Error('No JSON in model output: ' + (String(text).slice(0,300)) );
                    const parsed = JSON.parse(m[0]);
                    if(!Array.isArray(parsed) || parsed.length < 1) throw new Error('Parsed quiz invalid');
                    return { questions: parsed };
                }catch(e){ console.error('Quiz generation failed', e); throw e; }
            }

            // --- New feed fetchers: data.gov and arXiv ---
            // normalize to [{title,link,pubDate}]
            async function fetchPubMed(){
                try{
                    const apiKey = (function(){ try{ return localStorage.getItem('ncbi.apiKey'); }catch(e){ return null; } })();
                    const reldays = 2;
                    const retmax = 50;
                    const esearchUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=pubmed&retmode=json&reldate=${reldays}&datetype=edat&retmax=${retmax}${apiKey?('&api_key='+encodeURIComponent(apiKey)):''}`;
                    const esearchText = await fetchTextFromAny(esearchUrl);
                    const esearch = JSON.parse(esearchText);
                    let idlist = (esearch && esearch.esearchresult && Array.isArray(esearch.esearchresult.idlist)) ? esearch.esearchresult.idlist : [];
                    if(!idlist.length){
                        const altUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=pubmed&retmode=json&sort=pub+date&retmax=${retmax}${apiKey?('&api_key='+encodeURIComponent(apiKey)):''}`;
                        try{ const t = await fetchTextFromAny(altUrl); const alt = JSON.parse(t); idlist = idlist.concat((alt.esearchresult && Array.isArray(alt.esearchresult.idlist) ? alt.esearchresult.idlist : [])); }catch(e){}
                    }
                    idlist = idlist.slice(0, retmax);
                    if(!idlist || !idlist.length) throw new Error('No recent PubMed IDs');

                    // Prefer efetch XML to get reliable ArticleTitle and dates
                    try{
                        const efetchUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=pubmed&id=${encodeURIComponent(idlist.join(','))}&retmode=xml${apiKey?('&api_key='+encodeURIComponent(apiKey)):''}`;
                        const efetchText = await fetchTextFromAny(efetchUrl);
                        const xdoc = new DOMParser().parseFromString(efetchText, 'text/xml');
                        const articles = Array.from(xdoc.getElementsByTagName('PubmedArticle')||[]);
                        const out = [];
                        for(const art of articles){
                            try{
                                const pmidEl = art.getElementsByTagName('PMID')[0];
                                const pmid = pmidEl ? (pmidEl.textContent||'').trim() : null;
                                const titleEl = art.getElementsByTagName('ArticleTitle')[0];
                                const title = titleEl ? (titleEl.textContent||'').trim() : (pmid ? `PubMed ${pmid}` : '(no title)');
                                // attempt to get a publication date
                                let pubDate = '';
                                const pubDateEl = art.getElementsByTagName('PubDate')[0] || art.getElementsByTagName('DateCreated')[0];
                                if(pubDateEl){ pubDate = (pubDateEl.textContent||'').trim(); }
                                // fallback: try Article/Journal/JournalIssue/PubDate
                                if(!pubDate){
                                    try{
                                        const jpd = art.getElementsByTagName('PubDate')[0]; if(jpd){ pubDate = (jpd.textContent||'').trim(); }
                                    }catch(e){}
                                }
                                const link = pmid ? `https://pubmed.ncbi.nlm.nih.gov/${pmid}/` : '#';
                                out.push({ title, link, pubDate: pubDate || new Date().toString() });
                            }catch(e){ /* ignore per-article parse errors */ }
                        }
                        if(out && out.length) { try{ localStorage.setItem(CACHE_KEY+'_pubmed', JSON.stringify({ t: Date.now(), items: out })); }catch{}; return out; }
                    }catch(e){ /* efetch failed, fall back to esummary JSON below */ }

                    // Fallback: use esummary JSON
                    try{
                        const esummaryUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?db=pubmed&id=${encodeURIComponent(idlist.join(','))}&retmode=json${apiKey?('&api_key='+encodeURIComponent(apiKey)):''}`;
                        const sumText = await fetchTextFromAny(esummaryUrl);
                        const sumObj = JSON.parse(sumText);
                        const uids = sumObj.result && sumObj.result.uids ? sumObj.result.uids : [];
                        const results = [];
                        for(const uid of uids){
                            const rec = sumObj.result && sumObj.result[uid] ? sumObj.result[uid] : null;
                            const title = rec ? (rec.title || rec.fulljournalname || rec.sorttitle || '') : '';
                            const pubdate = rec ? (rec.pubdate || rec.epubdate || '') : '';
                            const link = `https://pubmed.ncbi.nlm.nih.gov/${uid}/`;
                            results.push({ title: (String(title||'').trim()) || `PubMed ${uid}`, link, pubDate: pubdate || new Date().toString() });
                        }
                        try{ localStorage.setItem(CACHE_KEY+'_pubmed', JSON.stringify({ t: Date.now(), items: results })); }catch{}
                        return results;
                    }catch(e){ /* final fallback to cache */ }

                    try{ const raw = localStorage.getItem(CACHE_KEY+'_pubmed'); if(raw){ return JSON.parse(raw).items||[]; } }catch{}
                    return [];
                }catch(e){
                    try{ const raw = localStorage.getItem(CACHE_KEY+'_pubmed'); if(raw){ return JSON.parse(raw).items||[]; } }catch{}
                    return [];
                }
            }

            async function fetchArxiv(){
                try{
                    const API = 'https://export.arxiv.org/api/query?search_query=all&start=0&max_results=50&sortBy=submittedDate&sortOrder=descending';
                    let text = null;
                    // 1) try a direct fetch first (may succeed if CORS allowed)
                    try{
                        const r = await fetch(API, { mode: 'cors' });
                        if(r && r.ok){ text = await r.text(); }
                    }catch(e){ /* ignore direct fetch errors */ }
                    // 2) if direct failed or returned very little, use proxy attempts via fetchTextFromAny
                    if(!text || text.length < 50){
                        try{ text = await fetchTextFromAny(API); }catch(e){ /* ignore */ }
                    }
                    if(!text) throw new Error('arXiv fetch failed (no text)');

                    // Try robust XML parsing (namespace tolerant)
                    let items = [];
                    try{
                        const doc = new DOMParser().parseFromString(text, 'text/xml');
                        let entries = [];
                        try{ entries = Array.from(doc.getElementsByTagNameNS('*','entry') || []); }catch(e){}
                        if(!entries || !entries.length){ try{ entries = Array.from(doc.getElementsByTagName('entry') || []); }catch(e){ entries = []; } }
                        items = entries.map(e=>{
                            try{
                                // title
                                let title = '';
                                try{
                                    const tns = e.getElementsByTagNameNS('*','title');
                                    if(tns && tns.length) title = (tns[0].textContent||'').replace(/\s+/g,' ').trim();
                                    else { const t0 = e.getElementsByTagName('title')[0]; if(t0) title = (t0.textContent||'').replace(/\s+/g,' ').trim(); }
                                }catch(err){ title = ''; }

                                // link
                                let link = '';
                                try{
                                    const linkEls = Array.from(e.getElementsByTagNameNS('*','link') || e.getElementsByTagName('link') || []);
                                    for(const le of linkEls){
                                        const rel = (le.getAttribute && le.getAttribute('rel')) || '';
                                        const href = (le.getAttribute && le.getAttribute('href')) || '';
                                        if(href && (!rel || rel === 'alternate')){ link = href; break; }
                                    }
                                }catch(err){}
                                if(!link){ try{ const idEl = e.getElementsByTagNameNS('*','id')[0] || e.getElementsByTagName('id')[0]; if(idEl) link = (idEl.textContent||'').trim(); }catch(err){} }
                                if(link && link.indexOf('export.arxiv.org')>=0) link = link.replace(/^https?:\/\/export\.arxiv\.org/, 'https://arxiv.org');

                                // pubDate
                                let pubDate = '';
                                try{
                                    const ud = e.getElementsByTagNameNS('*','updated')[0] || e.getElementsByTagName('updated')[0];
                                    const pd = e.getElementsByTagNameNS('*','published')[0] || e.getElementsByTagName('published')[0];
                                    if(ud && ud.textContent) pubDate = (ud.textContent||'').trim();
                                    else if(pd && pd.textContent) pubDate = (pd.textContent||'').trim();
                                }catch(err){ pubDate = ''; }
                                if(!pubDate) pubDate = new Date().toString();
                                return { title: title || '(no title)', link: link || '#', pubDate };
                            }catch(e){ return null; }
                        }).filter(Boolean).slice(0,50);
                    }catch(e){ /* xml parse failed */ }

                    // Loose regex fallback if XML parsing produced nothing
                    if(!items || !items.length){
                        try{
                            const matches = Array.from((text.matchAll(/<entry[\s\S]*?<\/entry>/gmi) || []));
                            const loose = matches.map(m=>{
                                const block = m[0];
                                const t = ((block.match(/<title[^>]*>([\s\S]*?)<\/title>/i) || [,''])[1]||'').replace(/\s+/g,' ').trim();
                                const idm = (block.match(/<id[^>]*>([\s\S]*?)<\/id>/i) || [,''])[1] || '';
                                const linkm = (block.match(/<link[^>]*href=["']?([^"'\s>]+)["']?[^>]*>/i) || [,''])[1] || idm || '';
                                const pubm = (block.match(/<(updated|published)[^>]*>([\s\S]*?)<\/(?:updated|published)>/i) || [,'',''])[2] || new Date().toString();
                                let link = (linkm||'').trim(); if(link.indexOf('export.arxiv.org')>=0) link = link.replace(/^https?:\/\/export\.arxiv\.org/, 'https://arxiv.org');
                                if(/^\/abs\//.test(link)) link = 'https://arxiv.org' + link;
                                if(link && link.startsWith('http://arxiv.org')) link = link.replace('http://', 'https://');
                                return { title: t||'(no title)', link: link||'#', pubDate: pubm };
                            }).filter(Boolean).slice(0,50);
                            if(loose && loose.length) items = loose;
                        }catch(e){}
                    }

                    // Normalize pubDate: if an item is older than MAX_AGE_MS, set its pubDate to now so prune24h doesn't remove everything
                    try{
                        const now = Date.now();
                        if(Array.isArray(items)){
                            items = items.map(it=>{
                                try{
                                    const pd = Date.parse(it.pubDate||'');
                                    if(!isFinite(pd) || (now - pd) > (typeof MAX_AGE_MS === 'number' ? MAX_AGE_MS : 24*60*60*1000)){
                                        it.pubDate = new Date().toString();
                                    }
                                }catch(e){}
                                return it;
                            });
                        }
                    }catch(e){}

                    // If still empty, return cached items or a sample fallback so the ticker isn't blank
                    if(!items || !items.length){
                        try{ const raw = localStorage.getItem(CACHE_KEY+'_arxiv'); if(raw){ const j = JSON.parse(raw); if(Array.isArray(j.items) && j.items.length) return j.items; } }catch(e){}
                        return [{ title: 'arXiv headlines unavailable (network/CORS); check console', link:'#', pubDate: new Date().toString() }];
                    }

                    try{ console.debug('[arXiv] returning', (items && items.length) || 0, 'items'); localStorage.setItem(CACHE_KEY+'_arxiv', JSON.stringify({ t: Date.now(), items })); }catch(e){}
                    return items;
                }catch(e){
                    try{ const raw = localStorage.getItem(CACHE_KEY+'_arxiv'); if(raw){ return JSON.parse(raw).items||[]; } }catch{ }
                    return [{ title: 'arXiv fetch failed — using cached/sample fallback', link:'#', pubDate: new Date().toString() }];
                }
            }

            // Dispatcher to fetch by source key
            async function fetchNewsBySource(source){
                if(!source) source = 'pubmed';
                if(source === 'pubmed') return await fetchPubMed();
                if(source === 'arxiv') return await fetchArxiv();
                return [];
            }

            // Cancellation support: store the current generation controller so Close can abort
            window.__currentGenerationController = null;
            function cancelCurrentGeneration(){
                try{
                    const c = window.__currentGenerationController;
                    if(c && typeof c.abort === 'function'){
                        try{ c.abort(); }catch(e){}
                    }
                    // Clear reference so subsequent calls are fresh
                    window.__currentGenerationController = null;
                }catch(e){}
            }

            async function ensureDailyQuiz(){
                try{
                    // Return cached quiz if present and fresh
                    const rawQuiz = localStorage.getItem(DAILY_QUIZ_KEY);
                    if(rawQuiz){
                        const qObj = JSON.parse(rawQuiz);
                        if(qObj && qObj.generatedAt && (Date.now() - qObj.generatedAt) < 24*60*60*1000 && qObj.topic && qObj.questions) return qObj;
                    }
                    // Need to generate
                    let topic = getDailyTopic();
                    if(!topic){ topic = await fetchRandomWikipediaTitle(); saveDailyTopic(topic); }
                    // Resolve Gemini API key: prefer global input, respect enable/remember toggles, then fallback to stored key/prompt
                    function getEffectiveGemKey(){
                        try{
                            const input = document.getElementById('globalGemKey');
                            const enable = document.getElementById('globalGemEnable');
                            const remember = document.getElementById('globalGemRemember');
                            // If explicit "enable" checkbox exists and is unchecked, treat as disabled
                            if(enable && enable.checked === false) return null;
                            // Prefer the visible input value when present
                            if(input && String(input.value||'').trim()){
                                const v = String(input.value).trim();
                                // store if user opted to remember
                                try{ if(remember && remember.checked) localStorage.setItem('gemini.key', v); }catch(e){}
                                return v;
                            }
                            // Fallback to previously stored key
                            try{ const stored = localStorage.getItem('gemini.key'); if(stored) return stored; }catch(e){}
                            return null;
                        }catch(e){ return null; }
                    }

                    let gemKey = getEffectiveGemKey();
                    if(!gemKey){
                        try{ gemKey = prompt('Enter Gemini API key to generate the daily quiz (will be stored in your browser)'); if(gemKey) try{ localStorage.setItem('gemini.key', gemKey); }catch(e){} }catch(e){}
                    }
                    if(!gemKey) throw new Error('Gemini API key required');
                    // Create an AbortController for this generation and expose it (or reuse existing)
                    let controller = window.__currentGenerationController;
                    if(!controller){ controller = new AbortController(); window.__currentGenerationController = controller; }
                    const result = await askGeminiForQuiz(topic, gemKey, controller.signal);
                    const store = { topic, questions: result.questions, generatedAt: Date.now() };
                    try{ localStorage.setItem(DAILY_QUIZ_KEY, JSON.stringify(store)); }catch(e){}
                    return store;
                }catch(e){ console.warn('ensureDailyQuiz failed', e); throw e; }
            }

            // Render quiz into preview area (reuse existing preview card)
            async function showDailyQuiz(){
                const previewCard = document.getElementById('preview');
                const previewList = document.getElementById('previewList');
                const dailyBtn = document.getElementById('dailyQuizBtn');
                const modal = document.getElementById('dailyBuildModal');
                const statusEl = document.getElementById('dailyBuildStatus');
                const closeBtn = document.getElementById('dailyBuildClose');
                function log(...args){ try{ debugLog(...args); }catch(e){ console.log(...args); } }
                // helper to open/close modal
                function openModal(){ try{ modal.classList.remove('hidden'); document.documentElement.classList.add('modal-open'); }catch{} }
                function closeModal(){ try{ modal.classList.add('hidden'); document.documentElement.classList.remove('modal-open'); }catch{} }

                // disable button and show spinner/status
                try{
                    if(dailyBtn) { dailyBtn.disabled = true; }
                    openModal(); if(statusEl) statusEl.textContent = 'Initializing…';
                    // Record when modal was shown so we can enforce a minimum visible duration
                    let modalShownAt = Date.now();
                    const MIN_VISIBLE_MS = 10000; // keep modal visible at least this long (10s)
                    // Close button should be interactable immediately and cancels generation when clicked
                    try{ if(closeBtn){ closeBtn.disabled = false; closeBtn.addEventListener('click', ()=>{ statusEl && (statusEl.textContent = 'Canceled by user'); cancelCurrentGeneration(); try{ if(dailyBtn) dailyBtn.disabled = false; }catch{}; try{ modal.classList.add('hidden'); }catch{} }); } }catch(e){}
                    if(previewCard) previewCard.classList.remove('hidden');
                    if(previewList) previewList.innerHTML = '<div class="hint">Generating daily quiz…</div>';

                    log('Daily quiz: starting generation');
                    statusEl && (statusEl.textContent = 'Resolving topic and key…');
                    // Show the topic early in the modal: use cached topic if present, otherwise try a fast fetch
                    try{
                        const topicSpan = document.getElementById('dailyBuildTopic');
                        let earlyTopic = null;
                        try{ earlyTopic = getDailyTopic(); }catch{}
                        earlyTopic = normalizeTopic(earlyTopic);
                        if(topicSpan){
                            if(earlyTopic){
                                topicSpan.textContent = earlyTopic;
                                // ensure normal (non-inverted) colors for Daily
                                topicSpan.classList.remove('inverse');
                                // retrigger rainbow animation
                                topicSpan.classList.remove('rainbow'); void topicSpan.offsetWidth; topicSpan.classList.add('rainbow');
                                // Fit the title line to the modal width
                                try{ fitTitleToContainer(document.getElementById('dailyBuildTitle')); }catch(e){}
                            } else {
                                topicSpan.textContent = 'choosing...';
                                topicSpan.classList.remove('inverse');
                                topicSpan.classList.remove('rainbow'); void topicSpan.offsetWidth; topicSpan.classList.add('rainbow');
                                statusEl && (statusEl.textContent = 'Choosing a topic…');
                                try{
                                    // ensure a controller exists so this fetch can be aborted
                                    let ctr = window.__currentGenerationController;
                                    if(!ctr){ ctr = new AbortController(); window.__currentGenerationController = ctr; }
                                    const fetched = await fetchRandomWikipediaTitle(ctr.signal);
                                    if(fetched){
                                        const nf = normalizeTopic(fetched);
                                        topicSpan.textContent = nf;
                                        // ensure normal colors for Daily
                                        topicSpan.classList.remove('inverse');
                                        try{ saveDailyTopic(fetched); }catch{};
                                        statusEl && (statusEl.textContent = 'Topic resolved: ' + nf);
                                        try{ fitTitleToContainer(document.getElementById('dailyBuildTitle')); }catch(e){}
                                    }
                                }catch(e){ console.warn('Early topic fetch failed', e); }
                            }
                        }
                    }catch(e){ console.warn('Failed to set early topic', e); }

                    // Ensure quiz (this will fetch topic and call Gemini)
                    let quiz;
                    try{
                        quiz = await ensureDailyQuiz();
                    }catch(e){
                        if(e && e.name === 'AbortError'){
                            statusEl && (statusEl.textContent = 'Canceled');
                            try{ if(previewList) previewList.innerHTML = '<div class="hint">Generation canceled.</div>'; }catch{};
                            return;
                        }
                        throw e;
                    }
                    // Normalize stored topic for display and output
                    const finalTopic = normalizeTopic(quiz && quiz.topic ? quiz.topic : '');
                    // After obtaining the final quiz/topic, update title and ensure it fits
                    try{
                        const titleEl = document.getElementById('dailyBuildTitle');
                        const topicSlug = String(finalTopic||'').trim();
                        const wikiUrl = topicSlug ? ('https://en.wikipedia.org/wiki/' + encodeURIComponent(topicSlug.replace(/\s+/g,'_'))) : '';
                        if(titleEl){
                            if(wikiUrl){
                                titleEl.innerHTML = `Today's Random Quiz is about <a href="${wikiUrl}" target="_blank" rel="noopener noreferrer"><span id="dailyBuildTopic" class="rainbow">${escapeHtml(finalTopic)}</span></a>!`;
                            } else {
                                titleEl.innerHTML = `Today's Random Quiz is about <span id="dailyBuildTopic" class="rainbow">${escapeHtml(finalTopic)}</span>!`;
                            }
                        }
                        fitTitleToContainer(document.getElementById('dailyBuildTitle'));
                    }catch(e){}
                    log('Daily quiz: generation complete, formatting output');
                    statusEl && (statusEl.textContent = 'Formatting questions…');

                    const arr = quiz.questions || [];
                    // Build formatted question text for the paste area: Qn., options as - , and ANSWER KEY
                    let text = '';
                    text += `Daily Quiz: ${finalTopic}\n\n`;
                    const count = Math.min(arr.length, 10);
                    for(let i=0;i<count;i++){
                        const it = arr[i] || {};
                        const qnum = i+1;
                        const qText = (it.question || '').replace(/\n+/g,' ');
                        text += `Q${qnum}. ${qText}\n`;
                        (it.choices||[]).forEach((c)=>{ text += `- ${String(c||'').replace(/\n+/g,' ')}\n`; });
                        text += '\n';
                    }
                    // Answer key
                    text += 'ANSWER KEY\n';
                    for(let i=0;i<count;i++){
                        const it = arr[i] || {};
                        const ansIdx = typeof it.answerIndex === 'number' ? it.answerIndex : (it.answerIndex==null && it.answer ? (Array.isArray(it.choices)? it.choices.indexOf(it.answer) : 0) : 0);
                        const letter = String.fromCharCode(65 + (ansIdx||0));
                        text += `${i+1}. ${letter}\n`;
                    }

                    // Write to the Generate MCQ debug output as well
                    log('Daily quiz: injecting formatted questions into paste area');
                    const paste = document.getElementById('paste');
                    if(paste){ paste.value = text; }

                    // Also render a preview in the preview panel as before
                    try{
                        const finalTopicSlug2 = String(finalTopic||'').trim();
                        const finalWiki = finalTopicSlug2 ? ('https://en.wikipedia.org/wiki/' + encodeURIComponent(finalTopicSlug2.replace(/\s+/g,'_'))) : '';
                        let html = `<h2 class="mb-6 mt-0">Daily Quiz: ${ finalWiki ? ('<a href="' + finalWiki + '" target="_blank" rel="noopener noreferrer">' + escapeHtml(finalTopic) + '</a>') : escapeHtml(finalTopic) }</h2>`;
                        html += '<ol>';
                        for(let i=0;i<count;i++){
                            const it = arr[i];
                            html += `<li class="qcard"><div class="hint">${escapeHtml(it.question||'')}</div><ul>`;
                            (it.choices||[]).forEach((c,ci)=>{ html += `<li class="choice">${String.fromCharCode(65+ci)}. ${escapeHtml(c)}</li>`; });
                            html += '</ul></li>';
                        }
                        html += '</ol>';
                        if(previewList) previewList.innerHTML = html;
                        // Render LaTeX/math only for the math segments inside the preview.
                        // Uses the lightweight KaTeX loader wrapper defined in the page (with heuristics).
                        try{ if(window.renderMathIn && previewList){ window.renderMathIn(previewList); } }catch(e){ console.warn('renderMathIn preview (daily) failed', e); }
                        document.getElementById('previewCount').textContent = String(arr.length||0);
                    }catch(e){ log('Daily quiz: preview render failed', e); }

                    // Trigger Parse & Preview automatically if available
                    try{ const parseBtn = document.getElementById('parseBtn'); if(parseBtn){ parseBtn.click(); log('Daily quiz: triggered Parse & Preview'); } }
                    catch(e){ log('Daily quiz: failed to trigger parse', e); }

                    statusEl && (statusEl.textContent = 'Done');
                    // Close the modal after the minimum visible duration has passed
                    try{
                        const elapsed = Date.now() - (modalShownAt || 0);
                        const remaining = Math.max(0, (MIN_VISIBLE_MS || 10000) - elapsed);
                        setTimeout(()=>{ try{ closeModal(); }catch{} }, remaining);
                    }catch(e){ try{ closeModal(); }catch{} }
                }catch(e){
                    try{ debugLog('Daily quiz failed:', e && e.message ? e.message : e); }catch{};
                    if(previewList) previewList.innerHTML = `<div class="hint">Failed to generate quiz: ${String(e.message||e)}</div>`;
                    const errMsg = (e && e.message) ? e.message : String(e);
                    statusEl && (statusEl.textContent = 'Failed: ' + errMsg);
                    // Keep modal open for user to read error; enable close
                }finally{
                    try{ if(dailyBtn) dailyBtn.disabled = false; }catch{}
                }

                // Close button should always allow closing
                try{ document.getElementById('dailyBuildClose')?.addEventListener('click', ()=>{ document.getElementById('dailyBuildModal')?.classList.add('hidden'); cancelCurrentGeneration(); }); }catch(e){}
            }

            // showRandomQuiz: same UI/flow as showDailyQuiz but always forces a fresh random topic and generation
            async function showRandomQuiz(){
                const previewCard = document.getElementById('preview');
                const previewList = document.getElementById('previewList');
                const randomBtn = document.getElementById('randomQuizBtn');
                const modal = document.getElementById('dailyBuildModal');
                const statusEl = document.getElementById('dailyBuildStatus');
                function log(...args){ try{ debugLog(...args); }catch(e){ console.log(...args); } }
                function openModal(){ try{ modal.classList.remove('hidden'); document.documentElement.classList.add('modal-open'); }catch{} }
                function closeModal(){ try{ modal.classList.add('hidden'); document.documentElement.classList.remove('modal-open'); }catch{} }

                try{
                    if(randomBtn) { randomBtn.disabled = true; }
                    openModal(); if(statusEl) statusEl.textContent = 'Initializing…';
                    // Record when modal was shown so we can enforce a minimum visible duration
                    let modalShownAt = Date.now();
                    const MIN_VISIBLE_MS = 10000; // keep modal visible at least this long (10s)
                    // Close button should be interactable immediately and cancels generation when clicked
                    try{ const closeBtn = document.getElementById('dailyBuildClose'); if(closeBtn){ closeBtn.disabled = false; closeBtn.addEventListener('click', ()=>{ statusEl && (statusEl.textContent = 'Canceled by user'); cancelCurrentGeneration(); try{ if(randomBtn) randomBtn.disabled = false; }catch{}; try{ modal.classList.add('hidden'); }catch{} }); } }catch(e){}
                    if(previewCard) previewCard.classList.remove('hidden');
                    if(previewList) previewList.innerHTML = '<div class="hint">Generating random quiz…</div>';

                    log('Random quiz: selecting topic');
                    statusEl && (statusEl.textContent = 'Choosing a topic…');
                    // Always fetch a fresh topic and normalize it for display
                    let topic = 'choosing...';
                    try{ 
                        // allow aborting the topic fetch
                        let ctr = window.__currentGenerationController;
                        if(!ctr){ ctr = new AbortController(); window.__currentGenerationController = ctr; }
                        topic = await fetchRandomWikipediaTitle(ctr.signal);
                    }catch(e){ console.warn('Random topic fetch failed', e); topic = 'random topic'; }
                    const normTopic = normalizeTopic(topic);
                    const topicSpan = document.getElementById('dailyBuildTopic');
                    if(topicSpan){
                        topicSpan.textContent = normTopic;
                        // use inverted colors for Random Quiz
                        topicSpan.classList.add('inverse');
                        topicSpan.classList.remove('rainbow'); void topicSpan.offsetWidth; topicSpan.classList.add('rainbow');
                        try{
                            const titleEl = document.getElementById('dailyBuildTitle');
                            const slug = String(normTopic||'').trim();
                            const wiki = slug ? ('https://en.wikipedia.org/wiki/' + encodeURIComponent(slug.replace(/\s+/g,'_'))) : '';
                            if(titleEl){
                                if(wiki){
                                    titleEl.innerHTML = `This random quiz is about <a href="${wiki}" target="_blank" rel="noopener noreferrer"><span id="dailyBuildTopic" class="rainbow inverse">${escapeHtml(normTopic)}</span></a>!`;
                                } else {
                                    titleEl.innerHTML = `This random quiz is about <span id="dailyBuildTopic" class="rainbow inverse">${escapeHtml(normTopic)}</span>!`;
                                }
                            }
                            fitTitleToContainer(document.getElementById('dailyBuildTitle'));
                        }catch(e){}
                    }

                    statusEl && (statusEl.textContent = 'Generating quiz…');
                    // Resolve Gemini API key via existing helper
                    let gemKey = (typeof getEffectiveGemKey === 'function') ? getEffectiveGemKey() : null;
                    if(!gemKey){ try{ gemKey = prompt('Enter Gemini API key to generate the random quiz (will be stored in your browser)'); if(gemKey) try{ localStorage.setItem('gemini.key', gemKey); }catch(e){} }catch(e){} }
                    if(!gemKey) throw new Error('Gemini API key required');

                    // Create or reuse controller for this run (ensureDailyQuiz uses the same global controller when applicable)
                    let localController = window.__currentGenerationController;
                    if(!localController){ localController = new AbortController(); window.__currentGenerationController = localController; }
                    let result;
                    try{
                        result = await askGeminiForQuiz(topic, gemKey, localController.signal);
                    }catch(e){
                        if(e && e.name === 'AbortError'){
                            statusEl && (statusEl.textContent = 'Canceled');
                            if(previewList) previewList.innerHTML = '<div class="hint">Generation canceled.</div>';
                            return;
                        }
                        throw e;
                    }
                    statusEl && (statusEl.textContent = 'Formatting questions…');

                    const arr = result.questions || [];
                    // Build formatted question text for the paste area: Qn., options as - , and ANSWER KEY
                    let text = '';
                    text += `Random Quiz: ${normTopic}\n\n`;
                    const count = Math.min(arr.length, 10);
                    for(let i=0;i<count;i++){
                        const it = arr[i] || {};
                        const qnum = i+1;
                        const qText = (it.question || '').replace(/\n+/g,' ');
                        text += `Q${qnum}. ${qText}\n`;
                        (it.choices||[]).forEach((c)=>{ text += `- ${String(c||'').replace(/\n+/g,' ')}\n`; });
                        text += '\n';
                    }
                    // Answer key
                    text += 'ANSWER KEY\n';
                    for(let i=0;i<count;i++){
                        const it = arr[i] || {};
                        const ansIdx = typeof it.answerIndex === 'number' ? it.answerIndex : (it.answerIndex==null && it.answer ? (Array.isArray(it.choices)? it.choices.indexOf(it.answer) : 0) : 0);
                        const letter = String.fromCharCode(65 + (ansIdx||0));
                        text += `${i+1}. ${letter}\n`;
                    }

                    log('Random quiz: injecting formatted questions into paste area');
                    const paste = document.getElementById('paste');
                    if(paste){ paste.value = text; }

                    // Also render a preview in the preview panel
                    try{
                        const normSlug = String(normTopic||'').trim();
                        const normWiki = normSlug ? ('https://en.wikipedia.org/wiki/' + encodeURIComponent(normSlug.replace(/\s+/g,'_'))) : '';
                        let html = `<h2 class="mb-6 mt-0">Random Quiz: ${ normWiki ? ('<a href="' + normWiki + '" target="_blank" rel="noopener noreferrer">' + escapeHtml(normTopic) + '</a>') : escapeHtml(normTopic) }</h2>`;
                        html += '<ol>';
                        for(let i=0;i<count;i++){
                            const it = arr[i];
                            html += `<li class="qcard"><div class="hint">${escapeHtml(it.question||'')}</div><ul>`;
                            (it.choices||[]).forEach((c,ci)=>{ html += `<li class="choice">${String.fromCharCode(65+ci)}. ${escapeHtml(c)}</li>`; });
                            html += '</ul></li>';
                        }
                        html += '</ol>';
                        if(previewList) previewList.innerHTML = html;
                        // Render LaTeX/math only for the math segments inside the preview.
                        try{ if(window.renderMathIn && previewList){ window.renderMathIn(previewList); } }catch(e){ console.warn('renderMathIn preview (random) failed', e); }
                        document.getElementById('previewCount').textContent = String(arr.length||0);
                    }catch(e){ log('Random quiz: preview render failed', e); }

                    // Trigger Parse & Preview automatically if available
                    try{ const parseBtn = document.getElementById('parseBtn'); if(parseBtn){ parseBtn.click(); log('Random quiz: triggered Parse & Preview'); } }
                    catch(e){ log('Random quiz: failed to trigger parse', e); }

                    statusEl && (statusEl.textContent = 'Done');
                    // Close the modal after the minimum visible duration has passed
                    try{
                        const elapsed = Date.now() - (modalShownAt || 0);
                        const remaining = Math.max(0, (MIN_VISIBLE_MS || 10000) - elapsed);
                        setTimeout(()=>{ try{ closeModal(); }catch{} }, remaining);
                    }catch(e){ try{ closeModal(); }catch{} }
                }catch(e){
                    try{ debugLog('Random quiz failed:', e && e.message ? e.message : e); }catch{};
                    if(previewList) previewList.innerHTML = `<div class="hint">Failed to generate quiz: ${String(e.message||e)}</div>`;
                    const errMsg = (e && e.message) ? e.message : String(e);
                    statusEl && (statusEl.textContent = 'Failed: ' + errMsg);
                    // Keep modal open for user to read error; enable close
                }finally{
                    try{ if(randomBtn) randomBtn.disabled = false; }catch{}
                }
            }

            // Utility: simple HTML escape
            function escapeHtml(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

            // Normalize topic strings: convert underscores to spaces and trim
            function normalizeTopic(t){ try{ return String(t||'').replace(/_/g,' ').trim(); }catch(e){ return String(t||''); } }

            // Classify a Wikipedia topic title into a coarse data type by querying categories.
            // Returns one of: person, place, event, science, media, organism, organization, concept, other
            async function classifyTopic(title){
                try{
                    const t = String(title||'').trim();
                    if(!t) return 'other';
                    // Query categories via Wikipedia API (CORS friendly with origin=*)
                    const url = 'https://en.wikipedia.org/w/api.php?action=query&titles=' + encodeURIComponent(t) + '&prop=categories&cllimit=50&format=json&origin=*';
                    const controller = new AbortController();
                    const to = setTimeout(()=>controller.abort(), 3500);
                    const res = await fetch(url, { signal: controller.signal });
                    clearTimeout(to);
                    if(!res.ok) throw new Error('HTTP '+res.status);
                    const data = await res.json();
                    const pages = data && data.query && data.query.pages ? data.query.pages : null;
                    const cats = [];
                    if(pages){
                        for(const k in pages){
                            const p = pages[k];
                            if(p && Array.isArray(p.categories)){
                                p.categories.forEach(c=>{ if(c && c.title) cats.push(c.title.replace(/^Category:/i,'')); });
                            }
                        }
                    }
                    const catStr = (cats||[]).join('||').toLowerCase();
                    // Heuristics based on category keywords
                    if(/births|living people|deaths|born|died/.test(catStr)) return 'person';
                    if(/cities|towns|villages|municipalities|places|countries|geography|populated places|settlements|islands|boroughs/.test(catStr)) return 'place';
                    if(/films|novels|books|albums|songs|television|media|film|episode|series|music|video games/.test(catStr)) return 'media';
                    if(/wars|battles|election|events|historic|history|anniversary/.test(catStr)) return 'event';
                    if(/species|flora|fauna|mammals|birds|reptiles|insects|plants|fungi|taxonomy|taxa/.test(catStr)) return 'organism';
                    if(/chemistry|chemical|compound|enzyme|protein|biochemistry|biology|physics|mathematics|science|geology|ecology|medicine/.test(catStr)) return 'science';
                    if(/companies|organizations|institutes|universities|colleges|schools|corporations|associations|organizations/.test(catStr)) return 'organization';
                    if(/concepts|philosophy|theory|concept|principles|terminology/.test(catStr)) return 'concept';
                    return 'other';
                }catch(e){
                    // Fallback: simple heuristics
                    try{
                        const s = String(title||'');
                        if(/\b(University|College|Institute|School|Hospital|Company|Corporation)\b/i.test(s)) return 'organization';
                        if(/\b(\d{4}|BC|AD)\b/.test(s)) return 'event';
                        if(/\b(Protein|Enzyme|Chemistry|Biology|Physics|Math|Mathematics|Molecular)\b/i.test(s)) return 'science';
                        if(/\b(\w+idae|\w+ales|species|genus)\b/i.test(s)) return 'organism';
                        if(s.split(' ').length === 1 && /^[A-Z][a-z]+$/.test(s)) return 'concept';
                    }catch(err){}
                    return 'other';
                }
            }

            // Apply classification result to an anchor element by adding a topic-type-... class and tooltip
            async function classifyAndApply(anchorEl, title){
                try{
                    if(!anchorEl) return;
                    anchorEl.classList.add('topic-link');
                    const t = String(title||anchorEl.textContent||'').trim();
                    const typ = await classifyTopic(t);
                    anchorEl.classList.add('topic-type-' + typ);
                    anchorEl.setAttribute('data-topic-type', typ);
                    anchorEl.setAttribute('title', (typ ? (typ.charAt(0).toUpperCase()+typ.slice(1)) : 'Topic') + ' — opens in Wikipedia');
                }catch(e){ /* ignore */ }
            }

            // Fit the title text to the modal width by scaling font-size responsively.
            // Attempts to keep the title on one line by shrinking font-size (down to minPx).
            // If it would become smaller than minPx, it falls back to allowing wrapping.
            function fitTitleToContainer(titleEl, opts){
                try{
                    if(!titleEl) return;
                    opts = opts || {};
                    const maxPx = typeof opts.maxPx === 'number' ? opts.maxPx : 48;
                    const minPx = typeof opts.minPx === 'number' ? opts.minPx : 14;
                    const innerSpan = titleEl.querySelector('.rainbow') || titleEl.querySelector('#dailyBuildTopic');
                    // Ensure we try to fit on a single line first
                    titleEl.style.whiteSpace = 'nowrap';

                    // Measure natural width at the max font size by creating a hidden clone
                    const clone = titleEl.cloneNode(true);
                    clone.style.position = 'absolute';
                    clone.style.left = '-9999px';
                    clone.style.top = '0';
                    clone.style.visibility = 'hidden';
                    clone.style.whiteSpace = 'nowrap';
                    clone.style.fontSize = maxPx + 'px';
                    // Ensure clone doesn't inherit layout constraints
                    clone.style.width = 'auto';
                    clone.style.maxWidth = 'none';
                    // Inner rainbow should show text for measurement
                    const topicSpan = clone.querySelector('.rainbow');
                    if(topicSpan) topicSpan.style.fontSize = 'inherit';
                    document.body.appendChild(clone);
                    const naturalW = clone.getBoundingClientRect().width || clone.offsetWidth || clone.scrollWidth || 0;
                    document.body.removeChild(clone);

                    const containerW = titleEl.clientWidth || (titleEl.getBoundingClientRect && titleEl.getBoundingClientRect().width) || 400;
                    if(!naturalW || naturalW <= containerW){
                        // Fits at maxPx
                        titleEl.style.fontSize = maxPx + 'px';
                        if(innerSpan) innerSpan.style.fontSize = 'inherit';
                        return;
                    }

                    // Compute desired font size that would make naturalW scale to containerW
                    let desired = Math.floor(maxPx * (containerW / naturalW));
                    if(desired < minPx){
                        // Too small — allow wrapping and use a readable min size
                        titleEl.style.whiteSpace = 'normal';
                        titleEl.style.fontSize = minPx + 'px';
                        if(innerSpan) innerSpan.style.fontSize = 'inherit';
                        return;
                    }

                    // Apply desired size and ensure it fits; if not, decrement until it does or minPx reached
                    titleEl.style.fontSize = desired + 'px';
                    if(innerSpan) innerSpan.style.fontSize = 'inherit';
                    for(let i=0;i<12;i++){
                        const sw = titleEl.scrollWidth || titleEl.getBoundingClientRect().width;
                        const cw = titleEl.clientWidth || titleEl.getBoundingClientRect().width;
                        if(sw <= cw) break;
                        desired = Math.max(minPx, desired - 1);
                        titleEl.style.fontSize = desired + 'px';
                        if(desired === minPx){ titleEl.style.whiteSpace = 'normal'; break; }
                    }
                }catch(e){ console.warn('fitTitleToContainer failed', e); }
            }

            // Wire the button
            document.getElementById('dailyQuizBtn')?.addEventListener('click', ()=>{ showDailyQuiz().catch(()=>{}); });
            document.getElementById('randomQuizBtn')?.addEventListener('click', ()=>{ showRandomQuiz().catch(()=>{}); });

            // Random category gear wiring
            (function(){
                const gear = document.getElementById('randomGearBtn');
                const gearWrap = document.getElementById('randomGearWrap');
                const modal = document.getElementById('randomCategoryModal');
                const close = document.getElementById('randomCategoryClose');
                const input = document.getElementById('categorySearch');
                const results = document.getElementById('categorySearchResults');
                const saveBtn = document.getElementById('categorySaveBtn');
                const clearBtn = document.getElementById('categoryClear');
                function open(){ try{ if(gear && gear.disabled) return; modal.classList.remove('hidden'); document.documentElement.classList.add('modal-open'); input.focus(); }catch{} }
                function closeModal(){ try{ modal.classList.add('hidden'); document.documentElement.classList.remove('modal-open'); }catch{} }
                function setBadge(on){ try{ if(on) gearWrap.classList.add('active'); else gearWrap.classList.remove('active'); }catch{} }
                // load saved category
                try{ const saved = localStorage.getItem('random.category'); setBadge(!!saved); }catch(e){}

                gear?.addEventListener('click', (ev)=>{ try{ if(gear.disabled) { ev.preventDefault(); ev.stopImmediatePropagation(); return; } open(); }catch(e){} });
                // prevent keyboard activation when disabled
                gear?.addEventListener('keydown', (ev)=>{ try{ if((ev.key === 'Enter' || ev.key === ' ') && gear.disabled){ ev.preventDefault(); ev.stopImmediatePropagation(); } }catch(e){} });
                close?.addEventListener('click', ()=>{ closeModal(); });
                clearBtn?.addEventListener('click', ()=>{ try{ localStorage.removeItem('random.category'); results.innerHTML=''; input.value=''; setBadge(false); }catch(e){} });

                // Debounced search
                let deb = 0; let lastQ = '';
                input?.addEventListener('input', (ev)=>{
                    const q = String(input.value||'').trim(); lastQ = q;
                    if(deb) clearTimeout(deb);
                    if(!q){ results.innerHTML = '<div class="hint">Type to search Wikipedia.</div>'; return; }
                    deb = setTimeout(async ()=>{
                        try{
                            results.innerHTML = '<div class="hint">Searching…</div>';
                            const url = `https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(q)}&utf8=&format=json&origin=*`;
                            const r = await fetch(url);
                            if(!r.ok) throw new Error('search failed');
                            const d = await r.json();
                            const arr = (d && d.query && d.query.search) || [];
                            if(!arr.length){ results.innerHTML = '<div class="hint">No results</div>'; return; }
                            results.innerHTML = '';
                            arr.slice(0,12).forEach(it=>{
                                const div = document.createElement('div'); div.className='result'; div.textContent = it.title; div.addEventListener('click', ()=>{
                                    // select this as the category
                                    input.value = it.title; results.querySelectorAll('.selected').forEach(n=>n.classList.remove('selected'));
                                    div.classList.add('selected');
                                });
                                results.appendChild(div);
                            });
                        }catch(e){ results.innerHTML = '<div class="hint">Search failed</div>'; }
                    }, 350);
                });

                // Save selected/typed value
                saveBtn?.addEventListener('click', ()=>{
                    try{
                        const v = String(input.value||'').trim();
                        if(!v){ alert('Please enter or select a query to save.'); return; }
                        localStorage.setItem('random.category', v);
                        setBadge(true);
                        closeModal();
                    }catch(e){ console.warn('Save category failed', e); }
                });
            })();

            // Observe size/content changes to keep the safe area fresh
            let ro = null; let mo = null; let lastH = -1; let rafId = 0;
            function scheduleMeasure(){
                if(rafId) cancelAnimationFrame(rafId);
                rafId = requestAnimationFrame(()=>{ rafId = 0; const h = computeTopSafeArea(); if(h !== lastH) lastH = h; });
            }
            function startObservers(){
                try{
                    if(window.ResizeObserver && newsBar){
                        ro = new ResizeObserver(scheduleMeasure); ro.observe(newsBar);
                    }
                }catch{}
                try{
                    if(window.MutationObserver && newsBar){
                        mo = new MutationObserver(scheduleMeasure);
                        mo.observe(newsBar, { childList: true, subtree: true, attributes: true, characterData: true });
                    }
                }catch{}
                window.addEventListener('resize', ()=>{ scheduleMeasure(); computeStickyScale(); try{ if(typeof positionDockAndPanel==='function') positionDockAndPanel(); }catch{} });
            }

            function setNewsEnabled(on){
                try{ localStorage.setItem(PREF_KEY, on ? 'on' : 'off'); }catch{}
                if(newsBar) newsBar.style.display = on ? '' : 'none';
                if(toggleBtn) toggleBtn.textContent = on ? 'Disable news' : 'Enable news';
                // Apply offset immediately so elements jump to the correct spot without lag
                try{ computeTopSafeArea(); }catch{}
                scheduleMeasure();
                // Also reposition sticky elements that depend on top safe area
                try{ if(typeof positionDockAndPanel === 'function') positionDockAndPanel(); }catch{}
                // One more pass on next tick to catch any async layout changes
                setTimeout(()=>{ try{ computeTopSafeArea(); if(typeof positionDockAndPanel === 'function') positionDockAndPanel(); }catch{} }, 50);
            }

            // Compute sticky notes scale so their vertical footprint adapts to the news header
            function computeStickyScale(){
                try{
                    const cs = getComputedStyle(document.documentElement);
                    const topPx = parseFloat(cs.getPropertyValue('--topSafeArea')) || 0;
                    const vh = Math.max(480, window.innerHeight || document.documentElement.clientHeight || 0);
                    // Dedicate up to ~12% vertical compression when a large header is present;
                    // clamp scale to [0.85, 1.00] for readability.
                    const ratio = topPx / Math.max(1, vh);
                    const scale = Math.max(0.85, Math.min(1.0, 1.0 - ratio * 1.6));
                    document.documentElement.style.setProperty('--stickyScale', scale.toFixed(3));
                    // Maintain a small visual gap above the rail/dock/panel
                    const gap = Math.min(16, 8 + Math.round(topPx * 0.08));
                    document.documentElement.style.setProperty('--stickyTopGap', gap + 'px');
                }catch{}
            }

            function formatDate(d){
                try{ const dt = new Date(d); return dt.toLocaleDateString(undefined, { month:'short', day:'numeric' }); }catch{ return ''; }
            }
            function prune24h(items){
                const now = Date.now();
                return (items||[]).filter(it=>{ let t = Date.parse(it.pubDate||''); if(!isFinite(t)) t = now; return (now - t) <= MAX_AGE_MS; });
            }
            function dedupe(items){
                const seen = new Set();
                return (items||[]).filter(it=>{ const k = (it.title||'').trim(); if(!k || seen.has(k)) return false; seen.add(k); return true; });
            }
            // Headlines fetch/render
            function parseFeedXML(text){
                try{
                    const doc = new DOMParser().parseFromString(text, 'text/xml');
                    // RSS 2.0 <item>
                    let nodes = Array.from(doc.querySelectorAll('channel > item, item'));
                    if(nodes && nodes.length){
                        return nodes.map(it=>({
                            title: (it.querySelector('title')?.textContent||'').trim(),
                            link: (it.querySelector('link')?.textContent||'').trim(),
                            pubDate: (it.querySelector('pubDate')?.textContent||it.querySelector('dc\:date')?.textContent||'').trim()
                        }));
                    }
                    // Atom <entry>
                    nodes = Array.from(doc.querySelectorAll('feed > entry, entry'));
                    if(nodes && nodes.length){
                        return nodes.map(it=>({
                            title: (it.querySelector('title')?.textContent||'').trim(),
                            link: (it.querySelector('link[rel="alternate"][href]')?.getAttribute('href') || it.querySelector('link[href]')?.getAttribute('href') || '#').trim(),
                            pubDate: (it.querySelector('updated')?.textContent||it.querySelector('published')?.textContent||'').trim()
                        }));
                    }
                }catch(e){ /* fallthrough */ }
                return [];
            }
            async function fetchTextFromAny(url){
                // Try direct first (may fail due to CORS); then proxies
                const attempts = [ async ()=>{
                    try{ const r = await fetch(url, { mode:'cors' }); if(!r.ok) throw new Error('HTTP '+r.status); return await r.text(); }catch(e){ throw e; }
                }];
                PROXIES.forEach(build=>{
                    attempts.push(async ()=>{ const u = build(url); const r = await fetch(u, { mode:'cors' }); if(!r.ok) throw new Error('HTTP '+r.status); return await r.text(); });
                });
                let lastErr = null;
                for(const fn of attempts){
                    try{ const txt = await fn(); if(txt && txt.length>20) return txt; }catch(e){ lastErr = e; }
                }
                throw lastErr || new Error('All fetch attempts failed');
            }
            
            function buildTicker(items){
                if(!newsRow) return;
                newsRow.innerHTML = '';
                const viewport = document.createElement('div'); viewport.className = 'news-viewport'; newsRow.appendChild(viewport);
                trackA = document.createElement('div'); trackA.className = 'news-track';
                trackB = document.createElement('div'); trackB.className = 'news-track';
                const makeFrag = (arr) => {
                    const frag = document.createDocumentFragment();
                    arr.forEach((it, idx)=>{
                        const a = document.createElement('a'); a.className='news-item'; a.target='_blank'; a.rel='noopener noreferrer'; a.href = it.link || '#';
                            // include date+time inline (no boxed pill)
                            const date = document.createElement('span'); date.className='news-date-inline';
                            date.textContent = (function(dt){
                                try{
                                    const d = new Date(dt);
                                    // Use the shared global source so formatting can vary by source
                                    const src = (typeof window !== 'undefined' && window.__currentNewsSource) ? window.__currentNewsSource : null;
                                    // For PubMed and arXiv show date only (no hour/minute). For others keep time.
                                    if(src === 'pubmed' || src === 'arxiv'){
                                        return d.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
                                    }
                                    return d.toLocaleString(undefined, { month:'short', day:'numeric', hour:'2-digit', minute:'2-digit' });
                                }catch{
                                    return '';
                                }
                            })(it.pubDate);
                            const title = document.createElement('span'); title.textContent = it.title || 'Untitled';
                            a.appendChild(date); a.appendChild(title); frag.appendChild(a);
                        const sep = document.createElement('span'); sep.className='news-sep'; sep.textContent='•'; frag.appendChild(sep);
                    });
                    return frag;
                };
                trackA.appendChild(makeFrag(items));
                trackB.appendChild(makeFrag(items));
                viewport.appendChild(trackA); viewport.appendChild(trackB);
                // Position B right after A
                requestAnimationFrame(()=>{
                    const wA = trackA.getBoundingClientRect().width;
                    const vw = viewport.getBoundingClientRect().width;
                    // Fixed speed — do not adapt to content width
                    tickerSpeed = FIXED_NEWS_TICKER_SPEED;
                    console.debug('[news] tickerSpeed(px/s)=', tickerSpeed, 'trackWidth=', Math.round(wA));
                    trackA.style.transform = 'translateX(0px)';
                    trackB.style.transform = `translateX(${Math.max(0, Math.ceil(wA))}px)`;
                });
                // Pause on hover
                viewport.addEventListener('mouseenter', ()=>{ cancelTicker(); });
                viewport.addEventListener('mouseleave', ()=>{ startTicker(); });
                scheduleMeasure();
            }
            function startTicker(){
                cancelTicker();
                let lastTs = performance.now();
                const step = (ts)=>{
                    const dt = Math.max(0, ts - lastTs) / 1000; lastTs = ts;
                    const dx = tickerSpeed * dt; tickerX -= dx;
                    if(trackA && trackB){
                        const wA = trackA.getBoundingClientRect().width;
                        const wB = trackB.getBoundingClientRect().width;
                        // wrap when A completely off-screen
                        if(-tickerX >= wA){ tickerX += wA; }
                        const xA = Math.floor(tickerX);
                        const xB = Math.floor(tickerX + wA);
                        trackA.style.transform = `translateX(${xA}px)`;
                        trackB.style.transform = `translateX(${xB}px)`;
                    }
                    tickerRAF = requestAnimationFrame(step);
                };
                tickerRAF = requestAnimationFrame(step);
            }
            function cancelTicker(){ if(tickerRAF){ cancelAnimationFrame(tickerRAF); tickerRAF=0; } }
            function applyItems(items){
                itemsState = items.slice();
                if(itemsState.length === 0){
                    newsRow.innerHTML = '';
                    const hint = document.createElement('span'); hint.className='news-item'; hint.textContent = 'No headlines available right now.';
                    newsRow.appendChild(hint);
                    cancelTicker();
                    scheduleMeasure();
                    return;
                }
                buildTicker(itemsState);
                startTicker();
            }
            function init(){
                // Prevent double-initialization when this script is included/executed more than once.
                if(window.__newsInitDone) return;
                window.__newsInitDone = true;
                // Remember which news source to use (pubmed | arxiv)
                // allow a shared global value so other blocks can read it safely
                if(!window.__currentNewsSource) window.__currentNewsSource = 'pubmed';
                let currentNewsSource = window.__currentNewsSource;
                // Sequence counter to ignore stale/overlapping fetch results
                // Increment before each network fetch; only the latest seq may update UI.
                let newsReqSeq = 0;
                try{ currentNewsSource = localStorage.getItem('__newsSourcePref') || 'pubmed'; }catch(e){}
                // keep the global in sync
                window.__currentNewsSource = currentNewsSource;

                function setActiveNewsButton(){
                    try{
                        document.querySelectorAll('.news-source-opt').forEach(b=>{
                            try{ b.classList.toggle('active', (b.dataset && b.dataset.source) === currentNewsSource); }catch(e){}
                        });
                    }catch(e){}
                }

                async function reloadNews(){
                    // capture a sequence id so we can detect stale completions
                    const mySeq = ++newsReqSeq;
                    try{
                        const fresh = await fetchNewsBySource(currentNewsSource);
                        // If a newer request started while we were fetching, ignore this result
                        if(mySeq !== newsReqSeq){ console.debug('[news] ignoring stale fetch result for', currentNewsSource); return; }
                        const merged = dedupe(prune24h([...(fresh||[]), ...(itemsState||[])]));
                        applyItems(merged);
                    }catch(e){
                        console.warn('reloadNews failed', e);
                        try{ const raw = localStorage.getItem(CACHE_KEY+'_'+currentNewsSource); if(raw){ const cached = JSON.parse(raw).items||[]; if(mySeq === newsReqSeq) applyItems(cached); return; } }catch{}
                        if(mySeq === newsReqSeq) applyItems([]);
                    }
                }

                // Force news bar enabled on startup (ignore saved preference)
                try{ localStorage.setItem(PREF_KEY, 'on'); }catch{};
                setNewsEnabled(true);
                startObservers();
                // initial load via selected source
                setActiveNewsButton();
                reloadNews().finally(()=>{
                    // ensure enabled after first fetch
                    setNewsEnabled(true);
                    scheduleMeasure();
                });

                // hourly refresh: merge with current, prune 24h, rebuild ticker
                setInterval(async ()=>{
                    try{
                        const fresh = await fetchNewsBySource(currentNewsSource);
                        const merged = dedupe(prune24h([...(fresh||[]), ...(itemsState||[])]));
                        applyItems(merged);
                    }catch(e){ console.warn('periodic news refresh failed', e); }
                }, REFRESH_MS);

                // wire the enabled toggle
                if(toggleBtn){ toggleBtn.addEventListener('click', ()=>{
                    const on = !(newsBar && newsBar.style.display !== 'none');
                    setNewsEnabled(on);
                }); }

                // wire the source option buttons
                try{
                    document.querySelectorAll('.news-source-opt').forEach(btn=>{
                        try{
                            btn.addEventListener('click', async ()=>{
                                const src = btn.dataset && btn.dataset.source ? btn.dataset.source : 'pubmed';
                                // short-circuit if already active
                                if(currentNewsSource === src) return;
                                currentNewsSource = src;
                                window.__currentNewsSource = src;
                                try{ localStorage.setItem('__newsSourcePref', src); }catch(e){}
                                setActiveNewsButton();

                                // Pause the ticker and show loading hint
                                try{ cancelTicker(); }catch(e){}
                                const prevContent = newsRow.innerHTML;
                                try{
                                    newsRow.innerHTML = '';
                                    const loading = document.createElement('div'); loading.className = 'news-loading hint'; loading.textContent = 'Loading ' + src + ' headlines…';
                                    newsRow.appendChild(loading);
                                }catch(e){}

                                // disable controls while fetching
                                const opts = Array.from(document.querySelectorAll('.news-source-opt'));
                                opts.forEach(o=>{ try{ o.disabled = true; o.classList.add('disabled'); }catch(e){} });

                                // attempt reload; restore UI afterwards
                                try{
                                    await reloadNews();
                                }catch(e){
                                    console.warn('news reload failed on click', e);
                                    // leave loading hint but add notice
                                    try{ const el = newsRow.querySelector('.news-loading'); if(el) el.textContent = 'Failed to load ' + src + ' headlines.'; }catch(e){}
                                } finally {
                                    // re-enable buttons
                                    opts.forEach(o=>{ try{ o.disabled = false; o.classList.remove('disabled'); }catch(e){} });
                                }
                            });
                        }catch(e){}
                    });
                }catch(e){}
            }
            if(document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', init, { once:true }); } else { init(); }
        })();
        </script>
        <!-- Main Title: BUNKR 108 ASCII (restored) -->
        <style>
            /* Tweakable gap under the ASCII title. Try: 0px, 4px, 8px, 12px */
            :root{ --asciiTitleGap: 0px; }
            /* Increase top margin to move title away from the news bar; reduce bottom gap via --asciiTitleGap */
            .page-ascii-title{ margin:18px auto var(--asciiTitleGap); padding:0 2px; color: var(--ink); overflow:visible; pointer-events:none; -webkit-user-select:none; user-select:none; position:relative; display:flex; justify-content:center; align-items:flex-start; }
            .page-ascii-title pre{ margin:0; display:block; font-family: "Courier New", Consolas, monospace; font-weight:700; line-height:1.0; letter-spacing:0.35px; text-shadow:0 1px 0 #000; font-size:24px; white-space:pre; -webkit-user-select:none; user-select:none; transform-origin: top center; will-change: transform; }
            @media (max-width: 800px){ .page-ascii-title pre{ font-size:10px; } }
            @media (max-width: 480px){ .page-ascii-title pre{ font-size:9px; } }
            /* Site credit styling placed under title/boot overlays */
            /* Place credit directly under the title with no gap above; keep 6px below to separate from API bar */
            .site-credit{ margin:0 auto 12px; text-align:center; color:var(--ink); opacity:0.95; font-size:15px; font-weight:600; display:block; -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none; user-select:none; }
            @media (max-width:480px){ .site-credit{ font-size:13px; } }
        </style>
        <div id="mainAsciiTitle" class="page-ascii-title" aria-label="BUNKR 108 title banner">
            <pre>
888888b.   888     888 888b    888 888    d8P  8888888b.         d888    .d8888b.   .d8888b.  
888  "88b  888     888 8888b   888 888   d8P   888   Y88b       d8888   d88P  Y88b d88P  Y88b 
888  .88P  888     888 88888b  888 888  d8P    888    888         888   888    888 Y88b. d88P 
8888888K.  888     888 888Y88b 888 888d88K     888   d88P         888   888    888  "Y88888"  
888  "Y88b 888     888 888 Y88b888 8888888b    8888888P"          888   888    888 .d8P""Y8b. 
888    888 888     888 888  Y88888 888  Y88b   888 T88b           888   888    888 888    888 
888   d88P Y88b. .d88P 888   Y8888 888   Y88b  888  T88b          888   Y88b  d88P Y88b  d88P 
8888888P"   "Y88888P"  888    Y888 888    Y88b 888   T88b       8888888  "Y8888P"   "Y8888P"</pre>
        </div>
    <div class="site-credit" id="pageCredit">Created by <strong>Ethan Shaw</strong></div>
        <script>
        // Keep the ASCII title matched to the module width by scaling DOWN via transform (more reliable)
        (function initAsciiTitleFit(){
            function getEls(){
                const title = document.getElementById('mainAsciiTitle');
                const pre = title ? title.querySelector('pre') : null;
                const module = document.querySelector('.api-key-bar') || document.getElementById('setup') || document.querySelector('.card.pad');
                return { title, pre, module };
            }
            function measureNaturalWidth(pre){
                // Temporarily take the <pre> out of normal flow to measure its max-content width
                const prev = {
                    position: pre.style.position,
                    left: pre.style.left,
                    top: pre.style.top,
                    width: pre.style.width,
                    transform: pre.style.transform,
                    display: pre.style.display
                };
                try{
                    pre.style.position = 'fixed';
                    pre.style.left = '-99999px';
                    pre.style.top = '0';
                    pre.style.width = 'max-content';
                    pre.style.transform = 'none';
                    pre.style.display = 'inline-block';
                    // Use scrollWidth; fallback to bounding rect
                    return Math.max(pre.scrollWidth || 0, pre.getBoundingClientRect().width || 0) || 1;
                } finally {
                    pre.style.position = prev.position;
                    pre.style.left = prev.left;
                    pre.style.top = prev.top;
                    pre.style.width = prev.width;
                    pre.style.transform = prev.transform;
                    pre.style.display = prev.display;
                }
            }
            function fitOnce(){
                try{
                    const { title, pre, module } = getEls();
                    if(!title || !pre || !module) return;
                    const inset = 4; // px of breathing room to avoid any overhang
                    const modRect = module.getBoundingClientRect();
                    const targetW = Math.max(0, Math.round(modRect.width) - inset);
                    // Constrain container to target width but allow centering via margin:auto
                    // Use maxWidth instead of fixed width so the container can be horizontally centered.
                    title.style.width = 'auto';
                    title.style.maxWidth = targetW + 'px';
                    // Measure natural unscaled width
                    const naturalW = measureNaturalWidth(pre);
                    // Compute scale: only downscale; never upscale here
                    let scale = 1;
                    if(naturalW > 0 && targetW > 0){
                        scale = Math.min(1, (targetW / naturalW) * 0.992); // slight fudge to guarantee <= target
                        if(scale < 0.05) scale = 0.05; // hard floor to avoid zeroing out
                    }
                    // Apply transform; center horizontally by translating the scaled box
                    pre.style.transform = 'none';
                    // Force a reflow so getBoundingClientRect reflects unscaled position
                    const preRect0 = pre.getBoundingClientRect();
                    // Apply scale first
                    pre.style.transform = 'scale(' + scale + ')';
                    const titleRect = title.getBoundingClientRect();
                    const preRect = pre.getBoundingClientRect();
                    // Rely on flexbox for horizontal centering. Just apply scale transform.
                    pre.style.transform = 'scale(' + scale + ')';
                    // Reserve height so layout below doesn't jump; add extra pad to avoid clipping
                    const finalRect = pre.getBoundingClientRect();
                    // Respect the CSS gap when reserving height: the container's margin-bottom is external.
                    // Add a larger pad (12px) to ensure tall glyphs are not clipped when scaled.
                    title.style.height = Math.ceil(finalRect.height + 12) + 'px';
                    // Update or create invisible measurement box for diagnostics
                    let box = title.querySelector('#asciiMeasureBox');
                    if(!box){
                        box = document.createElement('div');
                        box.id = 'asciiMeasureBox';
                        box.style.position = 'absolute';
                        box.style.top = '0'; box.style.left = '0';
                        box.style.border = '1px dashed rgba(255,255,255,0)';
                        box.style.pointerEvents = 'none'; box.style.userSelect = 'none';
                        title.appendChild(box);
                    }
                    box.style.width = Math.round(Math.min(finalRect.width, targetW)) + 'px';
                    box.style.height = Math.round(finalRect.height) + 'px';
                    box.dataset.size = `${Math.round(Math.min(finalRect.width, targetW))}x${Math.round(finalRect.height)}`;
                }catch{}
            }
            function fitWithRetries(){
                fitOnce();
                // A couple of delayed passes to catch late layout/font shifts
                setTimeout(fitOnce, 60);
                setTimeout(fitOnce, 180);
            }
            function ready(cb){
                if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', cb, { once:true });
                else cb();
            }
            ready(()=>{
                fitWithRetries();
                window.addEventListener('resize', fitWithRetries);
                // Observe width changes of the target module
                try{
                    const ro = new ResizeObserver(fitWithRetries);
                    const target = document.querySelector('.api-key-bar') || document.getElementById('setup') || document.querySelector('.card.pad');
                    if(target) ro.observe(target);
                }catch{}
                // Ensure the page credit sits immediately under the ASCII title on startup
                try{
                    function ensureCreditUnderTitle(){
                        try{
                            const title = document.getElementById('mainAsciiTitle');
                            const credit = document.getElementById('pageCredit');
                            if(!title || !credit) return;
                            // If credit isn't the next sibling after title, move it there
                            if(title.nextElementSibling !== credit){
                                title.parentNode.insertBefore(credit, title.nextSibling);
                            }
                            // Ensure visual centering and modest spacing
                            credit.style.textAlign = 'center';
                            if(!credit.style.marginTop) credit.style.marginTop = '6px';
                        }catch{}
                    }
                    ensureCreditUnderTitle();
                    // Retry briefly in case other startup code rearranges nodes
                    setTimeout(ensureCreditUnderTitle, 60);
                    setTimeout(ensureCreditUnderTitle, 250);
                }catch{}
                // Re-fit after fonts are ready
                try{ if(document.fonts && document.fonts.ready){ document.fonts.ready.then(()=> fitWithRetries()); } }catch{}
            });
        })();
        </script>
        <!-- Global Gemini API Key (used by any AI feature below) - inside container so it matches width -->
        <div class="api-key-bar">
            <span id="globalKeyDot" class="api-key-dot missing" aria-hidden="true"></span>
            <strong class="fs-14">Gemini API Key</strong>
            <input type="password" id="globalGemKey" placeholder="AIza..." />
            <label class="switch" title="Remember key on this device">
                <input type="checkbox" id="globalGemRemember">
                <span class="slider"></span>
                <span class="switch-label ml-6 fs-12 muted">remember</span>
            </label>
            <label class="switch" title="Enable/disable the API key">
                <input type="checkbox" id="globalGemEnable">
                <span class="slider"></span>
                <span class="switch-label ml-6 fs-12 muted" id="globalGemEnableLabel">disabled</span>
            </label>
        </div>
        <!-- (compact widget removed; expanded TOS box inserted below AI Elements section) -->
        <div class="card pad" id="setup">
            <h1>Load MCQs → Quiz</h1>
            <div class="hint">Format: <span class="tag">Q1. …</span> options start with <span class="tag">-</span>, plus
                an <strong>ANSWER KEY</strong> like <span class="tag">1. B</span>.</div>
            <div class="row mt-10">
                <div class="col">
                    <label>Paste your document</label>
                    <div class="paste-wrap">
                    <textarea id="paste" class="flex-1 minh-320 maxw-600 w-100" placeholder="Q1. Why is protein purification essential in biochemistry?
- It prevents oxidation of DNA
- It allows isolation and study of specific proteins free from contaminants
- It enables bacterial transformation
- It increases cell growth rate
Q2. …
...
ANSWER KEY
1. B
2. C
..."></textarea>
                        <button id="indexPasteBtn" class="index-btn" type="button" title="Save this pasted document">Save MCQ</button>
                    </div>
                    <label class="mt-10">…or load a file (.txt)</label>
                    <div class="file-input">
                        <label class="choose-btn" for="file">Choose File</label>
                        <span class="filename" id="fileNameTxt">No file chosen</span>
                        <input type="file" id="file" accept=".txt" />
                    </div>
                    <!-- AI: Reformat & Assign Answers (same column, same width) -->
                    <div id="aiFixPanel" class="ai-fix-panel mt-10" role="region" aria-label="Reformat MCQs and Assign Answers">
                        <div class="flex center gap-12">
                            <div class="key-badge missing" id="fixKeyBadge" title="Shows whether a Gemini API key is present"><span class="dot"></span><span class="hint">No key set</span></div>
                            <button id="aiFixBtn" class="btn primary btn-wide" type="button" disabled>Reformat & Assign Answers (AI)</button>
                        </div>
                        <div id="aiFixStatus" class="hint mt-8 text-center" role="status" aria-live="polite"></div>
                        <div class="hint mt-6 text-center">Cleans up your pasted MCQ text to the required format (Qn., options with “-”, and an ANSWER KEY). If missing, it assigns a single correct answer per question. Output replaces the text above.</div>
                    </div>
                </div>
                <div class="col">
                    <div class="hint">Options</div>
                    <div class="options-container">
                        <label class="pill"><input type="checkbox" id="shuffleQ" checked> Shuffle questions</label>
                        <label class="pill"><input type="checkbox" id="shuffleA" checked> Shuffle answers</label>
                        <label class="pill"><input type="checkbox" id="instant" checked> Instant feedback</label>
                    </div>
                    <div class="row">
                        <button class="btn primary" id="parseBtn">Parse & Preview</button>
                        <button class="btn" id="startBtn">Start Quiz</button>
                        <button class="btn" id="sampleBtn">Load Sample Snippet</button>
                    </div>
                    <!-- Optional AI file → MCQs generator (docx/pdf) -->
<div class="ai-file-panel">
    <div class="ai-file-row">
    <div class="file-input flex-1-260">
            <label class="choose-btn" for="aiFile">Choose File</label>
            <span class="filename" id="aiFileName">No file chosen</span>
    <input type="file" id="aiFile" multiple accept=".pdf,application/pdf,.docx,application/vnd.openxmlformats-officedocument.wordprocessingml.document,.pptx,application/vnd.openxmlformats-officedocument.presentationml.presentation,image/png,image/jpeg,image/webp,image/gif,image/*">
        </div>
    <!-- Drop target: allow dragging textbook chapters here to feed the Generate MCQs flow -->
    <div id="aiFileTbDrop" class="dropzone ml-8" title="Drop content chapters here to use as source for MCQ generation" aria-label="Drop content chapters here"></div>
    <div class="flex gap-8 center flex-wrap">
    <button id="aiAutoBtn" class="btn pill" title="Let AI choose the question count (defaults to 4 options)" aria-pressed="false">Auto</button>
    <label class="pill" title="How many questions to generate">
            <span class="muted fs-12 mr-4">Questions</span>
            <input type="number" id="aiQCount" min="1" max="50" step="1" value="30" class="w-68" />
        </label>
        <label class="pill" title="How many answer options per question">
            <span class="muted fs-12 mr-4">Options/Q</span>
            <input type="number" id="aiOptCount" min="2" max="6" step="1" value="4" class="w-68" />
        </label>
        <button class="btn primary ai-fixed" id="aiFileGenBtn" title="Use Gemini 2.5-flash to read .docx/.pdf/.pptx and create MCQs">Generate MCQs from .docx/.pdf/.pptx (AI)</button>
    </div>
            <div class="key-badge missing" id="fileGenKeyBadge" title="Shows whether a Gemini API key is present"><span class="dot"></span><span class="hint">No key set</span></div>
    <div class="ai-file-status" id="aiFileStatus" role="status" aria-live="polite"></div>
  </div>
  
        <!-- Visible debug output for the file-gen flow (helps when DevTools isn't open) -->
            <pre id="aiFileDebug"></pre>

            <!-- AI output preview modal (hidden by default) -->
            <div id="aiPreviewModal" class="hidden" aria-hidden="true">
                <div class="overlay">
                    <div class="panel">
                        <div class="flex justify-between center">
                            <h3 id="aiPreviewTitle">AI Output Preview</h3>
                            <button class="btn" id="aiPreviewClose">Close</button>
                        </div>
                        <div class="hint mt-8" id="aiPreviewHint"></div>
                        <pre id="aiPreviewContent"></pre>
                        <div class="flex gap-8 justify-end mt-12">
                            <button class="btn" id="aiPreviewCancel">Cancel</button>
                            <button class="btn primary" id="aiPreviewInsert">Insert full output</button>
                        </div>
                    </div>
                </div>
            </div>
    <div class="hint mt-6">
        Upload a <strong>.docx</strong>, <strong>.pdf</strong>, or <strong>.pptx</strong>. Gemini will conservatively extract content and return a set of
    questions formatted for this tool (Qn. lines, <code>-</code> options, and an <strong>ANSWER KEY</strong>).
  </div>
  </div>

  <!-- Saved MCQs retrieval module (separate, dropdown, outside AI panel) -->
  <div id="savedMcqs" class="saved-card" role="region" aria-label="Saved MCQs">
    <div class="saved-header">
        <div class="flex center gap-8 saved-header-left">
            <strong>Saved MCQs</strong>
            <div class="saved-badge-wrap">
                <span class="muted fs-12" id="savedCount">0</span>
            </div>
            <div id="savedTotalKb" class="muted fs-12" title="Total size of saved MCQs">Total: 0.0 KB</div>
        </div>
        <div class="flex gap-8">
            <button id="toggleSavedBtn" class="btn small" aria-expanded="false" aria-controls="savedMenu">Show</button>
            <button id="exportAllSavedBtn" class="btn small" title="Export all saved MCQs to a single ZIP">Export all</button>
            <button id="clearSavedBtn" class="btn small" title="Remove all saved MCQ sets">Clear</button>
        </div>
    </div>
    <div id="savedMenu" class="saved-menu" role="listbox" aria-label="Saved MCQs Menu">
        <div id="savedList" class="saved-list"></div>
        <!-- footer removed to keep saved list compact (no extra spacing or divider) -->
    </div>
  </div>

                </div>
            </div>
        </div>
<style>
/* Ensure consistent vertical spacing between top-level card modules */
.card + .card { margin-top: 12px; }
  /* add space between the main setup card and the preview section */
  #preview {
    margin-top: 12px;   /* increase/decrease as desired */
  }

</style>
<!-- Ensure missed/validation qcards shrink to fit content (don't stretch full width) -->
<style>
    /* Stack missed items vertically and make each card fill the results panel width
       so missed-answer cards match the Results readout width. */
    #attemptMissedList {
        display: flex;
        flex-direction: column;
        gap: 12px;
        align-items: stretch; /* allow children to grow to full width */
        width: 100%;
        box-sizing: border-box;
    }
    /* Make each missed card expand to the container width (match Results panel) */
    #attemptMissedList .qcard {
        display: block;
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
        margin: 6px 0; /* vertical spacing between cards */
        padding: 12px 14px; /* align with Results card padding */
    }
    /* Prevent the 'hint' row from using flex:space-between which forces wide layout; keep it compact */
    #attemptMissedList .qcard .hint {
        display: block !important;
        margin-top: 6px !important;
        color: var(--muted);
    }
</style>
<style>
/* Simple modal for See All questions */
.modal{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:20000 }
.modal.hidden{ display:none }
.modal{ position: fixed; inset: 0; display:flex; align-items: center; justify-content: center; z-index: 22010; }
.modal-backdrop{ position:absolute; inset:0; background:rgba(2,6,12,0.6); -webkit-backdrop-filter: blur(4px); backdrop-filter: blur(4px); }
.modal-panel{ position:relative; z-index:2; width: min(920px, 96vw); max-height: calc(100vh - 96px); overflow:auto; -webkit-overflow-scrolling: touch; overscroll-behavior: contain; touch-action: auto; border-radius:12px; padding:16px; background: linear-gradient(180deg, rgba(8,12,18,.98), rgba(6,10,14,.98)); border:1px solid rgba(255,255,255,0.04); box-shadow: 0 12px 40px rgba(0,0,0,0.6); }
.modal-open, html.modal-open{ /* modal-open intentionally does not lock overflow so modal-panel can scroll on touch devices */ }
.modal-open body, html.modal-open body{ /* intentionally empty: don't restrict body overflow here */ }
.modal-header{ display:flex; justify-content:space-between; align-items:center; margin-bottom:12px }
.modal-body{ color:var(--ink); font-size:14px; line-height:1.4; }
.seeall-item{ padding:8px 6px; border-bottom:1px dashed rgba(255,255,255,0.02); }
.seeall-item h4{ margin:0 0 6px 0; font-size:14px }
.seeall-item pre{ margin:0; white-space:pre-wrap; font-family:monospace; font-size:13px }
/* concise choice rows inside the See-All modal */
.seeall-choices{ margin-top:6px }
.seeall-choice{ margin:6px 0; font-size:13px; color:var(--muted); }
.seeall-choice strong{ display:inline-block; width:2.2em; color:var(--muted); font-weight:700 }
.seeall-choice.correct{ color: #4dd17a; }
.seeall-choice.correct strong{ color: #4dd17a }
</style>
<style>
/* TOS modal and widget styles */
.tos-body pre{ white-space: pre-wrap; font-family: inherit; font-size:13px; }
.tos-widget{ display:flex; align-items:center; gap:8px; justify-content:flex-end; margin:8px auto; max-width:960px; }
.tos-status{ color:var(--muted); font-size:13px }
.tos-widget .tos-actions{ display:flex; gap:6px }
.tos-widget .btn.small{ padding:6px 8px; font-size:12px }
</style>
        <div id="preview" class="card pad hidden">
            <h2 class="mb-6 mt-0">Preview</h2>
            <div id="previewList"></div>
            <div class="footer">
                <span class="hint"><span id="previewCount">0</span> items parsed.</span>
                <button class="btn primary" id="seeAllBtn">See all</button>
            </div>
        </div>

    <!-- Random Quiz settings gear -->
    <style>
    /* Gear button next to Random button */
    .gear-btn{ display:inline-flex; align-items:center; justify-content:center; width:42px; height:42px; border-radius:50%; border:1px solid rgba(0,0,0,0.08); background:var(--card); cursor:pointer; margin-left:0; font-size:18px; line-height:1; color:#fff }
    .gear-badge{ position:relative; display:inline-block }
    /* badge removed per request; keep wrapper for layout only */
    /* Category modal */
    #randomCategoryModal .modal-panel{ max-width:640px }
    #categorySearchResults{ max-height:240px; overflow:auto; margin-top:8px; border:1px solid rgba(0,0,0,0.06); padding:6px; border-radius:6px; background:var(--card) }
    #categorySearchResults .result{ padding:8px; cursor:pointer; border-bottom:1px dashed rgba(0,0,0,0.03) }
    #categorySearchResults .result:last-child{ border-bottom:none }
    #categorySearchResults .result:hover{ background:rgba(0,0,0,0.02) }
    /* container that keeps random + gear together */
    .random-controls{ display:inline-flex; align-items:center; gap:0 }
    .gear-btn.disabled{ opacity:0.45; pointer-events:none }
    /* API key dot indicators */
    .api-key-dot{ display:inline-block; width:10px; height:10px; border-radius:50%; margin-right:8px; vertical-align:middle; box-shadow: 0 0 6px rgba(0,0,0,0.15); }
    /* Force daily/random key dots to a consistent size so they match visually inside pill buttons */
    #dailyKeyDot, #randomKeyDot { width:10px !important; height:10px !important; margin-right:8px !important; }
    /* Ensure perfect circular shape, no CSS transforms, and proper vertical centering beside text */
    #dailyKeyDot, #randomKeyDot { display:inline-block !important; vertical-align:middle !important; border-radius:50% !important; transform:none !important; box-shadow: 0 0 6px rgba(0,0,0,0.12) !important; }
    /* If dots appear inside .btn.pill, ensure the button doesn't apply a conflicting transform that skews the dot */
    .btn.pill { transform: none; }
    .api-key-dot.missing{ background:#ff6b6b; box-shadow:0 0 8px rgba(255,107,107,0.5); }
    .api-key-dot.present{ background:#4dd17a; box-shadow:0 0 10px rgba(77,209,122,0.5); }
    </style>


        <!-- Daily-build modal (shown while building questions) -->
        <div id="dailyBuildModal" class="modal hidden" role="dialog" aria-modal="true" aria-label="Building questions">
            <div class="modal-backdrop"></div>
            <div class="modal-panel" style="max-width:880px; width:90%;">
                    <div class="modal-header"><h3>Building questions…</h3><button id="dailyBuildClose" class="btn">Close</button></div>
                <div class="modal-body">
                        <div id="dailyBuildTitle" class="daily-title" style="margin-bottom:10px; font-weight:800;">Today's Random Quiz is about&nbsp;<span id="dailyBuildTopic" class="rainbow">choosing...</span>!</div>
                    <div id="dailyBuildSpinner" style="display:flex;align-items:center;gap:12px">
                        <span class="spinner" aria-hidden="true"></span>
                        <div id="dailyBuildStatus">Preparing…</div>
                    </div>
                    <div class="hint mt-6">This dialog displays progress while the daily quiz is generated. Messages are also logged to the Generate MCQ debug output.</div>
                </div>
            </div>
        </div>
    <style>
    /* Animated full-width rainbow gradient for topic line */
     /* Make the title large and responsive: all words on the line use the same size.
         The title spans the full modal width and centers its content. */
     /* Use block + centered text so the sentence and topic are rendered inline like normal text.
         Increase line-height slightly to avoid glyph clipping while keeping no extra vertical space. */
    .daily-title{ font-size: clamp(22px, 5vw, 48px); color: var(--ink); width: 100%; display: block; text-align: center; margin: 0; overflow: visible; font-weight:700; line-height:1.35; padding:6px 0 8px 0; }
    /* Create a moving gradient background that spans the full width of the title area.
       The text uses background-clip:text with transparent color to show the gradient fill.
       We apply the gradient to a child span (.rainbow) but stretch it so the animation moves
       across the entire title area regardless of the text length. */
    .daily-title .rainbow{
        /* behave exactly like inline text so baseline/descenders match surrounding words */
        display: inline;
        color: transparent;
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        /* Use a wide repeating gradient and animate its offset continuously. */
        /* Tileable gradient: start and end color are the same so repeats seamlessly.
           Colors chosen as three anchor regions (warm -> gold -> cool) with smooth stops.
           background-size is set to 300% and we animate exactly by that amount to avoid seams. */
        background-image: linear-gradient(90deg,
            rgb(255,99,71) 0%,    /* warm red (A) */
            rgb(255,165,64) 30%,  /* orange */
            rgb(255,205,86) 45%,  /* gold (A->G midpoint) */
            rgb(144,210,255) 70%, /* light blue (G->B midpoint) */
            rgb(91,170,255) 85%,  /* sky blue */
            rgb(255,99,71) 100%   /* repeat warm red (A) to tile */
        );
        /* Background size equals the animation travel; animate by -300% to loop seamlessly */
        background-size: 300% 100%;
        background-repeat: repeat-x;
        /* Slower, smoother continuous left-to-right animation for gentle fades */
        animation: rainbowMove 16s linear infinite;
        will-change: background-position, transform;
        /* Inherit size and line-height from the title so all text on the line is the same size and aligned */
        font-size: inherit;
        font-weight: 800;
        line-height: inherit;
        vertical-align: baseline;
        padding: 0 4px;
        /* keep overflow visible so descenders are not clipped */
        overflow: visible;
        white-space: nowrap;
        -webkit-font-smoothing: antialiased;
        backface-visibility: hidden;
        transform: translateZ(0);
    }
    /* Inverted color scheme for Random Quiz (colors reversed) */
    .daily-title .rainbow.inverse{
        display: inline;
        color: transparent;
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        /* Inverted rainbow palette and animation (mirror of .rainbow) */
        background-image: linear-gradient(90deg,
            rgb(144,210,255) 0%, /* light blue start */
            rgb(91,170,255) 20%,  /* sky */
            rgb(255,205,86) 45%,  /* gold */
            rgb(255,165,64) 70%,  /* orange */
            rgb(255,99,71) 90%,   /* warm red */
            rgb(144,210,255) 100% /* repeat light blue */
        );
        background-size: 300% 100%;
        background-repeat: repeat-x;
        animation: rainbowMoveReverse 16s linear infinite;
        will-change: background-position, transform;
        font-size: inherit;
        font-weight: 800;
        line-height: inherit;
        vertical-align: baseline;
        padding: 0 4px;
        overflow: visible;
        white-space: nowrap;
        -webkit-font-smoothing: antialiased;
        backface-visibility: hidden;
        transform: translateZ(0);
    }
    /* Ensure links inside the daily/random quiz title are not underlined (keep styling narrow and scoped) */
    .daily-title a { text-decoration: none; }
    .daily-title a:hover { text-decoration: none; }
    /* ASCII face idle animation in AI explanation panel */
    .ascii-face{ display:block; text-align:center; margin-top:12px }
    .ascii-face .face{ display:inline-block; font-family: inherit; font-size:18px; line-height:1; transform-origin:center; animation: faceIdle 3.6s ease-in-out infinite; }
    .ascii-face .mouth{ display:inline-block; min-width:1.1em; display:inline-block; animation: mouthIdle 3.6s ease-in-out infinite; }
    @keyframes faceIdle{ 0%{ transform: translateY(0) } 50%{ transform: translateY(-3px) } 100%{ transform: translateY(0) } }
    @keyframes mouthIdle{ 0%,100%{ transform: scaleX(1) } 45%{ transform: scaleX(1.02) } 50%{ transform: scaleX(0.56) } 55%{ transform: scaleX(1.02) } }
    /* Eye movement controlled by JS: use CSS variables so JS can set translations while blink uses scaleY
       This gives smooth transitions and lets us keep blink + translate composed together. */
    .ascii-face .eye{
        display:inline-flex; align-items:center; justify-content:center; width:0.9em; text-align:center;
        --ex: 0px; --ey: 0px;
        transform-origin:center;
        transition: transform 900ms cubic-bezier(.2,.8,.2,1);
        transform: translate(var(--ex), var(--ey)) scaleY(1);
    }
    /* Blink: compress vertically while preserving current translate values */
    .ascii-face .eye.blink{ transform: translate(var(--ex), var(--ey)) scaleY(0.12); transition: transform 120ms ease-in-out; }
    /* When AI output is active, JS will pause updates; keep this CSS selector as a safeguard */
    #resultsAiOutput.ai-active .eye{ transition: none !important; }
    /* Respect user preference for reduced motion */
    @media (prefers-reduced-motion: reduce){
        .ascii-face .face, .ascii-face .mouth, .ascii-face .eye { transition: none !important; transform: none !important; }
    }
    
    /* Topic link styling: remove underline but keep rainbow text inside; show a colored dot per type */
    a.topic-link{ text-decoration: none; color: inherit; display: inline-flex; align-items: center; gap:8px }
    a.topic-link:focus{ outline: 2px solid rgba(96,165,250,.18); outline-offset:2px; border-radius:6px }
    a.topic-link .rainbow{ padding:0; }
    /* Prepend a small colored dot to indicate inferred topic type */
    a.topic-link::before{ content: ''; display:inline-block; width:10px; height:10px; border-radius:50%; flex:0 0 auto; box-shadow:0 0 6px rgba(0,0,0,0.12); }
    a.topic-link.topic-type-person::before{ background: #FFB86B; box-shadow:0 0 10px rgba(255,184,107,0.35); }
    a.topic-link.topic-type-place::before{ background: #7AD3FF; box-shadow:0 0 10px rgba(122,211,255,0.35); }
    a.topic-link.topic-type-event::before{ background: #FFD36B; box-shadow:0 0 10px rgba(255,211,107,0.28); }
    a.topic-link.topic-type-science::before{ background: #A6FFBA; box-shadow:0 0 10px rgba(166,255,186,0.28); }
    a.topic-link.topic-type-media::before{ background: #D7A3FF; box-shadow:0 0 10px rgba(215,163,255,0.28); }
    a.topic-link.topic-type-organism::before{ background: #9BE57A; box-shadow:0 0 10px rgba(155,229,122,0.28); }
    a.topic-link.topic-type-organization::before{ background: #FFD1D1; box-shadow:0 0 10px rgba(255,209,209,0.28); }
    a.topic-link.topic-type-concept::before{ background: #9FB0FF; box-shadow:0 0 10px rgba(159,176,255,0.28); }
    a.topic-link.topic-type-other::before{ background: #CCCCCC; box-shadow:0 0 8px rgba(204,204,204,0.18); }
    @keyframes rainbowMove {
        0% { background-position: 0% 50%; }
        /* move exactly one background-size length so the pattern tiles without a seam */
        100% { background-position: -300% 50%; }
    }

    /* Compact modal adjustments for the daily build dialog */
    #dailyBuildModal .modal-panel{ padding: 12px 14px; max-width:880px; }
    #dailyBuildModal .modal-body{ padding: 8px 6px 12px 6px; }
    #dailyBuildModal .modal-header h3{ margin: 0 0 6px 0; font-size: 16px; }
    .daily-title{ font-size: clamp(20px, 4.2vw, 36px); line-height: 1.2; padding:4px 0 6px 0; }
    /* Center spinner + status and make them compact */
    #dailyBuildSpinner{ display:flex; align-items:center; justify-content:center; gap:8px; padding:6px 0; }
    #dailyBuildStatus{ text-align:center; font-weight:600; color:var(--muted); }
    /* Center and tighten hint/subtext */
    #dailyBuildModal .hint{ text-align:center; margin-top:8px; font-size:13px; color:var(--muted); }
    /* Reduce close button size visual impact */
    #dailyBuildClose{ padding:6px 10px; font-size:13px }

     /* Animated capsule outline that follows the button's border-radius exactly.
         Technique: two-layer background. The top layer (padding-box) paints the
         button interior; the bottom layer (border-box) paints the gradient which
         is visible only in the transparent border region. This keeps the center
         untouched and creates a perfect pill-shaped outline. */
    /* Make Daily button match other .btn elements (same filled background and border as the News toggle) */
    /* Keep the Daily button visually identical to other .btn.pill elements; avoid overriding
       background, border, or padding so it inherits the exact same look. */
    #dailyQuizBtn{
        position: relative;
        overflow: visible;
        color: var(--ink);
        z-index: 2;
        /* keep the button visually identical to other .btn.pill elements while ensuring
           internal content (dot + label) is properly centered */
        display: inline-flex;
        align-items: center;
    gap: 6px;
        vertical-align: middle;
        /* do not set background/border/padding here so .btn and .btn.pill rules apply exactly */
    }
    /* (removed) animate the button element itself — animation is applied to ::before ring only */
    /* Visible labels are rendered via ::after; no hidden inner label spans remain */
    /* (removed) previously hid the structural label for Random Quiz; label is now rendered via ::after */
    /* Gradient text remains animated for the label */
    #dailyQuizBtn::after{
        content: attr(data-label);
        position: relative;
        display: inline; /* match regular inline text so sizing matches siblings */
        padding: 0; /* don't add extra padding that increases button size */
        margin: 0;
        color: transparent;
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        background-image: linear-gradient(90deg, rgb(255,99,71) 0%, rgb(255,165,64) 30%, rgb(255,205,86) 45%, rgb(144,210,255) 70%, rgb(91,170,255) 85%, rgb(255,99,71) 100%);
        background-size: 300% 100%;
        background-repeat: repeat-x;
    animation: rainbowMove 16s linear infinite;
    font-weight: 800;
        font-size: inherit;
        line-height: inherit;
        z-index: 2;
        pointer-events: none;
        vertical-align: middle;
    }
    /* Random Quiz: use same gradient but animate in the opposite direction for an inverted effect */
    #randomQuizBtn::after{
        content: attr(data-label);
        position: relative;
        display: inline;
        padding: 0; margin: 0;
        color: transparent;
        -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent;
        /* shifted hue palette: purples -> magenta -> warm -> lime -> teal -> repeat */
        background-image: linear-gradient(90deg,
            hsl(260,90%,60%) 0%,   /* purple */
            hsl(320,85%,62%) 20%,  /* magenta */
            hsl(28,90%,60%) 45%,   /* warm orange */
            hsl(95,60%,48%) 70%,   /* lime */
            hsl(175,65%,50%) 90%,  /* teal */
            hsl(260,90%,60%) 100%  /* back to purple */
        );
        background-size: 300% 100%; background-repeat: repeat-x;
        animation: rainbowMoveReverse 14s linear infinite; /* slightly different duration for variety */
        font-weight: 800; font-size: inherit; line-height: inherit; z-index: 2; pointer-events: none; vertical-align: middle;
    }
    @keyframes rainbowMoveReverse { 0% { background-position: 0% 50%; } 100% { background-position: 300% 50%; } }
    /* Ensure the small API key dot keeps its original appearance and is above the outline/text
       and participates in the flex layout so it vertically centers with the label */
    /* Ensure the small API key dot keeps its original appearance and is above the outline/text
       and participates in the flex layout so it vertically centers with the label */
    #dailyQuizBtn .api-key-dot {
        position: relative;
        z-index: 3;
        flex: 0 0 auto;
        align-self: center;
        display: inline-block;
        width: 12px; height: 12px;
    }

    /* Make Random button match the Daily button's internal layout so labels align exactly */
    #randomQuizBtn{
        display: inline-flex;
        align-items: center;
        gap: 6px;
        vertical-align: middle;
    }
    </style>

        <!-- Terms of Use Modal (initial popup) -->
        <div id="tosModal" class="modal hidden" role="dialog" aria-modal="true" aria-label="Terms of Use and Disclaimer">
            <div class="modal-backdrop"></div>
            <div class="modal-panel" id="tosPanel">
                <div class="modal-header">
                    <h3>Terms of Use & Disclaimer — Effective Oct 20, 2025 (v1.0)</h3>
                    <button id="tosClose" class="btn small" aria-label="Close">Close</button>
                </div>
                <div class="modal-body tos-body" id="tosContent">
                    <pre>Terms of Use & Disclaimer
Effective Date: October 20, 2025
Version: 1.0
________________________________________
1. Overview and Acceptance
This website (the “Service”) provides a hosted demonstration of the BUNKR108 open-source multiple-choice question (MCQ) generator (the “Project").
By accessing or using this Service or any downloaded copy of the Project, you agree to these Terms of Use (“Terms"). If you do not agree, you must not use the Service.
The Project is made publicly available for educational and personal use only. This Service is offered as a client-side demo with no user registration, no server-side storage, and no commercial intent.
________________________________________
2. Open-Source License (MIT)
The Project’s source code is licensed under the MIT License, granting you broad rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the software, subject to inclusion of the original license notice and attribution to the authors.
Nothing in these Terms alters or limits your rights under the MIT License. You may view the complete license text at: https://opensource.org/licenses/MIT
________________________________________
3. Nature of the Hosted Demo
The hosted instance found at eshaw0322-design.github.io/BUNKR108/New_Comp_Test.html is a convenience demo of the open-source Project.
All data processing occurs locally in your browser.
No uploaded documents, quiz content, or API keys are transmitted to or stored by the website operator.
Use of the hosted demo is entirely voluntary. For privacy or customization, users are strongly encouraged to download the repository from GitHub and run the Project locally. Github repository URL: https://github.com/eshaw0322-design/BUNKR108
________________________________________
4. Local Processing and API Keys
The Service runs fully in the browser using local storage (IndexedDB/localStorage).
If you choose to enable AI-powered features, you may enter an external API key (e.g., Gemini). This key is stored only in your browser and never sent to the site operator.
There are no server-side safeguards for key security. You assume all responsibility for protecting, rotating, and revoking your own API keys.
If this is a concern, use the self-hosted version of the Project.
________________________________________
5. User Responsibility and Self-Hosting Option
You are free—and encouraged—to download and adapt the Project for your own use, subject to the MIT License.
You are solely responsible for:
• How you configure and operate the code;
• Any content you input or generate; and
• Compliance with all applicable laws in your jurisdiction.
By using, modifying, or redistributing the Project, you acknowledge that you act independently and assume full responsibility for all associated outcomes.
________________________________________
6. Third-Party APIs and Services
Certain features connect directly from your browser to third-party endpoints, including but not limited to:
• Gemini (Google Generative AI) – remote text generation and parsing (the app imports the Gemini SDK via esm.run which then connects to Google’s Generative Language endpoints when you invoke AI features);
• Library CDNs and package hosts (esm.run, jsDelivr, unpkg, cdnjs) used to load third-party JavaScript libraries such as pdf.js/pdf.worker, JSZip, mammoth (DOCX), tesseract.js (OCR), pako, and related tooling;
• Content proxies and CORS intermediaries (api.allorigins.win, cors.isomorphic-git.org, r.jina.ai) used in a small number of fetch operations as fallbacks or to work around CORS restrictions;
• Public content feeds and audio streams accessed by example features (for instance RSS/news feeds such as feeds.npr.org and public audio stream endpoints such as stream.srg-ssr.ch, ice5.somafm.com, strm112.1.fm, and similar public hosts).

These services are independent of this Project and operate under their own terms and privacy policies. When you invoke an AI feature or request any content that requires an external endpoint, your browser connects directly to those third-party services. The Project does not forward, persist, or otherwise intercept your transmitted data beyond what the third-party service receives in a direct browser request.
________________________________________
7. Acceptable Use and Prohibited Conduct
You agree not to use the Service or Project for:
• Any illegal, harmful, or fraudulent purpose;
• Uploading or generating content that violates privacy, intellectual property, or export laws;
• Impersonation of real persons, officials, or entities;
• Harassment, stalking, or targeted hate speech;
• Political or election manipulation without disclosure;
• Processing regulated data (e.g., PHI under HIPAA, children’s data under COPPA, financial records);
• Creating deceptive synthetic or “deepfake” media;
• Training or redistributing AI model outputs that violate copyright or data-use agreements.
Violation of these rules may result in access being blocked from the hosted demo.
________________________________________
8. Data Privacy and Security Notice
This Service does not:
• Require accounts;
• Collect analytics or telemetry;
• Store user-generated content on a remote server;
• Share or sell any user information.
All user data (documents, API keys, MCQs) is confined to your local browser environment and can be deleted at any time via your browser settings.
Because there is no server-side persistence, the operator is not a data controller under GDPR or similar regulations.
________________________________________
9. Intellectual Property and Attribution
• You retain ownership of all content you upload and any MCQs you generate.
• The Project’s source code, name, and visual design are protected by copyright and MIT license attribution.
• You may modify and distribute the Project, provided that you preserve the original license notice and attribution in visible form.
• You may not present derivative versions as the official [Project Name] release or imply endorsement by its authors.
________________________________________
10. No Warranty / Educational Disclaimer
The Project and all related materials are provided “AS IS” without warranty of any kind, express or implied, including but not limited to:
• Accuracy, completeness, or reliability of generated MCQs;
• Suitability for educational, professional, or assessment use;
• Error-free or uninterrupted operation.
All outputs generated through AI features should be independently verified before use in any instructional or evaluative setting.
________________________________________
11. Limitation of Liability
To the maximum extent permitted by applicable law:
• The developers, contributors, and maintainers of this Project shall not be liable for any direct, indirect, incidental, consequential, or special damages arising from or in connection with your use or inability to use the Service or Project.
• This includes, without limitation, loss of data, misuse of API keys, or inaccuracies in generated content.
Your sole remedy for dissatisfaction with the Service is to stop using it.
________________________________________
12. Indemnification
You agree to defend, indemnify, and hold harmless the developers, contributors, and affiliates of this Project from and against any claims, damages, liabilities, or expenses arising out of:
• Your use, configuration, or distribution of the Project;
• Any content or data you submit; or
• Any breach of these Terms or applicable law.
________________________________________
13. Termination and Availability
The maintainers may modify, suspend, or discontinue the hosted demo at any time without notice.
This will not affect your right to continue using the open-source Project independently under the MIT License.
You may stop using the Service or delete all locally stored data at any time.
________________________________________
14. Modifications to Terms or Project
These Terms may be updated periodically.
Changes take effect when posted to this site or repository.
Your continued use after updates constitutes acceptance of the new Terms.
The Project’s source code and dependencies may evolve, and functionality may change without prior notice.
________________________________________
15. Governing Law and Jurisdiction
These Terms are governed by the laws of the State of Texas, United States, without regard to conflict-of-law principles.
Any disputes arising under or in connection with these Terms shall be resolved exclusively in the courts located in Harris County, Texas, USA.
_____________________________
17. Effective Date and Version
Effective Date: October 20, 2025
Version: 1.0
</pre>
                </div>
                <div class="flex justify-end gap-8 mt-12">
                    <button id="tosDecline" class="btn">Decline</button>
                    <button id="tosAccept" class="btn primary">Accept</button>
                </div>
            </div>
        </div>
        <script>
        (function(){
            const KEY = 'tos.accepted.v1';
            const tosModal = document.getElementById('tosModal');
            const tosPanel = document.getElementById('tosPanel');
            const tosAccept = document.getElementById('tosAccept');
            const tosDecline = document.getElementById('tosDecline');
            const tosClose = document.getElementById('tosClose');
            const viewTosBtn = document.getElementById('viewTosBtn');
            // support either the compact widget (#tosState) or the boxed module (#tosStateBox)
            let tosState = document.getElementById('tosState');
            let tosStateBox = document.getElementById('tosStateBox');
            const tosStatus = document.getElementById('tosStatus');

            function setWidgetState(accepted){
                try{
                    if(!tosState) tosState = document.getElementById('tosState');
                    if(!tosStateBox) tosStateBox = document.getElementById('tosStateBox');
                    if(tosState){ tosState.textContent = accepted ? 'Accepted' : 'Not accepted'; tosState.style.color = accepted ? '#4dd17a' : ''; }
                    if(tosStateBox){ tosStateBox.textContent = accepted ? 'Accepted' : 'Not accepted'; tosStateBox.style.color = accepted ? '#4dd17a' : ''; }
                }catch{}
            }

            // UI lock/unlock: add/remove a class on the root to blur and block interactions
            function lockUI(){ try{ document.documentElement.classList.add('tos-locked'); const ov = document.getElementById('tosOverlay'); if(ov) ov.classList.remove('hidden'); }catch{} }
            function unlockUI(){ try{ document.documentElement.classList.remove('tos-locked'); const ov = document.getElementById('tosOverlay'); if(ov) ov.classList.add('hidden'); }catch{} }

            function saveAccepted(){ try{ localStorage.setItem(KEY, '1'); }catch{} setWidgetState(true); unlockUI(); }
            function clearAccepted(){ try{ localStorage.removeItem(KEY); }catch{} setWidgetState(false); lockUI(); }

            function openModal(){
                try{
                    // Hide the centered unlock overlay so the modal's own backdrop appears above the blurred plane
                    const ov = document.getElementById('tosOverlay'); if(ov){ ov.classList.add('hidden'); ov.setAttribute('aria-hidden','true'); }
                }catch(e){}
                tosModal.classList.remove('hidden'); tosModal.setAttribute('aria-hidden','false'); document.documentElement.classList.add('modal-open'); document.body.classList.add('modal-open');
                // focus the close button for accessibility
                try{ document.getElementById('tosClose')?.focus(); }catch(e){}
            }
            function closeModal(){
                tosModal.classList.add('hidden'); tosModal.setAttribute('aria-hidden','true'); document.documentElement.classList.remove('modal-open'); document.body.classList.remove('modal-open');
                try{
                    // If the TOS has not been accepted, restore the locked overlay so the page remains inaccessible
                    const ov = document.getElementById('tosOverlay'); const has = !!localStorage.getItem(KEY);
                    if(ov){ if(!has){ ov.classList.remove('hidden'); ov.setAttribute('aria-hidden','false'); } else { ov.classList.add('hidden'); ov.setAttribute('aria-hidden','true'); } }
                }catch(e){}
            }

            // Wait until DOM is ready so boxed elements exist, then wire buttons and initialize
            function ready(cb){ if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', cb, { once:true }); else cb(); }
            ready(()=>{
                // Re-query DOM elements that may appear after this script block
                try{
                    // modal buttons
                    const _tosAccept = document.getElementById('tosAccept');
                    const _tosDecline = document.getElementById('tosDecline');
                    const _tosClose = document.getElementById('tosClose');
                    const _viewTosBtn = document.getElementById('viewTosBtn');
                    const _tosBoxView = document.getElementById('tosBoxView');
                    // Wire handlers
                    if(_tosAccept) _tosAccept.addEventListener('click', ()=>{ saveAccepted(); closeModal(); });
                    if(_tosDecline) _tosDecline.addEventListener('click', ()=>{ clearAccepted(); closeModal(); });
                    if(_tosClose) _tosClose.addEventListener('click', ()=>{ closeModal(); });
                    if(_viewTosBtn) _viewTosBtn.addEventListener('click', ()=>{ openModal(); });
                    if(_tosBoxView) _tosBoxView.addEventListener('click', ()=>{ openModal(); });
                    const _tosUnlockBtn = document.getElementById('tosUnlockBtn');
                    if(_tosUnlockBtn) _tosUnlockBtn.addEventListener('click', ()=>{ openModal(); });

                    // Initialize widget/box state now that elements exist
                    try{ const v = localStorage.getItem(KEY); const accepted = !!v; setWidgetState(accepted); if(!accepted){ lockUI(); setTimeout(openModal, 250); } else { unlockUI(); } }catch{ setWidgetState(false); lockUI(); setTimeout(openModal, 250); }
                }catch(e){ console.warn('TOS init failed', e); }
            });

        })();
        </script>

        <div id="quiz" class="card pad hidden"></div>

        <!-- See All Modal: lists parsed questions for review -->
        <div id="seeAllModal" class="modal hidden" role="dialog" aria-modal="true" aria-label="All parsed questions">
            <div class="modal-backdrop"></div>
            <div class="modal-panel">
                <div class="modal-header">
                    <h3>All Questions</h3>
                    <button id="seeAllClose" class="btn small" aria-label="Close">Close</button>
                </div>
                <div id="seeAllContent" class="modal-body"></div>
            </div>
        </div>

        <!-- === Post-Quiz Results & AI Feedback (mirrors validate/like style) === -->
        <section id="results-card" class="card pad hidden">
            <!-- Attempts selector at the top, centered -->
            <div class="flex center gap-12">
                <label for="attemptSelect" class="muted fs-12">Attempts</label>
                <!-- Keep native select for accessibility but visually hide it; mirror with a styled dropdown -->
                <select id="attemptSelect" class="rp-select attempt-select visually-hidden" title="Select attempt to view missed questions" aria-hidden="true" tabindex="-1"></select>
                <div id="attemptDropdown" class="attempt-dd" role="combobox" aria-haspopup="listbox" aria-expanded="false" aria-label="Attempts">
                    <button id="attemptTrigger" class="attempt-trigger" type="button">
                        <span id="attemptTriggerText">Select attempt…</span>
                        <span class="chev">▾</span>
                    </button>
                    <div id="attemptMenu" class="attempt-menu" role="listbox" aria-label="Attempts"></div>
                </div>
            </div>
            <div class="hint mt-8 text-center">
                Summary of your quiz performance. Use the analyzer below for AI feedback on missed questions and trends.
            </div>
            <div id="resultsSummary" class="mt-8"></div>
            <div id="attemptMissedList" class="mt-12"></div>
            <hr class="ai-divider" />
            <!-- Analysis section separated under results -->
            <div class="flex col center gap-8 mt-8">
                <div class="key-badge missing" id="resultsKeyBadge" title="Shows whether a Gemini API key is present"><span class="dot"></span><span class="hint">No key set</span></div>
                <div class="flex center gap-12">
                    <button id="analyzeMissedBtn" type="button" class="btn primary btn-wide" disabled>Analyze Missed with AI</button>
                </div>
            </div>
            <div id="resultsAiStatus" class="hint mt-8 text-center"></div>
            <div id="resultsAiOutput" class="hint mt-12" role="status" aria-live="polite"></div>
        </section>

        <!-- === Textbook Library (replaced with index.html app UI + script) === -->
        <section id="textbook-lib" class="card pad">
            <div class="tb-wrap">
                <style>
                    :root{ --bg:#0b1620; --panel:#0f2130; --muted:#9fb0c5; --accent:#4aa3ff; --ok:#4dd17a; --bad:#ff6b6b }
                    .tb-wrap{ max-width:100%; margin-top:0; padding-top:0; overflow:visible }
                    .tb-toc{ width: 100%; }
                    .tb-log{ width: 100%; }
                    /* Layout: compact variant for denser, minimal UI */
                    .flexRow{ display:flex; gap:10px; align-items:flex-start; }
                    /* left column fixed, right column flexes to fill remaining space */
                    .flexRow > .w420 { flex: 0 0 360px; }
                    .flexRow > .flex1 { flex: 1 1 auto; min-width:240px; }
                    /* Tighter, compact cards — use saved-card theme for consistent parent outline */
                    .tb-card{ border-radius:12px; padding:10px; margin:0 0 10px 0; box-shadow: var(--depth); border:1px solid var(--btnBorder); background: linear-gradient(180deg, rgba(16,25,40,.75), rgba(10,16,28,.75)); }
                    .tb-card.small{ padding:8px }
                    .tb-row{ display:flex; gap:8px; align-items:center }
                    .tb-inputNarrow{ width:62px; margin-left:6px; padding:6px 6px; font-size:12px }
                    .tb-pill{ background:rgba(255,255,255,.03); padding:6px 8px; border-radius:8px; font-size:13px }
                    .tb-pill.small{ padding:4px 6px; font-size:12px }
                    .tb-group-sep{ border-top:1px solid rgba(255,255,255,0.04); margin:6px 0 }
                    .tb-node{ padding:4px 6px; border-radius:4px; margin:2px 0 }

                    /* TOC + Log compact sizes */
                    .toc-wrap{ position:relative; width:100%; box-sizing:border-box }
                    /* Make Log and TOC equal fixed height and compact */
                    .tb-toc{ width:100%; box-sizing:border-box; height:120px; overflow:auto; padding:8px; border-radius:6px; background:rgba(0,0,0,.04); font-size:13px }
                    .tb-log{ height:92px; overflow:auto; background:#051018; padding:8px; border-radius:6px; font-family:monospace; font-size:12px }

                    /* saved preview clamp fallback for non-webkit browsers */
                    #savedPreviewWrap{ display:block; max-height:88px; overflow:hidden; line-height:1.2 }

                    /* Center the small headers above each column and remove extra top spacing */
                    .w420 h3.noTopMargin, .flex1 h3.noTopMargin{ text-align: center; margin: 0 0 6px 0; padding-top:0; font-size:16px; font-weight:800 }
                    /* Ensure the card and row don't add extra top padding pushing headers down */
                    .tb-card .flexRow{ margin-top:0 }
                    .flexRow > .w420 h3.noTopMargin, .flexRow > .flex1 h3.noTopMargin{ margin-top:0 }

                    /* Inline meta readout (single row) */
                    .meta-inline{ display:flex; gap:14px; align-items:center; margin-top:8px }
                    .meta-inline .meta-item{ color:var(--muted); font-size:13px }

                    /* Numeric inputs styled as small pills */
                    .num-pill{ width:64px; text-align:center; border-radius:10px; border:1px solid rgba(255,255,255,0.06); background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01)); padding:8px 10px; margin:0 6px; font-size:13px; min-height:36px; box-sizing:border-box; color:var(--ink); }
                    /* Narrow numeric inputs inside TOC controls — use num-pill visual language */
                    .tb-inputNarrow{ width:64px; margin-left:6px; padding:8px 8px; font-size:13px; border-radius:10px; border:1px solid rgba(255,255,255,0.06); background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01)); color:var(--ink); text-align:center; box-shadow: inset 0 1px 0 rgba(255,255,255,0.02) }
                    .tb-inputNarrow:focus{ outline: 2px solid rgba(96,165,250,.16); outline-offset:2px }
                    /* hide number spinners for a cleaner look */
                    input[type=number].tb-inputNarrow::-webkit-outer-spin-button,
                    input[type=number].tb-inputNarrow::-webkit-inner-spin-button{ -webkit-appearance: none; margin: 0 }
                    input[type=number].tb-inputNarrow{ -moz-appearance: textfield; appearance: textfield }
                    .tb-controls-inline{ display:flex; gap:8px; align-items:center }
                    .tb-control-group{ display:flex; align-items:center; gap:6px; padding:6px 8px }

                    /* Saved card should span full width of its parent column */
                    .w420 .card.saved-card, .flex1 .card.saved-card{ width:100%; box-sizing:border-box }
                    /* Ensure saved-card and tb-card share the same visual treatment */
                    .card.saved-card, .tb-card{ background: linear-gradient(180deg, rgba(16,25,40,.75), rgba(10,16,28,.75)); border:1px solid var(--btnBorder); border-radius:12px; box-shadow: var(--depth); }

                    /* Saved sample viewer (monospace, compact) */
                    .saved-sample{ margin-top:6px; background:#051018; padding:6px; border-radius:6px; font-family:monospace; white-space:pre-wrap; max-height:88px; overflow:hidden; color:#cfe9ff; font-size:12px; line-height:1.2 }
                    /* Tighter controls for saved textbook buttons - match .btn.small sizing so they match Saved MCQ buttons */
                    .saved-controls .btn{ padding:6px 8px; font-size:13px; border-radius:10px; font-weight:700; letter-spacing:.2px }
                    /* Map specific clear buttons to the blue clear style */
                    #clearSavedBtn, #tbClearBtn, #sdClearAll { color: #dfeeff; background: rgba(30,110,220,0.08); border: 1px solid rgba(60,120,220,0.25); }
                    .saved-controls .btn.pill{ border-radius:999px }
                    /* Saved select (dropdown) — match paste-section choose-btn / global button palette */
                    .saved-select{ margin-left:6px; margin-right:6px; background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); border: 1px solid var(--btnBorder); color: var(--ink); padding:6px 10px; border-radius:8px; font-weight:700; font-size:13px; min-height:36px; display:inline-flex; align-items:center; position:relative; -webkit-appearance:none; -moz-appearance:none; appearance:none; padding-right:38px; background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24'><path fill='%23cfe9ff' d='M7 10l5 5 5-5z'/></svg>"); background-repeat:no-repeat; background-position: right 10px center; background-size:12px }
                    .saved-select:focus{ outline: 2px solid rgba(96,165,250,.12); outline-offset:2px }
                    /* Style native option list where supported (browsers vary) */
                    .saved-select option{ background: linear-gradient(180deg, rgba(14,20,32,.9), rgba(10,16,24,.95)); color: var(--ink); padding:6px 10px }
                    /* WebKit scrollbar for the native popup in supported browsers */
                    .saved-select::-webkit-scrollbar{ width: 10px; height: 10px }
                    .saved-select::-webkit-scrollbar-thumb{ background: rgba(255,255,255,0.06); border-radius:8px }
                    /* Fallback: if the platform forces native popup, ensure selected look is themed */
                    .saved-select option:checked{ background: linear-gradient(180deg, rgba(7,20,34,.95), rgba(6,10,18,.95)); color: #cfe9ff }
                    .saved-actions{ display:flex; gap:6px }
                    .saved-list{ max-height:220px; overflow:auto; padding:6px; background:rgba(0,0,0,0.03); border-radius:8px }
                    .saved-row{ margin-bottom:4px; padding:4px }

                    /* Hide native file input, use label.tb-pill as button trigger */
                    input[type="file"]#tbFile{ display:none }
                    /* Make Choose PDF label exactly match the paste-section's choose-btn */
                    label.tb-pill[for="tbFile"]{ display:inline-block; padding:6px 10px; border-radius:8px; background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); border: 1px solid var(--btnBorder); color: var(--ink); font-weight:700; cursor:pointer; font-size:13px; line-height:1; box-shadow: inset 0 1px 0 rgba(255,255,255,.06); }
                    @media (max-width: 640px){ label.tb-pill[for="tbFile"]{ min-height:44px; display:flex; align-items:center } }
                    /* Small scan button visual — match Choose/Index buttons */
                    button#btnScan{ padding:6px 10px; font-size:13px; border-radius:8px; background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); border:1px solid var(--btnBorder); color:var(--ink); font-weight:700; box-shadow: inset 0 1px 0 rgba(255,255,255,.06); cursor:pointer }
                    button#btnScan:disabled{ opacity:0.5; cursor:not-allowed }
                    button#btnScan:hover{ transform: translateY(-1px) }

                    /* Floating save FAB inside TOC preview - restyled to match index button (glass-like) */
                    .tb-save-fab{ position:absolute; right:12px; bottom:8px; background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); border: 1px solid var(--btnBorder); padding:8px 12px; border-radius:999px; box-shadow: var(--depth); cursor:pointer; font-size:13px; z-index:9999; display:inline-flex; align-items:center; justify-content:center; min-height:36px; transition: transform .12s ease, box-shadow .12s ease }
                    .tb-save-fab[disabled]{ opacity:0.5; cursor:not-allowed }
                    .tb-save-fab:hover{ transform:translateY(-2px); box-shadow: 0 10px 28px rgba(0,0,0,.55) }

                    /* Saved list wrapper and toggle */
                    .saved-list-wrap{ border-radius:6px; padding:8px; background:rgba(0,0,0,0.02); margin-top:8px }
                    /* Saved Content title: centered and match preview header sizing */
                    /* Center the Saved Content title and match preview header sizing */
                    .saved-card .row > h4.noTopMargin.small, .saved-card h4.noTopMargin.small{ display:block; width:100%; text-align:center !important; font-size:16px; font-weight:800; margin:6px 0 10px 0; color:var(--ink) }
                    .saved-toggle-wrap{ margin-left:auto }
                    /* Custom select control (dark themed) */
                    .custom-select{ background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); border:1px solid var(--btnBorder); color:var(--ink); padding:8px 12px; border-radius:8px; min-height:36px; display:flex; align-items:center; cursor:pointer }
                    .custom-select::after{ content:''; margin-left:auto; width:12px; height:12px; background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24'><path fill='%23cfe9ff' d='M7 10l5 5 5-5z'/></svg>"); background-repeat:no-repeat; background-position:center }
                    .custom-select.open{ box-shadow: 0 10px 28px rgba(0,0,0,.55); }
                    .custom-select-list{ position:absolute; left:0; top:calc(100% + 8px); width:100%; max-height:260px; overflow:auto; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background: linear-gradient(180deg, rgba(8,12,18,.95), rgba(6,10,14,.95)); box-shadow:0 14px 28px rgba(0,0,0,.6); z-index:99999 }
                    .custom-select-list .opt{ display:block; width:100%; box-sizing:border-box; padding:8px 12px; color:var(--ink); border-bottom:1px solid rgba(255,255,255,0.02); cursor:pointer; white-space:normal; overflow-wrap:anywhere; text-align:left }
                    .custom-select-list .opt *{ box-sizing:border-box; width:100% }
                /* keep the drop area visually minimal: store selected info in data-selected attribute and do not show text */
                #aiFileTbDrop[data-selected]{ color: transparent; text-shadow: none }
                    .custom-select-list .opt:hover, .custom-select-list .opt[aria-selected='true']{ background: linear-gradient(180deg, rgba(14,20,34,.95), rgba(10,16,24,.95)); color:#cfe9ff }
                    /* wrapper for custom select to replace inline styles */
                    .custom-select-wrap{ position:relative }

                    .tb-total-size{ margin-left:12px; align-self:center; color:var(--muted); font-size:0.9rem; }
                    .custom-select-hidden{ position:absolute; left:0; top:0; opacity:0; pointer-events:none; height:0; width:0; overflow:hidden }
                    /* Compact content library tweaks */
                    .tb-card{ padding:12px 12px; border-radius:10px; background: linear-gradient(180deg, rgba(8,12,18,.45), rgba(10,14,20,.45)); border:1px solid rgba(255,255,255,0.03) }
                    /* Blurb styling moved from inline to CSS to satisfy linter */
                    #contentLibBlurb{ text-align:center; color:var(--muted); font-size:13px; margin:6px 0 }
                    /* Remove extra gap when a blurb precedes the card */
                    #contentLibBlurb + .tb-card{ margin-top:0 }
                    .tb-row{ display:flex; gap:8px; align-items:center }
                    .tb-pill{ display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:8px; background: linear-gradient(180deg, rgba(16,25,40,.35), rgba(10,16,28,.35)); border:1px solid rgba(30,40,60,.25); font-size:13px }
                    .tb-controls-inline{ display:flex; gap:8px; align-items:center }
                    .tb-inputNarrow{ width:64px; padding:6px 8px; font-size:13px }
                    .num-pill{ width:56px }
                    .mt8{ margin-top:8px }
                    .meta-inline{ display:flex; gap:12px; align-items:center; font-size:13px }
                    .w420{ width:360px; display:flex; flex-direction:column }
                    .flexRow{ display:flex; gap:12px; align-items:stretch }
                    .flexRow > .flex1, .flexRow > .w420{ display:flex; flex-direction:column }
                    .toc-wrap{ position:relative; display:flex; flex-direction:column; flex:1 }
                    .tb-log{ height:120px; min-height:120px; max-height:120px; overflow:auto; background: linear-gradient(180deg, rgba(10,12,16,.35), rgba(8,10,14,.35)); border-radius:8px; padding:8px }
                    .tb-toc{ height:120px; min-height:120px; max-height:120px; overflow:auto; font-size:13px; padding:8px }

                    /* ensure the inner content region used for TOC preview respects the fixed size */
                    #tocTree{ height:100%; box-sizing:border-box; overflow:auto }
                    .tb-save-fab{ position:absolute; right:8px; bottom:8px; padding:8px 12px; border-radius:10px }
                    .compact-saved .saved-controls{ gap:8px; align-items:center }
                    .compact-saved-pad{ padding:10px }
                    .compact-saved-controls{ gap:8px; align-items:center }
                    .compact-select-wrap{ max-width:680px }
                </style>

                <h2 class="page-title">Content Library</h2>
                <div id="contentLibBlurb">Choose files to extract chapters and text into your local Content Library. Scan to preview, then use Save to store items; use the Saved Content controls to show, delete, or clear entries.</div>
                <div class="tb-card">
                    <div class="chooser-row">
                        <div class="chooser-left">
                            <div class="tb-row">
                                <label for="tbFile" class="tb-pill">Choose PDF</label>
                                <input id="tbFile" type="file" accept=".pdf,application/pdf" aria-label="PDF file input" />
                                <button id="btnScan" disabled>Scan TOC</button>
                                <div class="tb-controls-inline">
                                    <div class="tb-pill small tb-control-group">Depth
                                        <input id="depthStart" type="number" min="0" value="0" class="tb-inputNarrow num-pill" title="Minimum outline depth" />
                                        <span class="muted">-</span>
                                        <input id="depthEnd" type="number" min="0" value="0" class="tb-inputNarrow num-pill" title="Maximum outline depth" />
                                    </div>
                                    <div class="tb-pill small tb-control-group">Pages
                                        <input id="pageStart" type="number" min="1" placeholder="start" class="tb-inputNarrow num-pill" />
                                        <span class="muted">-</span>
                                        <input id="pageEnd" type="number" min="1" placeholder="end" class="tb-inputNarrow num-pill" />
                                    </div>
                                </div>
                            </div>
                            <div class="meta mt8 meta-inline">
                                <div class="meta-item">File: <span id="metaName">(none)</span></div>
                                <div class="meta-item">Pages: <span id="metaPages">0</span></div>
                                <div class="meta-item">Estimated: <span id="metaBytes">-</span></div>
                                <!-- Save/Clear buttons moved into the saved-textbook UI block below -->
                            </div>
                        </div>

                        <div class="chooser-divider" aria-hidden="true"></div>

                        <div class="chooser-right">
                            <div class="flexRow">
                                <div class="w420">
                                    <h3 class="noTopMargin">Activity / Progress</h3>
                                    <div id="log" class="tb-log"></div>
                                </div>

                                <div class="flex1">
                                    <h3 class="noTopMargin">Content Preview</h3>
                                    <div class="toc-wrap">
                                        <div id="tocTree" class="tb-toc">(no TOC scanned)</div>
                                        <!-- floating save button inside TOC preview wrapper (not inside tocTree content) -->
                                        <button id="tbSaveBtn" class="tb-save-fab" disabled title="Save scanned content">Save</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- notes removed per request -->
            </div>

            <!-- Saved Textbooks: full-width card placed below feature columns -->
            <div class="card saved-card compact-saved mt8 compact-saved-pad">
                <div class="row">
                    <h4 class="noTopMargin small">Saved Content</h4>
                </div>
                <div class="saved-controls row compact-row mt6 compact-saved-controls">
                    <!-- native select kept hidden for compatibility; custom UI shown below -->
                    <div class="flex1 custom-select-wrap compact-select-wrap">
                        <select id="savedSelect" class="flex1 saved-select compact-select custom-select-hidden" aria-label="Saved content"></select>
                        <div id="savedSelectCustom" class="custom-select" role="listbox" tabindex="0" aria-label="Saved content"></div>
                    </div>
                    <div class="saved-actions compact-actions">
                        <button id="tbShowBtn" class="btn small" disabled>Show</button>
                        <button id="tbDeleteBtn" class="btn small" disabled>Delete</button>
                        <button id="tbClearBtn" class="btn small" disabled>Clear</button>
                        <div id="tbTotalSize" class="tb-total-size" aria-hidden="true">Total: 0.0 KB</div>
                    </div>
                </div>
                <div class="saved-list-wrap mt6">
                    <div class="mt6 small muted compact-details" id="savedDetails">(select saved content and click Show)</div>
                </div>
            </div>

            <script>
            (function(){
                const $ = id => document.getElementById(id);
                const fileEl = $('tbFile'); const btnScan = $('btnScan');
                const tocTree = $('tocTree'); const logEl = $('log');
                const metaName = $('metaName'); const metaPages = $('metaPages'); const metaBytes = $('metaBytes');
                const depthStartEl = $('depthStart'); const depthEndEl = $('depthEnd'); const pageStart = $('pageStart'); const pageEnd = $('pageEnd');

                let pdfDoc = null; let pdfArrayBuffer = null; let pdfNumPages = 0; let outline = null;
                let flattened = [];
                let pdfjsLoaded = false;
                // per-file TOC cache so repeated scans overwrite previous entries instead of duplicating
                window.tocByFile = window.tocByFile || {};
                window.currentFileKey = window.currentFileKey || null;

                function log(...args){ try{ const s = args.map(a=> typeof a==='string'? a : JSON.stringify(a)).join(' '); const line = new Date().toLocaleTimeString() + ' ' + s; logEl.textContent = line + '\n' + logEl.textContent; }catch(e){ console.log(...args); } }
                function humanBytes(n){ if(!n && n!==0) return '-'; const units=['B','KB','MB','GB']; let u=0; while(n>=1024 && u<units.length-1){ n/=1024; u++; } return n.toFixed(n<10?2:1)+' '+units[u]; }

                async function loadScript(url){ return new Promise((res,rej)=>{ const s=document.createElement('script'); s.src=url; s.onload=res; s.onerror=()=>rej(new Error('load failed '+url)); document.head.appendChild(s); }); }
                async function ensurePdfJs(){ if(window.pdfjsLib && pdfjsLoaded) return true; const ver='2.16.105'; const candidates=[
                    `https://cdn.jsdelivr.net/npm/pdfjs-dist@${ver}/build/pdf.min.js`,
                    `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${ver}/pdf.min.js`,
                    `https://unpkg.com/pdfjs-dist@${ver}/build/pdf.min.js`
                ];
                for(const c of candidates){ try{ await loadScript(c); log('loaded pdfjs', c); window.pdfjsLib = window.pdfjsLib || window['pdfjs-dist/build/pdf']; try{ window.pdfjsLib.GlobalWorkerOptions.workerSrc = c.replace(/pdf.min.js$/, 'pdf.worker.min.js'); }catch{} pdfjsLoaded=true; return true;}catch(e){ log('pdfjs load failed', c); } }
                log('pdfjs could not be loaded from any CDN'); return false; }

                // Remove control/unprintable characters and collapse whitespace in titles
                function sanitizeTitle(s){
                    if(!s && s !== 0) return '';
                    try{
                        // remove C0/C1 control ranges and replacement characters, strip a few filesystem-unsafe chars
                        return String(s)
                            .replace(/[\x00-\x1F\x7F-\x9F\uFFFD]/g, '')
                            .replace(/[\\/:*?"<>|]/g, '')
                            .replace(/\s+/g, ' ')
                            .trim()
                            .slice(0, 180);
                    }catch(e){ return String(s||'').trim(); }
                }

                function flattenOutline(outl){
                    const arr=[];
                    function walk(items, depth){
                        if(!items) return;
                        for(const it of items){
                            const rawTitle = it && it.title ? it.title : 'Untitled';
                            const node = {
                                title: sanitizeTitle(rawTitle),
                                dest: it.dest || it.destref || it.dest || it.title,
                                raw: it,
                                depth: depth
                            };
                            arr.push(node);
                            if(it.items && it.items.length) walk(it.items, depth+1);
                        }
                    }
                    walk(outl, 0);
                    return arr;
                }

                function detectChapterDepth(arr){ if(!arr || !arr.length) return 0; const score = {}; const reNum = /^\s*(?:Chapter\b|Ch\.|\d+[.):]|[IVXLCDM]+[.):]|\d+\s)/i; for(const it of arr){ const d = it.depth||0; if(!score[d]) score[d]=0; if(reNum.test(it.title)) score[d]++; } let bestDepth = 0; let best = -1; for(const k in score){ if(score[k] > best){ best = score[k]; bestDepth = parseInt(k,10); } } if(best <= 0) return 0; return bestDepth; }

                async function resolveDestToPageIndex(doc, dest){ try{ if(!dest) return null; let resolved = null; try{ if(typeof dest === 'string'){ resolved = await doc.getDestination(dest); } else if(Array.isArray(dest)) resolved = dest; else if(dest && dest.getArray) resolved = await dest.getArray(); }catch(e){} if(!resolved){ if(dest && dest.num) resolved = [dest]; } if(!resolved) return null; const ref = resolved[0]; if(!ref) return null; const pageIndex = await doc.getPageIndex(ref); return pageIndex; }catch(e){ log('resolveDestToPageIndex failed', e?.message||e); return null; } }

                async function extractPageText(doc, pnum){ try{ const page = await doc.getPage(pnum); const txt = await page.getTextContent({ normalizeWhitespace:true, disableCombineTextItems:false, includeMarkedContent:true }); const parts = txt.items.map(it=> String(it.str || '') ); const s = parts.join(' ').replace(/\s+/g,' ').trim(); return s; }catch(e){ log('page extract failed', pnum, e?.message||e); return ''; } }

                function computeChapterRanges(entries, chapterDepth, numPages){ const chapters = entries.filter(e => Number.isFinite(e.page) && e.depth === chapterDepth).sort((a,b)=> a.page - b.page); for(let i=0;i<chapters.length;i++){ const start = chapters[i].page; const end = (i < chapters.length - 1) ? (chapters[i+1].page - 1) : numPages; chapters[i].startPage = Math.max(1, start); chapters[i].endPage = Math.min(numPages, end); } return chapters; }

                async function buildPageLengthCache(doc, ranges){ if(!ranges || !ranges.length) return {}; const minP = Math.min(...ranges.map(r=> r.startPage)); const maxP = Math.max(...ranges.map(r=> r.endPage)); const cache = {}; for (let p = minP; p <= maxP; p++){ try { const t = await extractPageText(doc, p); cache[p] = t.length; } catch (e){ cache[p] = 0; } await new Promise(r=> setTimeout(r,0)); } return cache; }

                function sumCharsFromCache(cache, start, end, limit){ let total = 0; for (let p = start; p <= end; p++){ const len = cache[p] || 0; if (limit && len > limit) continue; total += len; } return total; }

                async function scanTOC(){
                    if(!pdfDoc) return;
                    // clear previous log for this scan
                    try{ if(logEl) logEl.textContent = ''; }catch{}
                    log('scanning TOC...');
                    // reset working state so duplicates don't accumulate
                    outline = null;
                    flattened = [];
                    window.fullToc = [];
                    try{ tocTree.innerHTML = '(scanning...)'; }catch{};

                    outline = await pdfDoc.getOutline();
                    if(!outline || !outline.length){
                        log('no outline/bookmarks found');
                        flattened=[]; renderTOC(flattened);
                        if(window.currentFileKey) window.tocByFile[window.currentFileKey] = window.fullToc || [];
                        return;
                    }

                    const flat = flattenOutline(outline);
                    log('outline entries', flat.length);
                    if(Array.isArray(outline) && outline.some(it => it && Array.isArray(it.items) && it.items.length>0)){
                        detectedChapterDepth = 1;
                        log('detected chapters as secondary items (depth 1) because top-level entries have children');
                    } else {
                        detectedChapterDepth = detectChapterDepth(flat);
                        log('detected chapter depth (heuristic)', detectedChapterDepth);
                    }

                    for(let i=0;i<flat.length;i++){
                        const it=flat[i];
                        try{
                            const pageIndex = await resolveDestToPageIndex(pdfDoc, it.raw.dest || it.raw.destref || it.raw.destref|| it.raw.a || it.raw.dest);
                            it.page = (pageIndex!=null)? (pageIndex+1) : null;
                            log('resolved', i+1, it.title, '->', it.page);
                        }catch(e){ log('resolve failed for', it.title, e?.message||e); it.page=null; }
                    }

                    const withPage = flat.filter(x=> Number.isFinite(x.page)).sort((a,b)=> a.page - b.page);
                    const withoutPage = flat.filter(x=> !Number.isFinite(x.page));
                    const sorted = withPage.concat(withoutPage);

                    const chapterEntries = computeChapterRanges(sorted, detectedChapterDepth, pdfNumPages);
                    for (const e of sorted) {
                        if (e.depth === detectedChapterDepth) {
                            const found = chapterEntries.find(c => c === e || (c.title===e.title && c.page===e.page));
                            if (found) { e.startPage = found.startPage; e.endPage = found.endPage; }
                        } else {
                            e.startPage = e.page || 1;
                            e.endPage = e.page || e.startPage;
                        }
                    }

                    window.fullToc = sorted.map((s, idx)=> ({ uid: idx, order: idx+1, title: s.title, depth: s.depth, startPage: s.startPage, endPage: s.endPage, page: s.page, raw: s.raw }));
                    flattened = window.fullToc.map(s=> ({ uid: s.uid, order: s.order, title: s.title, depth: s.depth, startPage: s.startPage, endPage: s.endPage, page: s.page }));
                    try{ window.flattened = flattened; }catch(e){}

                    const LIMIT = null;
                    // Build page-length cache across all entries that have numeric start/end pages
                    const entriesForCount = window.fullToc.filter(s => Number.isFinite(s.startPage) && Number.isFinite(s.endPage));
                    try{
                        if(entriesForCount.length){
                            const pageLenCache = await buildPageLengthCache(pdfDoc, entriesForCount);
                            for (const s of window.fullToc){
                                if (Number.isFinite(s.startPage) && Number.isFinite(s.endPage)){
                                    s.charCount = sumCharsFromCache(pageLenCache, s.startPage, s.endPage, LIMIT);
                                } else { s.charCount = s.charCount || 0; }
                            }
                            // Attempt to extract full text for each chapter so saved payloads can include full content
                            try{
                                const FULL_SAVE_LIMIT = 500000; // cap per-chapter saved text to avoid runaway sizes
                                for (const s of window.fullToc){
                                    if (!Number.isFinite(s.startPage) || !Number.isFinite(s.endPage)) continue;
                                    try{
                                        let txt = '';
                                        if(typeof extractRangeText === 'function'){
                                            try{ const r = await extractRangeText(pdfDoc, s.startPage, s.endPage); txt = String(r && r.text ? r.text : ''); if(r && Number.isFinite(r.charCount)) s.charCount = r.charCount; }catch(e){ txt = ''; }
                                        } else if(typeof extractPageText === 'function'){
                                            let acc = '';
                                            for(let p = s.startPage; p <= s.endPage; p++){
                                                try{ const ptxt = await extractPageText(pdfDoc, p); if(ptxt) acc += ptxt + '\n\n'; }catch(e){ /* ignore */ }
                                                if(acc.length > FULL_SAVE_LIMIT) break;
                                            }
                                            txt = acc;
                                        }
                                        if(txt){ if(txt.length > FULL_SAVE_LIMIT) txt = txt.slice(0, FULL_SAVE_LIMIT); s.text = txt; s.snippet = txt.slice(0,20000); }
                                    }catch(e){ /* ignore per-chapter extract errors */ }
                                }
                            }catch(e){ log('chapter text extraction in scanTOC failed', e?.message||e); }
                        } else {
                            // nothing to count; set defaults
                            for (const s of window.fullToc) s.charCount = s.charCount || 0;
                        }
                        for (const f of flattened){ const full = window.fullToc.find(x=> x.uid === f.uid); f.charCount = full ? (full.charCount || 0) : 0; }
                    }catch(e){ log('quick count failed', e?.message||e); }

                    // persist/overwrite this file's TOC to avoid duplicates in future scans
                    if(window.currentFileKey) window.tocByFile[window.currentFileKey] = window.fullToc;

                    applyFiltersAndMeta();
                    try{ const sb = document.getElementById('tbSaveBtn'); if(sb) sb.disabled = false; }catch(e){}
                }

                let detectedChapterDepth = 0;
                function renderTOC(arr, startDepth = null){ if(!arr || !arr.length){ tocTree.innerHTML = '<div class="muted">(no TOC)</div>'; return; } const root=document.createElement('div'); let lastGroup = null; arr.forEach((it,idx)=>{ const d = it.depth; const indentBase = (startDepth!=null) ? Math.max(0, d - startDepth) : d; if(startDepth!=null && d === startDepth && lastGroup !== it.startPage){ const sep = document.createElement('div'); sep.className = 'tb-group-sep'; root.appendChild(sep); lastGroup = it.startPage; } const el = document.createElement('div'); el.className = 'tb-node'; el.style.paddingLeft=(indentBase*18)+'px'; const title=document.createElement('div'); title.textContent = `${String(idx+1).padStart(2,'0')} ${it.title}`; const meta=document.createElement('div'); meta.className='small muted'; const cc = (typeof it.charCount === 'number') ? it.charCount : (it.charCount || 0); meta.textContent = `pages ${it.startPage||'?'} - ${it.endPage||'?'} (${cc} chars)`; el.appendChild(title); el.appendChild(meta); root.appendChild(el); }); tocTree.innerHTML=''; tocTree.appendChild(root); }

                function applyFiltersAndMeta(){ const ds = parseInt(depthStartEl.value,10); const de = parseInt(depthEndEl.value,10); const minD = Number.isFinite(ds) ? ds : 0; const maxD = Number.isFinite(de) ? de : Math.max(9, minD); let filtered = flattened.filter(f => f.depth >= minD && f.depth <= maxD); const start = parseInt(pageStart.value,10) || 1; const end = parseInt(pageEnd.value,10) || pdfNumPages; filtered.forEach(f=>{ f.startPage = Math.max(start, f.startPage||1); f.endPage = Math.min(end, f.endPage||pdfNumPages); if(f.startPage>f.endPage) f.invalid=true; }); const finalList = filtered.filter(f=>!f.invalid && f.startPage<=f.endPage); finalList.forEach(f=> f.charCount = f.charCount || 0); renderTOC(finalList, minD); metaName.textContent = fileEl.files && fileEl.files[0] ? fileEl.files[0].name : '(none)'; metaPages.textContent = pdfNumPages; metaBytes.textContent = humanBytes(pdfArrayBuffer?pdfArrayBuffer.byteLength:0); flattened = finalList; try{ window.flattened = finalList; }catch(e){} }

                fileEl.addEventListener('change', async (e)=>{
                    const f = e.target.files && e.target.files[0]; if(!f) return;
                    // stable key: name::size::lastModified to identify same file across scans
                    const fileKey = `${f.name}::${f.size}::${f.lastModified||0}`;
                    window.currentFileKey = fileKey;
                    metaName.textContent = f.name; metaPages.textContent = '...'; metaBytes.textContent = humanBytes(f.size);
                    log('file selected', f.name, humanBytes(f.size), 'key=', fileKey);
                    // clear UI of previous scan results to avoid duplicate accumulation
                    try{ tocTree.innerHTML = '(no TOC scanned)'; logEl.textContent = ''; }catch{}
                    pdfArrayBuffer = await f.arrayBuffer(); await ensurePdfJs();
                    try{
                        pdfDoc = await window.pdfjsLib.getDocument({ data: pdfArrayBuffer }).promise;
                        pdfNumPages = pdfDoc.numPages; metaPages.textContent = pdfNumPages; log('loaded PDF', f.name, 'pages', pdfNumPages);
                        btnScan.disabled=false;
                        // If we have a cached TOC for this exact file, pre-populate it (overwrite semantics maintained on scan)
                        if(window.tocByFile && window.tocByFile[fileKey] && window.tocByFile[fileKey].length){
                            window.fullToc = window.tocByFile[fileKey];
                            flattened = window.fullToc.map(s=> ({ uid: s.uid, order: s.order, title: s.title, depth: s.depth, startPage: s.startPage, endPage: s.endPage, page: s.page, charCount: s.charCount }));
                            applyFiltersAndMeta();
                        }
                    }catch(err){ log('pdf open failed', err?.message||err); btnScan.disabled=true; }
                });

                btnScan.addEventListener('click', async ()=>{ if(!pdfDoc) return; // clear log when user requests a scan
                    try{ if(logEl) logEl.textContent = ''; }catch{}; btnScan.disabled=true; log('Scan TOC starting...'); try{ await scanTOC(); log('scan complete'); }catch(e){ log('scan failed', e?.message||e); } btnScan.disabled=false; });

                // Save scanned textbook into persistent library (saves current preview)
                const tbSaveBtn = document.getElementById('tbSaveBtn');
                tbSaveBtn?.addEventListener('click', async ()=>{
                    // Save what's currently visible in the preview (`flattened`), not the raw full TOC
                    if(!(Array.isArray(flattened) && flattened.length) || !pdfDoc) { alert('No scanned TOC available to save.'); return; }
                    try{
                        tbSaveBtn.disabled = true;
                        log('building save package...');
                        log('debug: window.loadTextbookLib=', !!window.loadTextbookLib, 'window.saveTextbookLib=', !!window.saveTextbookLib);
                        // Build a lightweight chapters array from the preview: title, startPage, endPage, and small text excerpt
                        const chapters = [];
                        for(const item of flattened){
                            try{
                                const start = Number.isFinite(item.startPage)? item.startPage : (Number.isFinite(item.page)? item.page : 1);
                                const end = Number.isFinite(item.endPage)? item.endPage : start;
                                // extract up to first 20k chars across these pages
                                let txt='';
                                for(let p=start; p<=end; p++){
                                    try{ const s = await extractPageText(pdfDoc, p); if(s) txt += s + '\n\n'; if(txt.length > 200000) break; }catch(e){ log('page extract part failed', e?.message||e); }
                                }
                                const snippet = (txt||'').slice(0,20000);
                                const charCount = (txt && txt.length) ? txt.length : 0;
                                chapters.push({ title: item.title || 'Chapter', uid: item.uid, startPage: start, endPage: end, charCount: charCount, snippet: snippet });
                            }catch(e){ log('chapter build failed', e?.message||e); chapters.push({ title: item.title||'Chapter', text: '' }); }
                        }
                        const bookTitle = metaName.textContent || ('Book ' + (new Date()).toLocaleString());
                        log('prepared book', bookTitle, 'chapters', chapters.length);
                        const LS_KEY = 'textbook.lib.v1';
                        let lib = [];
                        try{
                            if(window.loadTextbookLib){ log('using window.loadTextbookLib()'); lib = window.loadTextbookLib(); }
                            else { log('reading localStorage key', LS_KEY); lib = JSON.parse(localStorage.getItem(LS_KEY) || '[]'); }
                        }catch(e){ log('load failed', e?.message||e); lib = []; }
                        // Use consistent record shape with payload so saved entries include full metadata
                        // Persist full content into IndexedDB first (heavy record), then write a lightweight pointer into localStorage
                        let ok = false;
                        try{
                            // Build heavyweight chapters with full text for IDB storage (do this sequentially)
                            const heavyChapters = [];
                            for (const item of flattened){
                                try{
                                    const start = Number.isFinite(item.startPage)? item.startPage : (Number.isFinite(item.page)? item.page : 1);
                                    const end = Number.isFinite(item.endPage)? item.endPage : start;
                                    let fullText = '';
                                    // Prefer range extractor when available
                                    if(window.pdfDoc && typeof extractRangeText === 'function'){
                                        try{ const r = await extractRangeText(window.pdfDoc, start, end); fullText = String(r && r.text ? r.text : ''); }catch(e){ fullText = ''; }
                                    } else if(window.pdfDoc){
                                        // fallback to iterating pages
                                        let acc = '';
                                        for(let p = start; p <= end; p++){
                                            try{ const s = typeof extractPageText === 'function' ? await extractPageText(window.pdfDoc, p) : (typeof tbExtractPageText === 'function' ? await tbExtractPageText(window.pdfDoc, p) : ''); if(s) acc += s + '\n\n'; }catch(e){ /* ignore */ }
                                        }
                                        fullText = acc;
                                    }
                                    const snippet = (fullText||'').slice(0,20000);
                                    const charCount = fullText ? fullText.length : 0;
                                    // include `text` for compatibility with existing readers
                                    heavyChapters.push({ title: item.title||'Chapter', uid: item.uid, startPage: start, endPage: end, charCount: charCount, snippet: snippet, text: fullText, fullText: fullText });
                                }catch(e){ heavyChapters.push({ title: item.title||'Chapter', uid: item.uid, startPage: item.startPage||1, endPage: item.endPage||item.startPage||1, charCount: 0, snippet: '', fullText: '' }); }
                            }

                            const heavyRec = { title: sanitizeTitle(bookTitle), meta: { savedAt: Date.now(), pages: pdfNumPages, fileName: bookTitle }, payload: { savedAt: Date.now(), items: flattened, chapters: heavyChapters, meta: { fileName: bookTitle, pages: pdfNumPages } } };
                            // store full record in IndexedDB
                            try{
                                const storedId = await idbPutBook(heavyRec);
                                log('indexedDB stored heavy book id', storedId);
                                // write a lightweight pointer into localStorage so UI can show the saved entry quickly
                                try{
                                    if(window.loadTextbookLib){ log('using window.loadTextbookLib() to read lib'); lib = window.loadTextbookLib(); }
                                    else { log('reading localStorage key', LS_KEY); lib = JSON.parse(localStorage.getItem(LS_KEY) || '[]'); }
                                }catch(e){ lib = []; }
                                const pointer = { title: bookTitle, text: '', idbRef: storedId, meta: { pages: pdfNumPages, fileName: bookTitle, savedAt: (new Date()).toISOString() } };
                                lib.push(pointer);
                                try{ localStorage.setItem(LS_KEY, JSON.stringify(lib)); ok = true; log('wrote pointer to localStorage'); }
                                catch(localErr){ log('writing pointer to localStorage failed', localErr?.message||localErr); ok = true; /* pointer failed but heavy record is in IDB so mark ok true */ }
                            }catch(idbErr){ log('idbPutBook failed', idbErr?.message||idbErr); ok = false; }
                        }catch(e){ log('save to IDB failed', e?.message||e); ok = false; }
                        if(ok){ log('save succeeded'); try{ if(window.setTextbookStatus) window.setTextbookStatus('Saved content to library.'); else setStatus && setStatus('Saved content to library.'); try{ if(window.refreshTextbookLibrary) window.refreshTextbookLibrary(); }catch(e){ log('refresh failed', e?.message||e); } }catch(e){ log('status update failed', e?.message||e); } }
                        else {
                            log('save failed; no download fallback (removed)');
                            try{ if(window.setTextbookStatus) window.setTextbookStatus('Could not save content.', true); else setStatus && setStatus('Could not save content.', true); }catch(e){}
                        }
                    }catch(e){ log('save failed', e?.message||e); try{ if(window.setTextbookStatus) window.setTextbookStatus('Save failed', true); else setStatus && setStatus('Save failed', true); }catch(err){ log('status fallback failed', err); } }
                    finally{ try{ tbSaveBtn.disabled = false; }catch(e){} }
                });

                ['dragover','drop'].forEach(ev=> document.addEventListener(ev, (e)=>{ e.preventDefault(); }));
                document.addEventListener('drop', (e)=>{ if(e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length){ fileEl.files = e.dataTransfer.files; fileEl.dispatchEvent(new Event('change')); } });

            })();
            </script>
        </section>

    <script>
    (function(){
    // Inserted verbatim from index.html: IndexedDB-backed saved textbook UI + handlers
        // IndexedDB helpers
        async function idbOpen(){ return new Promise((res,rej)=>{ try{ const req = indexedDB.open('pdf-toc-lib', 1); req.onupgradeneeded = (evt)=>{ const db = evt.target.result; if(!db.objectStoreNames.contains('books')){ db.createObjectStore('books', { keyPath: 'id', autoIncrement: true }); } }; req.onsuccess = ()=> res(req.result); req.onerror = ()=> rej(req.error); }catch(e){ rej(e); } }); }
        async function idbPutBook(book){ const db = await idbOpen(); return new Promise((res, rej)=>{ const tx = db.transaction('books','readwrite'); const store = tx.objectStore('books'); const req = store.add(book); req.onsuccess = ()=>{ res(req.result); db.close(); }; req.onerror = ()=>{ rej(req.error); db.close(); }; }); }
        async function idbGetAllBooks(){ const db = await idbOpen(); return new Promise((res, rej)=>{ const tx = db.transaction('books','readonly'); const store = tx.objectStore('books'); const req = store.getAll(); req.onsuccess = ()=>{ res(req.result || []); db.close(); }; req.onerror = ()=>{ rej(req.error); db.close(); }; }); }
        async function idbGetBook(id){ const db = await idbOpen(); return new Promise((res, rej)=>{ const tx = db.transaction('books','readonly'); const store = tx.objectStore('books'); const req = store.get(id); req.onsuccess = ()=>{ res(req.result); db.close(); }; req.onerror = ()=>{ rej(req.error); db.close(); }; }); }
        async function idbDeleteBook(id){ const db = await idbOpen(); return new Promise((res, rej)=>{ const tx = db.transaction('books','readwrite'); const store = tx.objectStore('books'); const req = store.delete(id); req.onsuccess = ()=>{ res(true); db.close(); }; req.onerror = ()=>{ rej(req.error); db.close(); }; }); }

        // --- Export helpers: single .txt download and bulk .zip using JSZip ---
        function downloadBlob(blob, filename){ try{ const a = document.createElement('a'); const url = URL.createObjectURL(blob); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); try{ a.remove(); }catch{} }, 5000); }catch(e){ console.error('downloadBlob failed', e); }
        }

        async function ensureJSZip(){ if(window.JSZip) return window.JSZip; // try common CDN
            try{ await new Promise((res,rej)=>{ const s = document.createElement('script'); s.src = 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js'; s.onload = res; s.onerror = rej; document.head.appendChild(s); }); return window.JSZip; }catch(e){ console.warn('JSZip load failed', e); throw e; } }

        function sanitizeFilename(s){ try{ return String(s||'untitled').replace(/[\\/:*?"<>|\x00-\x1F]/g,'_').replace(/\s+/g,' ').trim().slice(0,180); }catch(e){ return 'untitled'; } }

        async function exportSingleChapter(ch, recTitle){ try{
            // prefer full text fields when available
            const txt = String(ch.text || ch.fullText || ch.snippet || ch.title || '');
            const filename = sanitizeFilename((recTitle? recTitle + ' - ' : '') + (ch.title || 'chapter')) + '.txt';
            const blob = new Blob([txt], { type: 'text/plain;charset=utf-8' });
            downloadBlob(blob, filename);
        }catch(e){ console.error('exportSingleChapter failed', e); alert('Export failed: ' + (e?.message||e)); } }

        async function exportAllSaved(){ try{
            const btn = document.getElementById('exportAllSavedBtn'); if(btn) { btn.disabled = true; const old = btn.textContent; btn.textContent = 'Preparing…'; }
            const all = await idbGetAllBooks(); if(!all || !all.length){ alert('No saved items to export.'); if(btn){ btn.disabled=false; btn.textContent = old || 'Export all (.zip)'; } return; }
            const JSZipLib = await ensureJSZip(); const zip = new window.JSZip();
            for(const rec of all){ try{
                    const title = rec.title || ('record-' + (rec.id||Date.now()));
                    const payload = rec.payload || {};
                    // If record has chapters, export each chapter as its own file, else create a single file per record
                    if(Array.isArray(payload.chapters) && payload.chapters.length){
                        for(const ch of payload.chapters){ const fname = sanitizeFilename(title + ' - ' + (ch.title||'chapter')) + '.txt'; const content = String(ch.text || ch.fullText || ch.snippet || ch.title || ''); zip.file(fname, content); }
                    } else {
                        const fname = sanitizeFilename(title) + '.txt'; const content = String(rec.text || (payload && payload.text) || ''); zip.file(fname, content);
                    }
            }catch(e){ console.warn('skipping record during zip', e); }
            }
            const blob = await zip.generateAsync({ type: 'blob' });
            const zipName = `saved-mcqs-${(new Date()).toISOString().replace(/[:.]/g,'-')}.zip`;
            downloadBlob(blob, zipName);
            if(btn) { btn.disabled=false; btn.textContent = old || 'Export all (.zip)'; }
        }catch(e){ console.error('exportAllSaved failed', e); alert('Export all failed: ' + (e?.message||e)); try{ const b = document.getElementById('exportAllSavedBtn'); if(b){ b.disabled = false; b.textContent = 'Export all (.zip)'; } }catch{} }
        }

        function log(...args){ try{ const s = args.map(a=> typeof a==='string'? a : JSON.stringify(a)).join(' '); const line = new Date().toLocaleTimeString() + ' ' + s; const logEl = document.getElementById('log') || document.getElementById('tbLog'); if(logEl) logEl.textContent = line + '\n' + logEl.textContent; }catch(e){ console.log(...args); } }

        function populateSavedSelect(items){
            const savedSelect = document.getElementById('savedSelect');
            const savedCustom = document.getElementById('savedSelectCustom');
            // reset both native and custom UI
            savedSelect.innerHTML = '';
            if(savedCustom) savedCustom.innerHTML = '';
            const emptyOpt = document.createElement('option');
            emptyOpt.value = '';
            emptyOpt.textContent = '(none)';
            savedSelect.appendChild(emptyOpt);

            // If no items, disable controls and show placeholder
            if(!items || !items.length){
                document.getElementById('tbClearBtn').disabled = true;
                document.getElementById('tbShowBtn').disabled = true;
                document.getElementById('tbDeleteBtn').disabled = true;
                if(savedCustom){ savedCustom.textContent = '(none)'; }
                return;
            }
            document.getElementById('tbClearBtn').disabled = false;

            // Build list of option data and populate native select
            const optionTexts = [];
            for(const it of items){
                const o = document.createElement('option');
                o.value = String(it.id);
                // Prefer the scanned range found in payload.chapters (startPage..endPage). Fallback to meta.pages.
                let rangeText = (it.meta && it.meta.pages) ? `${it.meta.pages} pages` : '? pages';
                try{
                    const payload = it.payload || {};
                    if(Array.isArray(payload.chapters) && payload.chapters.length){
                        let s = Infinity, e = -Infinity;
                        for(const c of payload.chapters){
                            if(Number.isFinite(c.startPage)) s = Math.min(s, Number(c.startPage));
                            if(Number.isFinite(c.endPage)) e = Math.max(e, Number(c.endPage));
                        }
                        if(s !== Infinity && e !== -Infinity){
                            rangeText = (s===e) ? `${s} pages` : `${s}-${e} pages`;
                        } else if(s !== Infinity){
                            rangeText = `${s} pages`;
                        }
                    }
                }catch(e){ }
                // compute approximate stored size in bytes (prefer chapter.text/fullText, fall back to snippet)
                let sizeBytes = null;
                try{
                    const payload = it.payload || {};
                    if(Array.isArray(payload.chapters) && payload.chapters.length){
                        sizeBytes = 0;
                        for(const c of payload.chapters){
                            const s = (c && (c.text || c.fullText || c.snippet || '')) || '';
                            sizeBytes += (s.length || 0);
                        }
                    } else if(it.text && typeof it.text === 'string'){
                        sizeBytes = it.text.length;
                    }
                }catch(e){ sizeBytes = null; }
                const sizeText = (sizeBytes==null) ? '' : ` • ${(sizeBytes/1024).toFixed(1)} KB`;
                const text = `${it.title || '(untitled)'} — ${rangeText}${sizeText}`;
                o.textContent = text;
                savedSelect.appendChild(o);
                optionTexts.push({ id: String(it.id), text });
            }

            // compute total size across all items and update display
            try{
                const totalBytes = items.reduce((acc,it)=>{
                    try{
                        const payload = it.payload || {};
                        if(Array.isArray(payload.chapters) && payload.chapters.length){
                            return acc + payload.chapters.reduce((a,c)=> a + ((c && (c.text||c.fullText||c.snippet)||'').length || 0), 0);
                        } else if(it.text) return acc + (it.text.length||0);
                    }catch(e){}
                    return acc;
                }, 0);
                const el = document.getElementById('tbTotalSize'); if(el) el.textContent = `Total: ${(totalBytes/1024).toFixed(1)} KB`;
            }catch(e){}

            // Create custom select UI
            if(savedCustom){
                // display element
                const display = document.createElement('div');
                display.className = 'custom-select-display';
                display.textContent = optionTexts[0] ? optionTexts[0].text : '(none)';
                savedCustom.appendChild(display);

                // store current selection
                let current = '';

                let _portalList = null;
                let _repositionHandler = null;
                function closeList(){
                    try{
                        const listEl = _portalList || document.querySelector('.custom-select-list[data-custom="savedSelect"]');
                        if(listEl && listEl.parentElement) listEl.parentElement.removeChild(listEl);
                        // remove attached reposition listeners when closing portal
                        try{ if(_repositionHandler){ window.removeEventListener('resize', _repositionHandler); window.removeEventListener('orientationchange', _repositionHandler); window.removeEventListener('scroll', _repositionHandler, true); } }catch(e){}
                    }catch(e){}
                    _portalList = null;
                    savedCustom.classList.remove('open');
                    document.removeEventListener('mousedown', onDocClick);
                }
                function onDocClick(e){
                    try{
                        const listEl = _portalList || document.querySelector('.custom-select-list[data-custom="savedSelect"]');
                        if(listEl && (listEl.contains(e.target) || savedCustom.contains(e.target))) return; // inside list or control -> keep open
                        closeList();
                    }catch(e){ closeList(); }
                }

                display.addEventListener('click', (e)=>{
                    e.stopPropagation();
                    const alreadyOpen = savedCustom.classList.contains('open');
                    if(alreadyOpen){ closeList(); return; }
                    // build list and render it in document.body (portal) so it's not clipped by stacking contexts
                    const list = document.createElement('div'); list.className = 'custom-select-list'; list.setAttribute('data-custom','savedSelect');
                    for(const it of optionTexts){
                        const opt = document.createElement('div'); opt.className = 'opt'; opt.textContent = it.text; opt.setAttribute('data-val', it.id);
                        if(String(it.id) === current) opt.setAttribute('aria-selected','true');
                        opt.addEventListener('click', ()=>{
                            // update native select value and dispatch change
                            try{ savedSelect.value = String(it.id); savedSelect.dispatchEvent(new Event('change', { bubbles:true })); }catch(e){}
                            display.textContent = it.text; current = String(it.id);
                            closeList();
                        });
                        list.appendChild(opt);
                    }
                    // position the list in the page (portal)
                    // anchor to the control wrapper's bounding rect (savedCustom) so the portal matches the visible button
                    const rect = (savedCustom && savedCustom.getBoundingClientRect && savedCustom.getBoundingClientRect()) || display.getBoundingClientRect();
                    list.style.position = 'absolute';
                    list.style.boxSizing = 'border-box';
                    // anchor to the wrapper's left and keep fixed spacing below the button
                    list.style.left = (rect.left + window.scrollX) + 'px';
                    list.style.top = (rect.bottom + window.scrollY + 8) + 'px';
                    // ensure the portal dropdown exactly matches the control's visible width and font sizing
                    list.style.width = rect.width + 'px';
                    list.style.minWidth = rect.width + 'px';
                    // copy direction and typographic sizing from trigger so appearance matches
                    try{ const dspStyle = window.getComputedStyle(display); list.style.fontSize = dspStyle.fontSize; list.style.fontFamily = dspStyle.fontFamily; list.style.direction = dspStyle.direction; list.style.textAlign = dspStyle.textAlign || 'left'; }catch(e){}
                    list.style.zIndex = '2147483647';
                    document.body.appendChild(list);
                    _portalList = list;

                    // reposition handler to keep portal locked to trigger during scroll/resize/orientation changes
                    _repositionHandler = function(){
                        try{
                            if(!_portalList) return;
                            const r = (savedCustom && savedCustom.getBoundingClientRect && savedCustom.getBoundingClientRect()) || display.getBoundingClientRect();
                            _portalList.style.left = (r.left + window.scrollX) + 'px';
                            _portalList.style.top = (r.bottom + window.scrollY + 8) + 'px';
                            _portalList.style.width = r.width + 'px';
                        }catch(e){}
                    };
                    // attach listeners (capture for scroll so nested scrolling still updates)
                    window.addEventListener('resize', _repositionHandler);
                    window.addEventListener('orientationchange', _repositionHandler);
                    window.addEventListener('scroll', _repositionHandler, true);
                    savedCustom.classList.add('open');
                    // close on outside click
                    setTimeout(()=> document.addEventListener('mousedown', onDocClick), 10);
                });

                // keyboard support: open on Enter/Space, navigate with arrows
                savedCustom.addEventListener('keydown', (ev)=>{
                    if(ev.key === 'Enter' || ev.key === ' '){ ev.preventDefault(); display.click(); }
                });
            }

            document.getElementById('tbShowBtn').disabled = false;
            document.getElementById('tbDeleteBtn').disabled = false;
        }

        async function refreshSavedList(){
            try{
                const all = await idbGetAllBooks();
                // include payload so populateSavedSelect can compute scanned ranges
                const mapped = all.map(a=> ({ id: a.id, title: a.title, meta: a.meta||{}, payload: a.payload||{} }));
                populateSavedSelect(mapped);
            }catch(e){
                log('refresh saved list failed', e?.message||e);
                const savedSelect = document.getElementById('savedSelect');
                savedSelect.innerHTML='';
                const emptyOpt = document.createElement('option');
                emptyOpt.value='';
                emptyOpt.textContent='(error)';
                savedSelect.appendChild(emptyOpt);
            }
        }

        document.getElementById('tbClearBtn')?.addEventListener('click', async ()=>{
            if(!confirm('Delete ALL saved content from the library? This will not affect the currently loaded PDF or preview.')) return;
            try{
                // delete IDB entries (saved textbooks only)
                const all = await idbGetAllBooks();
                for(const a of all){ await idbDeleteBook(a.id); }
                // clear localStorage pointer key used for saved list
                try{ localStorage.removeItem('textbook.lib.v1'); }catch(e){}
                log('cleared all saved textbooks');
                // refresh the saved list UI
                await refreshSavedList();
                // reset saved-list controls only (leave file, toc, flattened and log intact)
                try{ const savedSelect = document.getElementById('savedSelect'); if(savedSelect){ savedSelect.innerHTML = ''; const emptyOpt = document.createElement('option'); emptyOpt.value=''; emptyOpt.textContent='(none)'; savedSelect.appendChild(emptyOpt); } }catch(e){}
                try{ const savedDetails = document.getElementById('savedDetails'); if(savedDetails) savedDetails.textContent='(select saved content and click Show)'; }catch(e){}
                try{ const tbShowBtn = document.getElementById('tbShowBtn'); if(tbShowBtn){ tbShowBtn.dataset.visible = '0'; tbShowBtn.textContent = 'Show'; tbShowBtn.disabled = true; } }catch(e){}
                
                try{ const tbDeleteBtn = document.getElementById('tbDeleteBtn'); if(tbDeleteBtn) tbDeleteBtn.disabled = true; }catch(e){}
            }catch(e){ log('clear all failed', e?.message||e); }
        });

    // tbShowBtn now acts as a Hide/Show toggle for the savedDetails view
    document.getElementById('tbShowBtn')?.addEventListener('click', async ()=>{ const btn = document.getElementById('tbShowBtn'); const savedDetails = document.getElementById('savedDetails'); if(!btn || !savedDetails) return; // when toggling off, just hide the details and update label
        if(btn.dataset.visible === '1'){ btn.dataset.visible = '0'; btn.textContent = 'Show'; savedDetails.style.display = 'none'; return; }
        // otherwise, show (and populate) the selected saved record
        const id = parseInt(document.getElementById('savedSelect').value,10); if(!id) return; try{ const rec = await idbGetBook(id); if(!rec || !rec.payload) { savedDetails.textContent='(record not found)'; btn.dataset.visible = '0'; btn.textContent = 'Show'; return; } const payload = rec.payload; savedDetails.innerHTML=''; savedDetails.style.display = 'block'; btn.dataset.visible = '1'; btn.textContent = 'Hide'; const list = document.createElement('div'); list.className = 'saved-list'; const chapters = payload.chapters || []; if(!chapters.length){ savedDetails.textContent='(no chapters)'; btn.dataset.visible = '0'; btn.textContent = 'Show'; return; }
            function visualizeControlChars(s){ if(!s) return '(empty)'; return s.replace(/\t/g, '→\t').replace(/\r\n|\r|\n/g, '\n↵\n').replace(/[\x00-\x1F\x7F]/g, (c)=>{ const code = c.charCodeAt(0).toString(16).toUpperCase().padStart(2,'0'); return '\\u' + code; }); }
            // create a quick map of saved items (if present) so we can respect depth/indentation
            const itemsMap = (payload.items || []).reduce((acc,it)=>{ try{ acc[it.uid] = it; }catch(e){} return acc; }, {});
            for(const ch of chapters){
                const row = document.createElement('div'); row.className = 'saved-row pill';
                // compute display indentation from saved item's depth (fallback 0)
                const savedItem = itemsMap[ch.uid];
                const depth = (savedItem && Number.isFinite(savedItem.depth)) ? Number(savedItem.depth) : 0;
                const indent = Math.max(0, depth) * 16; // 16px per depth level

                const t = document.createElement('div'); t.style.paddingLeft = indent + 'px';
                // prefer authoritative counts from the current scan (if present) when saved payload looks small
                let displayCount = (typeof ch.charCount === 'number') ? ch.charCount : (ch.snippet ? ch.snippet.length : 0);
                try{
                    if((!displayCount || displayCount < 1000) && Array.isArray(window.fullToc) && window.fullToc.length){
                        const found = window.fullToc.find(x => Number(x.uid) === Number(ch.uid));
                        if(found && Number.isFinite(found.charCount)) displayCount = found.charCount;
                    }
                }catch(e){}
                t.textContent = `${ch.title} [${ch.startPage}-${ch.endPage}] (${displayCount} chars)`;

                // action buttons container
                const actions = document.createElement('div'); actions.className = 'si-actions';

                // Generate -> sets the selected generator source (replace semantics)
                const genBtn = document.createElement('button'); genBtn.className = 'btn small'; genBtn.textContent = 'Generate'; genBtn.title = 'Set this chapter as the source for Generate MCQs';
                genBtn.addEventListener('click', async (ev)=>{
                    try{
                        // If the saved chapter snippet is empty or appears truncated, try to extract the full range from the loaded PDF
                        // prefer stored full text when present on the chapter record
                        let useText = (ch.text && String(ch.text).trim()) ? ch.text : ((ch.fullText && String(ch.fullText).trim()) ? ch.fullText : ((ch.snippet && String(ch.snippet).trim()) ? ch.snippet : ''));
                        try{
                            const shouldTryExtract = (typeof ch.charCount === 'number' && ch.charCount > (useText.length || 0)) || (!useText);
                            if(shouldTryExtract && window.pdfDoc){
                                try{
                                    let r = null;
                                    if(typeof extractRangeText === 'function'){
                                        r = await extractRangeText(window.pdfDoc, ch.startPage, ch.endPage);
                                    } else if(window.pdfDoc && typeof window.pdfDoc.getPage === 'function'){
                                        // Inline fallback: iterate pages and extract text content
                                        let acc = '';
                                        const MAX_CHARS = 200000;
                                        for(let p = ch.startPage; p <= ch.endPage; p++){
                                            try{
                                                const page = await window.pdfDoc.getPage(p);
                                                const content = await page.getTextContent({ normalizeWhitespace:true, disableCombineTextItems:false, includeMarkedContent:true });
                                                const s = (content && Array.isArray(content.items)) ? content.items.map(it=> String(it.str||'')).join(' ').replace(/\s+/g,' ').trim() : '';
                                                if(s) acc += s + '\n\n';
                                                if(acc.length > MAX_CHARS) break;
                                            }catch(e){ break; }
                                        }
                                        r = { text: acc, charCount: acc.length };
                                    }
                                    if(r && r.text && String(r.text).trim().length){ useText = String(r.text).trim(); }
                                }catch(e){ /* extraction failed; keep fallback */ }
                            }
                        }catch(e){}
                        if(!useText) useText = `${ch.title} (pages ${ch.startPage}-${ch.endPage})`;
                        const data = { title: ch.title, text: useText, startPage: ch.startPage, endPage: ch.endPage };
                        // replace the generator context so this becomes the chosen file/source
                        window.__tbGenCtx = window.__tbGenCtx || { pieces: [] };
                        window.__tbGenCtx.pieces = [ data ];
                        // update status indicators to reflect selected source
                        const statusDz = document.getElementById('tbDropGenerate'); if(statusDz) statusDz.textContent = `Selected source: ${ch.title} [${ch.startPage}-${ch.endPage}] (1 chapter)`;
                        const aiStatus = document.getElementById('aiFileStatus'); if(aiStatus) aiStatus.textContent = `Selected source: ${ch.title} [${ch.startPage}-${ch.endPage}]`;
                        // update saved preview area with a snippet and charcount
                        try{
                            const preview = document.getElementById('savedPreviewWrap');
                            if(preview){ const s = String(useText||''); const snippet = s.length > 800 ? s.slice(0,800) + '\n\n[TRUNCATED]' : s; preview.textContent = snippet; preview.textContent += `\n\n(${(s.length||0).toLocaleString()} chars)`; }
                        }catch(e){}
                        // clear any other persisted selection and mark this row as selected
                        try{
                            const parent = row.parentElement;
                            if(parent){
                                parent.querySelectorAll('.saved-row.selected').forEach(r=>{
                                    r.classList.remove('selected');
                                    // clear aria-pressed for any Generate buttons in that row
                                    const b = r.querySelector('button'); if(b && b.textContent === 'Generate'){ b.setAttribute('aria-pressed','false'); }
                                });
                            }
                        }catch(e){}
                        row.classList.add('selected');
                        // mark this Generate button as pressed for accessibility
                        try{ genBtn.setAttribute('aria-pressed','true'); }catch(e){}
                        // mirror selection to the file drop element used by the file chooser
                        try{ const chooser = document.getElementById('aiFileTbDrop'); if(chooser) chooser.setAttribute('data-selected', `${ch.title} [${ch.startPage}-${ch.endPage}]`); }catch(e){}
                        log('Set generator source to', ch.title);
                    }catch(e){ log('apply generate failed', e?.message||e); }
                });

                // Validate -> applies to validator context
                const valBtn = document.createElement('button'); valBtn.className = 'btn small'; valBtn.textContent = 'Validate'; valBtn.title = 'Apply this chapter to the Validate Answers panel';
                valBtn.addEventListener('click', async (ev)=>{
                    try{
                        window.__tbValidateCtx = window.__tbValidateCtx || { pieces: [] };
                        const data = { title: ch.title, text: ch.snippet || '', startPage: ch.startPage, endPage: ch.endPage };
                        window.__tbValidateCtx.pieces.push(data);
                        const dz = document.getElementById('tbDropValidate'); if(dz) dz.textContent = `Attached ${window.__tbValidateCtx.pieces.length} chapter(s).`;
                        const valOut = document.getElementById('aiValidateOutput2'); if(valOut) valOut.textContent = `Applied: ${ch.title} [${ch.startPage}-${ch.endPage}]`;
                        // also reveal the global apply button so users can push corrections if needed
                        try{ const gbtn = document.getElementById('validatorApplyBtnGlobal'); if(gbtn) gbtn.classList.remove('hidden'); }catch(e){}
                        row.classList.add('applied'); setTimeout(()=> row.classList.remove('applied'), 1400);
                        log('Applied to validator context', ch.title);
                    }catch(e){ log('apply validate failed', e?.message||e); }
                });

                // support legacy dragstart (keep for compatibility) on the title element
                t.draggable = true;
                t.addEventListener('dragstart', (ev)=>{ try{ const payload = { title: ch.title, text: ch.snippet || '', startPage: ch.startPage, endPage: ch.endPage }; ev.dataTransfer.setData('application/json', JSON.stringify(payload)); ev.dataTransfer.effectAllowed = 'copy'; log('dragstart', ch.title); }catch(e){ log('dragstart failed', e?.message||e); } });

                // Export -> download this chapter as .txt
                const expBtn = document.createElement('button'); expBtn.className = 'btn small'; expBtn.textContent = 'Export'; expBtn.title = 'Export this chapter as .txt';
                expBtn.addEventListener('click', (ev)=>{ try{ ev.stopPropagation(); ev.preventDefault(); exportSingleChapter(ch, (payload && payload.meta && payload.meta.fileName) ? payload.meta.fileName : (rec && rec.title) ); }catch(e){ console.error(e); } });
                actions.appendChild(genBtn); actions.appendChild(valBtn); actions.appendChild(expBtn);
                row.appendChild(t); row.appendChild(actions); list.appendChild(row);
                // clicking the saved row should show the preview (but not auto-select as generator source)
                (function(row, ch){
                    row.addEventListener('click', (ev)=>{
                        try{
                            // ignore clicks on inline buttons
                            if(ev.target && (ev.target.tagName === 'BUTTON' || ev.target.closest('button'))) return;
                            const preview = document.getElementById('savedPreviewWrap'); if(!preview) return;
                            let useText = (ch.text && String(ch.text).trim()) ? ch.text : ((ch.snippet && String(ch.snippet).trim()) ? ch.snippet : '');
                            if(!useText && ch.title) useText = `${ch.title} (pages ${ch.startPage}-${ch.endPage})`;
                            const maxPreviewChars = 420;
                            const s = String(useText||'');
                            const snippet = s.length > maxPreviewChars ? s.slice(0,maxPreviewChars) + '\n\n[TRUNCATED]' : s || '(no excerpt available)';
                            preview.textContent = snippet;
                            preview.textContent += `\n\n(${(s.length||0).toLocaleString()} chars)`;
                            try{ const parent = row.parentElement; if(parent) parent.querySelectorAll('.saved-row.selected').forEach(r=> r.classList.remove('selected')); row.classList.add('selected'); }catch(e){}
                        }catch(e){}
                    });
                })(row, ch);
            }
            savedDetails.appendChild(list);
            // Preview container for selected saved chapter excerpts
            try{
                const previewWrap = document.createElement('div');
                previewWrap.id = 'savedPreviewWrap';
                previewWrap.className = 'saved-sample compact-sample';
                previewWrap.style.marginTop = '6px';
                // shorter preview by default (visual clamp)
                previewWrap.style.maxHeight = '160px';
                previewWrap.style.overflow = 'auto';
                previewWrap.style.position = 'relative';
                previewWrap.style.display = '-webkit-box';
                previewWrap.style.webkitLineClamp = '4';
                previewWrap.style.webkitBoxOrient = 'vertical';
                previewWrap.style.lineHeight = '1.2';
                previewWrap.textContent = '(select a chapter and click Generate to preview excerpt)';
                savedDetails.appendChild(previewWrap);

                // If the first chapter has a snippet that appears truncated and the PDF is loaded, try to extract the full range
                (async ()=>{
                    try{
                        const first = chapters && chapters.length ? chapters[0] : null;
                        if(!first) return;
                        const preview = document.getElementById('savedPreviewWrap');
                        if(!preview) return;
                        const sSnippet = String(first.snippet || '');
                        const sCount = (typeof first.charCount === 'number') ? first.charCount : sSnippet.length;
                        // if PDF loaded and snippet is much smaller than expected, attempt extraction
                        if(window.pdfDoc && (!sCount || sSnippet.length < Math.max(1000, Math.min(50000, sCount)))){
                            let useText = sSnippet || '';
                            try{
                                let r = null;
                                if(typeof extractRangeText === 'function'){
                                    r = await extractRangeText(window.pdfDoc, first.startPage, first.endPage);
                                } else if(window.pdfDoc && typeof window.pdfDoc.getPage === 'function'){
                                    let acc = '';
                                    const MAX_CHARS = 300000;
                                    for(let p = first.startPage; p <= first.endPage; p++){
                                        try{
                                            const page = await window.pdfDoc.getPage(p);
                                            const content = await page.getTextContent({ normalizeWhitespace:true, disableCombineTextItems:false, includeMarkedContent:true });
                                            const s = (content && Array.isArray(content.items)) ? content.items.map(it=> String(it.str||'')).join(' ').replace(/\s+/g,' ').trim() : '';
                                            if(s) acc += s + '\n\n';
                                            if(acc.length > MAX_CHARS) break;
                                        }catch(e){ break; }
                                    }
                                    r = { text: acc, charCount: acc.length };
                                }
                                if(r && r.text && String(r.text).trim().length) useText = String(r.text).trim();
                            }catch(e){}
                            if(!useText) useText = `${first.title} (pages ${first.startPage}-${first.endPage})`;
                            const s = String(useText||'');
                            const maxPreviewChars = 420;
                            const snippet = s.length > maxPreviewChars ? s.slice(0,maxPreviewChars) + '\n\n[TRUNCATED]' : s;
                            preview.textContent = snippet;
                            preview.textContent += `\n\n(${(s.length||0).toLocaleString()} chars)`;
                        } else {
                            // show whatever snippet is available
                            const s = sSnippet || '';
                            const maxPreviewChars = 420;
                            const snippet = s.length ? (s.length > maxPreviewChars ? s.slice(0,maxPreviewChars) + '\n\n[TRUNCATED]' : s) : '(no excerpt available)';
                            preview.textContent = snippet;
                            preview.textContent += `\n\n(${(sCount||0).toLocaleString()} chars)`;
                        }
                    }catch(e){ /* ignore preview extraction failures */ }
                })();
            }catch(e){}
        }catch(e){ log('show failed', e?.message||e); savedDetails.textContent='(error)'; } });

    document.getElementById('tbDeleteBtn')?.addEventListener('click', async ()=>{ const id = parseInt(document.getElementById('savedSelect').value,10); if(!id) return; if(!confirm('Delete selected saved content?')) return; try{ await idbDeleteBook(id); log('deleted saved', id); await refreshSavedList(); document.getElementById('savedDetails').textContent='(none)'; }catch(e){ log('delete failed', e?.message||e); } });

    

    // Migrate selected saved record to include full chapter text (when PDF is loaded)
    

        // Load into UI/generator context
    

    // Save handler (compact payload) + flash saved state
    document.getElementById('tbSaveBtn')?.addEventListener('click', async ()=>{ const tbSaveBtn = document.getElementById('tbSaveBtn'); const savedSelect = document.getElementById('savedSelect'); if(!(window.fullToc && window.fullToc.length)) return; tbSaveBtn.disabled=true; const oldText = tbSaveBtn.textContent; log('Saving scanned textbook to IndexedDB...'); try{ const meta = { savedAt: Date.now(), pages: (window.pdfNumPages||window.pdfNumPages===0)? window.pdfNumPages : (window.pdfNumPages||0), fileName: (document.getElementById('metaName')?.textContent || '') }; const chapters = []; const itemsToSave = Array.isArray(window.flattened)? window.flattened.slice() : (Array.isArray(window.fullToc)? window.fullToc.slice():[]); const fullMap = (window.fullToc||[]).reduce((acc, x)=>{ acc[x.uid] = x; return acc; }, {});
            for (const ch of itemsToSave) {
                // compute start/end pages with safe fallbacks and bounds checking
                const s = Math.max(1, Number.isFinite(ch.startPage) ? ch.startPage : (Number.isFinite(ch.page) ? ch.page : 1));
                let e = Number.isFinite(ch.endPage) ? ch.endPage : (Number.isFinite(ch.page) ? ch.page : s);
                if (Number.isFinite(window.pdfNumPages) && window.pdfNumPages > 0) e = Math.min(window.pdfNumPages, e);

                // we'll try to compute an authoritative charCount for the full range and capture the full text.
                // prefer extractRangeText if available (returns text + charCount). Otherwise fall back to per-page accumulation
                let snippet = '';
                let charCount = 0;
                let fullText = '';
                try{
                    if(window.pdfDoc){
                        if(typeof extractRangeText === 'function'){
                            // extract the full chapter range (s..e)
                            const r = await extractRangeText(window.pdfDoc, s, e);
                            fullText = String(r && r.text ? r.text : '');
                            // cap stored full text to a reasonable limit to avoid extremely large saves
                            const FULL_SAVE_LIMIT = 500000;
                            if(fullText.length > FULL_SAVE_LIMIT) fullText = fullText.slice(0, FULL_SAVE_LIMIT);
                            snippet = fullText.slice(0, 20000);
                            charCount = Number.isFinite(r && r.charCount) ? r.charCount : fullText.length;
                        } else {
                            // no range helper available: iterate pages and accumulate lengths
                            let acc = '';
                            let total = 0;
                            const ACC_LIMIT = 200000; // don't build enormous temporary buffers
                            for(let p = s; p <= e; p++){
                                try{
                                    let pageText = '';
                                    if(typeof extractPageText === 'function'){
                                        pageText = await extractPageText(window.pdfDoc, p);
                                    } else if(typeof tbExtractPageText === 'function'){
                                        pageText = await tbExtractPageText(window.pdfDoc, p);
                                    }
                                    if(pageText){
                                        total += pageText.length;
                                        if(acc.length < ACC_LIMIT) acc += pageText + '\n\n';
                                    }
                                }catch(e){ /* ignore page errors and continue */ }
                            }
                            // use accumulated text as the full text (within ACC_LIMIT)
                            fullText = acc;
                            snippet = fullText.slice(0, 20000);
                            charCount = total;
                        }
                    }
                }catch(err){ log('chapter extract failed', err?.message||err); snippet = snippet || ''; charCount = charCount || 0; }

                // prefer authoritative counts and stored text discovered during scan (fullMap) when present
                const authoritative = fullMap[ch.uid];
                let authCount = (authoritative && Number.isFinite(authoritative.charCount)) ? authoritative.charCount : (Number.isFinite(charCount) ? charCount : (snippet ? snippet.length : 0));
                // if the scan populated full text for this chapter, prefer that and avoid re-extraction
                let storedText = (authoritative && authoritative.text) ? authoritative.text : (authoritative && authoritative.fullText ? authoritative.fullText : (fullText || ''));
                if(storedText && !authCount) authCount = storedText.length;
                const finalSnippet = storedText ? (String(storedText).slice(0,20000)) : snippet;
                const finalText = storedText || fullText || '';
                chapters.push({ title: ch.title, uid: ch.uid, startPage: s, endPage: e, charCount: authCount, snippet: finalSnippet, text: finalText });
            }
            const payload = { savedAt: Date.now(), items: itemsToSave, chapters, meta }; const rec = { title: sanitizeTitle(meta.fileName || ('Saved '+new Date().toISOString())), meta: meta, payload }; const id = await idbPutBook(rec); log('saved textbook id', id); await refreshSavedList();
            // Flash saved state similar to the index MCQ button
            try{ tbSaveBtn.textContent = 'Saved'; tbSaveBtn.classList.add('saved'); setTimeout(()=>{ try{ tbSaveBtn.textContent = oldText || 'Save'; tbSaveBtn.classList.remove('saved'); }catch(e){} }, 1200); }catch(e){}
        }catch(e){ log('save failed', e?.message||e); } document.getElementById('tbSaveBtn').disabled=false; });

    // initial refresh
    refreshSavedList().catch(err=> log('initial saved list refresh failed', err?.message||err));

    // Wire bulk export button for localStorage saved MCQs
    try{ document.getElementById('exportAllSavedBtn')?.addEventListener('click', (e)=>{ e.preventDefault(); exportAllLocalSaved(); }); }catch(e){ console.warn('exportAllLocalSaved wiring failed', e); }

        // Wire savedSelect change
    document.getElementById('savedSelect')?.addEventListener('change', ()=>{ const id = document.getElementById('savedSelect').value; const has = !!id; const tbShowBtn = document.getElementById('tbShowBtn'); document.getElementById('tbShowBtn').disabled = !has; document.getElementById('tbDeleteBtn').disabled = !has; if(tbShowBtn){ tbShowBtn.dataset.visible = '0'; tbShowBtn.textContent = 'Show'; const savedDetails = document.getElementById('savedDetails'); if(savedDetails) savedDetails.style.display = 'none'; } });

        // toggleSavedList removed — Show/Hide functionality is handled by the TB Show button

        // Drag/drop receive helper (allow files to be dropped into page to trigger file inputs elsewhere)
        ['dragover','drop'].forEach(ev=> document.addEventListener(ev, (e)=>{ e.preventDefault(); }));
        document.addEventListener('drop', (e)=>{ if(e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length){ const fileEl = document.getElementById('file') || document.getElementById('tbFile'); if(fileEl){ try{ fileEl.files = e.dataTransfer.files; fileEl.dispatchEvent(new Event('change')); }catch(e){ } } } });

    // Small helper used above
    function sanitizeTitle(s){ return String(s||'').replace(/[\\/:*?"<>|\x00-\x1F]/g,'_').replace(/\s+/g,' ').trim().slice(0,180); }
    })();
    </script>

        <!-- === AI Like-Question Generator (start-only) === -->
        <section id="ai-likeq-copy" class="card pad ai-likeq">
            <div class="flex col center gap-8">
                <div class="key-badge missing" id="globalKeyBadge2" title="Shows whether a Gemini API key is present"><span class="dot"></span><span class="hint">No key set</span></div>
                <div id="validatorActionRow" class="flex center gap-12">
                <button id="aiLikeBtn2" class="btn primary btn-wide" disabled>Validate Answers (AI)</button>
                <!-- Apply corrections button moved here so it appears inside the same card/action area -->
                <button id="validatorApplyBtnGlobal" class="btn hidden ml-8">Apply corrections to text</button>
                </div>
            </div>
            <div class="hint mt-8 text-center">
                Validates each ANSWER KEY entry against its question options. Outputs a single-line summary (CORRECT / INCORRECT counts) followed by only the incorrectly keyed questions and their correct answers into the box below.
            </div>
            <div id="aiLikeStatus2" class="hint mt-8 text-center"></div>
                        <div id="aiValidateOutput2" class="hint mt-12" role="status" aria-live="polite"></div>
                        <div id="aiValidateActions" class="mt-8 flex justify-start gap-8"></div>
                        <!-- global apply button intentionally moved into the ai-like header so it's visible inside the card (see header markup) -->
        </section>

<script>
// Textbook Library: client-side extract + chapter segmentation + drag-drop integration
(function(){
    const $ = (id)=> document.getElementById(id);
    const LS = 'textbook.lib.v1';
    const tbFiles = $('tbFiles'); const tbName = $('tbFilesName'); const tbTree = $('tbTree'); const tbStatus = $('tbStatus'); const tbClear = $('tbClearBtn'); const tbDebug = $('tbDebug'); const tbProcess = $('tbProcessBtn');
    // safe global status updater for textbook module (guard against scope issues)
    try{ window.setTextbookStatus = window.setTextbookStatus || function(t, bad){ try{ const el = document.getElementById('tbStatus'); if(el){ el.textContent = t||''; el.style.color = bad? 'var(--bad)' : ''; } else { console.log('[TB status]', t); } }catch(e){ console.log('[TB status error]', e); } }; }catch(e){}

    // --- IndexedDB helpers for fallback storage when localStorage quota is exceeded ---
    function idbOpen(){
        return new Promise((res, rej)=>{
            try{
                const req = indexedDB.open('textbook_lib_v1', 1);
                req.onupgradeneeded = ()=>{ const db = req.result; if(!db.objectStoreNames.contains('books')) db.createObjectStore('books', { keyPath: 'id', autoIncrement: true }); };
                req.onsuccess = ()=> res(req.result);
                req.onerror = ()=> rej(req.error || new Error('idb open failed'));
            }catch(e){ rej(e); }
        });
    }
    async function idbPutBook(book){ try{ const db = await idbOpen(); return await new Promise((res, rej)=>{ const tx = db.transaction('books','readwrite'); const store = tx.objectStore('books'); const r = store.add(book); r.onsuccess = ()=> res(r.result); r.onerror = ()=> rej(r.error||new Error('idb add failed')); }); }catch(e){ throw e; } }
    // Update existing book record (uses put so object with id will replace)
    async function idbUpdateBook(book){ try{ const db = await idbOpen(); return await new Promise((res, rej)=>{ const tx = db.transaction('books','readwrite'); const store = tx.objectStore('books'); const r = store.put(book); r.onsuccess = ()=> res(r.result); r.onerror = ()=> rej(r.error||new Error('idb put failed')); }); }catch(e){ throw e; } }
    async function idbGetBook(id){ try{ const db = await idbOpen(); return await new Promise((res, rej)=>{ const tx = db.transaction('books','readonly'); const store = tx.objectStore('books'); const r = store.get(Number(id)); r.onsuccess = ()=> res(r.result); r.onerror = ()=> rej(r.error||new Error('idb get failed')); }); }catch(e){ throw e; } }
    // Ensure the visible 'Add Textbook' button triggers the hidden file input (robust click wiring)
    try{ const choose = document.querySelector('label.choose-btn[for="tbFiles"]'); if(choose){ choose.addEventListener('click', (ev)=>{ ev.preventDefault(); tbFiles && tbFiles.click(); }); } }catch(e){ /* ignore */ }
    if(!tbTree) return;
    function logDbg(...args){ try{ const s = args.map(a=> typeof a==='string'? a : JSON.stringify(a)).join(' '); if(tbDebug){ tbDebug.textContent = (new Date()).toLocaleTimeString() + ' ' + s + "\n" + tbDebug.textContent; } else { console.log('[TB]', ...args); } }catch(e){ console.log('[TB]', ...args); } }
    function loadLib(){ try{ const raw = localStorage.getItem(LS); return raw? JSON.parse(raw): []; }catch{ return []; } }
    function saveLib(arr){ try{ localStorage.setItem(LS, JSON.stringify(arr||[])); return true; }catch(e){ logDbg('saveLib failed', e?.message||e); setStatus('Could not save library to this device (storage full or blocked). Data kept in memory for this session.', true); return false; } }
    // expose helpers for other modules to reuse (safe no-op if overwritten)
    try{ window.loadTextbookLib = window.loadTextbookLib || loadLib; window.saveTextbookLib = window.saveTextbookLib || saveLib; window.setTextbookStatus = window.setTextbookStatus || setStatus; }catch(e){}
    function setStatus(t, bad){ if(tbStatus){ tbStatus.textContent = t||''; tbStatus.style.color = bad? 'var(--bad)' : ''; } }

    // --- Resilient CDN/script loader helpers ---
    async function loadScriptWithFallbacks(pairs){
        // pairs: [{script, worker?, onload?}]
        for(const p of pairs){
            try{
                await new Promise((res, rej)=>{
                    const s = document.createElement('script');
                    s.src = p.script; s.async = true; s.onload = ()=> res(); s.onerror = ()=> rej(new Error('load failed'));
                    document.head.appendChild(s);
                });
                if(typeof p.onload === 'function'){ await p.onload(); }
                logDbg('cdn loaded', p.script);
                return p; // return the winning pair
            }catch(e){ logDbg('cdn failed', p.script); }
        }
        return null;
    }

    async function ensurePdfJs(){
        if(window.pdfjsLib && window.pdfjsLib.getDocument) return true;
        const VER = '4.2.67';
        const candidates = [
            { script: `https://cdn.jsdelivr.net/npm/pdfjs-dist@${VER}/build/pdf.min.js`, worker: `https://cdn.jsdelivr.net/npm/pdfjs-dist@${VER}/build/pdf.worker.min.js` },
            { script: `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${VER}/pdf.min.js`, worker: `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${VER}/pdf.worker.min.js` },
            { script: `https://unpkg.com/pdfjs-dist@${VER}/build/pdf.min.js`, worker: `https://unpkg.com/pdfjs-dist@${VER}/build/pdf.worker.min.js` },
        ];
        const picked = await loadScriptWithFallbacks(candidates.map(c=>({ script:c.script })));
        if(picked && window.pdfjsLib){ try{ window.pdfjsLib.GlobalWorkerOptions.workerSrc = candidates.find(c=> c.script===picked.script)?.worker || ''; }catch{} return true; }
        logDbg('pdf.js could not be loaded from any CDN');
        return false;
    }

    async function ensureTesseract(){
        if(window.Tesseract && window.Tesseract.recognize) return true;
        const VER = '4.1.1';
        const candidates = [
            { script: `https://cdn.jsdelivr.net/npm/tesseract.js@${VER}/dist/tesseract.min.js` },
            { script: `https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/${VER}/tesseract.min.js` },
            { script: `https://unpkg.com/tesseract.js@${VER}/dist/tesseract.min.js` },
        ];
        const picked = await loadScriptWithFallbacks(candidates);
        if(picked && window.Tesseract){ return true; }
        logDbg('tesseract.js could not be loaded from any CDN');
        return false;
    }

    async function ensurePako(){
        if(window.pako && window.pako.inflate) return true;
        const VER = '2.1.0';
        const candidates = [
            { script: `https://cdn.jsdelivr.net/npm/pako@${VER}/dist/pako.min.js` },
            { script: `https://cdnjs.cloudflare.com/ajax/libs/pako/${VER}/pako.min.js` },
            { script: `https://unpkg.com/pako@${VER}/dist/pako.min.js` },
        ];
        const picked = await loadScriptWithFallbacks(candidates);
        if(picked && window.pako){ return true; }
        logDbg('pako could not be loaded from any CDN');
        return false;
    }

    function decodeHexString(hex){
        const clean = (hex||'').replace(/[^0-9a-fA-F]/g,'');
        if(clean.length < 2) return '';
        const bytes = [];
        for(let i=0;i<clean.length;i+=2){ bytes.push(parseInt(clean.slice(i,i+2),16)); }
        // UTF-16BE BOM handling
        if(bytes.length>=2 && bytes[0]===0xFE && bytes[1]===0xFF){
            let s=''; for(let i=2;i+1<bytes.length;i+=2){ s += String.fromCharCode((bytes[i]<<8)|bytes[i+1]); }
            return s;
        }
        return String.fromCharCode(...bytes);
    }

    function extractLiteralStrings(s){
        const out=[]; let i=0; const n=s.length;
        while(i<n){
            if(s[i]==='('){
                i++; let buf=''; let depth=1; while(i<n && depth>0){
                    const ch = s[i++];
                    if(ch==='\\'){ // escape
                        const nxt = s[i++]||''; if(nxt){
                            if(/[0-7]/.test(nxt)){ // octal sequence \ddd
                                let oct=nxt; for(let k=0;k<2 && /[0-7]/.test(s[i]);k++){ oct+=s[i++]; }
                                buf += String.fromCharCode(parseInt(oct,8));
                            }else{ const map={n:'\n', r:'\r', t:'\t', b:'\b', f:'\f', '(':'(', ')':')', '\\':'\\'}; buf += (map[nxt]??nxt); }
                        }
                        continue;
                    } else if(ch==='('){ depth++; buf += ch; }
                    else if(ch===')'){ depth--; if(depth>0) buf += ch; }
                    else { buf += ch; }
                }
                if(buf) out.push(buf);
            } else { i++; }
        }
        return out;
    }

    async function pdfFallbackExtractStrings(ab){
        const limitChars = 400000; // cap like the primary path
        const u8 = new Uint8Array(ab);
        const latin1 = new TextDecoder('latin1');
        const txts = [];
        const whole = latin1.decode(u8);
        // Collect candidate streams
        let idx = 0; let streams = 0; let decompressed = 0;
        while((idx = whole.indexOf('stream', idx)) !== -1){
            // Find endstream and slice raw bytes; account for CRLF after 'stream'
            let start = idx + 6; if(whole[start]==='\r' && whole[start+1]==='\n') start+=2; else if(whole[start]==='\n') start+=1;
            const end = whole.indexOf('endstream', start);
            if(end === -1) break;
            const raw = u8.subarray(start, end);
            let contents='';
            // Try inflate; if fails, fall back to latin1 plain
            try{ if(await ensurePako()){ const infl = window.pako.inflate(raw); contents = latin1.decode(infl); decompressed++; } }catch{ contents = latin1.decode(raw); }
            streams++;
            // Extract literal strings and hex strings
            const lits = extractLiteralStrings(contents);
            lits.forEach(s=> { if(s) txts.push(s); });
            const hexRe = /<([0-9A-Fa-f\s]+)>\s*(?:T[Jj]|TJ|Tj)/g; let m;
            while((m = hexRe.exec(contents))){ const decoded = decodeHexString(m[1]); if(decoded) txts.push(decoded); }
            if(txts.join(' ').length > limitChars) break;
            idx = end+9;
        }
        // If nothing from streams, try the whole file for stray literal strings
        if(txts.length===0){ extractLiteralStrings(whole).forEach(s=> txts.push(s)); }
        const out = txts.join('\n').replace(/\s+/g,' ').replace(/\s*\n\s*/g,'\n').trim();
        logDbg('pdf fallback streams', streams, 'inflated', decompressed, 'chars', out.length);
        return out;
    }

    // Simple segmentation heuristics: detect Chapter/Section headings and build nested structure
    function segmentChapters(text){
        const lines = (text||'').split(/\r?\n/);
        const chapters = [];
        let cur = null;
        let sub = null;
        function pushSub(){ if(cur && sub){ cur.sub.push(sub); sub = null; } }
        function pushCur(){ if(cur){ pushSub(); chapters.push(cur); cur = null; } }
        for(const raw of lines){
            const line = raw.trim(); if(!line) continue;
            const chap = line.match(/^(Chapter\s+\d+\b\.?|^\d+\.)\s*(.+)$/i);
            const sect = line.match(/^(Section\s+\d+(?:\.\d+)*\b\.?|^\d+\.\d+)\s*(.+)$/i);
            if(chap){
                pushCur();
                cur = { title: chap[0].replace(/\.$/, ''), text: '', sub: [] };
                continue;
            }
            if(sect){
                if(!cur){ cur = { title: 'Chapter', text:'', sub: [] }; }
                pushSub();
                sub = { title: sect[0].replace(/\.$/, ''), text: '' };
                continue;
            }
            if(sub){ sub.text += (sub.text? '\n':'') + raw; }
            else if(cur){ cur.text += (cur.text? '\n':'') + raw; }
        }
        pushCur();
        // Fallback if nothing detected: chunk into ~8-12k char pieces to keep drag manageable
        if(chapters.length===0){
            const CHUNK = 10000; // ~10k chars per chunk
            if(!text || !text.trim()) return [{ title:'Document (empty)', text:'', sub:[] }];
            for(let i=0;i<text.length;i+=CHUNK){
                const slice = text.slice(i, i+CHUNK);
                chapters.push({ title: `Segment ${Math.floor(i/CHUNK)+1}`, text: slice, sub:[] });
            }
        }
        return chapters;
    }

    async function ensureExtractors(){
        // Reuse existing extractors loaded by AI file gen block
        return true;
    }

    async function extractTextFromFile(file){
        // Reuse the AI file gen extractors to avoid code duplication
        await ensureExtractors();
        // Minimal inline extraction using the same libraries loaded on demand there
        const name = file?.name||'file'; const lower = name.toLowerCase();
        logDbg('extract start', name);
        if(/\.txt$/i.test(lower)) { const t = await file.text(); logDbg('txt bytes', t.length); return t; }
        if(/\.docx$/i.test(lower)){
            const ab = await file.arrayBuffer();
            try{
                if(!(window.mammoth && window.mammoth.convertToHtml)){
                    await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src='https://unpkg.com/mammoth@1.6.0/mammoth.browser.min.js'; s.onload=res; s.onerror=()=>rej(new Error('mammoth load failed')); document.head.appendChild(s); });
                }
                const res = await window.mammoth.convertToHtml({ arrayBuffer: ab });
                const html = (res && res.value) || '';
                const out = html.replace(/<[^>]+>/g,' ').replace(/\s+/g,' ').replace(/\s*\n\s*/g,'\n').trim();
                logDbg('docx mammoth chars', out.length);
                return out;
            }catch{
                if(!window.JSZip){ await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js'; s.onload=res; s.onerror=()=>rej(new Error('jszip load failed')); document.head.appendChild(s); }); }
                const zip = await window.JSZip.loadAsync(ab);
                const entry = zip.file('word/document.xml');
                const xml = await entry.async('string');
                const out = xml.replace(/<w:p[^>]*>/g, '\n').replace(/<w:tab\b[^>]*\/>/g,' ').replace(/<w:t[^>]*>(.*?)<\/w:t>/g,'$1').replace(/<[^>]+>/g,' ').replace(/\s+/g,' ').trim();
                logDbg('docx xml chars', out.length);
                return out;
            }
        }
        if(/\.pdf$/i.test(lower)){
            const ab = await file.arrayBuffer();
            let havePdfJs = await ensurePdfJs();
            if(havePdfJs && window.pdfjsLib && window.pdfjsLib.getDocument){
                try{
                    const pdf = await window.pdfjsLib.getDocument({ data: ab, disableFontFace:true, useSystemFonts:true }).promise; const parts=[]; logDbg('pdf pages', pdf.numPages);
                    let extractedChars = 0; const SOFT_LIMIT = 400000; // ~400k chars cap for memory/perf
                    for(let p=1;p<=pdf.numPages;p++){
                        const page = await pdf.getPage(p);
                        let pageText = '';
                        try{
                            const c = await page.getTextContent({ normalizeWhitespace:true, disableCombineTextItems:false });
                            pageText = c.items.map(it=> it.str).join(' ').replace(/\s+/g,' ').trim();
                        }catch(e){ logDbg('pdf textContent failed page', p, e?.message||e); }
                        if(pageText) { parts.push(pageText); extractedChars += pageText.length; }
                        if(extractedChars > SOFT_LIMIT) { logDbg('pdf soft limit reached'); break; }
                        if(p % 10 === 0) await new Promise(r=> setTimeout(r, 0));
                    }
                    let out = parts.join('\n');
                    logDbg('pdf chars (text extraction)', out.length);
                    const wantOcr = !!document.getElementById('tbOcrToggle')?.checked;
                    const ocrMax = parseInt(document.getElementById('tbOcrMax')?.value||'8',10) || 8;
                    if(out.length < 800 && wantOcr){
                        logDbg('pdf appears image-only, starting OCR up to', ocrMax, 'pages');
                        const ok = await ensureTesseract();
                        if(ok){
                            const ocrParts=[]; const dpi = 160;
                            for(let p=1; p<=Math.min(pdf.numPages, ocrMax); p++){
                                try{
                                    const page = await pdf.getPage(p);
                                    const viewport = page.getViewport({ scale: 1.5 });
                                    const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d', { willReadFrequently:true });
                                    canvas.width = Math.floor(viewport.width * (dpi/96));
                                    canvas.height = Math.floor(viewport.height * (dpi/96));
                                    await page.render({ canvasContext: ctx, viewport }).promise;
                                    const dataUrl = canvas.toDataURL('image/png');
                                    const res = await window.Tesseract.recognize(dataUrl, 'eng');
                                    const txt = (res && res.data && res.data.text) ? res.data.text : '';
                                    if(txt && txt.trim()) ocrParts.push(txt.trim());
                                    canvas.width = canvas.height = 0;
                                }catch(e){ logDbg('ocr page failed', p, e?.message||e); }
                                await new Promise(r=> setTimeout(r, 0));
                            }
                            const ocrText = ocrParts.join('\n');
                            logDbg('ocr chars', ocrText.length);
                            if(ocrText.length > out.length) out = ocrText;
                        } else {
                            logDbg('OCR skipped: tesseract unavailable');
                        }
                    }
                    return out;
                }catch(e){ logDbg('pdf.js extract failed, falling back', e?.message||e); }
            }
            // Fallback path: parse strings directly from PDF content streams
            const fallbackText = await pdfFallbackExtractStrings(ab);
            if(fallbackText && fallbackText.length){ return fallbackText; }
            logDbg('pdf fallback got no text');
            return '';
        }
        if(/\.pptx$/i.test(lower)){
            if(!window.JSZip){ await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js'; s.onload=res; s.onerror=()=>rej(new Error('jszip load failed')); document.head.appendChild(s); }); }
            const ab = await file.arrayBuffer(); const zip = await window.JSZip.loadAsync(ab);
            const names = Object.keys(zip.files).filter(n=>/^ppt\/slides\/slide\d+\.xml$/i.test(n)).sort((a,b)=>parseInt(a.match(/slide(\d+)/i)[1])-parseInt(b.match(/slide(\d+)/i)[1])); logDbg('pptx slides', names.length);
            const chunks=[]; for(const n of names){ const xml = await zip.file(n).async('string'); const t = xml.replace(/<a:br\s*\/>/gi,'\n').replace(/<a:p[^>]*>/gi,'\n').replace(/<a:t[^>]*>([\s\S]*?)<\/a:t>/gi,'$1').replace(/<[^>]+>/g,' ').replace(/\s+/g,' ').trim(); if(t) chunks.push(t); if(chunks.join(' ').length>200000) break; }
            const out = chunks.join('\n\n'); logDbg('pptx chars', out.length); return out;
        }
        const t = await file.text(); logDbg('fallback text chars', t.length); return t;
    }

    // --- Lightweight TOC scanner (uses pdf.js if available) ---
    const tbScanBtn = $('tbScanBtn'); const tbTocTree = $('tbTocTree'); const tbLog = $('tbLog'); const tbMetaName = $('tbMetaName'); const tbMetaPages = $('tbMetaPages'); const tbMetaBytes = $('tbMetaBytes');

    function tbLogLine(...a){ try{ if(tbLog) tbLog.textContent = (new Date()).toLocaleTimeString() + ' ' + a.join(' ') + '\n' + tbLog.textContent; else console.log(...a); }catch(e){ console.log(...a); } }

    // sanitize title text for display (remove control/unprintable chars)
    function tbSanitizeTitle(s){ if(!s && s !== 0) return ''; try{ return String(s).replace(/[\x00-\x1F\x7F-\x9F\uFFFD]/g,'').replace(/[\\/:*?"<>|]/g,'').replace(/\s+/g,' ').trim().slice(0,180); }catch(e){ return String(s||'').trim(); } }

    function tbFlattenOutline(outl){
        const arr = [];
        function walk(items, depth){
            if(!items) return;
            for(const it of items){
                const rawTitle = it && it.title ? it.title : 'Untitled';
                const node = { title: tbSanitizeTitle(rawTitle), raw: it, depth };
                arr.push(node);
                if(it.items && it.items.length) walk(it.items, depth+1);
            }
        }
        walk(outl, 0);
        return arr;
    }

    function tbDetectChapterDepth(arr){ if(!arr || !arr.length) return 0; const score={}; const reNum=/^\s*(?:Chapter\b|Ch\.|\d+[.):]|[IVXLCDM]+[.):]|\d+\s)/i; for(const it of arr){ const d=it.depth||0; score[d]=(score[d]||0)+(reNum.test(it.title)?1:0); } let best=-1,bd=0; for(const k in score){ if(score[k]>best){ best=score[k]; bd=parseInt(k,10); } } return best>0?bd:0; }

    async function tbResolveDestToPageIndex(pdf, dest){ try{ if(!dest) return null; let resolved=null; try{ if(typeof dest === 'string') resolved = await pdf.getDestination(dest); else if(Array.isArray(dest)) resolved = dest; else if(dest && dest.getArray) resolved = await dest.getArray(); }catch{} if(!resolved && dest && dest.num) resolved=[dest]; if(!resolved) return null; const ref = resolved[0]; if(!ref) return null; const idx = await pdf.getPageIndex(ref); return idx; }catch(e){ tbLogLine('resolve fail', e?.message||e); return null; } }

    async function tbExtractPageText(pdf, pnum){ try{ const page = await pdf.getPage(pnum); const txt = await page.getTextContent({ normalizeWhitespace:true, disableCombineTextItems:false, includeMarkedContent:true }); const s = txt.items.map(it=> it.str||'').join(' ').replace(/\s+/g,' ').trim(); return s; }catch(e){ tbLogLine('page extract failed', pnum, e?.message||e); return ''; } }

    function tbComputeChapterRanges(entries, chapterDepth, numPages){ const chapters = entries.filter(e=> Number.isFinite(e.page) && e.depth===chapterDepth).sort((a,b)=>a.page-b.page); for(let i=0;i<chapters.length;i++){ const start=chapters[i].page; const end=(i<chapters.length-1)? chapters[i+1].page-1 : numPages; chapters[i].startPage=Math.max(1,start); chapters[i].endPage=Math.min(numPages,end); } return chapters; }

    async function tbBuildPageLengthCache(pdf, ranges){ if(!ranges || !ranges.length) return {}; const minP = Math.min(...ranges.map(r=>r.startPage)); const maxP = Math.max(...ranges.map(r=>r.endPage)); const cache={}; for(let p=minP;p<=maxP;p++){ try{ const t = await tbExtractPageText(pdf,p); cache[p]=t.length; }catch{ cache[p]=0; } await new Promise(r=>setTimeout(r,0)); } return cache; }

    function tbSumCharsFromCache(cache,start,end,limit){ let total=0; for(let p=start;p<=end;p++){ const len=cache[p]||0; if(limit && len>limit) continue; total+=len; } return total; }

    function tbRenderToc(arr, startDepth){ if(!tbTocTree) return; if(!arr||!arr.length){ tbTocTree.innerHTML='<div class="hint">(no TOC)</div>'; return; } const root=document.createElement('div'); root.setAttribute('role','tree'); let lastGroup=null; let groupEl = null; arr.forEach((it,idx)=>{ const d=it.depth; const indentBase = (startDepth!=null) ? Math.max(0, d-startDepth) : d; if(startDepth!=null && d===startDepth && lastGroup !== it.startPage){ // start a new group
            groupEl = document.createElement('div'); groupEl.setAttribute('role','group'); groupEl.className='group-wrapper'; const sep=document.createElement('div'); sep.className='group-sep'; groupEl.appendChild(sep); root.appendChild(groupEl); lastGroup = it.startPage; }
        const el=document.createElement('div'); el.className='tb-chapter'; el.style.paddingLeft=(indentBase*18)+'px'; el.setAttribute('role','treeitem'); const left=document.createElement('div'); left.textContent = `${String(idx+1).padStart(2,'0')} ${it.title}`; const meta=document.createElement('div'); meta.className='tb-meta'; meta.textContent = `pages ${it.startPage||'?'}-${it.endPage||'?'} • ${it.charCount||0} chars`; el.appendChild(left); el.appendChild(meta); if(groupEl) groupEl.appendChild(el); else root.appendChild(el); }); tbTocTree.innerHTML=''; tbTocTree.appendChild(root); }

    // Scan TOC for selected file (first selected file used)
    tbScanBtn?.addEventListener('click', async ()=>{
        const f = (tbFiles && tbFiles.files && tbFiles.files[0]) || null; if(!f){ setStatus('No file selected to scan.', true); return; }
        try{
            tbScanBtn.disabled = true; tbLogLine('Loading file', f.name);
            const ab = await f.arrayBuffer(); tbMetaName.textContent = f.name; tbMetaBytes.textContent = (f.size/1024/1024).toFixed(2)+' MB';
            const ok = await ensurePdfJs(); if(!ok){ tbLogLine('pdf.js not available'); tbScanBtn.disabled=false; return; }
            const pdf = await window.pdfjsLib.getDocument({ data: ab }).promise; tbMetaPages.textContent = pdf.numPages; tbLogLine('PDF loaded pages', pdf.numPages);
            const outline = await pdf.getOutline(); if(!outline || !outline.length){ tbLogLine('No outline/bookmarks found'); tbRenderToc([], null); tbScanBtn.disabled=false; return; }
            const flat = tbFlattenOutline(outline); tbLogLine('outline entries', flat.length);
            const detected = (Array.isArray(outline) && outline.some(it=> Array.isArray(it.items) && it.items.length>0)) ? 1 : tbDetectChapterDepth(flat);
            tbLogLine('detected chapter depth', detected);
            // resolve dests
            for(let i=0;i<flat.length;i++){ const it=flat[i]; try{ const pageIndex = await tbResolveDestToPageIndex(pdf, it.raw.dest || it.raw.destref || it.raw.a || it.raw.dest); it.page = pageIndex!=null ? pageIndex+1 : null; tbLogLine('resolved', it.title, '->', it.page); }catch(e){ it.page = null; } }
            const withPage = flat.filter(x=>Number.isFinite(x.page)).sort((a,b)=>a.page-b.page); const withoutPage = flat.filter(x=>!Number.isFinite(x.page)); const sorted = withPage.concat(withoutPage);
            const chapterEntries = tbComputeChapterRanges(sorted, detected, pdf.numPages);
            for(const e of sorted){ if(e.depth===detected){ const found = chapterEntries.find(c=> c===e || (c.title===e.title && c.page===e.page)); if(found){ e.startPage=found.startPage; e.endPage=found.endPage; } } else { e.startPage = e.page || 1; e.endPage = e.page || e.startPage; } }
            window.tbFullToc = sorted.map((s,idx)=> ({ uid: idx, order: idx+1, title: s.title, depth: s.depth, startPage: s.startPage, endPage: s.endPage, page: s.page }));
            // quick count
            const chaptersForCount = window.tbFullToc.filter(s=> s.depth===detected && Number.isFinite(s.startPage) && Number.isFinite(s.endPage));
            const cache = await tbBuildPageLengthCache(pdf, chaptersForCount);
            for(const s of window.tbFullToc){ if(s.depth===detected && s.startPage && s.endPage){ s.charCount = tbSumCharsFromCache(cache, s.startPage, s.endPage, null); } else { s.charCount = s.charCount||0; } }
            const flattened = window.tbFullToc.map(s=> ({ uid: s.uid, order: s.order, title: s.title, depth: s.depth, startPage: s.startPage, endPage: s.endPage, page: s.page, charCount: s.charCount }));
            const ds = parseInt($('depthStart')?.value||'0',10); tbRenderToc(flattened, Number.isFinite(ds)?ds:0);
            tbLogLine('scan complete');
        }catch(e){ tbLogLine('scan failed', e?.message||e); }
        tbScanBtn.disabled = false;
    });


    function renderTree(){
        const lib = loadLib();
    if(!lib.length){ tbTree.innerHTML = '<div class="hint">No saved content added yet.</div>'; return; }
        function nodeHtml(id, label, kind){ return `<span class="tb-chip" draggable="true" data-id="${id}" data-kind="${kind}">${label}</span>`; }
        tbTree.innerHTML = lib.map((book, bi)=>{
            const chHtml = (book.chapters||[]).map((ch, ci)=>{
                const subHtml = (ch.sub||[]).map((s, si)=> '<div class="tb-sub" data-path="'+bi+':'+ci+':'+si+'"><div>'+nodeHtml(bi+':'+ci+':'+si, s.title||('Section '+(ci+1)+'.'+(si+1)), 'sub')+'</div><div class="tb-meta">'+((s.text||'').length)+' chars</div></div>').join('');
                return '<div class="tb-chapter" data-path="'+bi+':'+ci+'"><div>'+nodeHtml(bi+':'+ci, ch.title||('Chapter '+(ci+1)), 'chapter')+'</div><div class="tb-meta">'+((ch.text||'').length)+' chars '+(subHtml? (' • '+((ch.sub||[]).length)+' sub') : '')+'</div>'+(subHtml? ('<div class="tb-chapters ml-12 mt-6">'+subHtml+'</div>') : '')+'</div>';
            }).join('');
            // if this entry is a pointer to IndexedDB, show a placeholder and resolve asynchronously
            const bookTitleSafe = book.idbRef ? (book.title || ('Book '+(bi+1)+' (saved)')) : (book.title||('Book '+(bi+1)));
            // estimate size in bytes for display
            let estBytes = null;
            try{
                if(book.idbRef && book.chapters && book.chapters.length){
                    estBytes = book.chapters.reduce((acc,c)=> acc + ((c && (c.text||c.fullText||c.snippet)||'').length || 0), 0);
                } else if(book.text){ estBytes = (book.text||'').length; }
            }catch(e){ estBytes = null; }
            const sizeBadge = estBytes==null ? '' : (' • '+(estBytes/1024).toFixed(1)+' KB');
            const metaText = book.idbRef ? ('Stored (indexedDB id '+book.idbRef+') • '+((book.chapters||[]).length)+' chapters'+sizeBadge) : (((book.text||'').length)+' chars • '+((book.chapters||[]).length)+' chapters'+sizeBadge);
            const html = '<div class="tb-book" data-book="'+bi+'"><div class="tb-head"><div class="tb-title" data-book-idx="'+bi+'">'+bookTitleSafe+'</div><div class="tb-actions"><span class="tb-meta">'+metaText+'</span></div></div>' + (chHtml ? ('<div class="tb-chapters mt-6">'+chHtml+'</div>') : '') + '</div>';
            return html;
        }).join('');

        // Drag payload wiring
        tbTree.querySelectorAll('.tb-chip').forEach(ch=>{
            ch.addEventListener('dragstart', (e)=>{
                const id = ch.getAttribute('data-id'); const [bi, ci, si] = id.split(':').map(n=>parseInt(n,10));
                const lib2 = loadLib(); const book = lib2[bi]; if(!book) return;
                let title='', text='';
                if(si!=null && isFinite(si)) { const s = book?.chapters?.[ci]?.sub?.[si]; title = s?.title||'Section'; text = s?.text||''; }
                else if(ci!=null && isFinite(ci)) { const c = book?.chapters?.[ci]; title = c?.title||'Chapter'; text = [c?.text||'', ...(c?.sub||[]).map(x=>x.text||'')].filter(Boolean).join('\n\n'); }
                else {
                    // top-level book: if it's an idbRef pointer, try to fetch the full record synchronously via idbGetBook
                    if(book.idbRef){ title = book.title || 'Book'; text = ''; try{ idbGetBook(book.idbRef).then(full=>{ const payload = JSON.stringify({ title: full.title||book.title, text: (full.payload && full.payload.chapters ? (full.payload.chapters||[]).map(ch=> ch.text || ch.fullText || ch.snippet || '').join('\n\n') : ((full.chapters||[]).map(ch=> ch.text || ch.fullText || ch.snippet || '').join('\n\n'))) }); e.dataTransfer.setData('application/json', payload); }); }catch(e){ log('idbGetBook for drag failed', e?.message||e); } }
                    title = book.title||'Book';
                }
                const payload = JSON.stringify({ title, text });
                e.dataTransfer.setData('application/json', payload);
                e.dataTransfer.effectAllowed = 'copy';
            }); // end addEventListener('dragstart')
        }); // end forEach('.tb-chip')

        // Resolve idbRef titles asynchronously so UI shows friendly names
        (async ()=>{
            const nodes = tbTree.querySelectorAll('[data-book-idx]');
            for(const n of nodes){
                const idx = parseInt(n.getAttribute('data-book-idx'), 10);
                const lib2 = loadLib(); const book = lib2[idx];
                if(book && book.idbRef){ try{ const full = await idbGetBook(book.idbRef); if(full && full.title) n.textContent = full.title + ' (saved)'; }catch(e){ /* ignore */ } }
            }
        })();
    }
    // allow other parts of the page to refresh the saved textbook UI
    try{ window.refreshTextbookLibrary = window.refreshTextbookLibrary || renderTree; }catch(e){}

    // Upload handling: only record selection; processing happens on button click
    tbFiles?.addEventListener('change', ()=>{
        const files = Array.from(tbFiles.files||[]);
        tbName && (tbName.textContent = files.length? `${files.length} file(s)` : 'No files selected');
        if(!files.length){ setStatus(''); return; }
        logDbg('selected', files.map(f=>f.name));
        setStatus('Ready. Click “Process selected” to begin.');
    });

    // Process selected files on demand
    tbProcess?.addEventListener('click', async ()=>{
        const files = Array.from(tbFiles?.files||[]);
        if(!files.length){ setStatus('No files selected.', true); return; }
        tbProcess.disabled = true; const origLabel = tbProcess.textContent; tbProcess.textContent = 'Processing…';
        setStatus('Extracting…'); logDbg('process begin', files.map(f=>f.name));
        const lib = loadLib(); let added = 0;
        for(let i=0;i<files.length;i++){
            const f = files[i];
            try{
                setStatus(`(${i+1}/${files.length}) ${f.name}…`); logDbg('processing', f.name, f.type||'');
                const text = await extractTextFromFile(f);
                const chapters = segmentChapters(text);
                lib.push({ title: f.name.replace(/\.[^.]+$/, ''), text, chapters });
                added++;
            }catch(e){ console.warn('extract failed', f?.name, e); logDbg('extract failed', f?.name, e?.message||e); }
        }
        const saved = saveLib(lib);
        renderTree();
        setStatus(added? 'Done.' : 'No content extracted. Try another file.', !added);
        tbProcess.textContent = origLabel; tbProcess.disabled = false;
    });

    tbClear?.addEventListener('click', ()=>{ if(confirm('Clear content library?')){ saveLib([]); renderTree(); setStatus('Cleared.'); } });

    // Drop integration: Validate Answers and Generate MCQ
    function makeDropzone(el, onDrop){ if(!el) return; ['dragenter','dragover'].forEach(ev=> el.addEventListener(ev, (e)=>{ e.preventDefault(); el.classList.add('hover'); e.dataTransfer.dropEffect='copy'; })); ['dragleave','dragend','drop'].forEach(ev=> el.addEventListener(ev, ()=> el.classList.remove('hover'))); el.addEventListener('drop', (e)=>{ e.preventDefault(); try{ const json = e.dataTransfer.getData('application/json'); if(!json) return; const data = JSON.parse(json); onDrop && onDrop(data); }catch{} }); }

    // Validate Answers dropzone (under output/actions area)
    (function(){
        const actions = document.getElementById('aiValidateActions');
        if(!actions || actions.dataset.tbDropWired==='1') return; actions.dataset.tbDropWired='1';
    const dz = document.createElement('div'); dz.id='tbDropValidate'; dz.className='dropzone'; dz.textContent='Drop content chapters here to supplement Validate Answers'; actions.appendChild(dz);
        const ctx = { pieces: [] };
        makeDropzone(dz, (data)=>{
            if(!data || !data.text) return; ctx.pieces.push(data); dz.textContent = `Attached ${ctx.pieces.length} chapter(s).`;
        });
        // Hook the Validate button to include context
        const vBtn = document.getElementById('aiLikeBtn2');
        if(vBtn && !vBtn.dataset.tbAug){
            vBtn.dataset.tbAug='1';
            const origHandler = vBtn.onclick; // not used in current wiring (addEventListener used)
            // Monkey-patch the generator to read extra context in prompt build
            const originalFetch = window.GoogleGenerativeAI;
            // Instead of patching SDK, patch the click handler path by intercepting prompt creation via a global flag
            window.__tbValidateCtx = ctx;
        }
        // Patch prompt usage inside validate block by wrapping model.generateContent
        const wrapGen = async (key, promptBuilder)=>{
            const AI = window.GoogleGenerativeAI; const client = new AI(key); const model = client.getGenerativeModel({ model: 'gemini-2.5-flash' });
            const extra = (window.__tbValidateCtx?.pieces||[]).map(p=> p.text).join('\n\n');
            const prompt = promptBuilder(extra);
            const resp = await model.generateContent({ contents: [{ role:'user', parts:[{ text: prompt }] }] });
            return (await resp?.response?.text?.())?.trim();
        };
        // Expose for validate module to call
        window.__tbWrapGen = wrapGen;
    })();

    // Generate MCQ drop target: attach to the AI file panel status area
    (function(){
        const status = document.getElementById('aiFileStatus'); if(!status || status.dataset.tbDropWired==='1') return; status.dataset.tbDropWired='1';
    const dz = document.createElement('div'); dz.id='tbDropGenerate'; dz.className='dropzone mt-8'; dz.textContent='Drop content chapters here to generate MCQs'; status.parentElement?.appendChild(dz);
        const ctx = { pieces: [] };
        makeDropzone(dz, (data)=>{ if(!data || !data.text) return; ctx.pieces.push(data); dz.textContent = `Attached ${ctx.pieces.length} chapter(s).`; });
        window.__tbGenCtx = ctx;
    })();

    // Wire the AI file chooser's drop element (created in the choose-file parent) to the same generator context
    (function(){
        try{
            const dropEl = document.getElementById('aiFileTbDrop');
            if(!dropEl) return;
            // Ensure global gen context exists
            window.__tbGenCtx = window.__tbGenCtx || { pieces: [] };
            makeDropzone(dropEl, (data)=>{
                if(!data || !data.text) return;
                window.__tbGenCtx.pieces.push(data);
                dropEl.textContent = `Attached ${window.__tbGenCtx.pieces.length} chapter(s)`;
                // mirror to existing status dropzone if present
                const statusDz = document.getElementById('tbDropGenerate'); if(statusDz) statusDz.textContent = dropEl.textContent;
            });
        }catch(e){ console.log('aiFileTbDrop wiring failed', e); }
    })();

    // Initial render
    renderTree();
})();
</script>

        <!-- === AI Like-Question Generator (start-only) === -->
        <section id="ai-likeq" class="card pad ai-likeq">
            <div class="flex col center gap-8">
                <div class="key-badge missing" id="globalKeyBadge" title="Shows whether a Gemini API key is present"><span class="dot"></span><span class="hint">No key set</span></div>
                <div class="flex center gap-12">
                    <button id="aiLikeBtn" class="btn primary btn-wide" disabled>Generate Like-Questions (AI)</button>
                </div>
            </div>
            <div class="hint mt-8 text-center">
                Carefully replaces your pasted set with new, <em>format-identical</em> items. Uses conservative
                rewriting; keeps same count, structure, and single correct answer per question.
            </div>
            <div id="aiLikeStatus" class="hint mt-8 text-center"></div>
        </section>

        <!-- === AI Caveat + Credit (paste near the end of your main container) === -->
        <section id="ai-disclaimer" class="card pad ai-legal">
            <h3 class="mt-0 mb-8">About AI Elements (Gemini 2.5 Flash)</h3>
            <p class="muted">
                The rationale shown in the panel is generated by Google’s Gemini model. While useful for learning,
                it may occasionally misidentify the correct option or provide incomplete justification. Reasons include:
            </p>
            <ul class="muted">
                <li><strong>Non-determinism & sampling:</strong> temperature/top-p sampling can yield different
                    rationales across runs, including confident but incorrect claims.</li>
                <li><strong>Prompt/format drift:</strong> if the question/options aren’t parsed exactly as intended,
                    the model may reason over the wrong input.</li>
                <li><strong>Hallucinations & shortcut bias:</strong> large models sometimes invent facts or over-rely
                    on surface cues rather than domain-accurate reasoning.</li>
                <li><strong>Answer-key disagreement:</strong> if your key or parsing is off, the model could be “right”
                    while disagreeing with the displayed key (or vice-versa).</li>
            </ul>

            <p class="muted mt-10">
                For guidance on safety, evaluation, and reliability, see:
                <a href="https://ai.google.dev/gemini-api/docs" target="_blank" rel="noopener">API Docs</a>
            </p>

            <!-- Gemini status indicator: shows remote/ local API status (green/yellow/red) -->
            <div id="geminiStatus" class="muted mt-8" style="display:flex;align-items:center;gap:10px">
                <span id="geminiStatusDot" class="status-dot status-unknown" aria-hidden="true"></span>
                <div id="geminiStatusLabel">Gemini status: <strong id="geminiStatusText">unknown</strong></div>
                <a id="geminiStatusLink" href="https://aistudio.google.com/status" target="_blank" rel="noopener" class="muted" style="margin-left:6px; text-decoration:underline;">status</a>
            </div>

            <div class="ai-credit">
                <!-- credit moved to page header and boot overlay -->
            </div>
        </section>

    <!-- === Terms of Use Box (placed under 'About AI Elements') === -->
    <section id="tos-box" class="card pad tos-box">
        <h3 class="mt-0 mb-8">Terms of Use & Disclaimer</h3>
        <div class="muted">
            <p>Effective Date: October 20, 2025 — Version: 1.0</p>
            <p>This hosted demo runs entirely in your browser. Acceptance of the full Terms of Use is required to use AI features. Click "View TOS" to read the full Terms.</p>
        </div>
        <div class="flex gap-8 mt-8">
            <span id="tosBoxState" class="muted">Signed: <strong id="tosStateBox">Unknown</strong></span>
            <div class="right">
                <button id="tosBoxView" class="btn small">View TOS</button>
            </div>
        </div>
    </section>
    <script>
    (function(){
        const dot = document.getElementById('geminiStatusDot');
        const label = document.getElementById('geminiStatusText');
        const link = document.getElementById('geminiStatusLink');

        function setStatus(kind, text){
            try{
                dot.className = 'status-dot';
                if(kind === 'operational') dot.classList.add('status-operational');
                else if(kind === 'degraded') dot.classList.add('status-degraded');
                else if(kind === 'down') dot.classList.add('status-down');
                else dot.classList.add('status-unknown');
                label.textContent = text || kind || 'unknown';
            }catch(e){}
        }

        async function probeRemoteStatus(){
            // Try to fetch the Google AI status page (public endpoint)
            // The provided site is https://aistudio.google.com/status — try a JSON endpoint fallback if available
            try{
                const url = 'https://aistudio.google.com/status';
                const r = await fetch(url, { cache: 'no-store', mode: 'cors' });
                if(!r.ok) return { kind: 'unknown', text: 'remote unreachable' };
                const txt = await r.text();
                // Heuristic: look for 'operational' or 'degraded' keywords in the page text
                const lower = txt.toLowerCase();
                if(lower.includes('operational') || lower.includes('all systems operational')) return { kind: 'operational', text: 'remote: operational' };
                if(lower.includes('degraded') || lower.includes('partial outage') || lower.includes('degradation')) return { kind: 'degraded', text: 'remote: degraded' };
                if(lower.includes('outage') || lower.includes('down') || lower.includes('major outage')) return { kind: 'down', text: 'remote: outage' };
                return { kind: 'unknown', text: 'remote: status unknown' };
            }catch(e){ return { kind: 'unknown', text: 'remote: fetch failed' }; }
        }

        function checkLocalStatus(){
            try{
                const key = (document.getElementById('globalGemKey') && document.getElementById('globalGemKey').value) || localStorage.getItem('gemini.key');
                const enabled = !!(document.getElementById('globalGemEnable') && document.getElementById('globalGemEnable').checked);
                // Presence of a key + enabled checkbox counts as local operational; presence only of key is degraded
                if(enabled && key) return { kind: 'operational', text: 'local: enabled' };
                if(key) return { kind: 'degraded', text: 'local: key present' };
                return { kind: 'unknown', text: 'local: no key' };
            }catch(e){ return { kind: 'unknown', text: 'local: unknown' }; }
        }

        async function updateGeminiStatus(){
            try{
                setStatus('unknown','checking...');
                const [remote, local] = await Promise.allSettled([probeRemoteStatus(), Promise.resolve(checkLocalStatus())]);
                let remoteRes = { kind: 'unknown', text: '' };
                if(remote.status === 'fulfilled' && remote.value) remoteRes = remote.value;
                let localRes = { kind: 'unknown', text: '' };
                if(local.status === 'fulfilled' && local.value) localRes = local.value;

                // Prioritize remote outage signals (down => red). If remote degraded, show degraded unless local is down.
                if(remoteRes.kind === 'down') { setStatus('down', remoteRes.text + (localRes.text ? ' • ' + localRes.text : '')); return; }
                if(remoteRes.kind === 'degraded') { setStatus('degraded', remoteRes.text + (localRes.text ? ' • ' + localRes.text : '')); return; }
                // If remote looks fine or unknown, use local signal
                if(localRes.kind === 'operational') { setStatus('operational', localRes.text + (remoteRes.text ? ' • ' + remoteRes.text : '')); return; }
                if(localRes.kind === 'degraded') { setStatus('degraded', localRes.text + (remoteRes.text ? ' • ' + remoteRes.text : '')); return; }
                // default
                setStatus(remoteRes.kind || localRes.kind || 'unknown', (remoteRes.text || '') + (localRes.text ? ' • ' + localRes.text : '') || 'unknown');
            }catch(e){ setStatus('unknown','error'); }
        }

        // Run on load and periodically
        try{ updateGeminiStatus(); setInterval(updateGeminiStatus, 60 * 1000); }catch(e){}

        // Also update when key/enable inputs change
        try{ document.getElementById('globalGemKey')?.addEventListener('input', updateGeminiStatus); document.getElementById('globalGemEnable')?.addEventListener('change', updateGeminiStatus); }catch(e){}
    })();
    </script>

    <!-- Overlay used when TOS not accepted to block/blur the UI; contains centered unlock panel -->
    <div id="tosOverlay" class="tos-overlay hidden" aria-hidden="true">
        <div class="tos-unlock-panel" role="dialog" aria-label="Accept Terms to access site">
            <p class="tos-unlock-text">This site is restricted until you accept the Terms of Use. You can view and accept the Terms to unlock access.</p>
            <div class="tos-unlock-actions">
                <button id="tosUnlockBtn" class="btn primary">View & Sign TOS</button>
            </div>
        </div>
    </div>

        <!-- === style touch-ups (can live in your existing <style> block) === -->
        <style>

            .ai-legal {
                margin-top: 12px;
            }

            .ai-legal .muted {
                color: var(--muted, #9fb0c5);
                font-size: 12px;
            }

            .ai-legal a {
                color: var(--brand, #6aa9ff);
                text-decoration: underline;
            }

            .ai-legal a:focus-visible {
                outline: none;
                box-shadow: 0 0 0 2px rgba(106, 169, 255, .35);
                border-radius: 4px;
            }

            .ai-divider {
                border: 0;
                height: 1px;
                margin: 6px 0; /* reduced vertical gap */
                background: rgba(160, 180, 220, .18);
            }

            .ai-credit {
                font-size: 13px;
                color: var(--ink, #e9f0f7);
                opacity: .85;
            }

            .ai-likeq {
                margin-top: 12px;
            }

            .ai-likeq {
                margin-bottom: 12px;
            }

            .ai-likeq .hint {
                color: var(--muted, #9fb0c5);
            }
        </style>

        <style>
            /* Gemini status dot: green (operational), yellow (degraded), red (outage), gray unknown */
            .status-dot{ display:inline-block; width:12px; height:12px; border-radius:50%; border:1px solid rgba(0,0,0,0.08); box-shadow: 0 0 6px rgba(0,0,0,0.12); }
            .status-operational{ background: #4dd17a; box-shadow: 0 0 10px rgba(77,209,122,0.18); }
            .status-degraded{ background: #ffd166; box-shadow: 0 0 10px rgba(255,209,102,0.12); }
            .status-down{ background: #ff6b6b; box-shadow: 0 0 10px rgba(255,107,107,0.18); }
            .status-unknown{ background: #9fb0c5; box-shadow: none; }
            #geminiStatusLabel{ font-size:13px; color:var(--muted,#9fb0c5); }
            #geminiStatusText{ color:var(--ink,#e9f0f7); }
        </style>

        <style>
        /* Compact TOS box: reduced vertical footprint while preserving content and controls */
        .tos-box{
            max-width: none;
            width: 100%;
            box-sizing: border-box;
            margin-top: 8px;
            padding: 8px 12px; /* tighter padding */
            border-radius: 12px;
        }
        /* Tighter text sizing and spacing for the compact card */
        .tos-box .muted, .tos-box p, .tos-box span { font-size: 11px; color: var(--muted, #9fb0c5); line-height:1.3; margin:0 }
        .tos-box h3{ font-size: 14px; margin: 0 0 6px 0; font-weight:700 }
        /* Reduce gap between state and actions and align vertically */
        .tos-box .flex { gap: 6px }
        .tos-box .right { margin-left: auto }
        .tos-box #tosBoxState { font-size: 11px }
        /* Make the View TOS button slightly smaller and tighter */
        .tos-box .btn.small{ padding: 6px 8px; font-size: 12px; border-radius: 8px }
        /* Responsive adjustments: keep compact spacing on narrow screens */
        @media (max-width: 960px){ .tos-box{ width: calc(100% - 24px); margin-left:12px; margin-right:12px; } }
        
        /* Compact overlay unlock panel */
        .tos-unlock-panel{ padding: 10px 12px; max-width: 520px; border-radius: 10px }
        .tos-unlock-text{ font-size:13px; margin:0 0 8px }
        .tos-unlock-actions .btn.primary{ padding: 8px 10px; font-size:13px }
        </style>

    </div>

    <!-- Reset to Main Menu (shown only during quiz) -->
    <div id="resetBar" class="mt-12 hidden text-center">
        <button id="resetToMenuBtn" class="btn">Return to Main Menu</button>
    </div>

    

        <!-- Layout reinforcement for AI explanation sizing -->
        <style>
            /* Make the AI explanation fill the right panel on desktop */
            @media (min-width: 981px){
                #quiz .side{ display:flex; flex-direction:column; min-height:0; }
                #quiz #gemOut{ height:auto !important; max-height:none !important; flex:1 1 auto; min-height:420px; }
            }
        </style>

    <!-- Official Gemini JS SDK -->
    <script
        type="module">import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai"; window.GoogleGenerativeAI = GoogleGenerativeAI;</script>

    <script>
        // --- GLOBAL HELPERS: normalizeGreek and friends ---
        const GREEK_MAP = {
            '&alpha;':'α','&beta;':'β','&gamma;':'γ','&delta;':'δ','&epsilon;':'ε','&zeta;':'ζ','&eta;':'η','&theta;':'θ','&iota;':'ι','&kappa;':'κ','&lambda;':'λ','&mu;':'μ','&nu;':'ν','&xi;':'ξ','&omicron;':'ο','&pi;':'π','&rho;':'ρ','&sigma;':'σ','&tau;':'τ','&upsilon;':'υ','&phi;':'φ','&chi;':'χ','&psi;':'ψ','&omega;':'ω',
            '&Alpha;':'Α','&Beta;':'Β','&Gamma;':'Γ','&Delta;':'Δ','&Epsilon;':'Ε','&Zeta;':'Ζ','&Eta;':'Η','&Theta;':'Θ','&Iota;':'Ι','&Kappa;':'Κ','&Lambda;':'Λ','&Mu;':'Μ','&Nu;':'Ν','&Xi;':'Ξ','&Omicron;':'Ο','&Pi;':'Π','&Rho;':'Ρ','&Sigma;':'Σ','&Tau;':'Τ','&Upsilon;':'Υ','&Phi;':'Φ','&Chi;':'Χ','&Psi;':'Ψ','&Omega;':'Ω',
            '&sigmaf;':'ς','&thetasym;':'ϑ','&upsih;':'ϒ','&varphi;':'ϕ'
        };
        const decodeNumericEntities = (s)=> String(s||'').replace(/&#(x?)([0-9A-Fa-f]+);/g, (m, x, code) => {
            try{ const cp = x ? parseInt(code,16) : parseInt(code,10); if(!isFinite(cp) || cp<0 || cp>0x10FFFF) return m; return String.fromCodePoint(cp); }catch{ return m; }
        });
        const decodeGreekNamed = (s)=> String(s||'').replace(/&(alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Alpha|Beta|Gamma|Delta|Epsilon|Zeta|Eta|Theta|Iota|Kappa|Lambda|Mu|Nu|Xi|Omicron|Pi|Rho|Sigma|Tau|Upsilon|Phi|Chi|Psi|Omega|sigmaf|thetasym|upsih|varphi);/g, (m)=> GREEK_MAP[m]||m);
        const normalizeGreek = (s)=>{
            try{
                if(s==null) return s;
                let t = String(s);
                t = t.replace(/[\u200B-\u200D\u2060\uFEFF]/g, '');
                t = t.replace(/Âµ/g, 'µ');
                t = t.replace(/\u00B5/g, '\u03BC');
                const VARIANT = { 'ϑ':'θ','ϵ':'ε','ϕ':'φ','ϱ':'ρ','ϖ':'π','ϰ':'κ','ϴ':'Θ','ϐ':'β','ϒ':'Υ' };
                t = t.replace(/[ϑϵϕϱϖϰϴϐϒ]/g, ch => VARIANT[ch] || ch);
                if(t.normalize){ t = t.normalize('NFC'); }
                return t;
            }catch{ return s; }
        };
        try{ window.normalizeGreek = normalizeGreek; }catch(e){}

        (function () {
            const $ = id => document.getElementById(id);
            const setup = $('setup'), preview = $('preview'), quiz = $('quiz');
            const resetBar = $('resetBar');
            const letters = ['A', 'B', 'C', 'D', 'E', 'F'];
            const state = { items: [], order: [], idx: 0, score: 0, answered: {}, skipped: new Set(), started: false, mode: 'quiz', reviewPool: [], returnIdx: null, returnMode: null, quizStartTime: null, quizEndTime: null, timerInterval: null, attempts: [], currentAttempt: null };
            // Expose quiz state for modules outside this closure (e.g., results analyzer)
            try{ window.__quizState = state; }catch{}

            // Theme switching: updates CSS vars to recolor bg lighting and button gradients
            (function initThemes(){
                const root = document.documentElement;
                const orbSel = document.querySelectorAll('.theme-capsule .theme-orb');
                const themes = {
                    ocean:  { glow1:'rgba(74,144,255,.20)', glow2:'rgba(112,220,255,.14)', glow3:'rgba(130,100,255,.16)', btnTop:'rgba(96,165,250,.35)', btnBottom:'rgba(24,60,120,.65)', btnBorder:'#1f3a64', brand:'#6aa9ff' },
                    sunset: { glow1:'rgba(255,122,122,.22)', glow2:'rgba(255,184,77,.16)', glow3:'rgba(255,216,107,.18)', btnTop:'rgba(255,184,122,.30)', btnBottom:'rgba(120,60,24,.65)', btnBorder:'#7a3e1f', brand:'#f59e0b' },
                    forest: { glow1:'rgba(43,212,122,.20)', glow2:'rgba(117,230,140,.15)', glow3:'rgba(63,178,160,.17)', btnTop:'rgba(45,160,110,.30)', btnBottom:'rgba(18,64,44,.65)', btnBorder:'#1a3f2c', brand:'#22c55e' },
                    violet: { glow1:'rgba(139,92,246,.22)', glow2:'rgba(96,165,250,.16)', glow3:'rgba(34,211,238,.18)', btnTop:'rgba(124,58,237,.32)', btnBottom:'rgba(49,46,129,.65)', btnBorder:'#3b2f6d', brand:'#8b5cf6' },
                    ember:  { glow1:'rgba(255,107,107,.22)', glow2:'rgba(245,158,11,.16)', glow3:'rgba(251,146,60,.18)', btnTop:'rgba(239,68,68,.32)', btnBottom:'rgba(80,30,24,.65)', btnBorder:'#4a1f1f', brand:'#ef4444' },
                                        greyscale: { 
                                            glow1:'rgba(180, 180, 180, .20)', 
                                            glow2:'rgba(120, 120, 120, .16)', 
                                            glow3:'rgba(70, 70, 70, .18)', 
                                            btnTop:'rgba(200, 200, 200, .30)', 
                                            btnBottom:'rgba(40, 40, 40, .70)', 
                                            btnBorder:'#4b5563', 
                                            brand:'#c0c0c0' 
                                        },
                };
                function applyTheme(name){
                    const t = themes[name] || themes.ocean;
                    root.style.setProperty('--glow1', t.glow1);
                    root.style.setProperty('--glow2', t.glow2);
                    root.style.setProperty('--glow3', t.glow3);
                    root.style.setProperty('--btnTop', t.btnTop);
                    root.style.setProperty('--btnBottom', t.btnBottom);
                    root.style.setProperty('--btnBorder', t.btnBorder);
                    root.style.setProperty('--brand', t.brand);
                    orbSel.forEach(o=>o.classList.toggle('active', o.dataset.theme===name));
                    // persist selection and notify listeners
                    try{ localStorage.setItem('__theme', name); }catch(e){}
                    try{ document.dispatchEvent(new CustomEvent('theme-changed', { detail: { name } })); }catch(e){}
                }
                orbSel.forEach(o=> o.addEventListener('click', ()=> applyTheme(o.dataset.theme)));
                // Restore last theme or default to ocean
                let initial = 'ocean';
                try{ const saved = localStorage.getItem('__theme'); if(saved && themes[saved]) initial = saved; }catch(e){}
                applyTheme(initial);
            })();

            /* ---------- Skipped modal (lazy) ---------- */
            function ensureSkippedModal() {
                if (document.getElementById('skippedModal')) return;
                const wrap = document.createElement('div'); wrap.id = 'skippedModal'; wrap.className = 'hidden';
                wrap.innerHTML = `<div class="overlay"><div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center"><h3>Skipped Questions</h3><button class="btn" id="closeSkipped">Close</button></div>
      <div class="hint">Click a question to jump. Use <span class="tag">Return</span> to go back to your current spot.</div>
      <div id="skippedList" class="list" style="margin-top:10px"></div>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-end"><button class="btn" id="returnToCurrent">Return</button></div>
    </div></div>`;
                document.body.appendChild(wrap);
                $('closeSkipped').onclick = () => wrap.classList.add('hidden');
                $('returnToCurrent').onclick = () => { if (state.returnIdx != null) { state.idx = state.returnIdx; state.mode = state.returnMode || 'quiz'; } wrap.classList.add('hidden'); renderCurrent(); };
            }
            const showSkipped = () => $('skippedModal')?.classList.remove('hidden');
            const hideSkipped = () => $('skippedModal')?.classList.add('hidden');

            /* ---------- Parse ---------- */
            function parseDoc(text) {
                const lines = normalizeGreek(text || '').replace(/\r\n?/g, '\n').split('\n');
                const items = []; const qre = /^Q\s*(\d+)\.\s*(.+)$/i; const keyMap = {};
                const keyIdx = lines.findIndex(l => /^\s*ANSWER\s+KEY\s*$/i.test(l));
                if (keyIdx !== -1) {
                    for (let k = keyIdx + 1; k < lines.length; k++) {
                        const m = lines[k].match(/^(\d+)\s*\.?\s*([A-D])/i);
                        if (m) keyMap[m[1]] = m[2].toUpperCase();
                    }
                }
                for (let i = 0; i < lines.length; i++) {
                    const q = lines[i].match(qre);
                    if (!q) continue;
                    const qnum = q[1]; const qtext = q[2].trim(); const choices = [];
                    for (let j = i + 1; j < lines.length; j++) {
                        const s = lines[j].trim();
                        if (/^Q\s*\d+\./i.test(s) || /^ANSWER\s+KEY/i.test(s)) { i = j - 1; break; }
                        if (/^[\-\u2013\u2014]\s+/.test(s)) choices.push(normalizeGreek(s.replace(/^[\-\u2013\u2014]\s+/, ''))); // - option
                        if (j === lines.length - 1) i = j;
                    }
                    if (choices.length >= 2) {
                        const letter = (keyMap[qnum] || 'A').toUpperCase();
                        const correctIdx = Math.max(0, Math.min(choices.length - 1, letter.charCodeAt(0) - 65));
                        items.push({ num: qnum, q: qtext, choices, correctIdx });
                    }
                }
                return items;
            }
            // Expose parser globally for validator/apply-corrections helpers
            try{ window.parseDoc = parseDoc; }catch{}

            /* ---------- Helpers ---------- */
            const shuffle = a => { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[a[i], a[j]] = [a[j], a[i]]; } return a; };
            // Reshuffle choices for an item, ensuring the correct answer changes position if possible
            function shuffleChoicesEnsureMove(it){
                try{
                    if(!it || !Array.isArray(it.choices) || it.choices.length < 2) return;
                    const prev = typeof it.correctIdx === 'number' ? it.correctIdx|0 : 0;
                    const base = it.choices.map((c,i)=>({ c, i }));
                    let z = base.slice();
                    let tries = 0;
                    do{ z = base.slice(); shuffle(z); tries++; } while(z.findIndex(t=>t.i===prev) === prev && tries < 8);
                    it.choices = z.map(t=>t.c);
                    it.correctIdx = z.findIndex(t=>t.i===prev);
                }catch(e){ console.warn('shuffleChoicesEnsureMove failed', e); }
            }
            const esc = s => (s + '').replace(/[&<>"']/g, c => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#39;" }[c]));
            // Safely decode only numeric entities and common Greek named entities, then escape for HTML
            const decodeNumericEntities = (s)=> String(s||'').replace(/&#(x?)([0-9A-Fa-f]+);/g, (m, x, code) => {
                try{ const cp = x ? parseInt(code,16) : parseInt(code,10); if(!isFinite(cp) || cp<0 || cp>0x10FFFF) return m; return String.fromCodePoint(cp); }catch{ return m; }
            });
            const GREEK_MAP = {
                '&alpha;':'α','&beta;':'β','&gamma;':'γ','&delta;':'δ','&epsilon;':'ε','&zeta;':'ζ','&eta;':'η','&theta;':'θ','&iota;':'ι','&kappa;':'κ','&lambda;':'λ','&mu;':'μ','&nu;':'ν','&xi;':'ξ','&omicron;':'ο','&pi;':'π','&rho;':'ρ','&sigma;':'σ','&tau;':'τ','&upsilon;':'υ','&phi;':'φ','&chi;':'χ','&psi;':'ψ','&omega;':'ω',
                '&Alpha;':'Α','&Beta;':'Β','&Gamma;':'Γ','&Delta;':'Δ','&Epsilon;':'Ε','&Zeta;':'Ζ','&Eta;':'Η','&Theta;':'Θ','&Iota;':'Ι','&Kappa;':'Κ','&Lambda;':'Λ','&Mu;':'Μ','&Nu;':'Ν','&Xi;':'Ξ','&Omicron;':'Ο','&Pi;':'Π','&Rho;':'Ρ','&Sigma;':'Σ','&Tau;':'Τ','&Upsilon;':'Υ','&Phi;':'Φ','&Chi;':'Χ','&Psi;':'Ψ','&Omega;':'Ω',
                '&sigmaf;':'ς','&thetasym;':'ϑ','&upsih;':'ϒ','&varphi;':'ϕ'
            };
            const decodeGreekNamed = (s)=> String(s||'').replace(/&(alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Alpha|Beta|Gamma|Delta|Epsilon|Zeta|Eta|Theta|Iota|Kappa|Lambda|Mu|Nu|Xi|Omicron|Pi|Rho|Sigma|Tau|Upsilon|Phi|Chi|Psi|Omega|sigmaf|thetasym|upsih|varphi);/g, (m)=> GREEK_MAP[m]||m);
            // Normalize Greek letters: unify variant glyphs, fix micro sign, strip zero-width, NFC normalize
            const normalizeGreek = (s)=>{
                try{
                    if(s==null) return s;
                    let t = String(s);
                    // strip zero-width spaces/marks and BOMs
                    t = t.replace(/[\u200B-\u200D\u2060\uFEFF]/g, '');
                    // common UTF-8 mis-decode for micro sign
                    t = t.replace(/Âµ/g, 'µ');
                    // unify micro sign to Greek mu
                    t = t.replace(/\u00B5/g, '\u03BC');
                    // map variant Greek symbols to canonical letters
                    const VARIANT = { 'ϑ':'θ','ϵ':'ε','ϕ':'φ','ϱ':'ρ','ϖ':'π','ϰ':'κ','ϴ':'Θ','ϐ':'β','ϒ':'Υ' };
                    t = t.replace(/[ϑϵϕϱϖϰϴϐϒ]/g, ch => VARIANT[ch] || ch);
                    // NFC normalization (safe in modern browsers)
                    if(t.normalize){ t = t.normalize('NFC'); }
                    return t;
                }catch{ return s; }
            };
                try{ window.normalizeGreek = normalizeGreek; }catch(e){}
            const safeText = (s)=> esc(normalizeGreek(decodeGreekNamed(decodeNumericEntities(s))));
            const activeList = () => state.mode === 'quiz' ? state.order : state.reviewPool;
            const activeLength = () => activeList().length;
            const activeIndex = () => activeList()[state.idx];

            /* ---------- Preview ---------- */
            function renderPreview(items) {
                preview.classList.remove('hidden');
                const list = $('previewList'); list.innerHTML = '';
                const n = Math.min(items.length, 5); // Limit to 5 items for preview
                for (let k = 0; k < n; k++) {
                    const it = items[k];
                    const div = document.createElement('div'); div.className = 'qcard';
                    div.innerHTML =
                        `<div><strong>Q${esc(it.num)}.</strong> ${safeText(it.q)}</div>` +
                        `<div style="margin-top:6px">${it.choices.map((c, i) => `<span class="tag">${letters[i] || '?'}.</span> ${safeText(c)}`).join('<br>')}</div>` +
                        `<div class="hint" style="margin-top:6px">Key: <span class="tag">${letters[it.correctIdx] || 'A'}</span></div>`;
                    list.appendChild(div);
                }
                $('previewCount').textContent = items.length;
                window.scrollTo({ top: preview.offsetTop - 10, behavior: 'smooth' });
                try{ setTimeout(()=>{ try{ window.renderMathIn && window.renderMathIn(list); }catch(e){} }, 80); }catch(e){}
            }

            /* Helpers: save/restore Gemini enabled state around quizzes */
            function saveGeminiStateForQuiz(){
                try{
                    const cb = document.getElementById('globalGemEnable');
                    if(!cb) return;
                    // Save the previous checked state. For safety, uncheck the toggle at quiz start
                    // but DO NOT disable it — allow the user to enable the API during the quiz if they choose.
                    window.__prevGemEnabled = !!cb.checked;
                    cb.checked = false;
                    // Intentionally do NOT set cb.disabled = true so the control remains interactive during quiz.
                    cb.dispatchEvent(new Event('change'));
                }catch(e){}
            }
            function restoreGeminiStateAfterQuiz(){
                try{
                    const cb = document.getElementById('globalGemEnable');
                    if(!cb) return;
                    if(typeof window.__prevGemEnabled !== 'undefined') cb.checked = !!window.__prevGemEnabled;
                    cb.disabled = false;
                    cb.dispatchEvent(new Event('change'));
                    try{ delete window.__prevGemEnabled }catch(e){}
                }catch(e){}
            }

            /* ---------- Start Quiz ---------- */
            function startQuiz() {
                if (!state.items.length) { alert('Parse & Preview first.'); return; }
                const items = state.items.map(it => ({ ...it, choices: [...it.choices] }));
                state.order = items.map((_, i) => i);
                if ($('shuffleQ').checked) shuffle(state.order);
                if ($('shuffleA').checked) items.forEach(it => { // Shuffle answer choices if enabled
                    const z = it.choices.map((c, i) => ({ c, i })); shuffle(z);
                    it.choices = z.map(t => t.c); it.correctIdx = z.findIndex(t => t.i === it.correctIdx);
                });
                state.items = items; state.idx = 0; state.score = 0; state.mode = 'quiz'; state.started = true;
                // track whether we've shown the one-time AI placeholder message for this quiz
                try{ state._aiPlaceholderShown = false; }catch(e){}
                try{ document.body.classList.add('quiz-running'); }catch{}
                try{ saveGeminiStateForQuiz(); }catch{}
                state.answered = {}; state.skipped.clear(); state.reviewPool = []; state.returnIdx = null; state.returnMode = null;
                // Reset attempts and start initial attempt slice
                state.attempts = []; state.currentAttempt = null;
                startAttempt('initial', state.order.slice());
                setup.classList.add('hidden'); preview.classList.add('hidden'); quiz.classList.remove('hidden');
                // hide the Content Library during quiz
                try{ document.getElementById('textbook-lib')?.classList.add('hidden'); }catch{}
                if(resetBar) resetBar.style.display = 'block';
                // Hide Validate/Like-Questions sections during the entire quiz session
                try{ document.getElementById('ai-likeq')?.classList.add('hidden'); }catch{}
                try{ document.getElementById('ai-likeq-copy')?.classList.add('hidden'); }catch{}
                // Always hide results/attempts card when entering quiz
                try{ document.getElementById('results-card')?.classList.add('hidden'); }catch{}
                // start timer
                state.quizStartTime = Date.now(); state.quizEndTime = null; if(state.timerInterval){ clearInterval(state.timerInterval); state.timerInterval = null; }
                state.timerInterval = setInterval(()=>{ try{ if(document.hidden) return; if(!state.started) return; const el = document.getElementById('quizTimer'); if(!el) return; const ms = (Date.now() - (state.quizStartTime||Date.now())); el.textContent = formatDuration(ms); }catch{} }, 1000);
                hideSkipped(); renderCurrent();
            }

            // Ensure Content Library is restored whenever the UI returns to setup
            document.addEventListener('click', function(e){
                try{
                    const btn = e.target.closest && e.target.closest('#backSetup');
                    if(btn){ 
                        document.getElementById('textbook-lib')?.classList.remove('hidden');
                        try{ if(window.refreshTextbookLibrary) window.refreshTextbookLibrary(); }catch{}
                    }
                }catch(e){}
            });

            // Keep Daily/Random quiz buttons visible ONLY when the main setup (main menu) is shown
            (function mainMenuButtonsVisibility(){
                function updateMainMenuButtonsVisibility(){
                    try{
                        const daily = document.getElementById('dailyQuizBtn');
                        const random = document.getElementById('randomQuizBtn');
                        const gear = document.getElementById('randomGearWrap');
                        const setupEl = document.getElementById('setup');
                        const isMain = !!setupEl && !setupEl.classList.contains('hidden') && !document.body.classList.contains('quiz-running');
                        [daily, random, gear].forEach(el=>{ if(!el) return; try{ el.style.display = isMain ? '' : 'none'; }catch(e){} });
                    }catch(e){ }
                }

                // Observe body class changes (quiz-running toggled) and setup visibility
                const bodyObserver = new MutationObserver(()=> updateMainMenuButtonsVisibility());
                try{ bodyObserver.observe(document.body, { attributes: true, attributeFilter: ['class'] }); }catch(e){}

                const setupEl = document.getElementById('setup');
                if(setupEl){
                    try{ const setupObserver = new MutationObserver(()=> updateMainMenuButtonsVisibility()); setupObserver.observe(setupEl, { attributes: true, attributeFilter: ['class', 'style'] }); }catch(e){}
                }

                // Initial run and ensure runs after DOM ready
                if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', updateMainMenuButtonsVisibility, { once:true }); else updateMainMenuButtonsVisibility();
                // Also run on window focus to catch external state changes
                window.addEventListener('focus', updateMainMenuButtonsVisibility);
            })();

            function startAttempt(mode, poolIndices){
                try{
                    state.currentAttempt = { id: (state.attempts.length + 1), mode: mode||'initial', pool: (poolIndices||[]).slice(), startedAt: Date.now(), endedAt: null, durationMs: 0, missed: [] };
                }catch(e){ console.warn('startAttempt failed', e); }
            }

            function finalizeCurrentAttempt(){
                try{
                    if(!state.currentAttempt) return;
                    const att = state.currentAttempt; att.endedAt = Date.now(); att.durationMs = Math.max(0, (att.endedAt - (att.startedAt||att.endedAt)));
                    const missed = [];
                    for(const ix of (att.pool||[])){
                        const it = state.items[ix]; const rec = state.answered[ix];
                        const wasWrong = !rec || !rec.submitted || !rec.correct;
                        if(wasWrong){ missed.push({ index: ix, num: it?.num, q: it?.q, choices: (it?.choices||[]).slice(), correctIdx: it?.correctIdx, user: (rec && rec.selected!=null ? rec.selected : null), attemptId: att.id, mode: att.mode }); }
                    }
                    att.missed = missed;
                    state.attempts.push(att);
                    state.currentAttempt = null;
                }catch(e){ console.warn('finalizeCurrentAttempt failed', e); }
            }

            /* ---------- Render current ---------- */
            function renderCurrent() {
                // Ensure any in-progress AI output (text/audio) is stopped and cleared immediately
                try{
                    if(typeof window.stopAiOutput === 'function') window.stopAiOutput();
                }catch{}
                try{ const w = document.getElementById('resultsAiOutput'); if(w){ try{ if(w._page) w._page.textContent = ''; else w.textContent = ''; }catch{} } }catch{}
                const list = activeList();
                if (!list.length) { if (state.mode === 'review') return showReviewDone(); alert('Nothing to show.'); return; }
                // Ensure results/attempts card is hidden while viewing questions
                try{ document.getElementById('results-card')?.classList.add('hidden'); }catch{}
                const itemIndex = activeIndex(); const it = state.items[itemIndex]; const total = activeLength();
                if (!state.answered[itemIndex]) state.answered[itemIndex] = { selected: null, submitted: false, correct: false, skipped: false };
                const rec = state.answered[itemIndex];
                const prog = Math.round((state.idx) / Math.max(1, total) * 100);

                                const grid = document.createElement('div'); grid.className = 'quizgrid';
                // ensure the grid stretches so the sidebar can fill vertical space
                grid.style.alignItems = 'stretch'; grid.style.minHeight = '420px';
                const left = document.createElement('div');
                                left.innerHTML = `
      <div class="footer" style="margin-bottom:6px">
        <div class="row" style="gap:8px">
          <span class="tag">${state.mode === 'quiz' ? 'Quiz' : 'Review'}</span>
          <span class="tag">#${state.idx + 1} / ${total}</span>
          <span class="tag">Score: ${state.score}</span>
          <span class="tag">Skipped: <span id="skippedCount">${state.skipped.size}</span></span>
                    <span class="tag" title="Elapsed time"><span id="quizTimer">00:00</span></span>
          <span class="link" id="openSkipped" style="cursor:pointer;color:var(--brand);text-decoration:underline">Open Skipped</span>
        </div>
        <div class="progress" style="flex:1 1 auto; max-width:420px"><div style="width:${prog}%"></div></div>
      </div>
      <div class="qcard">
    <div style="font-weight:700;margin-bottom:8px">Q${esc(it.num)}. ${safeText(it.q)}</div>
        <div id="choices"></div>
        <div id="status" class="hint" style="margin-top:6px"></div>
      </div>
                <div class="footer">
                <div class="toolbar">
                    <button class="btn warn" id="skipBtn">Skip</button>
                    <button class="btn" id="backBtn" ${state.idx === 0 ? 'disabled' : ''}>Back</button>
                </div>
                <div class="toolbar">
                    <button class="btn" id="revealBtn">Reveal</button>
                    <button class="btn primary" id="nextBtn">${state.idx === total - 1 ? 'Finish' : 'Next'}</button>
                </div>
            </div>`;
                const ch = left.querySelector('#choices');
                    it.choices.forEach((c, idx) => {
                    const lab = document.createElement('label'); lab.className = 'choice';
                    lab.innerHTML = `<input type="radio" name="c"> <strong>${letters[idx]}.</strong> ${safeText(c)}`;
                    const input = lab.querySelector('input'); input.checked = rec.selected === idx;
                    // immediately submit on selection and lock choices so they cannot be changed
                    input.addEventListener('change', () => {
                        if (!rec.submitted) { rec.selected = idx; doSubmit(it, itemIndex); }
                    });
                    if (rec.submitted) lab.classList.add('disabled');
                    ch.appendChild(lab);
                });
                const statusEl = left.querySelector('#status'); if (rec.submitted) { statusEl.textContent = rec.correct ? 'Already submitted: Correct.' : 'Already submitted: Incorrect.'; }

                                                                const right = document.createElement('aside'); right.className = 'side';
                                                                // make the sidebar a column flexbox so gemOut can flex-grow
                                                                right.style.display = 'flex'; right.style.flexDirection = 'column'; right.style.gap = '8px'; right.style.minHeight = '0'; right.style.alignSelf = 'stretch'; right.style.height = '100%'; right.style.flex = '0 0 320px';
                                                                // Ensure the sidebar visually occludes anything behind it (avoid buffering effect)
                                                                try{ right.style.background = 'linear-gradient(180deg, rgba(14,21,34,1), rgba(9,15,26,1))'; right.style.border = '1px solid var(--stroke)'; right.style.boxSizing = 'border-box'; right.style.zIndex = '3'; right.style.position = 'relative'; }catch(e){}
                                                                right.innerHTML = `
                                            <h3 style="margin:0 0 6px 0; display:inline-flex; align-items:center;"> <span id="aiExplanationKeyDot" class="key-dot missing" aria-hidden="true" title="API key status" style="display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:8px;vertical-align:middle;background:#ef4444;"></span>AI Explanation</h3>
                                            <div style="flex:1 1 0; min-height:0; display:flex; flex-direction:column;">
                                                <div id="resultsAiOutput" class="hint mt-12" role="status" aria-live="polite"></div>
                                            </div>
                                        `;
                grid.appendChild(left); grid.appendChild(right); quiz.innerHTML = ''; quiz.appendChild(grid);

                // Render LaTeX in the newly inserted quiz content (questions, choices, AI output)
                try{ setTimeout(()=>{ try{ const qarea = quiz; window.renderMathIn && window.renderMathIn(qarea); const aiOut = document.getElementById('resultsAiOutput'); if(aiOut) window.renderMathIn && window.renderMathIn(aiOut); }catch(e){ console.warn('renderMathIn quiz failed', e); } }, 60); }catch(e){}

                // Ensure the AI Explanation wrapper (text + ASCII face) is initialized.
                // Show the one-time placeholder only once per quiz; after that, ensure the wrapper exists
                // but do not repeat the spoken/typed placeholder.
                try{
                    setTimeout(()=>{
                        try{
                            const showOnce = !(state && state._aiPlaceholderShown);
                            // Preferred: use the animated wrapper initializer if available
                            if(typeof window.showAiOutput === 'function'){
                                if(showOnce){
                                    try{ window.showAiOutput('AI explanation panel ready. Enable the API Key and select an answer to see a short AI analysis.'); }catch(e){}
                                    try{ state._aiPlaceholderShown = true; }catch(e){}
                                } else {
                                    // Ensure wrapper exists without speaking the placeholder
                                    try{ if(typeof ensureWrapper === 'function') ensureWrapper(); else if(typeof window.showAiOutput === 'function') window.showAiOutput(''); }catch(e){}
                                }
                            } else {
                                // Fallback: augment the resultsAiOutput element so it shows a page box and face
                                const out = document.getElementById('resultsAiOutput');
                                if(out){
                                    if(out.innerHTML.trim() === ''){
                                        out.classList.add('aiTextbookOutput');
                                        if(showOnce){
                                            // Make the output container opaque to prevent the underlying panel from showing through
                                            try{ out.style.background = 'linear-gradient(180deg, rgba(14,21,34,1), rgba(9,15,26,1))'; out.style.border = '1px solid var(--stroke)'; out.style.boxSizing = 'border-box'; out.style.zIndex = '4'; }catch(e){}
                                            out.innerHTML = '<div class="page" role="status" aria-live="polite">AI explanation panel ready. Select an answer to see a short AI analysis.</div>' +
                                                            '<div class="ascii-face"><div class="face">(•<span class="mouth">___</span>•)</div></div>';
                                            try{ state._aiPlaceholderShown = true; }catch(e){}
                                        } else {
                                            out.innerHTML = '<div class="page" role="status" aria-live="polite"></div>' +
                                                            '<div class="ascii-face"><div class="face">(•<span class="mouth">___</span>•)</div></div>';
                                        }
                                    } else {
                                        // If content exists but we haven't marked placeholder as shown, mark it so we don't repeat
                                        if(showOnce){ try{ state._aiPlaceholderShown = true; }catch(e){} }
                                    }
                                }
                            }
                        }catch(e){}
                    }, 90);
                }catch(e){}

                // AI explanation uses the global key in #globalGemKey; no per-quiz key input required here.

                left.querySelector('#revealBtn').onclick = () => reveal(it, rec);
                left.querySelector('#nextBtn').onclick = next;
                left.querySelector('#backBtn').onclick = back;
                left.querySelector('#skipBtn').onclick = skipCurrent;
                left.querySelector('#openSkipped').onclick = openSkippedPanel;
            }

            // Reset to main menu: clear quiz state and return to setup screen
            (function bindReset(){
                const btn = $('resetToMenuBtn');
                if(!btn) return;
                btn.addEventListener('click', ()=>{
                    try{
                        state.items = []; state.order = []; state.idx = 0; state.score = 0; state.answered = {}; state.skipped.clear(); state.reviewPool = []; state.started = false; state.mode = 'quiz';
                        // stop and clear timer
                        if(state.timerInterval){ clearInterval(state.timerInterval); state.timerInterval = null; }
                        state.quizStartTime = null; state.quizEndTime = null;
                        // Hide quiz, show setup
                        quiz.classList.add('hidden');
                        preview.classList.add('hidden');
                        setup.classList.remove('hidden');
                        try{ document.body.classList.remove('quiz-running'); }catch{}
                        try{ restoreGeminiStateAfterQuiz(); }catch{}
                        // Ensure textbook library UI is visible and refreshed
                        try{ document.getElementById('textbook-lib')?.classList.remove('hidden'); }catch{}
                        try{ if(window.refreshTextbookLibrary) window.refreshTextbookLibrary(); }catch{}
                        if(resetBar) resetBar.style.display = 'none';
                        // Unhide AI panels that were hidden after parsing/starting
                        try{ document.getElementById('ai-likeq')?.classList.remove('hidden'); }catch{}
                        try{ document.getElementById('ai-likeq-copy')?.classList.remove('hidden'); }catch{}
                        try{ document.querySelector('.ai-file-panel')?.classList.remove('hidden'); }catch{}
                        // Re-run light UI sync for key badges/buttons
                        try{
                            const evt = new Event('change');
                            document.getElementById('globalGemKey')?.dispatchEvent(new Event('input'));
                            document.getElementById('globalGemEnable')?.dispatchEvent(evt);
                        }catch{}
                        // Clear AI explanation panel and any transient UI
                        try{ if(typeof window.stopAiOutput === 'function'){ window.stopAiOutput(); } else { const gemOut = document.getElementById('gemOut'); if(gemOut) gemOut.value = ''; } }catch{}
                        const skipped = document.getElementById('skippedModal'); if(skipped) skipped.classList.add('hidden');
                        // hide results card
                        try{ document.getElementById('results-card')?.classList.add('hidden'); document.getElementById('resultsSummary').innerHTML=''; document.getElementById('resultsAiStatus').textContent=''; try{ if(typeof window.stopAiOutput === 'function'){ window.stopAiOutput(); } else { document.getElementById('resultsAiOutput').textContent=''; } }catch{} }catch{}
                        // Mark as not parsed so initializers won't hide AI panels until next parse
                        try{ window.__parsed = false; }catch{}
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                    }catch(e){ console.error('resetToMenu failed', e); }
                });
            })();

            const lockChoices = () => {
                // visually mark and prevent further interaction with choices
                quiz.querySelectorAll('.choice').forEach(n => {
                    n.classList.add('disabled');
                    // disable contained input and make label inert
                    const inp = n.querySelector('input'); if(inp){ inp.disabled = true; inp.checked = inp.checked; }
                    n.style.pointerEvents = 'none';
                    n.style.opacity = '0.95';
                });
            };

            function doSubmit(it, itemIndex) {
                const rec = state.answered[itemIndex] || (state.answered[itemIndex] = { selected: null, submitted: false, correct: false, skipped: false });
                if (rec.submitted) return;
                if (rec.selected == null) { alert('Choose an option first.'); return; }
                const nodes = quiz.querySelectorAll('.choice');
                nodes.forEach((n, idx) => { n.classList.remove('correct', 'wrong'); if (idx === it.correctIdx) n.classList.add('correct'); if (idx === rec.selected && rec.selected !== it.correctIdx) n.classList.add('wrong'); });
                rec.submitted = true; rec.correct = (rec.selected === it.correctIdx); rec.skipped = false; if (rec.correct) state.score++;
                const el = $('status'); if (el) el.textContent = rec.correct ? 'Correct!' : 'Not quite.';
                lockChoices();
                requestGeminiRationale(it, rec.selected);
            }

            function reveal(it, rec) {
                const nodes = quiz.querySelectorAll('.choice');
                nodes.forEach((n, idx) => { n.classList.toggle('correct', idx === it.correctIdx); });
                if (rec && rec.submitted) lockChoices();
            }

            function skipCurrent() {
                try{ if(typeof window.stopAiOutput === 'function') window.stopAiOutput(); }catch{}
                try{ const w = ensureWrapper(); if(w && w._page) w._page.textContent = ''; }catch{}
                const idx = activeIndex();
                const rec = state.answered[idx] || (state.answered[idx] = { selected: null, submitted: false, correct: false, skipped: false });
                rec.skipped = true; state.skipped.add(idx);
                if (state.idx < activeLength() - 1) { state.idx++; renderCurrent(); } else next();
            }

            function openSkippedPanel() {
                if (!state.started) return;
                ensureSkippedModal();
                state.returnIdx = state.idx; state.returnMode = state.mode;
                const listEl = $('skippedList'); listEl.innerHTML = '';
                if (!state.skipped.size) {
                    listEl.innerHTML = '<div class="hint">No skipped questions.</div>';
                } else {
                    [...state.skipped].forEach(ix => {
                        const chip = document.createElement('div'); chip.className = 'chip';
                        const n = state.items[ix]?.num || '?'; chip.textContent = `Q${n}`;
                        chip.onclick = () => { state.mode = 'quiz'; const pos = activeList().indexOf(ix); if (pos >= 0) { state.idx = pos; } else { state.order.unshift(ix); state.idx = 0; } hideSkipped(); renderCurrent(); };
                        listEl.appendChild(chip);
                    });
                }
                showSkipped();
            }

            function next() { try{ if(typeof window.stopAiOutput === 'function') window.stopAiOutput(); }catch{} try{ const w = ensureWrapper(); if(w && w._page) w._page.textContent = ''; }catch{} if (state.idx < activeLength() - 1) { state.idx++; renderCurrent(); } else { if (state.mode === 'quiz') return showSummary(); return showReviewDone(); } }
            function back() { try{ if(typeof window.stopAiOutput === 'function') window.stopAiOutput(); }catch{} try{ const w = ensureWrapper(); if(w && w._page) w._page.textContent = ''; }catch{} if (state.idx > 0) { state.idx--; renderCurrent(); } }

            // Format ms -> HH:MM:SS (or MM:SS if under 1 hour)
            function formatDuration(ms){
                ms = Math.max(0, ms|0);
                const s = Math.floor(ms/1000);
                const hh = Math.floor(s/3600);
                const mm = Math.floor((s%3600)/60);
                const ss = s%60;
                const pad = n=> String(n).padStart(2,'0');
                return hh>0 ? `${pad(hh)}:${pad(mm)}:${pad(ss)}` : `${pad(mm)}:${pad(ss)}`;
            }

            function showSummary() {
                // stop timer and compute duration
                if(state.timerInterval){ clearInterval(state.timerInterval); state.timerInterval = null; }
                state.quizEndTime = Date.now();
                const elapsedMs = (state.quizStartTime && state.quizEndTime) ? (state.quizEndTime - state.quizStartTime) : 0;
                // Ensure Validate/Like-Questions sections remain hidden on the summary screen
                try{ document.getElementById('ai-likeq')?.classList.add('hidden'); }catch{}
                try{ document.getElementById('ai-likeq-copy')?.classList.add('hidden'); }catch{}
                try{ document.body.classList.remove('quiz-running'); }catch{}
                try{ restoreGeminiStateAfterQuiz(); }catch{}
                // finalize current attempt (initial pass)
                finalizeCurrentAttempt();
                const missed = [];
                state.items.forEach((_, ix) => { const r = state.answered[ix]; if (!r || !r.submitted || !r.correct) missed.push(ix); });
                quiz.innerHTML =
                    `<div class="qcard"><h2 style="margin:0 0 8px">Finished</h2>
                        <div>Score: ${state.score} / ${state.items.length}</div>
                        <div>Percent Correct: ${(state.items.length? (state.score/state.items.length*100):0).toFixed(1)}%</div>
                        <div>Time: ${formatDuration(elapsedMs)}</div>
                        <div class="hint" style="margin-top:8px">${missed.length ? 'You have questions to (re)try.' : 'All questions correct! 🎉'}</div>
                    </div>` +
                    `<div class="footer"><div><button class="btn" id="openSkipped2">Open Skipped (${state.skipped.size})</button></div><div><button class="btn primary" id="reviewMissed" ${missed.length ? '' : 'disabled'}>Review Missed</button> <button class="btn" id="restart">Restart</button> <button class="btn" id="backSetup">Back to Setup</button></div></div>`;
                // Also render a results card below mirroring the validate/like style
                try{
                    const results = document.getElementById('results-card');
                    const sum = document.getElementById('resultsSummary');
                    if(results && sum){
                        if(missed.length === 0){
                            const pct = state.items.length? (state.score/state.items.length*100):0;
                            sum.innerHTML = `<div class="qcard">
                                <div><strong>Results</strong></div>
                                <div class="mt-6">Score: ${state.score} / ${state.items.length}</div>
                                <div>Percent Correct: ${pct.toFixed(1)}%</div>
                                <div>Time: ${formatDuration(elapsedMs)}</div>
                                <div>Missed (this pass): ${missed.length}</div>
                            </div>`;
                            // Build attempts UI and reveal only when fully complete
                            renderAttemptsUI();
                            results.classList.remove('hidden');
                            // Re-sync analyze button enabled state and key badge when results are shown
                            try{
                                const keyVal = (document.getElementById('globalGemKey')?.value||'').trim();
                                const enabled = !!document.getElementById('globalGemEnable')?.checked;
                                const ok = !!keyVal && enabled;
                                const analyze = document.getElementById('analyzeMissedBtn'); if(analyze) analyze.disabled = !ok;
                                const rBadge = document.getElementById('resultsKeyBadge'); if(rBadge){ rBadge.classList.toggle('ok', ok); rBadge.classList.toggle('missing', !ok); const h=rBadge.querySelector('.hint'); if(h) h.textContent = ok ? 'Key set' : 'No key set'; }
                            }catch{}
                        } else {
                            // Hide the results/attempts card until all questions have been completed correctly
                                results.classList.add('hidden');
                                sum.innerHTML = '';
                                const sel = document.getElementById('attemptSelect'); if(sel) sel.innerHTML = '';
                                const missList = document.getElementById('attemptMissedList'); if(missList) missList.innerHTML = '';
                                const stat = document.getElementById('resultsAiStatus'); if(stat) stat.textContent = '';
                                // Prefer aborting any animated AI output; fall back to clearing text if not available
                                try{ if(typeof window.stopAiOutput === 'function'){ window.stopAiOutput(); } else { const out = document.getElementById('resultsAiOutput'); if(out) out.textContent = ''; } }catch{}
                        }
                    }
                }catch{}
                $('restart').onclick = () => { state.idx = 0; state.score = 0; startQuiz(); };
                $('backSetup').onclick = () => { setup.classList.remove('hidden'); quiz.classList.add('hidden'); try{ document.getElementById('textbook-lib')?.classList.remove('hidden'); }catch{} };
                $('openSkipped2').onclick = openSkippedPanel;
                $('reviewMissed').onclick = () => {
                    if (!missed.length) return;
                    state.mode = 'review';
                    state.reviewPool = missed.slice();
                    // Hide results card and attempts UI during review
                    try{ document.getElementById('results-card')?.classList.add('hidden'); }catch{}

                    // ⬅️ unlock items for re-answering
                    state.reviewPool.forEach(ix => {
                        const r = state.answered[ix] || (state.answered[ix] = {});
                        r.submitted = false;   // allow resubmit
                        r.selected = null;    // optional: clear old choice
                        r.skipped = false;
                        // reshuffle choices ensuring the correct answer moves to a new slot
                        shuffleChoicesEnsureMove(state.items[ix]);
                    });

                    state.idx = 0;
                    // start a new attempt covering the review pool
                    startAttempt('review', state.reviewPool.slice());
                    renderCurrent();
                };
            }

            function renderAttemptsUI(){
                try{
                    const sel = document.getElementById('attemptSelect');
                    const list = document.getElementById('attemptMissedList');
                    const sum = document.getElementById('resultsSummary');
                    const status = document.getElementById('resultsAiStatus');
                    const dd = document.getElementById('attemptDropdown');
                    const trigger = document.getElementById('attemptTrigger');
                    const trigText = document.getElementById('attemptTriggerText');
                    const menu = document.getElementById('attemptMenu');
                    if(!sel || !list) return;
                    // Ensure we have at least the finalized attempts
                    const attempts = state.attempts.slice();
                    // Aggregate totals (across all attempts)
                    const allMissed = attempts.flatMap(a => a.missed || []);
                    // Build labels once
                    const labels = attempts.map(a=>({ id:String(a.id), text:`${a.id}. ${a.mode} — missed ${a.missed?.length||0}, time ${formatDuration(a.durationMs||0)}` }));
                    // Fill native select (kept hidden)
                    sel.innerHTML = '';
                    labels.forEach(l=>{ const opt=document.createElement('option'); opt.value=l.id; opt.textContent=l.text; sel.appendChild(opt); });
                    // Fill custom menu
                    if(menu){ menu.innerHTML = labels.map(l=>`<div class="attempt-option" role="option" data-id="${l.id}"><span class="tag">${l.id}.</span> <span>${l.text.replace(/^\d+\.\s+/, '')}</span></div>`).join(''); }
                    // Default selection: most recent with misses, else last
                    if(attempts.length){ let def=null; for(let i=attempts.length-1;i>=0;i--){ if(attempts[i]?.missed && attempts[i].missed.length){ def=String(attempts[i].id); break; } } if(!def) def=String(attempts[attempts.length-1].id); sel.value=def; if(trigText) trigText.textContent = labels.find(x=>x.id===def)?.text || 'Select attempt…'; }
                    // Open/close behavior
                    function syncMenuWidth(){ try{ if(!dd||!menu||!trigger) return; const w = Math.ceil(trigger.getBoundingClientRect().width); menu.style.width = w + 'px'; }catch{} }
                    function setOpen(open){ if(!dd) return; dd.classList.toggle('open', !!open); dd.setAttribute('aria-expanded', open?'true':'false'); if(open) syncMenuWidth(); }
                    trigger && trigger.addEventListener('click', ()=> setOpen(!dd.classList.contains('open')));
                    document.addEventListener('click', (e)=>{ if(!dd) return; if(!dd.contains(e.target)){ setOpen(false); } });
                    document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') setOpen(false); });
                    window.addEventListener('resize', ()=>{ if(dd && dd.classList.contains('open')) syncMenuWidth(); });
                    // Renderer for a selected attempt
                    function renderAttempt(id){
                        const a = attempts.find(z => String(z.id) === String(id));
                        if(!a){ list.innerHTML = '<div class="hint">No attempt selected.</div>'; if(sum) sum.innerHTML=''; return; }
                        // Keep analyze button in sync with current selection (for robust reads)
                        try{ const ab = document.getElementById('analyzeMissedBtn'); if(ab){ ab.dataset.selAttemptId = String(a.id); } }catch{}
                        // Sync the custom trigger text
                        try{ if(trigText){ const l = labels.find(x=>x.id===String(a.id)); if(l) trigText.textContent = l.text; } }catch{}
                        // Update summary block for the selected attempt (isolated score/time)
                        try{
                            const pool = Array.isArray(a.pool) ? a.pool.length : 0;
                            const missedN = Array.isArray(a.missed) ? a.missed.length : 0;
                            const correct = Math.max(0, pool - missedN);
                            const pct = pool ? (correct/pool*100) : 0;
                            if(sum){
                                sum.innerHTML = `<div class="qcard">
                                    <div><strong>Results</strong></div>
                                    <div class="mt-6">Score: ${correct} / ${pool}</div>
                                    <div>Percent Correct: ${pct.toFixed(1)}%</div>
                                    <div>Time: ${formatDuration(a.durationMs||0)}</div>
                                    <div>Missed (this attempt): ${missedN}</div>
                                </div>`;
                            }
                        }catch(e){ /* ignore summary update errors */ }
                        if(!a.missed || a.missed.length===0){
                            list.innerHTML = '<div class="hint text-center">No missed questions in this attempt.</div>';
                            if(status) status.textContent = 'No missed questions in the selected attempt to analyze.';
                            return;
                        }
                        // Similar to preview, show missed questions with A/B/C labels and key
                        // CRITICAL: Always render from the attempt snapshot (m.choices, m.correctIdx)
                        // to avoid mismatches when choices were reshuffled in later attempts.
                        const letters = ['A','B','C','D','E','F'];
                        const html = a.missed.map(m=>{
                            const it = state.items[m.index];
                            const q = (m.q ?? it?.q ?? '');
                            const num = (m.num ?? it?.num ?? '?');
                            const choicesArr = Array.isArray(m.choices) && m.choices.length ? m.choices : (it?.choices || []);
                            const choices = choicesArr.map((c,i)=>`<span class="tag">${letters[i]||'?'}.</span> ${safeText(c)}`).join('<br>');
                            const keyIdx = (typeof m.correctIdx === 'number') ? m.correctIdx : (it?.correctIdx ?? 0);
                            const keyLetter = letters[keyIdx] || 'A';
                            const userLetter = (m.user==null? '—' : (letters[m.user]||'?'));
                            // Build missed card using same structure as preview (compact, no inline flex)
                            return `<div class="qcard">
                                <div><strong>Q${esc(String(num))}.</strong> ${safeText(q)}</div>
                                <div style="margin-top:6px">${choices}</div>
                                <div class="hint" style="margin-top:6px">Key: <span class="tag">${keyLetter}</span></div>
                            </div>`;
                        }).join('');
                        list.innerHTML = html;
                        if(status) status.textContent = `Selected attempt ${a.id}: ${a.missed.length} missed will be analyzed.`;
                    }
                    sel.onchange = ()=> { renderAttempt(sel.value); try{ const ab = document.getElementById('analyzeMissedBtn'); if(ab){ ab.dataset.selAttemptId = String(sel.value||''); } }catch{} };
                    // Menu selection wiring
                    if(menu && menu.children.length){
                        Array.from(menu.children).forEach(el=>{
                            el.addEventListener('click', ()=>{ const id = el.getAttribute('data-id'); if(id){ sel.value = id; renderAttempt(id); } setOpen(false); syncMenuWidth(); });
                        });
                    }
                    if(attempts.length){ renderAttempt(sel.value); }
                }catch(e){ console.warn('renderAttemptsUI failed', e); }
            }

            function showReviewDone() {
                const remaining = state.reviewPool.filter(ix => { const r = state.answered[ix]; return !r || !r.correct; });
                if (remaining.length) {
                    // Ensure results card remains hidden on Keep Going screens
                    try{ document.getElementById('results-card')?.classList.add('hidden'); }catch{}
                    // Ensure the just-completed slice is recorded so attempts UI can show it now
                    finalizeCurrentAttempt();
                    quiz.innerHTML =
                        `<div class="qcard"><h2 style="margin:0 0 8px">Keep Going</h2><div class="hint">Attempt ${(state.currentAttempt && state.currentAttempt.id) ? state.currentAttempt.id : (state.attempts[state.attempts.length-1]?.id || '?')} (${(state.currentAttempt && state.currentAttempt.mode) ? state.currentAttempt.mode : (state.attempts[state.attempts.length-1]?.mode || 'review')}): Some questions are still incorrect or unsubmitted. Continue until all are correct.</div></div>` +
                        `<div class="footer"><button class="btn" id="continueReview">Continue</button><button class="btn" id="summary">Summary</button></div>`;
                    $('continueReview').onclick = () => {
                        // start a new attempt for the remaining items
                        try{ document.getElementById('results-card')?.classList.add('hidden'); }catch{}
                        state.reviewPool = remaining;

                        // ⬅️ unlock remaining items again
                        state.reviewPool.forEach(ix => {
                            const r = state.answered[ix] || (state.answered[ix] = {});
                            r.submitted = false;
                            r.selected = null;
                            r.skipped = false;
                            // reshuffle again so position can't be memorized
                            shuffleChoicesEnsureMove(state.items[ix]);
                        });

                        state.idx = 0;
                        startAttempt('review', state.reviewPool.slice());
                        renderCurrent();
                    };
                    $('summary').onclick = showSummary;
                } else {
                    // finalize the last review attempt slice and auto-redirect to Summary
                    finalizeCurrentAttempt();
                    try{ document.body.classList.remove('quiz-running'); }catch{};
                    try{ restoreGeminiStateAfterQuiz(); }catch{};
                    showSummary();
                }
            }

            /* ---------- Gemini 2.5 rationale (SDK) ---------- */
            async function requestGeminiRationale(it, choiceIdx) {
                const key = (document.getElementById('globalGemKey')?.value || '').trim(); const out = $('resultsAiOutput') || $('gemOut');
                const enabled = !!document.getElementById('globalGemEnable')?.checked;
                if (!key || !enabled) {
                    // Do not write a user-facing message into the AI Explanation panel when API is disabled.
                    // The UI instead shows a small red/green dot next to the AI Explanation header to indicate status.
                    try{ console.debug('AI explanations disabled or API key missing; skipping Gemini request.'); }catch(e){}
                    return;
                }
                const AI = window.GoogleGenerativeAI; if (!AI) { try{ if(typeof window.showAiOutput === 'function'){ window.showAiOutput('SDK failed to load. Check network.'); } else { if(out) out.value = 'SDK failed to load. Check network.'; } }catch{}; return; }
                const client = new AI(key);
                const model = client.getGenerativeModel({ model: 'gemini-2.5-flash' });
                const prompt = `You are a concise tutor. Provide a compact, meaningful explanation of the student’s choice and evaluate each option.
Constraints:
- Keep the whole response brief (≈80–140 words). No fluff.
- Start with a one-line verdict: "Verdict: Correct." or "Verdict: Incorrect." (if incorrect, say which letter is correct).
- Then give 1–2 short sentences explaining the core concept.
- Then list every option (A., B., C., …): one short reason each; mark the correct one with "(correct)".
- End with a one-line takeaway.

Question: ${it.q}
Options:
${it.choices.map((c, i) => `${letters[i]}. ${c}`).join('\n')}
Student selected: ${letters[choiceIdx]}. ${it.choices[choiceIdx]}
Correct answer: ${letters[it.correctIdx]}. ${it.choices[it.correctIdx]}`;
                // Show immediate UI feedback (animated preferred)
                try{ if(typeof window.stopAiOutput === 'function'){ window.stopAiOutput(); } }catch{}
                // Capture the quiz index at the time of request so we can ignore late responses
                const _requestIdx = (window.state && typeof state.idx === 'number') ? state.idx : null;
                try{ if(typeof window.showAiOutput === 'function'){ window.showAiOutput('Analyzing with Gemini 2.5...'); } else { if(out) { out.value = 'Analyzing with Gemini 2.5...'; out.disabled = true; } } }catch{}
                // Capture the controller token created by showAiOutput (if any) so we only overwrite
                // the same output area when the original request is still active.
                const _myAiController = window.__aiOutputController || null;
                // spinner visual removed for AI Explanation (use animated textbook output instead)
                const spin = null;
                try {
                    const resp = await model.generateContent({ contents: [{ role: 'user', parts: [{ text: prompt }] }] });
                    const text = await resp?.response?.text?.();
                    const final = (text || '').trim() || 'No explanation returned.';
                    // Before writing, ensure the user is still on the same question and
                    // that no newer Gemini request has replaced the global controller.
                    try{
                        const stillOnQuestion = (_requestIdx === null) || (window.state && state.idx === _requestIdx);
                        const globalCtrl = window.__aiOutputController;
                        // Allow write when still on question and either this request's controller
                        // is the global one, or there's no active global controller (null/undefined).
                        const canWriteAnimated = (globalCtrl === _myAiController) || (globalCtrl == null);
                        if(!stillOnQuestion){
                            console.log('Gemini response ignored: question changed since request');
                        } else if(typeof window.showAiOutput === 'function'){
                            if(canWriteAnimated){
                                window.showAiOutput(final);
                            } else {
                                // Fallback: if animated output can't be written, try legacy textarea
                                if(out) out.value = final; else console.log('Gemini response skipped: newer request active');
                            }
                        } else if(out){ out.value = final; }
                    }catch(e){ if(out) out.value = final; }
                } catch (e) {
                    console.error('Gemini request error', e);
                    const raw = (e?.message || String(e || '')).toString();
                    // Detect invalid API key error and provide actionable guidance
                    if (/API_KEY_INVALID|API key not valid/i.test(raw)){
                        // mask key preview
                        let preview = '<no key provided>';
                        try{ if(key && key.length){ preview = key.length>8 ? (key.slice(0,4) + '…' + key.slice(-4)) : ('*'.repeat(Math.max(4,key.length))); } }catch{}
                        const msg = `Gemini request failed: API key invalid.\nKey preview: ${preview}\n\nFixes to try:\n1) Confirm the global API key at the top of the page is correct. (Open devtools and run: document.getElementById('globalGemKey').value)\n2) In Google Cloud Console, enable the Generative Language API (generativelanguage.googleapis.com) and ensure billing is enabled for your project.\n3) Check API key restrictions: if the key is restricted by HTTP referrers or IPs, either remove restrictions for testing or add this origin (for local files consider running a localhost server).\n4) If issues persist, create a new API key and try again.\n`;
                        try{
                            const stillOnQuestion = (_requestIdx === null) || (window.state && state.idx === _requestIdx);
                            const globalCtrl = window.__aiOutputController;
                            const canWriteAnimated = (globalCtrl === _myAiController) || (globalCtrl == null);
                            if(stillOnQuestion){
                                if(typeof window.showAiOutput === 'function'){
                                    if(canWriteAnimated){ window.showAiOutput(msg); }
                                    else { console.log('Gemini error skipped: newer request active'); }
                                } else if(out){ out.value = msg; }
                            } else { console.log('Gemini error ignored: question changed'); }
                        }catch{}
                    } else {
                        const msg = 'Gemini request failed: ' + raw;
                        try{
                            const stillOnQuestion = (_requestIdx === null) || (window.state && state.idx === _requestIdx);
                            const globalCtrl = window.__aiOutputController;
                            const canWriteAnimated = (globalCtrl === _myAiController) || (globalCtrl == null);
                            if(stillOnQuestion){ if(typeof window.showAiOutput === 'function'){ if(canWriteAnimated){ window.showAiOutput(msg); } else { console.log('Gemini error skipped: newer request active'); } } else if(out){ out.value = msg; } }
                            else { console.log('Gemini error ignored: question changed'); }
                        }catch{}
                    }
                } finally {
                    try{
                        // Only re-enable the legacy textarea if the user is still on the same question
                        // and this request is still the latest one (or there is no active global controller).
                        const stillOnQuestion = (_requestIdx === null) || (window.state && state.idx === _requestIdx);
                        const globalCtrl = window.__aiOutputController;
                        const isLatestOrNoGlobal = (globalCtrl === _myAiController) || (globalCtrl == null);
                        if(out && stillOnQuestion && isLatestOrNoGlobal){ out.disabled = false; }
                    }catch{}; if(spin) try{ spin.remove(); }catch{}
                }
            }

            /* ---------- Wire up ---------- */
            function doParse() {
                const text = $('paste').value || ''; state.items = parseDoc(text); state.order = state.items.map((_, i) => i);
                state.answered = {}; state.skipped.clear(); state.reviewPool = []; state.idx = 0; state.score = 0; state.mode = 'quiz'; state.started = false;
                // mark that the document has been parsed so UI hides (AI cards) only after parse
                try{ window.__parsed = true; }catch{}
                renderPreview(state.items); hideSkipped();
            }
            $('parseBtn').onclick = doParse;

        // See All modal wiring
        (function(){
            const seeAllBtn = document.getElementById('seeAllBtn');
            const modal = document.getElementById('seeAllModal');
            const closeBtn = document.getElementById('seeAllClose');
            const content = document.getElementById('seeAllContent');
            function openModal(){
                try{
                    // populate content from quiz state
                    const items = (window.__quizState && window.__quizState.items) ? window.__quizState.items : (window.state && state.items) ? state.items : [];
                    if(!items || !items.length){
                        content.innerHTML = '<div class="hint">No parsed items yet. Parse your document first.</div>';
                    } else {
                        // Render concise question + lettered choices for each parsed item
                        const esc = s => String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;');
                        const letters = ['A','B','C','D','E','F','G','H'];
                        content.innerHTML = items.map((it, ix) => {
                            const num = it.num || (ix + 1);
                            const q = esc(it.q || it.text || '');
                            const choices = Array.isArray(it.choices) ? it.choices : [];
                            // determine correct index: prefer numeric correctIdx, else try to parse a key letter
                            let correctIdx = (typeof it.correctIdx === 'number' && isFinite(it.correctIdx)) ? it.correctIdx : null;
                            if(correctIdx === null && it.answer){
                                // allow 'A' or '1. A' etc.
                                const m = String(it.answer).match(/([A-F])/i);
                                if(m) correctIdx = 'ABCDEF'.indexOf(m[1].toUpperCase());
                            }
                            if(correctIdx === null && it.key){ const m = String(it.key).match(/([A-F])/i); if(m) correctIdx = 'ABCDEF'.indexOf(m[1].toUpperCase()); }
                            const choicesHtml = choices.map((c, i) => {
                                const cls = (correctIdx !== null && i === correctIdx) ? 'seeall-choice correct' : 'seeall-choice';
                                return `<div class="${cls}"><strong>${letters[i]||String(i+1)}.</strong> ${esc(c)}</div>`;
                            }).join('');
                            return `<div class="seeall-item">` +
                                `<div style="font-weight:700;margin-bottom:6px">Q${num}. ${q}</div>` +
                                `<div class="seeall-choices">${choicesHtml}</div>` +
                                `</div>`;
                        }).join('');
                    }
                    // disable page scroll while modal is open (robust across platforms)
                    try{
                        // save current scroll and inline styles so we can restore exactly
                        document.body.dataset._prevOverflow = document.body.style.overflow || '';
                        document.body.dataset._prevPosition = document.body.style.position || '';
                        document.body.dataset._prevTop = document.body.style.top || '';
                        const scrollY = window.scrollY || window.pageYOffset || 0;
                        document.body.dataset._scrollY = String(scrollY);
                        // lock by fixing body position which prevents mobile overscroll too
                        document.body.style.position = 'fixed';
                        document.body.style.top = `-${scrollY}px`;
                        document.body.style.left = '0';
                        document.body.style.right = '0';
                        document.body.style.overflow = 'hidden';
                    }catch(e){}
                    modal.classList.remove('hidden');
                }catch(e){ console.log('openModal failed', e); }
            }
            function closeModal(){ try{ modal.classList.add('hidden'); try{
                        // restore scroll and body styles
                        const prevOverflow = document.body.dataset._prevOverflow || '';
                        const prevPosition = document.body.dataset._prevPosition || '';
                        const prevTop = document.body.dataset._prevTop || '';
                        const scrollY = parseInt(document.body.dataset._scrollY || '0', 10) || 0;
                        document.body.style.overflow = prevOverflow;
                        document.body.style.position = prevPosition;
                        document.body.style.top = prevTop;
                        // remove temp dataset keys
                        delete document.body.dataset._prevOverflow; delete document.body.dataset._prevPosition; delete document.body.dataset._prevTop; delete document.body.dataset._scrollY;
                        // restore scroll position
                        window.scrollTo(0, scrollY);
                    }catch(e){} }catch(e){} }
            seeAllBtn?.addEventListener('click', openModal);
            closeBtn?.addEventListener('click', closeModal);
            // close on backdrop click (also restore scroll)
            modal?.addEventListener('click', (ev)=>{ if(ev.target === modal || ev.target.classList.contains('modal-backdrop')) closeModal(); });
        })();
            // Ensure bindings work even if the $ helper isn't in this scope
            try{ document.getElementById('beginFromPreview')?.addEventListener('click', startQuiz); }catch(e){}
            try{ document.getElementById('startBtn')?.addEventListener('click', startQuiz); }catch(e){}
            (function(){
                const btn = document.getElementById('sampleBtn');
                if(!btn) return;
                btn.addEventListener('click', function(){
                    try{
                        const paste = document.getElementById('paste');
                        if(paste) paste.value = `Q1. Why is protein purification essential in biochemistry?\n- It prevents oxidation of DNA\n- It allows isolation and study of specific proteins free from contaminants\n- It enables bacterial transformation\n- It increases cell growth rate\nQ2. Which of the following high-resolution methods requires highly purified protein samples?\n- Mass spectrometry\n- Chromatography\n- X-ray crystallography, NMR, or cryo-EM\n- Ultrafiltration\nANSWER KEY\n1. B\n2. C`;
                        // call the parsing routine if available
                        try{ if(typeof doParse === 'function') doParse(); else document.getElementById('parseBtn')?.click(); }catch(e){}
                    }catch(e){ console.warn('sampleBtn handler failed', e); }
                });
            })();
            $('file').addEventListener('change', async (e) => { const f = e.target.files[0]; if (!f) return; const txt = await f.text(); $('paste').value = normalizeGreek(txt); doParse(); });
            // show chosen filenames in styled wrappers
            $('file')?.addEventListener('change', (e)=>{ const f = e.target.files?.[0]; const name = f ? f.name : 'No file chosen'; const span = document.getElementById('fileNameTxt'); if(span) span.textContent = name; });
            $('aiFile')?.addEventListener('change', (e)=>{
                const files = Array.from(e.target.files||[]);
                const span = document.getElementById('aiFileName');
                if(!span){ return; }
                if(files.length === 0){ span.textContent = 'No file chosen'; }
                else if(files.length === 1){ span.textContent = files[0].name; }
                else { span.textContent = `${files.length} files selected`; }
            });

        })();
    </script>
    <script>
    /* === Saved MCQs: storage + UI wiring === */
    (function(){
        const LS_KEY = 'mcq.pastes.v1';
        const byId = (id)=> document.getElementById(id);
    const savedList = byId('savedList');
    const savedCount = byId('savedCount');
    const savedMenu = byId('savedMenu');
    const toggleBtn = byId('toggleSavedBtn');
        const refreshBtn = byId('refreshSavedBtn');
        const clearBtn = byId('clearSavedBtn');
        const indexBtn = byId('indexPasteBtn');
        const pasteEl = byId('paste');

        function loadAll(){ try{ return JSON.parse(localStorage.getItem(LS_KEY)||'[]'); }catch{ return []; } }
        function saveAll(arr){ try{ localStorage.setItem(LS_KEY, JSON.stringify(arr)); }catch(e){ alert('Could not save to local storage.'); } }
        function now(){ const d=new Date(); return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`; }
        function shortTitle(s){ s=s||''; return s.split('\n').map(l=>l.trim()).filter(Boolean)[0]||'Untitled'; }

    // helper: safe filename
    function sanitizeFilenameLocal(s){ try{ return String(s||'untitled').replace(/[\\/:*?"<>|\x00-\x1F]/g,'_').replace(/\s+/g,' ').trim().slice(0,180); }catch(e){ return 'untitled'; } }

    // helper: ensure JSZip for bulk export of local saved MCQs
    async function loadJSZip(){ if(window.JSZip) return window.JSZip; try{ await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js'; s.onload=res; s.onerror=rej; document.head.appendChild(s); }); return window.JSZip; }catch(e){ console.warn('Failed to load JSZip', e); throw e; } }

        function render(){
            if(!savedList||!savedCount) return;
            const arr = loadAll(); savedCount.textContent = String(arr.length);
            // compute total bytes across saved items
            try{
                const totalBytes = arr.reduce((acc,it)=>{
                    try{ if(it && it.text) return acc + (it.text.length||0); }catch(e){}
                    return acc;
                },0);
                const elTotal = document.getElementById('savedTotalKb'); if(elTotal) elTotal.textContent = `Total: ${(totalBytes/1024).toFixed(1)} KB`;
            }catch(e){}
            if(!arr.length){ savedList.innerHTML = '<div class="hint">No saved items yet. Use "Save MCQ" to save your paste.</div>'; return; }
                savedList.innerHTML = arr.map((it, i)=>
                    `<div class="saved-item" data-i="${i}">
                        <div class="si-main">
                            <div class="si-title" contenteditable="true" spellcheck="false">${(it.title||'Untitled').replace(/&/g,'&amp;').replace(/</g,'&lt;')}</div>
                            <div class="si-meta">${it.date||''}</div>
                        </div>
                        <div class="si-actions">
                            <button class="btn small" data-act="export">Export</button>
                            <button class="btn small" data-act="delete">Delete</button>
                        </div>
                    </div>`
                ).join('');
            savedList.querySelectorAll('.saved-item').forEach(el=>{
                // Inline title editing
                const titleEl = el.querySelector('.si-title');
                const idx = Number(el.getAttribute('data-i'));
                function commitTitle(newTitle){
                    const arr2 = loadAll(); const itm = arr2[idx]; if(!itm) return;
                    // Sanitize and default
                    const t = String(newTitle || '').replace(/[\r\n]+/g,' ').trim() || 'Untitled';
                    itm.title = t; saveAll(arr2);
                    // Re-render to ensure consistency and to escape HTML
                    render();
                }
                titleEl && titleEl.addEventListener('keydown', (e)=>{
                    if(e.key==='Enter'){
                        e.preventDefault(); titleEl.blur();
                    } else if(e.key==='Escape'){
                        e.preventDefault();
                        const arr2 = loadAll(); const itm = arr2[idx]; if(itm){ titleEl.textContent = itm.title || 'Untitled'; }
                        titleEl.blur();
                    }
                    e.stopPropagation();
                });
                titleEl && titleEl.addEventListener('blur', ()=>{ commitTitle(titleEl.textContent||''); });

                // Item click actions: clicking the main area loads/pastes the item; buttons (delete) remain functional
                el.addEventListener('click', (e)=>{
                    const i = Number(el.getAttribute('data-i'));
                    const arr = loadAll(); const item = arr[i]; if(!item) return;
                    const btn = (e.target && e.target.closest) ? e.target.closest('[data-act]') : null;
                    if(btn){
                        const act = btn.getAttribute('data-act');
                        if(act==='delete'){
                            if(confirm('Delete this saved MCQ set?')){ arr.splice(i,1); saveAll(arr); render(); }
                        } else if(act==='export'){
                            try{
                                const item = arr[i]; if(!item) return;
                                const text = item.text || '';
                                const filename = sanitizeFilenameLocal((item.title||shortTitle(text))) + '.txt';
                                const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
                                const a = document.createElement('a'); const url = URL.createObjectURL(blob); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); try{ a.remove(); }catch{} }, 3000);
                            }catch(e){ console.error('export failed', e); alert('Export failed: ' + (e?.message||e)); }
                        }
                    } else {
                        // if click happened inside the editable title, allow editing (do not load)
                        if(e.target && e.target.closest && e.target.closest('.si-title')){
                            // let the click focus the editable title
                            return;
                        }
                        // perform load/paste
                        if(pasteEl){ pasteEl.value = item.text||''; try{ document.getElementById('parseBtn')?.click(); }catch{} }
                        try{ window.scrollTo({ top: document.getElementById('setup').offsetTop, behavior: 'smooth' }); }catch(e){}
                    }
                    e.preventDefault(); e.stopPropagation();
                });
            });
        }

        indexBtn && indexBtn.addEventListener('click', ()=>{
            const txt = (pasteEl && pasteEl.value)||''; if(!txt.trim()){ alert('Paste your questions first.'); return; }
            const arr = loadAll();
            arr.unshift({ id: Date.now().toString(36), date: now(), title: shortTitle(txt), text: txt });
            saveAll(arr); render();
            indexBtn.classList.add('saved'); indexBtn.textContent = 'Saved';
            setTimeout(()=>{ indexBtn.classList.remove('saved'); indexBtn.textContent = 'Save MCQ'; }, 1800);
        });

        // Positioning + portal helpers
        const savedCard = byId('savedMcqs');
        let portalPlaceholder = null;
        function ensurePortaled(){
            if(!savedMenu) return;
            if(savedMenu.parentNode === document.body) return;
            try{
                portalPlaceholder = document.createComment('saved-menu-portal');
                savedMenu.parentNode.insertBefore(portalPlaceholder, savedMenu);
                document.body.appendChild(savedMenu);
            }catch{}
        }
        function restorePortal(){
            try{
                if(portalPlaceholder && portalPlaceholder.parentNode){
                    portalPlaceholder.parentNode.insertBefore(savedMenu, portalPlaceholder);
                    portalPlaceholder.remove();
                }else if(savedCard){
                    savedCard.appendChild(savedMenu);
                }
            }catch{}
        }
        function positionSavedMenu(){
            try{
                if(!savedMenu.classList.contains('open')) return;
                // Match the width and left edge of the parent card
                const parentEl = (byId('savedMcqs') || toggleBtn);
                const parentRect = parentEl.getBoundingClientRect();
                // Use the bottom of the parent card so the dropdown clearly separates from the card
                const margin = 12; // visible separation between card and dropdown
                const menuW = Math.ceil(parentRect.width);
                // Absolute page coordinates so the menu scrolls with content
                const scrollY = window.scrollY || window.pageYOffset;
                const scrollX = window.scrollX || window.pageXOffset;
                const top = Math.round(parentRect.bottom + margin + scrollY);
                let left = Math.round(parentRect.left + scrollX);
                const maxLeft = Math.max(0, window.innerWidth - menuW - 8);
                if(left > maxLeft) left = maxLeft;
                savedMenu.style.top = top + 'px';
                savedMenu.style.left = left + 'px';
                savedMenu.style.width = menuW + 'px';
            }catch{}
        }
        let onScrollOrResize = null;
        function bindReposition(){
            if(onScrollOrResize) return;
            onScrollOrResize = ()=> positionSavedMenu();
            // On scroll/resize, recompute absolute page coordinates
            window.addEventListener('scroll', onScrollOrResize, true);
            window.addEventListener('resize', onScrollOrResize);
        }
        function unbindReposition(){
            if(!onScrollOrResize) return;
            window.removeEventListener('scroll', onScrollOrResize, true);
            window.removeEventListener('resize', onScrollOrResize);
            onScrollOrResize = null;
        }

        toggleBtn && toggleBtn.addEventListener('click', ()=>{
            const opening = !savedMenu.classList.contains('open');
            if(opening){ ensurePortaled(); }
            const open = savedMenu.classList.toggle('open');
            toggleBtn.textContent = open ? 'Hide' : 'Show';
            toggleBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
            if(open){ positionSavedMenu(); bindReposition(); }
            else { unbindReposition(); restorePortal(); }
        });
        // Close on outside click or Escape
        document.addEventListener('mousedown', (e)=>{
            try{
                if(!savedMenu.classList.contains('open')) return;
                if(e.target.closest('#savedMenu') || e.target.closest('#toggleSavedBtn')) return;
                savedMenu.classList.remove('open');
                toggleBtn.textContent = 'Show';
                toggleBtn.setAttribute('aria-expanded', 'false');
                unbindReposition();
                restorePortal();
            }catch{}
        });
        document.addEventListener('keydown', (e)=>{
            if(e.key === 'Escape' && savedMenu.classList.contains('open')){
                savedMenu.classList.remove('open');
                toggleBtn.textContent = 'Show';
                toggleBtn.setAttribute('aria-expanded', 'false');
                unbindReposition();
                restorePortal();
            }
        });
        refreshBtn && refreshBtn.addEventListener('click', render);
        clearBtn && clearBtn.addEventListener('click', ()=>{ if(confirm('Clear all saved MCQ sets?')){ saveAll([]); render(); } });

        // initial render
        render();

        // Bulk export for localStorage saved MCQs (zips each saved item into .txt files)
        async function exportAllLocalSaved(){ try{
            const btn = document.getElementById('exportAllSavedBtn'); if(btn){ btn.disabled = true; const old = btn.textContent; btn.textContent = 'Preparing…'; }
            const items = loadAll(); if(!items || !items.length){ alert('No saved MCQs to export.'); if(btn){ btn.disabled=false; btn.textContent = 'Export all'; } return; }
            // ensure JSZip
            await loadJSZip(); const zip = new window.JSZip();
            for(let i=0;i<items.length;i++){
                try{
                    const it = items[i]; const title = it.title || (`saved-${i+1}`);
                    const fname = sanitizeFilenameLocal(title) + '.txt';
                    const content = String(it.text || it.payload || '');
                    zip.file(fname, content);
                }catch(e){ console.warn('skipping item during zip', e); }
            }
            const blob = await zip.generateAsync({ type: 'blob' });
            const zipName = `saved-mcqs-${(new Date()).toISOString().replace(/[:.]/g,'-')}.zip`;
            const a = document.createElement('a'); const url = URL.createObjectURL(blob); a.href = url; a.download = zipName; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); try{ a.remove(); }catch{} }, 5000);
            if(btn){ btn.disabled=false; btn.textContent = 'Export all'; }
        }catch(e){ console.error('exportAllLocalSaved failed', e); alert('Export all failed: ' + (e?.message||e)); try{ const b = document.getElementById('exportAllSavedBtn'); if(b){ b.disabled=false; b.textContent='Export all'; } }catch{} }
        }
        // Expose and ensure binding: attach a delegated click handler so the button works
        try{
            window.exportAllLocalSaved = exportAllLocalSaved;
            if(!window.__exportAllSavedDelegatedBound){
                document.addEventListener('click', function(e){
                    try{
                        const t = e.target && e.target.closest ? e.target.closest('#exportAllSavedBtn') : null;
                        if(!t) return;
                        e.preventDefault(); if(t.disabled) return; window.exportAllLocalSaved && window.exportAllLocalSaved();
                    }catch(err){}
                });
                window.__exportAllSavedDelegatedBound = true;
            }
        }catch(e){}
    })();
    /* === end Saved MCQs === */
    </script>
    <script>
    // AI: Reformat & Assign Answers — writes results back to #paste
    (function(){
        const $ = (id)=>document.getElementById(id);
        const btn = $('aiFixBtn'); const stat = $('aiFixStatus'); const paste = $('paste');
        function setStatus(msg){ if(stat) stat.textContent = msg || ''; }
        function isEnabled(){ return !!document.getElementById('globalGemEnable')?.checked; }
        function keyVal(){ return (document.getElementById('globalGemKey')?.value||'').trim(); }
        // Mirror global key state into this panel's badge/button
        function sync(){ try{
            const ok = !!keyVal() && isEnabled();
            const badge = document.getElementById('fixKeyBadge');
            if(badge){ badge.classList.toggle('ok', ok); badge.classList.toggle('missing', !ok); const h=badge.querySelector('.hint'); if(h) h.textContent = ok ? 'Key set' : 'No key set'; }
            if(btn) btn.disabled = !ok;
        }catch{} }
        document.getElementById('globalGemKey')?.addEventListener('input', sync);
        document.getElementById('globalGemEnable')?.addEventListener('change', sync);
        sync();

        async function reformatWithAI(raw){
            const key = keyVal(); if(!key || !isEnabled()) throw new Error('API key disabled or missing.');
            if(!window.GoogleGenerativeAI){ try{ const mod = await import('https://esm.run/@google/generative-ai'); window.GoogleGenerativeAI = mod.GoogleGenerativeAI; }catch(e){ throw new Error('Could not load Gemini SDK.'); } }
            const client = new window.GoogleGenerativeAI(key);
            const model = client.getGenerativeModel({ model: 'gemini-2.5-flash' });
            const prompt = `You are a strict formatter for multiple-choice question sets.
Input may be messy, partial, or missing an ANSWER KEY. Your job:
1) Ensure every question starts with "Qn." where n is a sequential integer starting at 1.
2) Each option must be on its own line, prefixed with a hyphen and a space ("- "). Keep 4 options when possible; if more/less exist, keep what's present.
3) Ensure there is a final block titled exactly "ANSWER KEY" followed by lines "n. X" where X is the correct letter.
4) If an answer is not provided in the input for any question, infer a SINGLE best answer from the options and include it in the ANSWER KEY.
5) Do NOT add explanations or extra commentary. Output ONLY the cleaned MCQ set in the target format.

 IMPORTANT: Preserve all Unicode characters exactly, including Greek letters and symbols (e.g., α β γ δ ε θ μ π σ φ Ω). Do not transliterate to Latin or replace with names. If an input character cannot be determined, leave it unchanged rather than substituting placeholder glyphs.

Target format example:
Q1. Example question text?
- Option one
- Option two
- Option three
- Option four
Q2. ...
...
ANSWER KEY
1. B
2. D
...

Now reformat the following exactly into that target format:
-----
${raw}
-----`;
            const resp = await model.generateContent({ contents: [{ role:'user', parts:[{ text: prompt }] }] });
            const text = resp?.response?.text?.() || resp?.response?.candidates?.[0]?.content?.parts?.map(p=>p.text||'').join('') || '';
            if(!text.trim()) throw new Error('Empty response from model.');
            return text.trim();
        }

        btn && btn.addEventListener('click', async ()=>{
            try{
                const src = (paste?.value||'').trim(); if(!src){ alert('Paste your MCQs first.'); return; }
                setStatus('Contacting Gemini 2.5…'); btn.disabled = true;
                const out = await reformatWithAI(src);
                paste.value = normalizeGreek(out); setStatus('Reformatted. Re-parsing…');
                document.getElementById('parseBtn')?.click();
                setTimeout(()=> setStatus(''), 1200);
            }catch(err){ console.warn('AI fix failed', err); setStatus('AI error: ' + (err?.message||err)); alert('AI error: ' + (err?.message||err)); }
            finally{ btn.disabled = false; }
        });
    })();
    </script>
        <script>
    // Make any "Back to Setup" button return to setup WITHOUT reloading (preserves radio playback)
    (function(){
        const $ = (id)=>document.getElementById(id);
        function goToSetupPreserveAudio(){
            try{
                const setup = $('setup'); const preview = $('preview'); const quiz = $('quiz');
                if(setup) setup.classList.remove('hidden');
                if(preview) preview.classList.add('hidden');
                const resetBar = $('resetBar'); if(resetBar) resetBar.style.display = 'none';
                // Hide and reset Results + Analyze sections
                try{
                    const results = document.getElementById('results-card');
                    if(results){
                        results.classList.add('hidden');
                        const sum = document.getElementById('resultsSummary'); if(sum) sum.innerHTML = '';
                        const stat = document.getElementById('resultsAiStatus'); if(stat) stat.textContent = '';
                            try{ if(typeof window.stopAiOutput === 'function'){ window.stopAiOutput(); } else { const out = document.getElementById('resultsAiOutput'); if(out) out.textContent = ''; } }catch{}
                        const sel = document.getElementById('attemptSelect'); if(sel) sel.innerHTML = '';
                        const miss = document.getElementById('attemptMissedList'); if(miss) miss.innerHTML = '';
                    }
                    // Clear attempt tracking
                    try{ state.attempts = []; state.currentAttempt = null; }catch{}
                }catch{}
                // Ensure AI panels (Validate and Like Questions) reappear on Setup
        // Auto mode UI is managed by initAiFileGenNew(); do not rebind here.
                try{ document.getElementById('ai-likeq')?.classList.remove('hidden'); }catch{}
                try{ document.getElementById('ai-likeq-copy')?.classList.remove('hidden'); }catch{}
                try{ document.querySelector('.ai-file-panel')?.classList.remove('hidden'); }catch{}
                // Mark as not parsed so init code won't auto-hide these until the next parse
                try{ window.__parsed = false; }catch{}
                // Ensure the textbook library is visible and refreshed when returning to setup
                try{ document.getElementById('textbook-lib')?.classList.remove('hidden'); }catch{}
                try{ if(window.refreshTextbookLibrary) window.refreshTextbookLibrary(); }catch{}
                // Do not touch the radio/audio state; just navigate views.
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }catch(e){ console.warn('Back to setup (no-reload) failed', e); }
        }
        document.addEventListener('click', function (e) {
            const btn = e.target.closest('#backSetup');
            if (!btn) return;
            e.preventDefault();
            // Avoid bubbling to any legacy handlers that might reload
            e.stopPropagation();
            goToSetupPreserveAudio();
        });
    })();
    </script>
</body>
<script>
    (async function aiLikeInit() {
        // Try to load Gemini SDK if not present (safe no-op if already loaded)
        if (!window.GoogleGenerativeAI) {
            try {
                const mod = await import("https://esm.run/@google/generative-ai");
                window.GoogleGenerativeAI = mod.GoogleGenerativeAI;
            } catch (e) {
                console.warn("Gemini SDK load failed (will retry on click).", e);
            }
        }

        const $ = id => document.getElementById(id);
        const wrap = $("ai-likeq");
        const btn = $("aiLikeBtn");
        // Use the global Gemini API key bar instead of a separate key input
        const stat = $("aiLikeStatus");

        // Ensure buttons reflect the current global key AND enable toggle (safe local updater)
        function updateKeyState(){
            try{
                const val = (document.getElementById('globalGemKey')?.value||'').trim();
                const enabled = !!document.getElementById('globalGemEnable')?.checked;
                const ok = !!val && enabled;
                const badge = document.getElementById('globalKeyBadge');
                if(badge){ badge.classList.toggle('ok', ok); badge.classList.toggle('missing', !ok); const h=badge.querySelector('.hint'); if(h) h.textContent = ok ? 'Key set' : 'No key set'; }
                if(btn) btn.disabled = !ok;
                // also update the results card key badge and analyze button
                const rBadge = document.getElementById('resultsKeyBadge');
                if(rBadge){ rBadge.classList.toggle('ok', ok); rBadge.classList.toggle('missing', !ok); const h=rBadge.querySelector('.hint'); if(h) h.textContent = ok ? 'Key set' : 'No key set'; }
                const analyze = document.getElementById('analyzeMissedBtn'); if(analyze) analyze.disabled = !ok;
            }catch{}
        }
        // run once on init
        updateKeyState();
    // also watch for changes to the global key and enable toggle
    document.getElementById('globalGemKey')?.addEventListener('input', updateKeyState);
    document.getElementById('globalGemEnable')?.addEventListener('change', updateKeyState);

    // Hide this whole card once quiz has actually had a successful parse + start
    function hideAiLike() { try{ if(window.__parsed) { if(wrap){ wrap.classList.add('hidden'); } } }catch{} }
    document.getElementById("startBtn")?.addEventListener("click", hideAiLike);
    document.getElementById("beginFromPreview")?.addEventListener("click", hideAiLike);

    // Prevent double-binding across duplicate initializers
    if(btn && btn.dataset.boundLike === '1') return;
    if(btn) btn.dataset.boundLike = '1';
    btn?.addEventListener("click", async () => {
            const paste = document.getElementById("paste");
            if (!paste || !paste.value.trim()) { alert("Paste your questions first."); return; }

            // Ensure SDK
            if (!window.GoogleGenerativeAI) {
                try {
                    const mod = await import("https://esm.run/@google/generative-ai");
                    window.GoogleGenerativeAI = mod.GoogleGenerativeAI;
                } catch (e) {
                    alert("Could not load Gemini SDK. Check your connection and try again.");
                    return;
                }
            }

            // Read key + check enable toggle from global top bar
            const key = (document.getElementById('globalGemKey')?.value || '').trim();
            const enabled = !!document.getElementById('globalGemEnable')?.checked;
            if (!key || !enabled) { alert('Enable the API key (toggle in the key bar) and enter your Gemini API key.'); stat.textContent = 'API key disabled or missing.'; return; }

            // Build strict, structure-preserving prompt
            const original = paste.value;
            const prompt =
                `You are to conservatively rewrite the following MCQ set into LIKE-QUESTIONS for practice.
You MUST preserve:
- The exact document structure and formatting.
- The SAME number of questions.
- Each question prefixed "Q<number>. " on its own line.
- Each option on its own line, prefixed with "- ".
- Do NOT label options with letters or numbers. Do not prefix options with "A.", "B)", "(C)", "1.", "a)", etc. The ONLY identifier for an option line is the leading "- ".
- A final "ANSWER KEY" section with one line per question in the form "<number>. <LETTER>".
- Exactly ONE correct option per question; options must be mutually exclusive and plausible.
- Domain and difficulty should be similar; small surface changes are preferred (synonyms, numerics, contexts).
- Do NOT include any extra commentary, JSON, or Markdown. Output ONLY the rewritten text.

Also:
- Ensure correctness: internally verify each keyed answer truly matches the best option.
- Keep language clear and unambiguous; avoid clues that trivially reveal the answer.
- If any item is malformed, repair it conservatively to follow the rules above.

Rewrite this set now:

${original}`;

            btn.disabled = true;
            const orig = btn.textContent;
            btn.innerHTML = '<span class="spinner" aria-hidden="true"></span> Contacting…';
            stat.textContent = "Contacting Gemini 2.5…";
            try {
                const AI = window.GoogleGenerativeAI;
                const client = new AI(key);
                const model = client.getGenerativeModel({ model: "gemini-2.5-flash" });

                const resp = await model.generateContent({
                    contents: [{ role: "user", parts: [{ text: prompt }] }]
                });

                const text = (await resp?.response?.text?.())?.trim();
                if (!text) throw new Error("Empty response from model.");

                // Very basic sanity checks to reduce surprises
                if (!/^\s*Q\s*\d+\./mi.test(text) || !/^\s*ANSWER\s+KEY\s*$/mi.test(text)) {
                    if (!confirm("The AI output didn't clearly match the expected structure. Insert anyway?")) {
                        stat.textContent = "Cancelled.";
                        try{
                            // Restore label reliably
                            const live = document.getElementById(btn?.id) || btn;
                            live.disabled = false;
                            live.innerHTML = orig;
                        }catch{}
                        return;
                    }
                }

                paste.value = text;

                // If your page has a "Parse & Preview" button with id=parseBtn, click it automatically
                document.getElementById("parseBtn")?.click();
                stat.textContent = "Replaced with like-questions.";
            } catch (err) {
                console.error(err);
                stat.textContent = "AI generation failed.";
                alert("Gemini error: " + (err?.message || err));
            } finally {
                try{
                    const live = document.getElementById(btn?.id) || btn;
                    live.disabled = false;
                    live.innerHTML = orig;
                }catch{}
            }
        });
    })();
    (function resultsAnalysisInit(){
        const $ = id=>document.getElementById(id);
        // Keep analyze button in sync with key state using existing updater via input/change events
        function syncFromGlobalKey(){ try{
            const val = (document.getElementById('globalGemKey')?.value||'').trim();
            const enabled = !!document.getElementById('globalGemEnable')?.checked;
            const ok = !!val && enabled; const analyze = $('analyzeMissedBtn'); if(analyze) analyze.disabled = !ok;
            const rBadge = $('resultsKeyBadge'); if(rBadge){ rBadge.classList.toggle('ok', ok); rBadge.classList.toggle('missing', !ok); const h=rBadge.querySelector('.hint'); if(h) h.textContent = ok ? 'Key set' : 'No key set'; }
        }catch{} }
        document.getElementById('globalGemKey')?.addEventListener('input', syncFromGlobalKey);
        document.getElementById('globalGemEnable')?.addEventListener('change', syncFromGlobalKey);
    // Initialize state on load so Analyze button/key badge are correct
    try{ syncFromGlobalKey(); }catch{}

    const btn = $('analyzeMissedBtn');
    // Define runner first so both direct and delegated bindings can use it
    async function runResultsAnalysis(targetBtn){
            try{
                const state = (window.__quizState || window.state || window.__STATE__);
                if(!state){
                    const s = document.getElementById('resultsAiStatus'); if(s) s.textContent = 'Internal error: quiz state unavailable.';
                    return;
                }
                const key = (document.getElementById('globalGemKey')?.value||'').trim();
                const enabled = !!document.getElementById('globalGemEnable')?.checked;
                if(!key || !enabled){ alert('Enable the API key and enter your Gemini API key.'); return; }
                // Ensure SDK
                if(!window.GoogleGenerativeAI){ try{ const mod = await import('https://esm.run/@google/generative-ai'); window.GoogleGenerativeAI = mod.GoogleGenerativeAI; }catch(e){ alert('Could not load Gemini SDK.'); return; } }
    // Show immediate feedback that click is captured
    try{ const s = document.getElementById('resultsAiStatus'); if(s) s.textContent = 'Preparing analysis…'; try{ if(typeof window.stopAiOutput === 'function'){ window.stopAiOutput(); } else { const o = document.getElementById('resultsAiOutput'); if(o) o.textContent = ''; } }catch{} }catch{}
                // Helper: resolve selected attempt id reliably (prefer dropdown, then button dataset)
                function getSelectedAttemptId(){
                    try{
                        const sel = document.getElementById('attemptSelect');
                        if(sel && sel.value){ return String(sel.value); }
                    }catch{}
                    try{
                        const ab = document.getElementById('analyzeMissedBtn');
                        const did = ab?.dataset?.selAttemptId; if(did!=null && did!==''){ return String(did); }
                    }catch{}
                    // fallback: use most recent attempt id
                    try{
                        const atts = Array.isArray(state.attempts) ? state.attempts : [];
                        if(atts.length){ return String(atts[atts.length-1].id); }
                    }catch{}
                    return null;
                }
                function findAttemptById(attempts, idStr){
                    if(!idStr) return null; return attempts.find(z => String(z.id) === String(idStr)) || null;
                }
                // Collect missed questions for the selected attempt, or aggregate across ALL attempts if none selected
                function collectMissed(){
                    try{
                        const attempts = Array.isArray(state.attempts) ? state.attempts : [];
                        if(!attempts.length){
                            // fallback to current state if attempts missing
                            const res = [];
                            (state.items||[]).forEach((it, ix)=>{
                                const r = state.answered[ix]; const wasWrong = !r || !r.submitted || !r.correct;
                                if(wasWrong){ res.push({ num: it.num, q: it.q, choices: it.choices.slice(), correctIdx: it.correctIdx, user: r && r.selected!=null ? r.selected : null, attemptId: 0 }); }
                            });
                            return res;
                        }
                        // Resolve selected attempt and use that snapshot if available
                        const selIdStr = getSelectedAttemptId();
                        if(selIdStr!=null){
                            const a = findAttemptById(attempts, selIdStr);
                            if(a){
                                return (a.missed||[]).map(m => ({ num: m.num, q: m.q, choices: (m.choices||[]).slice(), correctIdx: m.correctIdx, user: m.user, attemptId: a.id, mode: a.mode }));
                            }
                        }
                        // Otherwise aggregate across all attempts
                        const out = [];
                        attempts.forEach(a=>{ (a.missed||[]).forEach(m=>{ out.push({ num: m.num, q: m.q, choices: (m.choices||[]).slice(), correctIdx: m.correctIdx, user: m.user, attemptId: a.id, mode: a.mode }); }); });
                        return out;
                    }catch(e){ return []; }
                }
                const selectedAttemptId = getSelectedAttemptId();
                const attemptsArr = Array.isArray(state.attempts) ? state.attempts : [];
                const selectedAttempt = selectedAttemptId ? findAttemptById(attemptsArr, selectedAttemptId) : null;
                let missedItems = collectMissed();
                const status = $('resultsAiStatus'); const output = $('resultsAiOutput');
                // Early feedback so users see the click did something
                try{ if(missedItems.length && selectedAttempt){ status.textContent = `Preparing analysis for attempt ${selectedAttempt.id} — ${missedItems.length} missed.`; } }catch{}
                // If selected attempt has zero misses, auto-fallback to most recent attempt with misses
                if(selectedAttempt && (!selectedAttempt.missed || selectedAttempt.missed.length===0)){
                    const fallback = attemptsArr.slice().reverse().find(a=>a.missed && a.missed.length);
                    if(fallback){
                        missedItems = (fallback.missed||[]).map(m => ({ num: m.num, q: m.q, choices: (m.choices||[]).slice(), correctIdx: m.correctIdx, user: m.user, attemptId: fallback.id, mode: fallback.mode }));
                        try{ const sel = document.getElementById('attemptSelect'); if(sel){ sel.value = String(fallback.id); } }catch{}
                        try{ status.textContent = `Preparing analysis for attempt ${fallback.id} — ${missedItems.length} missed.`; }catch{}
                    }
                }
                    if(!missedItems.length){
                    // Clarify scope in status message with selected attempt id
                    if(selectedAttempt){ status.textContent = `No missed questions in the selected attempt (id ${selectedAttempt.id}) to analyze.`; }
                    else {
                        try{ const sel = document.getElementById('attemptSelect'); if(sel && sel.value){ status.textContent = `No missed questions in the selected attempt to analyze.`; } else { status.textContent = 'No missed questions across attempts to analyze.'; } }catch{ status.textContent = 'No missed questions to analyze.'; }
                    }
                    try{ if(typeof window.stopAiOutput === 'function'){ window.stopAiOutput(); } else { output.textContent=''; } }catch{} return; }
                // Build text block of missed Qs in simple structure
                const letters = ['A','B','C','D','E','F'];
                const block = missedItems.map(it=>{
                    const userLine = (it.user==null? 'None' : `${letters[it.user]}. ${it.choices[it.user]}`);
                    const att = it.attemptId ? `Attempt: ${it.attemptId}${it.mode? ' ('+it.mode+')':''}` : '';
                    return `${att}\nQ${it.num}. ${it.q}\n${it.choices.map((c,i)=>`- ${letters[i]}. ${c}`).join('\n')}\nUser selected: ${userLine}\nCorrect answer: ${letters[it.correctIdx]}. ${it.choices[it.correctIdx]}`;
                }).join('\n\n');

                // Mention scope (selected attempt vs all attempts)
                let scope = 'across all attempts';
                if(selectedAttempt){ scope = `for attempt ${selectedAttempt.id}`; }
                const prompt = `You are a precise tutor. Analyze the missed MCQs ${scope}. For each missed item, give a 1-2 sentence explanation of the correct reasoning and why the chosen answer was wrong. Then summarize trends/patterns across mistakes and give concise, actionable study tips. Output plain text only (no Markdown).\n\nMISSED QUESTIONS (with user selections and correct keys):\n\n${block}`;

                const AI = window.GoogleGenerativeAI; const client = new AI(key);
                const model = client.getGenerativeModel({ model: 'gemini-2.5-flash' });
                const liveBtn = document.getElementById('analyzeMissedBtn') || targetBtn;
                liveBtn.disabled = true; const orig = liveBtn.textContent; liveBtn.innerHTML = '<span class="spinner" aria-hidden="true"></span> Analyzing…';
                status.textContent = 'Contacting Gemini 2.5…'; try{ if(typeof window.stopAiOutput === 'function'){ window.stopAiOutput(); } else { output.textContent=''; } }catch{}
                try{
                    const resp = await model.generateContent({ contents: [{ role:'user', parts:[{ text: prompt }] }] });
                    const text = (await resp?.response?.text?.())?.trim();
                    // animated textbook-style output (typewriter + ASCII face + noise)
                    try{ if(typeof window.showAiOutput === 'function'){ window.showAiOutput(text || 'No analysis returned.'); } else { output.textContent = text || 'No analysis returned.'; } }catch(e){ output.textContent = text || 'No analysis returned.'; }
                    status.textContent = 'Done.';
                }catch(e){
                    console.error('Results AI error', e);
                    status.textContent = 'AI analysis failed.';
                    output.textContent = (e?.message || String(e||'')).toString();
                }finally{
                    liveBtn.disabled = false; liveBtn.textContent = orig;
                }
            }catch(err){ console.error(err); }
        }
        // Direct binding when button is present
        try{
            if(btn && btn.dataset.bound !== '1'){
                btn.dataset.bound = '1';
                btn.addEventListener('click', (e)=>{ e.preventDefault(); if(btn.disabled) return; runResultsAnalysis(btn); });
            }
        }catch{}
        // Delegated binding (aligns with other button logic) so clicks are caught even if button was added later
        try{
            if(!window.__resultsAnalysisDelegatedBound){
                document.addEventListener('click', function(e){ const t = e.target && e.target.closest ? e.target.closest('#analyzeMissedBtn') : null; if(!t) return; e.preventDefault(); if(t.disabled) return; runResultsAnalysis(t); });
                window.__resultsAnalysisDelegatedBound = true;
            }
        }catch{}
    })();
    (async function aiLikeInit2() {
        // Second copy initializer for the duplicated like-questions module
        if (!window.GoogleGenerativeAI) {
            try {
                const mod = await import("https://esm.run/@google/generative-ai");
                window.GoogleGenerativeAI = mod.GoogleGenerativeAI;
            } catch (e) { /* ignore - will retry on click */ }
        }
    const $ = id => document.getElementById(id);
    const wrap = $("ai-likeq-copy");
    const btn = $("aiLikeBtn2");
    const stat = $("aiLikeStatus2");
    // Local helpers to avoid ReferenceErrors from other modules
    const letters = ['A','B','C','D','E','F'];
    const esc = s => (String(s||'')).replace(/[&<>"']/g, c => ({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]));
    const decodeNumericEntities = (s)=> String(s||'').replace(/&#(x?)([0-9A-Fa-f]+);/g, (m, x, code) => { try{ const cp = x?parseInt(code,16):parseInt(code,10); if(!isFinite(cp)||cp<0||cp>0x10FFFF) return m; return String.fromCodePoint(cp); }catch{ return m; } });
    const GREEK_MAP = { '&alpha;':'α','&beta;':'β','&gamma;':'γ','&delta;':'δ','&epsilon;':'ε','&zeta;':'ζ','&eta;':'η','&theta;':'θ','&iota;':'ι','&kappa;':'κ','&lambda;':'λ','&mu;':'μ','&nu;':'ν','&xi;':'ξ','&omicron;':'ο','&pi;':'π','&rho;':'ρ','&sigma;':'σ','&tau;':'τ','&upsilon;':'υ','&phi;':'φ','&chi;':'χ','&psi;':'ψ','&omega;':'ω','&Alpha;':'Α','&Beta;':'Β','&Gamma;':'Γ','&Delta;':'Δ','&Epsilon;':'Ε','&Zeta;':'Ζ','&Eta;':'Η','&Theta;':'Θ','&Iota;':'Ι','&Kappa;':'Κ','&Lambda;':'Λ','&Mu;':'Μ','&Nu;':'Ν','&Xi;':'Ξ','&Omicron;':'Ο','&Pi;':'Π','&Rho;':'Ρ','&Sigma;':'Σ','&Tau;':'Τ','&Upsilon;':'Υ','&Phi;':'Φ','&Chi;':'Χ','&Psi;':'Ψ','&Omega;':'Ω','&sigmaf;':'ς','&thetasym;':'ϑ','&upsih;':'ϒ','&varphi;':'ϕ' };
    const decodeGreekNamed = (s)=> String(s||'').replace(/&(alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Alpha|Beta|Gamma|Delta|Epsilon|Zeta|Eta|Theta|Iota|Kappa|Lambda|Mu|Nu|Xi|Omicron|Pi|Rho|Sigma|Tau|Upsilon|Phi|Chi|Psi|Omega|sigmaf|thetasym|upsih|varphi);/g, (m)=> GREEK_MAP[m]||m);
    const safeText = (s)=> esc(decodeGreekNamed(decodeNumericEntities(s)));

        function updateKeyState(){
            try{
                const val = (document.getElementById('globalGemKey')?.value||'').trim();
                const enabled = !!document.getElementById('globalGemEnable')?.checked;
                const ok = !!val && enabled;
                const badge = document.getElementById('globalKeyBadge2');
                if(badge){ badge.classList.toggle('ok', ok); badge.classList.toggle('missing', !ok); const h=badge.querySelector('.hint'); if(h) h.textContent = ok ? 'Key set' : 'No key set'; }
                if(btn) btn.disabled = !ok;
            }catch{}
        }
        updateKeyState();
    document.getElementById('globalGemKey')?.addEventListener('input', updateKeyState);
    document.getElementById('globalGemEnable')?.addEventListener('change', updateKeyState);

    function hideAiLike() { try{ if(window.__parsed) { if(wrap){ wrap.classList.add('hidden'); } } }catch{} }
    document.getElementById("startBtn")?.addEventListener("click", hideAiLike);
    document.getElementById("beginFromPreview")?.addEventListener("click", hideAiLike);

    // Prevent double-binding across duplicate initializers
    if(btn && btn.dataset.boundLike === '1') return;
    if(btn) btn.dataset.boundLike = '1';
    btn?.addEventListener("click", async () => {
            const paste = document.getElementById("paste");
            if (!paste || !paste.value.trim()) { alert("Paste your questions first."); return; }

            if (!window.GoogleGenerativeAI) {
                try { const mod = await import("https://esm.run/@google/generative-ai"); window.GoogleGenerativeAI = mod.GoogleGenerativeAI; } catch (e) { alert("Could not load Gemini SDK. Check your connection and try again."); return; }
            }

            const key = (document.getElementById('globalGemKey')?.value || '').trim();
            const enabled = !!document.getElementById('globalGemEnable')?.checked;
            if (!key || !enabled) { alert('Enable the API key (toggle in the key bar) and enter your Gemini API key.'); stat.textContent = 'API key disabled or missing.'; return; }

            const original = paste.value;
            const extraCtx = (window.__tbValidateCtx?.pieces||[]).map(p=> p.text).join('\n\n');
            const prompt = `You are a strict MCQ answer validator. Input is a list of questions with options and an ANSWER KEY. OUTPUT FORMAT (exact):\n\n1) First line must be a single summary line in the form:\nSummary: <CORRECT_COUNT> CORRECT, <INCORRECT_COUNT> INCORRECT\n\n2) After the summary, list ONLY the incorrectly keyed questions, one per line, using this exact format:\nQ<N>: correct is <LETTER>\n\nDo NOT list questions that are correct. Do NOT include any extra commentary, explanation, JSON, or blank lines beyond the required summary and the incorrect-question lines.\n\nUse the following textbook context ONLY to help judge correctness (do not quote it back):\n\n${extraCtx}\n\nHere is the document to validate:\n\n${original}`;

            btn.disabled = true; const orig = btn.textContent; btn.innerHTML = '<span class="spinner" aria-hidden="true"></span> Contacting…';
            stat.textContent = "Contacting Gemini 2.5…";
            try {
                const AI = window.GoogleGenerativeAI;
                const client = new AI(key);
                const model = client.getGenerativeModel({ model: "gemini-2.5-flash" });

                const resp = await model.generateContent({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
                const text = (await resp?.response?.text?.())?.trim();
                if (!text) throw new Error("Empty response from model.");

                // Expect a summary line followed by zero-or-more incorrect-question lines.
                if(!/Summary\s*:\s*\d+\s*(?:OK|CORRECT)\s*,\s*\d+\s*(?:MISMATCH|INCORRECT)/mi.test(text)){
                    if(!confirm('Model output did not include the expected summary line. Display anyway?')){ stat.textContent = 'Cancelled.'; return; }
                }

                // Parse Gemini's concise validator lines and render only mismatched question blocks
                const dst = document.getElementById('aiValidateOutput2');
                try{
                    const full = (text||'').split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
                    // collect counts and mismatches (model now returns a summary first, then only incorrect items)
                    let okCount = 0, mismatchCount = 0;
                    const mismatches = {}; // qnum -> correctLetter
                    for(const line of full){
                        // summary line like: Summary: 12 OK, 1 INCORRECT
                        const sm = line.match(/^Summary\s*:\s*(\d+)\s*(?:OK|CORRECT)\s*,\s*(\d+)\s*(?:MISMATCH|INCORRECT)/i);
                        if(sm){ okCount = parseInt(sm[1],10)||okCount; mismatchCount = parseInt(sm[2],10)||mismatchCount; continue; }

                        // incorrect lines: Q<N>: correct is <LETTER>  OR  Q<N>: <LETTER>
                        const m1 = line.match(/^Q\s*(\d+)\s*:\s*(?:correct\s+is\s+)?([A-F])/i);
                        if(m1){ mismatches[m1[1]] = m1[2].toUpperCase(); continue; }
                    }

                    // Parse the original document into items and pick mismatched ones (use global parser if needed)
                    const parser = (typeof window !== 'undefined' && window.parseDoc) ? window.parseDoc : (typeof parseDoc === 'function' ? parseDoc : null);
                    const items = parser ? parser(original || '') : [];
                    const mismatchedItems = items.filter(it => mismatches[it.num]);

                                        // rendering helpers (show current Key and AI-correct letter side by side)
                    const renderItemHTML = it => {
                        const currentKey = letters[it.correctIdx] || 'A';
                        const aiKey = (mismatches[String(it.num)] || '').toUpperCase();
                        const choicesHtml = it.choices.map((c,i)=>{
                            const L = (letters[i]||'?');
                            let cls = 'validator-choice';
                            if(L === aiKey) cls += ' correct';
                            if(L === currentKey && L !== aiKey) cls += ' wrong';
                            return `<div class="${cls}" style="margin:0"><span class="tag">${L}.</span> ${safeText(c)}</div>`;
                        }).join('');
                        return `<div class="qcard"><div><strong>Q${esc(it.num)}.</strong> ${safeText(it.q)}</div><div style="margin-top:6px">${choicesHtml}</div><div class="hint" style="margin-top:6px; display:flex; align-items:center; justify-content:space-between; gap:12px"><div>Key: <span class="tag">${currentKey}</span></div><div>Correct: <span class="tag">${aiKey || '?'}</span></div></div></div>`;
                    };
                    const renderListHTML = list => list.map(renderItemHTML).join('');

                    const globalApply = document.getElementById('validatorApplyBtnGlobal');
                    if(globalApply){ globalApply.classList.add('hidden'); globalApply.style.display = 'none'; globalApply.disabled = false; globalApply.textContent = 'Apply corrections to text'; globalApply._mismatches = null; }
                    if(!dst) {
                        stat.textContent = 'Validation complete.';
                    } else if(mismatchCount === 0){
                        dst.innerHTML = `<div><strong>Summary:</strong> ${okCount} CORRECT, ${mismatchCount} INCORRECT</div><div class="hint">All answers appear correct.</div>`;
                        if(globalApply) { globalApply.classList.add('hidden'); globalApply.style.display = 'none'; globalApply._mismatches = null; }
                        try{ window.hideValidatorApplyButton && window.hideValidatorApplyButton(); }catch(e){}
                        stat.textContent = 'Validation complete.';
                    } else {
                        // collapsed / expanded UI with show more / show less
                        const collapsedN = Math.min(3, mismatchedItems.length);
                        const collapsedHTML = `<div><strong>Summary:</strong> ${okCount} CORRECT, ${mismatchCount} INCORRECT</div>` + renderListHTML(mismatchedItems.slice(0, collapsedN)) + (mismatchedItems.length>collapsedN ? `<div style="margin-top:8px"><a href="#" id="validator-show-more" class="linkish">(show more)</a></div>` : '');
                        const expandedHTML = `<div><strong>Summary:</strong> ${okCount} CORRECT, ${mismatchCount} INCORRECT</div>` + renderListHTML(mismatchedItems) + `<div style="margin-top:8px"><a href="#" id="validator-show-less" class="linkish">(show less)</a></div>`;

                        dst.innerHTML = collapsedHTML;
                        dst.style.cursor = 'auto';
                        // The apply button will render under the Validate button via window.showValidatorApplyButton

                        const attachShowMore = () => {
                            const a = dst.querySelector('#validator-show-more');
                            if(!a) return;
                            if(a._attached) return; a._attached = true;
                            a.addEventListener('click', e=>{
                                e.preventDefault();
                                dst.innerHTML = expandedHTML;
                                const less = dst.querySelector('#validator-show-less');
                                if(less){
                                    if(!less._attached){ less._attached = true; less.addEventListener('click', e2=>{ e2.preventDefault(); dst.innerHTML = collapsedHTML; attachShowMore(); }); }
                                }
                            });
                        };

                        // initial attachments
                        attachShowMore();

                        try{ window.showValidatorApplyButton && window.showValidatorApplyButton(mismatches); }catch(e){ console.error(e); }
                        // Fallback placement to ensure visibility right under the output
                        try{
                            const actions = document.getElementById('aiValidateActions');
                            if(actions){
                                let applyBtn = document.getElementById('validatorApplyBtnGlobal');
                                if(!applyBtn){
                                    applyBtn = document.createElement('button');
                                    applyBtn.id = 'validatorApplyBtnGlobal';
                                    applyBtn.className = 'btn';
                                    applyBtn.textContent = 'Apply corrections to text';
                                }
                                applyBtn._mismatches = mismatches;
                                applyBtn.classList.remove('hidden');
                                applyBtn.style.display = 'inline-block';
                                applyBtn.style.background = '#2563eb';
                                applyBtn.style.color = '#fff';
                                applyBtn.style.border = '1px solid rgba(255,255,255,0.06)';
                                if(applyBtn.parentNode !== actions){ actions.appendChild(applyBtn); }
                                if(!applyBtn._attached){
                                    applyBtn._attached = true;
                                    applyBtn.addEventListener('click', function(e){ e.preventDefault(); try{ window.applyValidationCorrections && window.applyValidationCorrections(applyBtn._mismatches||{}); applyBtn.textContent = 'Incorrect Answers Corrected'; applyBtn.disabled = true; }catch(err){ console.error('Apply corrections failed', err); } });
                                }
                            }
                        }catch(e){ console.error('fallback apply placement failed', e); }

                        stat.textContent = 'Validation complete.';
                    }
                }catch(e){
                    console.error('Render validator output failed', e);
                    if(dst) dst.textContent = (text||'');
                    stat.textContent = 'Validation complete.';
                }
            } catch (err) {
                console.error(err);
                stat.textContent = "AI validation failed.";
                // fallback to local validator if available
                try{
                    // Use local validator to find mismatches and render same UI
                    const txt = paste.value || '';
                    const res = window.answerValidator.validate(txt);
                    const dst = document.getElementById('aiValidateOutput2');
                    if(!dst){ stat.textContent = res.ok ? 'Local validation CORRECT.' : 'Local validation found issues.'; }
                    // If local found issues, try to extract which questions are missing/incorrect
                    const parser2 = (typeof window !== 'undefined' && window.parseDoc) ? window.parseDoc : (typeof parseDoc === 'function' ? parseDoc : null);
                    const items = parser2 ? parser2(txt) : [];
                    const badNums = new Set();
                    if(!res.ok){
                        res.issues.forEach(i=>{
                            const m = (i||'').match(/Q(\d+)/); if(m) badNums.add(m[1]);
                            const m2 = (i||'').match(/Missing answer for Q(\d+)/i); if(m2) badNums.add(m2[1]);
                        });
                    }
                    const mismatchedItems = items.filter(it=>badNums.has(it.num));
                    const globalApply = document.getElementById('validatorApplyBtnGlobal');
                    if(mismatchedItems.length===0){
                        if(dst) dst.innerHTML = `<div><strong>Summary:</strong> ${res.ok ? `${res.questions} CORRECT, 0 INCORRECT` : 'Issues detected'}</div><div class="hint">All answers appear correct.</div>`;
                        if(globalApply){ globalApply.classList.add('hidden'); globalApply._mismatches = null; }
                        try{ window.hideValidatorApplyButton && window.hideValidatorApplyButton(); }catch(e){}
                    } else {
                        const renderItemHTML = it => {
                            const currentKey = letters[it.correctIdx] || 'A';
                            const aiKey = (mismatchesMap && mismatchesMap[String(it.num)]) ? mismatchesMap[String(it.num)] : '?';
                            const choicesHtml = it.choices.map((c,i)=>{
                                const L = (letters[i]||'?');
                                let cls = 'validator-choice';
                                if(L === aiKey) cls += ' correct';
                                if(L === currentKey && L !== aiKey) cls += ' wrong';
                                return `<div class="${cls}" style="margin:0"><span class="tag">${L}.</span> ${safeText(c)}</div>`;
                            }).join('');
                            return `<div class="qcard"><div><strong>Q${esc(it.num)}.</strong> ${safeText(it.q)}</div><div style="margin-top:6px">${choicesHtml}</div><div class="hint" style="margin-top:6px; display:flex; align-items:center; justify-content:space-between; gap:12px"><div>Key: <span class="tag">${currentKey}</span></div><div>Correct: <span class="tag">${aiKey}</span></div></div></div>`;
                        };
                        const collapsedHTML = `<div><strong>Summary:</strong> Local issues: ${mismatchedItems.length} INCORRECT</div>` + mismatchedItems.slice(0,3).map(renderItemHTML).join('') + (mismatchedItems.length>3?`<div style="margin-top:8px"><a href="#" id="validator-show-more" class="linkish">(show more)</a></div>`:'');
                        const expandedHTML = `<div><strong>Summary:</strong> Local issues: ${mismatchedItems.length} INCORRECT</div>` + mismatchedItems.map(renderItemHTML).join('') + `<div style="margin-top:8px"><a href="#" id="validator-show-less" class="linkish">(show less)</a></div>`;
                        dst.innerHTML = collapsedHTML;
                        if(mismatchedItems.length>3){ const a = dst.querySelector('#validator-show-more'); if(a) a.addEventListener('click', e=>{ e.preventDefault(); dst.innerHTML = expandedHTML; const less = dst.querySelector('#validator-show-less'); if(less) less.addEventListener('click', e2=>{ e2.preventDefault(); dst.innerHTML = collapsedHTML; }); }); }
                        try{ const mismatchesMap = {}; mismatchedItems.forEach(it=>{ mismatchesMap[String(it.num)] = (letters[it.correctIdx]||'A'); }); window.showValidatorApplyButton && window.showValidatorApplyButton(mismatchesMap); }catch(e){ console.error(e); }
                    }
                }catch(ex){ alert("Gemini error: " + (err?.message || err)); }
            } finally {
                try{
                    const liveBtn = document.getElementById(btn?.id);
                    if(liveBtn) { liveBtn.disabled = false; try{ liveBtn.innerHTML = orig; }catch{} }
                    else if(btn) { btn.disabled = false; try{ btn.innerHTML = orig; }catch{} }
                }catch{}
            }
        });
    })();
    (async function aiLikeInit() {
        // Try to load Gemini SDK if not present (safe no-op if already loaded)
        if (!window.GoogleGenerativeAI) {
            try {
                const mod = await import("https://esm.run/@google/generative-ai");
                window.GoogleGenerativeAI = mod.GoogleGenerativeAI;
            } catch (e) {
                console.warn("Gemini SDK load failed (will retry on click).", e);
            }
        }

        const $ = id => document.getElementById(id);
        const wrap = $("ai-likeq");
        const btn = $("aiLikeBtn");
        // Use the global Gemini API key bar instead of a separate key input
        const stat = $("aiLikeStatus");

        // Ensure buttons reflect the current global key (safe local updater)
        function updateKeyState(){
            try{
                const val = (document.getElementById('globalGemKey')?.value||'').trim();
                const ok = !!val;
                const badge = document.getElementById('globalKeyBadge');
                if(badge){ badge.classList.toggle('ok', ok); badge.classList.toggle('missing', !ok); badge.querySelector('.hint').textContent = ok ? 'Key set' : 'No key set'; }
                if(btn) btn.disabled = !ok;
            }catch{}
        }
        // run once on init
        updateKeyState();
        // also watch for changes to the global key
        document.getElementById('globalGemKey')?.addEventListener('input', updateKeyState);

    // Hide this whole card once quiz begins
    function hideAiLike() { try{ if(window.__parsed) { if(wrap){ wrap.classList.add('hidden'); } } }catch{} }
    document.getElementById("startBtn")?.addEventListener("click", hideAiLike);
    document.getElementById("beginFromPreview")?.addEventListener("click", hideAiLike);

    // Prevent double-binding across duplicate initializers
    if(btn && btn.dataset.boundLike === '1') return;
    if(btn) btn.dataset.boundLike = '1';
    btn?.addEventListener("click", async () => {
            const paste = document.getElementById("paste");
            if (!paste || !paste.value.trim()) { alert("Paste your questions first."); return; }

            // Ensure SDK
            if (!window.GoogleGenerativeAI) {
                try {
                    const mod = await import("https://esm.run/@google/generative-ai");
                    window.GoogleGenerativeAI = mod.GoogleGenerativeAI;
                } catch (e) {
                    alert("Could not load Gemini SDK. Check your connection and try again.");
                    return;
                }
            }

            // Read key from global top bar
            const key = (document.getElementById('globalGemKey')?.value || '').trim();
            if (!key) { alert('Enter your Gemini API key in the top "Gemini API Key" bar.'); return; }

            // Build strict, structure-preserving prompt
            const original = paste.value;
            const prompt =
                `You are to conservatively rewrite the following MCQ set into LIKE-QUESTIONS for practice.
You MUST preserve:
- The exact document structure and formatting.
- The SAME number of questions.
- Each question prefixed "Q<number>. " on its own line.
- Each option on its own line, prefixed with "- ".
- A final "ANSWER KEY" section with one line per question in the form "<number>. <LETTER>".
- Exactly ONE correct option per question; options must be mutually exclusive and plausible.
- Domain and difficulty should be similar; small surface changes are preferred (synonyms, numerics, contexts).
- Do NOT include any extra commentary, JSON, or Markdown. Output ONLY the rewritten text.

Also:
- Ensure correctness: internally verify each keyed answer truly matches the best option.
- Keep language clear and unambiguous; avoid clues that trivially reveal the answer.
- If any item is malformed, repair it conservatively to follow the rules above.

Rewrite this set now:

${original}`;

            btn.disabled = true;
            const orig = btn.textContent;
            btn.innerHTML = '<span class="spinner" aria-hidden="true"></span> Contacting…';
            stat.textContent = "Contacting Gemini 2.5…";
            try {
                const AI = window.GoogleGenerativeAI;
                const client = new AI(key);
                const model = client.getGenerativeModel({ model: "gemini-2.5-flash" });

                const resp = await model.generateContent({
                    contents: [{ role: "user", parts: [{ text: prompt }] }]
                });

                const text = (await resp?.response?.text?.())?.trim();
                if (!text) throw new Error("Empty response from model.");

                // Very basic sanity checks to reduce surprises
                if (!/^\s*Q\s*\d+\./mi.test(text) || !/^\s*ANSWER\s+KEY\s*$/mi.test(text)) {
                    if (!confirm("The AI output didn't clearly match the expected structure. Insert anyway?")) {
                        stat.textContent = "Cancelled.";
                        try{
                            const live = document.getElementById(btn?.id) || btn;
                            live.disabled = false;
                            live.innerHTML = orig;
                        }catch{}
                        return;
                    }
                }

                paste.value = text;

                // If your page has a "Parse & Preview" button with id=parseBtn, click it automatically
                document.getElementById("parseBtn")?.click();
                stat.textContent = "Replaced with like-questions.";
            } catch (err) {
                console.error(err);
                stat.textContent = "AI generation failed.";
                alert("Gemini error: " + (err?.message || err));
            } finally {
                try{
                    const live = document.getElementById(btn?.id) || btn;
                    live.disabled = false;
                    live.innerHTML = orig;
                }catch{}
            }
        });
    })();
</script>
<script>
/* Avoid static ESM imports here so this script runs even under file://. */

const $ = (id)=>document.getElementById(id);

/* Global key persistence */
(function setupGlobalKey(){
  const keyI = $('globalGemKey');
  const chk = $('globalGemRemember');
    const en  = $('globalGemEnable');
    const badge = document.getElementById('globalKeyBadge');
    function isEnabled(){ return !!(en ? en.checked : true); }
    function updateKeyUI(){
        const rawVal = (keyI?.value||'').trim();
        const ok = !!rawVal && isEnabled();
        try{
            // update all badges with these ids (handles duplicate-id copies)
            const badgeIds = ['globalKeyBadge','globalKeyBadge2','validateKeyBadge','validateKeyBadgeCopy','fileGenKeyBadge'];
            badgeIds.forEach(id => {
                const nodes = document.querySelectorAll('#' + id);
                nodes.forEach(b => {
                    b.classList.toggle('ok', ok); b.classList.toggle('missing', !ok);
                    const h = b.querySelector('.hint'); if(h) h.textContent = ok ? 'Key set' : 'No key set';
                });
            });

            // update all buttons with these ids (include the Daily Random Quiz button so it is disabled when no key)
            const btnIds = ['aiLikeBtn','aiLikeBtn2','aiFileGenBtn','validateAnswersBtn','aiValidateBtn','dailyQuizBtn','randomQuizBtn'];
            btnIds.forEach(id => {
                const nodes = document.querySelectorAll('#' + id);
                nodes.forEach(n => {
                    try{ n.disabled = !ok; }catch{};
                    try{ if(!ok) n.setAttribute('aria-disabled', 'true'); else n.removeAttribute('aria-disabled'); }catch{};
                });
            });
            // top-left single dot
            const topDot = document.getElementById('globalKeyDot'); if(topDot){ topDot.classList.toggle('ok', ok); topDot.classList.toggle('missing', !ok); }
            // daily button dot (left side of Daily Random Quiz)
            const dailyDot = document.getElementById('dailyKeyDot'); if(dailyDot){ dailyDot.classList.toggle('ok', ok); dailyDot.classList.toggle('missing', !ok); }
            // random button dot (left side of Random Quiz)
            const randomDot = document.getElementById('randomKeyDot'); if(randomDot){ randomDot.classList.toggle('ok', ok); randomDot.classList.toggle('missing', !ok); }
            // AI Explanation header dot
            const aiDot = document.getElementById('aiExplanationKeyDot'); if(aiDot){ aiDot.classList.toggle('ok', ok); aiDot.classList.toggle('missing', !ok); try{ aiDot.title = ok ? 'API key enabled' : 'API key disabled'; aiDot.style.background = ok ? '#16a34a' : '#ef4444'; }catch(e){} }
            // switch label
            const lab = document.getElementById('globalGemEnableLabel'); if(lab){ lab.textContent = isEnabled() ? 'enabled' : 'disabled'; }
        }catch{}
    }
    // Shared helper used by various AI flows to resolve the effective Gemini key
    window.getEffectiveGemKey = function(){
        try{
            const input = document.getElementById('globalGemKey');
            const enable = document.getElementById('globalGemEnable');
            const remember = document.getElementById('globalGemRemember');
            if(enable && enable.checked === false) return null;
            if(input && String(input.value||'').trim()){
                const v = String(input.value).trim();
                try{ if(remember && remember.checked) localStorage.setItem('gemini.key', v); }catch(e){}
                return v;
            }
            try{ const stored = localStorage.getItem('gemini.key'); if(stored) return stored; }catch(e){}
            return null;
        }catch(e){ return null; }
    };
  try{
    const k = localStorage.getItem('gemKeyGlobal');
    if(k){ keyI.value = k; chk.checked = true; }
  }catch{}
    // update UI after restoring stored key and reflect default toggle OFF
    updateKeyUI();
    chk?.addEventListener('change', ()=>{
    try{
      if(chk.checked) localStorage.setItem('gemKeyGlobal', keyI.value||'');
      else localStorage.removeItem('gemKeyGlobal');
    }catch{}
  });
    en?.addEventListener('change', ()=>{
        // toggling does not destroy stored key; it only affects whether features treat it as present
        updateKeyUI();
    });
    // Watch storage events so badges update across tabs
    window.addEventListener('storage', (ev)=>{ if(ev.key && (ev.key==='gemini.key' || ev.key==='gemKeyGlobal')){ updateKeyUI(); } });
    keyI?.addEventListener('input', ()=>{
        if(chk.checked){ try{ localStorage.setItem('gemKeyGlobal', keyI.value||''); }catch{} }
        updateKeyUI();
    });
    keyI?.addEventListener('change', updateKeyUI);
})();

/* ---------- AI Output Preview helper (global) ---------- */
window.showPreviewModal = function(previewText, warningText, cb){
    try{
        const modal = document.getElementById('aiPreviewModal');
        const content = document.getElementById('aiPreviewContent');
        const hint = document.getElementById('aiPreviewHint');
        const insertBtn = document.getElementById('aiPreviewInsert');
        const cancelBtn = document.getElementById('aiPreviewCancel');
        const closeBtn = document.getElementById('aiPreviewClose');
        if(!modal || !content || !insertBtn) { cb && cb(true); return; }
        // fill
        content.textContent = previewText || '';
        hint.textContent = warningText || '';
        modal.classList.remove('hidden'); modal.setAttribute('aria-hidden','false');

        function cleanup(){
            modal.classList.add('hidden'); modal.setAttribute('aria-hidden','true');
            insertBtn.removeEventListener('click', onInsert); cancelBtn.removeEventListener('click', onCancel); closeBtn.removeEventListener('click', onCancel);
        }
        function onInsert(){ cleanup(); cb && cb(true); }
        function onCancel(){ cleanup(); cb && cb(false); }
        insertBtn.addEventListener('click', onInsert);
        cancelBtn.addEventListener('click', onCancel);
        closeBtn.addEventListener('click', onCancel);
    }catch(e){ console.error(e); cb && cb(true); }
};

// Apply validator corrections into the pasted document's ANSWER KEY and reparse
window.applyValidationCorrections = function(mismatches){
    try{
        if(!mismatches || typeof mismatches !== 'object') return;
        const paste = document.getElementById('paste');
        if(!paste) return;
    const text = normalizeGreek(paste.value || '');
        const lines = text.replace(/\r\n?/g,'\n').split('\n');
        const keyIdx = lines.findIndex(l => /^\s*ANSWER\s+KEY\s*$/i.test(l));
        // build a map of existing answers
        const answerLines = [];
        if(keyIdx !== -1){
            for(let k = keyIdx+1; k < lines.length; k++){
                if(!/^\s*\d+/i.test(lines[k])) break;
                answerLines.push(lines[k]);
            }
        }

        // create or replace answer key section
        const maxQ = Object.keys(mismatches).reduce((m,n)=> Math.max(m, parseInt(n,10)||0), 0);
        const items = [];
        // If parsed items exist, we prefer to use their numbering; fallback to mismatches keys
        try{ const parsed = window.parseDoc && window.parseDoc(paste.value || ''); parsed && parsed.forEach(it=> items.push(it.num)); }catch{};

        // Build replacement lines: keep other lines intact, replace or append ANSWER KEY
        const newLines = [];
        if(keyIdx === -1){
            // append ANSWER KEY at end
            newLines.push(...lines);
            newLines.push('');
            newLines.push('ANSWER KEY');
            // if we have parsed items, use those numbers; otherwise use mismatch keys
            const qnums = items.length ? items : Object.keys(mismatches).map(n=>parseInt(n,10)).sort((a,b)=>a-b);
            qnums.forEach(n=>{
                const k = String(n);
                const letter = mismatches[k] || '';
                newLines.push(`${n}. ${letter}`);
            });
        } else {
            // copy until ANSWER KEY header
            newLines.push(...lines.slice(0, keyIdx+1));
            // build a map of existing answers to preserve non-mismatched ones
            const existing = {};
            for(let k = keyIdx+1; k < lines.length; k++){
                const m = lines[k].match(/^(\d+)\s*\.?\s*([A-F])/i);
                if(!m) break;
                existing[m[1]] = m[2].toUpperCase();
            }
            // compute full set of question numbers to write
            const qnums = Array.from(new Set([ ...Object.keys(existing).map(n=>parseInt(n,10)), ...Object.keys(mismatches).map(n=>parseInt(n,10)) ])).filter(Boolean).sort((a,b)=>a-b);
            qnums.forEach(n=>{
                const k = String(n);
                const letter = (mismatches[k] || existing[k] || '').toUpperCase();
                newLines.push(`${n}. ${letter}`);
            });
        }

        // commit and reparse
    paste.value = normalizeGreek(newLines.join('\n'));
        // trigger parse
        const btn = document.getElementById('parseBtn'); if(btn) btn.click();
    }catch(e){ console.error('applyValidationCorrections', e); }
};

// UI helpers to show/hide the global Apply Corrections button under the validator output
window.showValidatorApplyButton = function(mismatches){
    try{
        let btn = document.getElementById('validatorApplyBtnGlobal');
        // If the button isn't in the DOM for any reason, create it
        if(!btn){
            btn = document.createElement('button');
            btn.id = 'validatorApplyBtnGlobal';
            btn.className = 'btn';
            btn.textContent = 'Apply corrections to text';
        }
        btn._mismatches = mismatches || null;
        btn.classList.remove('hidden');
        btn.style.display = 'inline-block';
        btn.style.background = '#2563eb';
        btn.style.color = '#fff';
        btn.style.border = '1px solid rgba(255,255,255,0.06)';
        btn.style.marginTop = '8px';
        btn.disabled = false;
        btn.textContent = 'Apply corrections to text';
        if(!btn._attached){
            btn._attached = true;
            btn.addEventListener('click', function onValidatorApply(e){
                e.preventDefault();
                try{
                    window.applyValidationCorrections && window.applyValidationCorrections(btn._mismatches);
                    btn.textContent = 'Incorrect Answers Corrected';
                    btn.disabled = true;
                }catch(err){ console.error('Apply corrections failed', err); btn.textContent = 'Apply failed'; }
            });
        }
        // Place the button directly under the validator output area
        try{
            const dst = document.getElementById('aiValidateOutput2');
            const actions = document.getElementById('aiValidateActions');
            if((actions || dst) && (actions?.parentNode || dst?.parentNode)){
                // Ensure margin reset suitable for below-output placement
                btn.style.marginLeft = '0px';
                btn.style.marginTop = '8px';
                // Preferred: actions container just beneath output
                if(actions){
                    if(btn.parentNode !== actions){ actions.appendChild(btn); }
                } else if(dst){
                    // Fallback: insert after output element
                    if(btn.parentNode !== dst.parentNode || btn.previousElementSibling !== dst){
                        dst.parentNode.insertBefore(btn, dst.nextSibling);
                    }
                }
                try{ btn.scrollIntoView({behavior:'smooth', block:'nearest'}); }catch(e){}
            } else {
                // Fallback to floating position near output rect if present
                try{ window.showFloatingApply && window.showFloatingApply(mismatches, dst); }catch(_){ }
            }
        }catch(e){ console.error('showValidatorApplyButton placement error', e); }
    }catch(e){ console.error(e); }
};

window.hideValidatorApplyButton = function(){
    try{
        const btn = document.getElementById('validatorApplyBtnGlobal');
        if(!btn) return;
        btn._mismatches = null;
        btn.disabled = false;
        btn.textContent = 'Apply corrections to text';
        btn.style.display = 'none';
        btn.classList.add('hidden');
    }catch(e){ console.error(e); }
};

// Floating apply button: create a visible floating button positioned under the validator output
window.showFloatingApply = function(mismatches, dstElement){
    try{
        // create container if not present
        let wrap = document.getElementById('validatorApplyFloating');
        if(!wrap){
            wrap = document.createElement('div'); wrap.id = 'validatorApplyFloating';
            wrap.style.position = 'fixed'; wrap.style.zIndex = 99999; wrap.style.display = 'none';
            wrap.style.pointerEvents = 'auto';
            const btn = document.createElement('button'); btn.id = 'validatorApplyFloatingBtn'; btn.className = 'btn';
            btn.style.padding = '8px 12px'; btn.style.borderRadius = '10px'; btn.style.background = '#2563eb'; btn.style.color = '#fff'; btn.style.border = '1px solid rgba(255,255,255,0.06)';
            btn.textContent = 'Apply corrections to text';
            wrap.appendChild(btn);
            document.body.appendChild(wrap);
            btn.addEventListener('click', function(e){ e.preventDefault(); try{ window.applyValidationCorrections && window.applyValidationCorrections(wrap._mismatches||{}); btn.textContent = 'Incorrect Answers Corrected'; btn.disabled = true; }catch(err){ console.error(err); btn.textContent = 'Apply failed'; } });
        }
        // attach mismatches
        wrap._mismatches = mismatches || {};
        // position under dstElement if provided
        let left = 20, top = window.innerHeight - 80;
        if(dstElement && dstElement.getBoundingClientRect){
            const r = dstElement.getBoundingClientRect();
            left = Math.max(8, r.left + window.scrollX);
            top = r.bottom + window.scrollY + 8;
            // if off screen at bottom, clamp
            if(top + 48 > window.scrollY + window.innerHeight) top = window.scrollY + window.innerHeight - 64;
        }
        wrap.style.left = left + 'px'; wrap.style.top = top + 'px'; wrap.style.display = 'block';
        // ensure visible
        try{ wrap.scrollIntoView({behavior:'smooth', block:'nearest'}); }catch(e){}
    }catch(e){ console.error('showFloatingApply', e); }
};

window.hideFloatingApply = function(){ try{ const w = document.getElementById('validatorApplyFloating'); if(w) w.style.display = 'none'; }catch(e){ } };

/* ---------- Answer validator (client-side; placeholder for server-side integration) ---------- */
window.answerValidator = {
    parseQuestions(text){
        const lines = (text||'').replace(/\r\n?/g,'\n').split('\n');
        const qre = /^Q\s*(\d+)\.\s*(.+)$/i;
        const items = [];
        for(let i=0;i<lines.length;i++){
            const m = lines[i].match(qre);
            if(m) items.push({num: parseInt(m[1],10), text: m[2].trim(), line: i+1});
        }
        return items;
    },
    parseAnswerKey(text){
        const lines = (text||'').replace(/\r\n?/g,'\n').split('\n');
        const keyIdx = lines.findIndex(l => /^\s*ANSWER\s+KEY\s*$/i.test(l));
        if(keyIdx === -1) return {keyMap:{}, startLine:-1};
        const keyMap = {};
        for(let k=keyIdx+1;k<lines.length;k++){
            const m = lines[k].match(/^(\d+)\s*\.?\s*([A-F])/i);
            if(m) keyMap[parseInt(m[1],10)] = m[2].toUpperCase();
        }
        return {keyMap, startLine: keyIdx+1};
    },
    validate(text){
        const qs = this.parseQuestions(text);
        const {keyMap, startLine} = this.parseAnswerKey(text);
        const issues = [];
        if(qs.length === 0) issues.push('No questions found (expect lines starting `Q1. ` etc).');
        // check numbering sequence
        const nums = qs.map(q=>q.num).sort((a,b)=>a-b);
        for(let i=0;i<nums.length;i++){
            if(nums[i] !== i+1) { issues.push(`Question numbering gap or mismatch: expected Q${i+1} but found Q${nums[i]||'?'}`); break; }
        }
        // Check answer key presence
        if(Object.keys(keyMap).length === 0) issues.push('No ANSWER KEY found or no valid entries under ANSWER KEY.');
        // Compare counts
        if(qs.length && Object.keys(keyMap).length && qs.length !== Object.keys(keyMap).length) issues.push(`Question count (${qs.length}) and ANSWER KEY entries (${Object.keys(keyMap).length}) differ.`);
        // Missing answers
        qs.forEach(q=>{ if(!(q.num in keyMap)) issues.push(`Missing answer for Q${q.num}`); });
        // Out-of-range letters and duplicates
        const seen = {};
        Object.entries(keyMap).forEach(([n,ch])=>{
            if(!/^[A-F]$/.test(ch)) issues.push(`Answer for Q${n} uses invalid letter '${ch}'. Use A-F.`);
            if(seen[n]) issues.push(`Duplicate key entry for Q${n}`);
            seen[n]=ch;
        });
        return {ok: issues.length===0, issues, questions: qs.length, answers: Object.keys(keyMap).length, keyStartLine: startLine};
    }
};

// The old runValidateAnswers handler was removed. A functional AI-like validator initializer is added below.

/* === AI: Generate MCQs from .docx/.pdf (new approach: client-side extraction) === */
(function initAiFileGenNew(){
    function bind(){
    const $ = (id) => document.getElementById(id);
    const fileInput = $('aiFile');
        const btn = $('aiFileGenBtn');
        const statusEl = $('aiFileStatus');
    const qCountEl = $('aiQCount');
    const optCountEl = $('aiOptCount');
    const autoBtn = $('aiAutoBtn');
    let autoMode = false;
        if(!fileInput || !btn || !statusEl) return false;

        // Lock button width to its initial rendered width to avoid layout reflow on label changes
        try{
            if(!btn.dataset.widthLocked){
                const w = Math.ceil(btn.getBoundingClientRect().width);
                if(w && isFinite(w)){
                    btn.style.width = w + 'px';
                    btn.style.maxWidth = w + 'px';
                    btn.style.flex = `0 0 ${w}px`;
                    btn.dataset.widthLocked = '1';
                }
            }
        }catch(e){}

        // Helper to lock/unlock the AI file row widths during processing
        function lockAiFileRow(lock){
            try{
                const row = document.querySelector('.ai-file-panel .ai-file-row');
                if(!row) return;
                const fileWrap = row.querySelector('.file-input');
                const badge = document.getElementById('fileGenKeyBadge');
                const fname = fileWrap ? fileWrap.querySelector('.filename') : null;
                const targets = [fileWrap, btn, badge, statusEl, fname].filter(Boolean);
                if(lock){
                    row.dataset.locked = '1';
                    targets.forEach(el=>{
                        const rect = el.getBoundingClientRect();
                        const w = Math.ceil(rect.width);
                        el.style.width = w + 'px';
                        el.style.maxWidth = w + 'px';
                        el.style.flex = `0 0 ${w}px`;
                    });
                } else {
                    delete row.dataset.locked;
                    targets.forEach(el=>{
                        el.style.width = '';
                        el.style.maxWidth = '';
                        el.style.flex = '';
                    });
                }
            }catch(e){}
        }

    function setStatus(msg, isError){ try{ statusEl.textContent = msg||''; statusEl.style.color = isError ? 'var(--bad)' : ''; }catch(e){} }
    function stripHtml(html){ return (html||'').replace(/<[^>]+>/g, ' ').replace(/\s+/g,' ').trim(); }
        function debugLog(...args){ try{ const p = document.getElementById('aiFileDebug'); if(!p) return; const t = args.map(a=>{ try{ return (typeof a==='string'?a:JSON.stringify(a)); }catch(e){ return String(a); } }).join(' '); p.textContent = (new Date()).toLocaleTimeString() + ' ' + t + '\n' + p.textContent; }catch(e){ console.log.apply(console, args); } }
        function loadScript(url){
            return new Promise((resolve,reject)=>{
                try{
                    const s = document.createElement('script');
                    s.src = url; s.async = true; s.onload = ()=>resolve(); s.onerror = ()=>reject(new Error('Failed to load '+url));
                    document.head.appendChild(s);
                }catch(e){ reject(e); }
            });
        }

    // Load saved prefs
    try{
        if(qCountEl){ const savedQ = parseInt(localStorage.getItem('ai.mcq.qCount')||'30',10); if(isFinite(savedQ)) qCountEl.value = String(Math.max(1, Math.min(50, savedQ))); }
        if(optCountEl){ const savedO = parseInt(localStorage.getItem('ai.mcq.optCount')||'4',10); if(isFinite(savedO)) optCountEl.value = String(Math.max(2, Math.min(6, savedO))); }
        autoMode = localStorage.getItem('ai.mcq.auto') === '1';
    }catch{}

    // Auto mode UI sync and toggle
    function syncAutoUI(){
        try{
            if(autoBtn){ autoBtn.classList.toggle('primary', !!autoMode); autoBtn.setAttribute('aria-pressed', autoMode ? 'true' : 'false'); }
            if(qCountEl) qCountEl.disabled = !!autoMode;
            if(optCountEl){ if(autoMode){ optCountEl.value = '4'; optCountEl.disabled = true; } else { optCountEl.disabled = false; } }
        }catch(e){}
    }
    syncAutoUI();
    if(autoBtn && !autoBtn.dataset.wired){
        autoBtn.addEventListener('click', (e)=>{
            e.preventDefault();
            autoMode = !autoMode;
            try{ localStorage.setItem('ai.mcq.auto', autoMode ? '1' : '0'); }catch{}
            syncAutoUI();
        });
        autoBtn.dataset.wired = '1';
    }

    btn.addEventListener('click', async (ev)=>{
        ev.preventDefault();
        console.log('[aiFileGenNew] click'); debugLog('click');
        setStatus('Starting...'); debugLog('starting');

        // Read and validate counts
    let qCount = parseInt(qCountEl?.value||'30',10); if(!isFinite(qCount)) qCount = 30; qCount = Math.max(1, Math.min(50, qCount));
    let optCount = parseInt(optCountEl?.value||'4',10); if(!isFinite(optCount)) optCount = 4; optCount = Math.max(2, Math.min(6, optCount));
    if(autoMode){ optCount = 4; }
    try{ localStorage.setItem('ai.mcq.qCount', String(qCount)); localStorage.setItem('ai.mcq.optCount', String(optCount)); }catch{}

        const key = $('globalGemKey')?.value?.trim();
        const enabled = !!document.getElementById('globalGemEnable')?.checked;
        if(!key || !enabled){ setStatus('API key disabled or missing. Enable and enter your key at the top.', true); alert('Enable the API key (toggle in the key bar) and enter your Gemini API key.'); return; }

    const files = Array.from(fileInput.files || []);
    // If no files selected, allow using the selected saved content (generator context) as the source
    let usingSavedOnly = false;
    if(files.length === 0){
        const tbTexts = (window.__tbGenCtx?.pieces || []).map(p=> p.text).filter(Boolean);
        if(tbTexts.length){
            // use the saved content as the extracted source
            usingSavedOnly = true;
            // we'll assign to `extracted` later (before sending to model)
            // show helpful status to the user
            setStatus(`Using selected source: ${window.__tbGenCtx.pieces[0]?.title || 'saved content'}`);
        } else {
            setStatus('No files selected. Choose .docx, .pdf, .pptx, or image files, or select saved content as the source.', true);
            alert('Choose .docx, .pdf, .pptx, or image files (.png, .jpg, .webp, .gif), or first select a saved content chapter and click its Generate button to set it as the source.');
            return;
        }
    }

    // Freeze row widths while we mutate labels to avoid layout jitter
    lockAiFileRow(true);
    try{ fileInput.disabled = true; }catch{}
    btn.disabled = true; btn.setAttribute('aria-busy','true'); const orig = btn.textContent; btn.innerHTML = '<span class="spinner" aria-hidden="true"></span> Contacting…';
        // Prevent changing counts while generating
    try{ if(qCountEl) qCountEl.disabled = true; if(optCountEl) optCountEl.disabled = true; }catch(e){}
        setStatus('Contacting Gemini…');
            try{
                setStatus('Reading file(s) in browser...');
                let extracted = '';

                async function extractFromFile(f){
                    const name = f?.name || 'file';
                    const lower = name.toLowerCase();
                    const isDocx = /\.docx$/i.test(lower);
                    const isPdf = /\.pdf$/i.test(lower);
                    const isPptx = /\.pptx$/i.test(lower);
                    const isImage = (f?.type && f.type.startsWith('image/')) || /\.(png|jpe?g|webp|gif)$/i.test(lower);
                    if(isDocx){
                        setStatus(`Extracting text from ${name} (.docx via mammoth)...`);
                        const ab = await f.arrayBuffer();
                        setStatus('Extracting text from .docx (mammoth)...');
                        try{
                            debugLog('loading mammoth UMD...');
                            if(!(window.mammoth && window.mammoth.convertToHtml)){
                                await loadScript('https://unpkg.com/mammoth@1.6.0/mammoth.browser.min.js');
                            }
                            if(!(window.mammoth && window.mammoth.convertToHtml)) throw new Error('mammoth not available');
                            const res = await window.mammoth.convertToHtml({ arrayBuffer: ab });
                            const text = normalizeGreek(stripHtml(res && res.value || ''));
                            debugLog('docx extracted length', text.length);
                            return text;
                        }catch(e1){
                            console.warn('[aiFileGenNew] mammoth failed', e1); debugLog('mammoth failed', e1?.message||e1);
                            // Fallback: use JSZip to read word/document.xml
                            try{
                                setStatus(`Mammoth failed for ${name}, falling back to basic .docx extraction...`);
                                debugLog('loading JSZip and extracting word/document.xml');
                                if(!(window.JSZip)){
                                    await loadScript('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js');
                                }
                                if(!window.JSZip) throw new Error('JSZip not available');
                                const zip = await window.JSZip.loadAsync(ab);
                                const entry = zip.file('word/document.xml');
                                if(!entry) throw new Error('document.xml not found in docx');
                                const xml = await entry.async('string');
                                // very naive XML -> text: keep text nodes and spaces for paragraph breaks
                                const txt = normalizeGreek(xml.replace(/<w:p[^>]*>/g, '\n')
                                                             .replace(/<w:tab\b[^>]*\/>/g, ' ')
                                                             .replace(/<w:t[^>]*>(.*?)<\/w:t>/g, '$1')
                                                             .replace(/<[^>]+>/g, ' ')
                                                             .replace(/\s+/g, ' ')
                                                             .trim());
                                debugLog('docx extracted length (fallback)', txt.length);
                                return txt;
                            }catch(e2){
                                console.warn('[aiFileGenNew] JSZip fallback failed', e2); debugLog('docx fallback failed', e2?.message||e2);
                                throw new Error('Failed to extract .docx text');
                            }
                        }
                    } else if(isPdf) {
                setStatus(`Extracting text from ${name} (PDF via pdfjs)...`);
                        const ab = await f.arrayBuffer();
                        try{
                            debugLog('loading pdfjs UMD (robust)...');
                            // Try multiple CDN candidates for pdf.js
                            const pdfCandidates = [
                                'https://cdn.jsdelivr.net/npm/pdfjs-dist@2.16.105/build/pdf.min.js',
                                'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js',
                                'https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.min.js'
                            ];
                            let pdfjs = window.pdfjsLib || window.pdfjs || null;
                            if(!(pdfjs && pdfjs.getDocument)){
                                let loaded = false;
                                for(const c of pdfCandidates){
                                    try{ await loadScript(c); debugLog('loaded pdfjs candidate', c); pdfjs = window.pdfjsLib || window['pdfjs-dist/build/pdf'] || window.pdfjsLib || window.pdfjs || window['pdfjs']; if(pdfjs && pdfjs.getDocument){ loaded = true; try{ pdfjs.GlobalWorkerOptions.workerSrc = c.replace(/pdf.min.js$/, 'pdf.worker.min.js'); }catch(e){} break; } }catch(e){ debugLog('candidate failed', c, e?.message||e); }
                                }
                                if(!pdfjs || !pdfjs.getDocument) throw new Error('pdfjsLib not available after trying CDNs');
                            }
                            try{ if(pdfjs.GlobalWorkerOptions) pdfjs.GlobalWorkerOptions.workerSrc = (pdfjs.GlobalWorkerOptions && pdfjs.GlobalWorkerOptions.workerSrc) || pdfjs.GlobalWorkerOptions.workerSrc; }catch(e){}
                            const loadingTask = pdfjs.getDocument({ data: ab });
                            const pdf = await loadingTask.promise;
                            const maxPages = pdf.numPages; let texts = [];
                            for(let p=1;p<=maxPages;p++){
                                const page = await pdf.getPage(p);
                                const content = await page.getTextContent();
                                const pageText = content.items.map(it=>it.str).join(' ');
                                texts.push(pageText);
                                if(texts.join(' ').length > 200000) break; // stop early if huge
                            }
                            const text = normalizeGreek(texts.join('\n'));
                            debugLog('pdf extracted length', text.length);
                            return text;
                        }catch(e){ console.warn('[aiFileGenNew] pdfjs robust loader failed', e); debugLog('pdfjs failed', e?.message||e); throw new Error('Failed to extract PDF text'); }
            } else if(isPptx){
                setStatus(`Extracting text from ${name} (.pptx via JSZip)...`);
                const ab = await f.arrayBuffer();
                try{
                    debugLog('loading JSZip for pptx...');
                    if(!(window.JSZip)){
                        await loadScript('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js');
                    }
                    if(!window.JSZip) throw new Error('JSZip not available');
                    const zip = await window.JSZip.loadAsync(ab);
                    // gather slide XML files in numeric order
                    const slideNames = Object.keys(zip.files)
                        .filter(n => /^ppt\/slides\/slide\d+\.xml$/i.test(n))
                        .sort((a,b)=>{
                            const na = parseInt((a.match(/slide(\d+)\.xml/i)||[])[1]||'0',10);
                            const nb = parseInt((b.match(/slide(\d+)\.xml/i)||[])[1]||'0',10);
                            return na - nb;
                        });
                    if(slideNames.length === 0) throw new Error('No slides found in PPTX');
                    const parts = [];
                    for(const name of slideNames){
                        const xml = await zip.file(name).async('string');
                        // Extract text from <a:t> nodes; treat <a:br/> and paragraph boundaries as breaks
                        const text = xml
                            .replace(/<a:br\s*\/>/gi, '\n')
                            .replace(/<a:p[^>]*>/gi, '\n')
                            .replace(/<a:t[^>]*>([\s\S]*?)<\/a:t>/gi, '$1')
                            .replace(/<[^>]+>/g, ' ')
                            .replace(/\s+/g, ' ')
                            .trim();
        
                        if(text) parts.push(text);
                        if(parts.join(' ').length > 200000) break; // safety cap
                    }
                        const text = normalizeGreek(parts.join('\n\n'));
                    debugLog('pptx extracted length', text.length, 'slides', slideNames.length);
                    return text;
                }catch(e){ console.warn('[aiFileGenNew] pptx extraction failed', e); debugLog('pptx extraction failed', e?.message||e); throw new Error('Failed to extract PPTX text'); }
            } else if(isImage){
                setStatus(`OCR (Tesseract) on ${name}…`);
                try{
                    if(!window.Tesseract){
                        await loadScript('https://unpkg.com/tesseract.js@4.1.1/dist/tesseract.min.js');
                    }
                    if(!window.Tesseract || !window.Tesseract.recognize) throw new Error('Tesseract not available');
                    const url = URL.createObjectURL(f);
                    try{
                        const res = await window.Tesseract.recognize(url, 'eng', { logger: m => { if(m && m.status){ debugLog('tesseract', m.status, (m.progress!=null)? ((m.progress*100)|0)+'%':'' ); } } });
                        const text = normalizeGreek((res && res.data && res.data.text) ? res.data.text : '');
                        debugLog('tesseract text length', text.length);
                        return text;
                    } finally { try{ URL.revokeObjectURL(url); }catch(e){} }
                }catch(e){ console.warn('[aiFileGenNew] OCR failed', e); debugLog('ocr failed', e?.message||e); throw new Error('Failed to OCR image'); }
            } else {
                throw new Error('Unsupported file type: ' + name);
            }
                }

                // Extract from all selected files, concatenating results. If using saved-only, skip file extraction.
                let parts = [];
                if(!usingSavedOnly){
                    for(let i=0;i<files.length;i++){
                        const f = files[i];
                        try{
                            setStatus(`Processing (${i+1}/${files.length}): ${f.name}`);
                            const text = await extractFromFile(f);
                            if(text && text.trim()){
                                parts.push(text.trim());
                            }
                        }catch(e){
                            console.warn('Extraction failed for', f?.name, e);
                            // continue with others, but record that this one failed
                        }
                    }
                    extracted = normalizeGreek(parts.join('\n\n'));
                } else {
                    // use the selected saved content pieces as the extracted source
                    try{
                        extracted = normalizeGreek((window.__tbGenCtx?.pieces||[]).map(p=> p.text || '').join('\n\n'));
                    }catch(e){ extracted = '' }
                }

            if(!extracted || !extracted.trim()) throw new Error('No text could be extracted from the file.');

            // Truncate to a safe prompt size (approx chars). Adjust as needed.
            const maxChars = 120000; // conservative cap
            if(extracted.length > maxChars){ extracted = extracted.slice(0, maxChars) + '\n\n[TRUNCATED]'; debugLog('extracted text truncated'); }

            setStatus('Sending document to Gemini for MCQ generation...'); debugLog('sending to Gemini, length', extracted.length);
            // dynamic import of Gemini SDK if needed
            if(!window.GoogleGenerativeAI){
                try{ const mod = await import('https://esm.run/@google/generative-ai'); window.GoogleGenerativeAI = mod.GoogleGenerativeAI; }catch(e){ console.warn('[aiFileGenNew] import generative-ai failed', e); }
            }
            if(!window.GoogleGenerativeAI) throw new Error('Generative AI SDK unavailable (could not import).');

            const client = new window.GoogleGenerativeAI(key);
            const model = client.getGenerativeModel({ model: 'gemini-2.5-flash' });

            // Build the prompt with strict formatting requirements
            const tbCtx = (window.__tbGenCtx?.pieces||[]).map(p=> p.text).join('\n\n');
            const prompt = `You are given the extracted plain text contents of a document. From this content${tbCtx ? ' and the supplemental textbook context below' : ''}, create ${autoMode ? 'the number of' : qCount} high-quality, exam-worthy multiple-choice questions (MCQs) ${autoMode ? 'that best fit the material (choose the count yourself, do not exceed 50, and prefer quality over quantity)' : 'if the source supports it (fewer if necessary to maintain quality)'}.
        Rules (must follow exactly):
        - Output ONLY the MCQs in this raw format. Do NOT include any other commentary.
        - Each question must be on its own line starting with "Q<NUMBER>. " (e.g., Q1. ...).
        - Each option must be on its own line starting with "- " (dash + space).
        - Produce exactly ${optCount} options per question. If the source does not support ${optCount} strong distractors for a given question, rewrite or drop the question; do NOT produce fewer than ${optCount} options.
        - Do NOT label options with letters or numbers. Do not prefix options with "A.", "B)", "(C)", "1.", "a)", etc. The ONLY identifier for an option line is the initial "- ", followed by the option text.
        - At the end include a section exactly titled "ANSWER KEY" followed by one line per question in the form "<number>. <LETTER>" (e.g., 1. B).
        - Exactly one correct option per question.
        - Return at most ${autoMode ? 50 : qCount} questions.

        Character handling requirements:
        - Preserve all Unicode characters from the source text exactly in both questions and options, especially Greek letters/symbols (e.g., α β γ δ ε θ μ π σ φ Ω). Do not transliterate or spell out names. If a glyph is unclear, leave it as-is; never replace with �.

        Content selection constraints (very important):
        - Prioritize technical, non-trivial, domain-specific material that requires understanding, discrimination, or reasoning.
        - Avoid general/common knowledge or boilerplate content even if present (e.g., course logistics, introductions, obvious definitions, historical trivia, generic study tips, reading lists, or broad non-technical overview statements).
        - Ignore preliminary outlines, headings, or meta/administrative text not suitable for assessment.
        - If a concept appears in both general and technical forms, prefer the technically precise version and craft distractors that are plausible but incorrect.
        - If insufficient technical material exists for 30 good questions, generate fewer rather than padding with trivial items.

    Use only information from the provided document text${tbCtx ? ' and the provided textbook context' : ''} (do not add external facts):
        """
    ${ (tbCtx ? (tbCtx + '\n\n') : '') + extracted }
        """

        Now produce only the MCQs in the exact format described above.`;

            console.log('[aiFileGenNew] prompt length', prompt.length);
            debugLog('prompt length', prompt.length);
            btn.innerHTML = '<span class="spinner" aria-hidden="true"></span> Generating…';
            setStatus('Generating questions…');

            const resp = await model.generateContent({ contents: [{ role: 'user', parts: [{ text: prompt }] }] });
            const out = (await resp?.response?.text?.())?.trim();
            debugLog('received response; length', out ? out.length : 0);
            if(!out) throw new Error('Empty response from Gemini.');

            // Basic sanity
            if(!/^\s*Q\s*\d+\./mi.test(out) || !/\bANSWER\s+KEY\b/mi.test(out)){
                const ok = confirm('AI output does not look like MCQs in the expected format. Insert anyway?');
                if(!ok){ setStatus('Cancelled by user.'); return; }
            }

                    // Insert into paste and parse
            const paste = $('paste'); if(!paste) throw new Error('Could not find paste textarea.');
            paste.value = normalizeGreek(out);
            setStatus('Inserted. Parsing…');
                    debugLog('inserted into #paste; triggering parse');
            $('parseBtn')?.click();
            setStatus('Done.');
            console.log('[aiFileGenNew] finished successfully');

                } catch(err){
                    console.error('[aiFileGenNew] error', err);
                    debugLog('error', err?.message || err);
                    setStatus('Error: ' + (err?.message || err), true);
                    alert('AI generation failed: ' + (err?.message || String(err)));
                } finally{
                    try{ btn.disabled = false; btn.removeAttribute('aria-busy'); btn.innerHTML = orig; }catch(e){}
                    // Restore controls to reflect current auto mode
                    try{ syncAutoUI(); }catch(e){}
                    // Unfreeze widths after processing completes
                    lockAiFileRow(false);
                    try{ fileInput.disabled = false; }catch{}
                }
        });
            return true;
        }

        // Try immediate bind; if DOM not ready, bind on DOMContentLoaded
        if(!bind()){
            document.addEventListener('DOMContentLoaded', bind, { once: true });
            // Safety retry shortly after load in case of dynamic DOM
            setTimeout(bind, 300);
        }
})();

</script>

</html>

        <script>
// Resilient UI sync for global key -> badges/buttons
(function(){
    // ASCII BG toggle button wiring (under theme capsule)
    try{
        var btn = document.getElementById('asciiBgToggle');
        if(btn){
            // initialize label from preference
            var pref = 'on'; try{ pref = localStorage.getItem('__asciiBg')||'on'; }catch(e){}
            btn.textContent = (pref==='off') ? 'Turn on animated background' : 'Turn off animated background';
            btn.addEventListener('click', function(){
                var running = window.__asciiBg && window.__asciiBg.isRunning();
                if(running){
                    // stop and hide
                    try{ window.__asciiBg.stop(); }catch(e){}
                    try{ var layer = document.querySelector('.ascii-watermark'); if(layer) layer.style.display='none'; }catch(e){}
                    btn.textContent = 'Turn on animated background';
                }else{
                    // show and start
                    try{ var layer = document.querySelector('.ascii-watermark'); if(layer) layer.style.display=''; }catch(e){}
                    try{ window.__asciiBg.start(); }catch(e){}
                    btn.textContent = 'Turn off animated background';
                }
            });
        }
    }catch(e){}
    function updateAll(){
        try{
            const keyInput = document.getElementById('globalGemKey');
            const en = document.getElementById('globalGemEnable');
            const ok = !!(keyInput && keyInput.value && keyInput.value.trim() && (!en || en.checked));
            const badgeIds = ['validateKeyBadge','validateKeyBadgeCopy','globalKeyBadge'];
            badgeIds.forEach(id=>{
                const nodes = document.querySelectorAll('#' + id);
                nodes.forEach(el=>{
                    el.classList.toggle('ok', ok);
                    el.classList.toggle('missing', !ok);
                    const hint = el.querySelector('.hint'); if(hint) hint.textContent = ok ? 'Key set' : 'No key set';
                });
            });
            const btnIds = ['aiLikeBtn','aiFileGenBtn','validateAnswersBtn','aiValidateBtn'];
            btnIds.forEach(id=>{ document.querySelectorAll('#'+id).forEach(b=>b.disabled = !ok); });
            // also update top-left dot
            const topDot = document.getElementById('globalKeyDot'); if(topDot){ topDot.classList.toggle('ok', ok); topDot.classList.toggle('missing', !ok); }
        }catch(e){ console.warn('updateAll failed', e); }
    }
    document.addEventListener('input', function(e){ if(e.target && e.target.id==='globalGemKey') updateAll(); });
    document.addEventListener('change', function(e){ if(!e.target) return; if(e.target.id==='globalGemKey' || e.target.id==='globalGemEnable') updateAll(); });
    window.addEventListener('load', updateAll);
    // run once now
    setTimeout(updateAll, 100);
})();
</script>

<style>
/* Overrides and additions for sticky notes UX */
.sticky-note{ min-width: 300px; }
.sticky-resize{ width:14px; height:14px; position:absolute; right:6px; bottom:6px; cursor:se-resize; border-radius:3px; background:
    repeating-linear-gradient(135deg,
        rgba(255,255,255,0.55) 0, rgba(255,255,255,0.55) 2px,
        rgba(0,0,0,0) 2px, rgba(0,0,0,0) 4px);
    opacity:0.6;
}
.sticky-resize:hover{ opacity:0.95; }

/* Title above dock: bare ASCII (no box), larger size, non-selectable */
#stickyTitleBox{ position:fixed; top: calc(env(safe-area-inset-top) + var(--topSafeArea) + var(--stickyTopGap)); right:12px; z-index:210; padding:0; border:none; background:transparent; box-shadow:none; -webkit-backdrop-filter:none; backdrop-filter:none }
#stickyTitleBox pre{ margin:0 0 0px 0; line-height:1.0; font-family: "Courier New", Consolas, monospace; font-weight:700; letter-spacing:0.35px; color:#dfe7ff; text-shadow:0 1px 0 #000; font-size: 12px; -webkit-user-select:none; user-select:none }
#stickyTitleBox{ -webkit-user-select:none; user-select:none }
/* Boot overlay ASCII title: make non-selectable */
#bootAscii{ -webkit-user-select:none; user-select:none }
/* Also make the watermark ASCII non-selectable */
#asciiWatermark{ -webkit-user-select:none; user-select:none }

/* Anchor dock right beneath title */
/* Dock beneath the title; positioned dynamically via JS to avoid overlap */
#stickyDock{ position:fixed; right:12px; z-index:210; }
#stickyPanel{ position:fixed; right:12px; z-index:210; }

/* Panel list delete button */
.sticky-item{ display:flex; align-items:center; gap:10px; justify-content:space-between; }
.sticky-item .si-main{ display:flex; align-items:center; gap:10px; }
.sticky-del{ margin-left:10px; color:#ffd1d1; background:rgba(255,0,0,0.08); border:1px solid rgba(255,0,0,0.25); border-radius:6px; padding:4px 8px; font-size:12px; cursor:pointer; }
.sticky-del:hover{ background:rgba(255,0,0,0.15); }

/* Unified Delete button styling: apply sticky-note delete theme across interface for common selectors */
.sticky-del,
button[data-act="delete"],
.btn[data-act="delete"],
button[data-del],
button.delete-btn,
#tbDeleteBtn,
button[data-delete]{
    color: #ffd1d1;
    background: rgba(255,0,0,0.08);
    border: 1px solid rgba(255,0,0,0.25);
    border-radius: 6px;
    padding: 4px 8px;
    font-size: 12px;
    cursor: pointer;
}
.sticky-del:hover,
button[data-act="delete"]:hover,
.btn[data-act="delete"]:hover,
button[data-del]:hover,
button.delete-btn:hover,
#tbDeleteBtn:hover,
button[data-delete]:hover{
    background: rgba(255,0,0,0.15);
}

/* Clear buttons: same shape but blue */
button[data-act="clear"],
.btn[data-act="clear"],
button.clear-btn,
#tbClearBtn,
button[data-clear]{
    color: #dfeeff;
    background: rgba(30,110,220,0.08);
    border: 1px solid rgba(60,120,220,0.25);
    border-radius: 6px;
    padding: 4px 8px;
    font-size: 12px;
    cursor: pointer;
}
button[data-act="clear"]:hover,
.btn[data-act="clear"]:hover,
button.clear-btn:hover,
#tbClearBtn:hover,
button[data-clear]:hover{
    background: rgba(30,110,220,0.14);
}
</style>

<div id="stickyTitleBox" aria-hidden="false">
    <pre>
.dP"Y8 888888 88b 88 88      dP"Yb   dP""b8 
`Ybo."   88   88Yb88 88     dP   Yb dP   `" 
o.`Y8b   88   88 Y88 88  .o Yb   dP Yb  "88 
8bodP'   88   88  Y8 88ood8  YbodP   YboodP 
    </pre>
</div>

<script>
// Sticky Notes: dock + windows with localStorage persistence
(function(){
    const storeKey = 'sticky.notes.v1';
    const $ = id => document.getElementById(id);
            const dock = $('stickyDock'); const panel = $('stickyPanel');
            const titleBox = $('stickyTitleBox');
            const rail = document.getElementById('stickyRail');
            /**
             * Make sticky UI inert (non-focusable, no pointer events) but still visible.
             * This is used during the boot sequence so sticky controls stay in the background.
             */
            function setStickyInert(inert){
                try{
                    const root = document.documentElement;
                    // visual containers: set aria-hidden/pointer-events and temporarily lower z-index so overlay remains on top
                    [dock, panel, rail, titleBox].forEach(el=>{
                        if(!el) return;
                            if(inert){ 
                            // save previous z-index
                            try{ el.dataset._oldZ = el.style.zIndex || ''; }catch{};
                            el.setAttribute('aria-hidden', 'true'); el.style.pointerEvents = 'none'; el.style.zIndex = '10';
                        }
                        else { 
                            el.removeAttribute('aria-hidden'); el.style.pointerEvents = ''; 
                            try{ if(el.dataset._oldZ !== undefined) { el.style.zIndex = el.dataset._oldZ || ''; delete el.dataset._oldZ; } }catch{};
                        }
                    });
                    // individual note windows: make inputs non-focusable while inert
                    document.querySelectorAll('.sticky-note').forEach(win=>{
                        const inputs = win.querySelectorAll('input,textarea,button');
                        inputs.forEach(i=>{
                            if(inert){ i.dataset._oldTab = i.getAttribute('tabindex') || ''; i.setAttribute('tabindex','-1'); i.setAttribute('aria-hidden','true'); }
                            else { if(i.dataset._oldTab!=='') i.setAttribute('tabindex', i.dataset._oldTab); else i.removeAttribute('tabindex'); i.removeAttribute('aria-hidden'); delete i.dataset._oldTab; }
                        });
                        // pointer-events for the whole window and temporarily lower z-index so boot overlay remains above notes
                        if(inert){ try{ win.dataset._oldZ = win.style.zIndex || ''; }catch{}; win.style.pointerEvents = 'none'; win.style.zIndex = '12'; }
                        else { win.style.pointerEvents = ''; try{ if(win.dataset._oldZ!==undefined){ win.style.zIndex = win.dataset._oldZ || ''; delete win.dataset._oldZ; } }catch{} }
                    });
                    // If restoring interactivity, ensure layout is recomputed
                    if(!inert){ try{ if(typeof layoutAllSlots === 'function') layoutAllSlots(); }catch(e){} }
                }catch(e){}
            }
    function computeMinWidthFor(el){
        try{
            const actions = el.querySelector('.sticky-actions');
            const actionsW = actions ? actions.getBoundingClientRect().width : 0;
            // space for title input + padding + actions
            const needed = Math.ceil(actionsW + 140);
            return Math.max(300, needed);
        }catch{ return 300; }
    }

    const btnNew = $('sdNew'), btnList = $('sdList'), btnClose = $('sdClose');
    const btnClearAll = $('sdClearAll');
    const listWrap = $('sdListWrap'); const search = $('sdSearch'); const countEl = $('sdCount');
    const colors = ['yellow','green','pink','sky','lav'];

    function uid(){ return Math.random().toString(36).slice(2,9); }
    function now(){ return Date.now(); }
    function load(){ try{ const raw = localStorage.getItem(storeKey); return raw ? JSON.parse(raw) : []; }catch(e){ return []; } }
    function save(arr){ try{ localStorage.setItem(storeKey, JSON.stringify(arr||[])); updateCount(); }catch(e){} }
    function updateCount(){ try{ const arr = load(); countEl.textContent = String(arr.length); }catch{} }
    // Rail width control: persisted CSS variable
    const railWidthKey = 'sticky.railW.v1';
    function getRailW(){
        try{ const v = localStorage.getItem(railWidthKey); const n = v? parseInt(v,10): NaN; if(!isNaN(n)) return Math.min(520, Math.max(220, n)); }catch{}
        return 280;
    }
    function setRailW(px){
        const v = Math.min(520, Math.max(220, Math.round(px||280)));
        try{ localStorage.setItem(railWidthKey, String(v)); }catch{}
        try{ document.documentElement.style.setProperty('--stickyRailW', v + 'px'); }catch{}
        try{ layoutAllSlots(); }catch{}
        return v;
    }

    // Sticky rail helpers
    const getSlots = () => Array.from(document.querySelectorAll('.clip-slot'));
    function highlightSlot(index){
        try{ getSlots().forEach((s,i)=> s.classList.toggle('slot-hover', i===index)); }catch{}
    }
    function setOccupiedFlags(){
        try{
            const arr = load();
            getSlots().forEach((s,i)=>{
                const notes = arr.filter(n=> n.open!==false && n.clippedSlot===i).sort((a,b)=> (b.updatedAt||0)-(a.updatedAt||0));
                const count = notes.length;
                s.classList.toggle('occupied', count>0);
                // remove previous color classes
                s.classList.remove('c-yellow','c-green','c-pink','c-sky','c-lav');
                if(count>0){
                    const top = notes[0]; const col = top.color || 'yellow'; s.classList.add('c-'+col);
                }
            });
        }catch{}
    }
    function layoutSlot(i){
        try{
            const slots = getSlots(); const sEl = slots[i]; if(!sEl) return;
            const rect = sEl.getBoundingClientRect();
            const pad = 6, gap = 6;
            const width = Math.max(40, Math.floor(rect.width - pad*2));
            const arr = load().filter(n=> n.open!==false && n.clippedSlot===i).sort((a,b)=> (b.updatedAt||0)-(a.updatedAt||0));
            if(arr.length===0){ sEl.classList.remove('occupied'); return; }
            const availH = Math.max(40, Math.floor(rect.height - pad*2 - gap*(arr.length-1)));
            const minH = 56;
            const height = Math.max(minH, Math.floor(availH / arr.length));
            let top = Math.floor(rect.top + pad);
            const left = Math.floor(rect.left + pad);
            arr.forEach((note)=>{
                const win = document.querySelector(`[data-sticky-id="${note.id}"]`);
                if(!win) return;
                // Allow shrinking below normal min when clipped
                win.style.minWidth = '0px';
                win.style.left = left + 'px';
                win.style.top = top + 'px';
                win.style.width = width + 'px';
                win.style.height = height + 'px';
                updateNote(note.id, { x: left, y: top, w: width, h: height });
                top += height + gap;
            });
            sEl.classList.add('occupied');
        }catch{}
    }
    function layoutAllSlots(){ try{ const slots = getSlots(); slots.forEach((_,i)=> layoutSlot(i)); setOccupiedFlags(); }catch{} }

    // Helpers to assign notes into empty clip slots
    function getSlotCounts(){
        try{
            const slots = getSlots(); const arr = load();
            return slots.map((s,i)=> arr.filter(n=> n.open!==false && n.clippedSlot===i).length);
        }catch{ return []; }
    }
    function findFirstEmptySlot(){
        try{
            const counts = getSlotCounts(); for(let i=0;i<counts.length;i++){ if(counts[i] === 0) return i; } return -1;
        }catch{ return -1; }
    }
    function assignNoteToFirstEmptySlot(noteId){
        try{
            const slot = findFirstEmptySlot(); if(slot < 0) return false;
            const arr = load(); const n = arr.find(x=> x.id===noteId); if(!n) return false;
            // persist clippedSlot and pre-size if possible
            updateNote(noteId, { clippedSlot: slot, preW: n.w || 300, preH: n.h || 220 });
            try{ layoutSlot(slot); setOccupiedFlags(); }catch{}
            return true;
        }catch{ return false; }
    }
    function assignOpenNotesToSlots(){
        try{
            const slots = getSlots(); if(!slots.length) return;
            const arr = load().filter(n=> n.open!==false && n.clippedSlot==null);
            if(!arr.length) return;
            for(let i=0;i<slots.length && arr.length;i++){
                const count = load().filter(n=> n.open!==false && n.clippedSlot===i).length;
                if(count === 0){ const note = arr.shift(); updateNote(note.id, { clippedSlot: i, preW: note.w||300, preH: note.h||220 }); try{ layoutSlot(i); }catch{} }
            }
            try{ setOccupiedFlags(); }catch{}
        }catch{}
    }

    // Keep pinned notes centered and sized within viewport when layout changes (news toggle, resize, tabs move)
    function centerPinnedNotes(topDock, dockH){
        try{
            const M = 12; // outer margin
            const arr = load().filter(n=> n.pinned);
            if(!arr || !arr.length) return;
            arr.forEach(n=>{
                const el = document.querySelector(`[data-sticky-id="${n.id}"]`);
                if(!el) return;
                // compute dynamic minimum width so actions aren't clipped
                const dynMin = computeMinWidthFor(el);
                const maxW = Math.max(dynMin, window.innerWidth - 2*M);
                let desiredW = Math.min(el.offsetWidth || (n.w||300), maxW);
                if(desiredW < dynMin) desiredW = dynMin;
                el.style.width = desiredW + 'px';
                // center horizontally
                const left = Math.max(M, Math.min(window.innerWidth - desiredW - M, Math.round((window.innerWidth - desiredW)/2)));
                // position vertically just under the dock/title if provided, otherwise keep current top
                const top = (typeof topDock === 'number' ? Math.max(M, Math.round(topDock + (dockH||0) + 12)) : Math.max(M, el.offsetTop || M));
                el.style.left = left + 'px';
                el.style.top = top + 'px';
                // persist
                updateNote(n.id, { x: left, y: top, w: desiredW, h: el.offsetHeight });
            });
        }catch{}
    }

        function createNote(data){
        const id = data?.id || uid();
        const note = {
            id,
            title: data?.title || 'Untitled',
            text: data?.text || '',
            color: data?.color || 'yellow',
                // spawn below the dock
                x: data?.x ?? (function(){ const r = dock?.getBoundingClientRect(); const w = data?.w ?? 300; return (window.innerWidth - (w + 24)); })(),
                y: data?.y ?? (function(){ const r = dock?.getBoundingClientRect(); return (r ? (r.bottom + 12) : 100); })(),
                w: data?.w ?? 300,
            h: data?.h ?? 220,
            z: data?.z ?? 195,
                clippedSlot: (data?.clippedSlot ?? null),
                preW: data?.preW,
                preH: data?.preH,
                minimized: false,
                pinned: false,
                open: data?.open ?? true,
            createdAt: data?.createdAt || now(),
            updatedAt: data?.updatedAt || now()
        };
        const arr = load();
        const ix = arr.findIndex(n => n.id===id);
        if(ix>=0) arr[ix] = note; else arr.push(note);
        save(arr);
        renderNoteWindow(note);
        return note;
    }

    function updateNote(id, patch){
        const arr = load();
        const ix = arr.findIndex(n=>n.id===id);
        if(ix<0) return;
        arr[ix] = { ...arr[ix], ...patch, updatedAt: now() };
        save(arr);
        return arr[ix];
    }

    function deleteNote(id){
        const arr = load().filter(n=>n.id!==id); save(arr);
        const win = document.querySelector(`[data-sticky-id="${id}"]`); if(win && win.parentNode) win.parentNode.removeChild(win);
        renderList(); try{ layoutAllSlots(); }catch{}
    }

    function bringToFront(el){
        try{
            const wins = document.querySelectorAll('.sticky-note');
            let top = 195; wins.forEach(w => { const z = parseInt(w.style.zIndex||'195',10)||195; if(z>top) top = z; });
            const z = top + 1; el.style.zIndex = String(z);
            const id = el.getAttribute('data-sticky-id'); updateNote(id, { z });
        }catch{}
    }

    function renderNoteWindow(n){
        let el = document.querySelector(`[data-sticky-id="${n.id}"]`);
        if(!el){ el = document.createElement('div'); el.className = `sticky-note c-${n.color||'yellow'}`; el.setAttribute('data-sticky-id', n.id); document.body.appendChild(el); }
            // layout: flex so body area always fills and is editable
            el.style.display = 'flex';
            el.style.flexDirection = 'column';
            const MIN_H = 140;
    // Clamp starting position within viewport with margins
    const vw = window.innerWidth, vh = window.innerHeight; const M = 8;
    const startX = Math.max(M, Math.min(vw - (n.w||300) - M, (n.x||20)));
    const startY = Math.max(M, Math.min(vh - (n.h||220) - M, (n.y||80)));
    el.style.left = startX + 'px';
    el.style.top = startY + 'px';
            el.style.minWidth = '300px';
            el.style.width = Math.max(300, n.w||300) + 'px';
            el.style.height = Math.max(MIN_H, Math.min(vh - 2*M, n.h||220)) + 'px';
        el.style.zIndex = String(n.z||195);
        el.innerHTML = `
                <div class="sticky-head" style="flex:0 0 auto;">
                <input class="sticky-title" value="${(n.title||'').replace(/"/g,'&quot;')}" placeholder="Title" />
                <div class="sticky-actions">
                    <div class="sticky-color">
                        ${colors.map(c=>`<span class="dot c-${c}" data-color="${c}" title="${c}"></span>`).join('')}
                    </div>
                        <button class="sa" data-act="close" title="Close" aria-label="Close">×</button>
                </div>
            </div>
                <div class="sticky-body" style="flex:1 1 auto; min-height:0; display:flex;">
                    <textarea class="sticky-text" style="flex:1 1 auto; min-height:0; width:100%; height:100%; resize:none;" placeholder="Write anything…">${(n.text||'').replace(/</g,'&lt;')}</textarea>
            </div>
            <div class="sticky-resize" aria-hidden="true"></div>
        `;
            // After DOM built, enforce dynamic minimum width so actions never cut off
            try{
                const dynMin = computeMinWidthFor(el);
                el.style.minWidth = dynMin + 'px';
                // If current width is less than required, bump it up
                const curW = el.getBoundingClientRect().width;
                if(curW < dynMin){ el.style.width = dynMin + 'px'; }
            }catch{}
            // If this note is already clipped, lay it out inside its slot
            try{ if(n.clippedSlot != null){ requestAnimationFrame(()=>{ try{ layoutSlot(n.clippedSlot); setOccupiedFlags(); }catch{} }); } }catch{}
            // Apply color theme independent of global palette
            const COLOR_MAP = {
                yellow: { accent:'#f2cc60', border:'#6b5c20' },
                green:  { accent:'#5bd6a6', border:'#2a6e5c' },
                pink:   { accent:'#f29ac2', border:'#7a3158' },
                sky:    { accent:'#7cc7ff', border:'#2f5b7a' },
                lav:    { accent:'#bda3ff', border:'#5b4a8c' }
            };
            function applyNoteVisuals(color){
                const theme = COLOR_MAP[color] || COLOR_MAP.yellow;
                // base neutrals to avoid palette coupling
                const head = el.querySelector('.sticky-head');
                const body = el.querySelector('.sticky-body');
                el.style.background = '#0b1220';
                el.style.border = `1px solid ${theme.border}`;
                head.style.background = 'linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.22))';
                body.style.background = '#0e1624';
                // subtle accent outline and resize handle
                el.style.boxShadow = `0 10px 28px rgba(0,0,0,0.45), 0 0 0 1px ${theme.border}`;
            }
            applyNoteVisuals(n.color||'yellow');
            // wire interactions
        const title = el.querySelector('.sticky-title');
        const text = el.querySelector('.sticky-text');
        title.addEventListener('input', ()=>{ updateNote(n.id, { title: title.value }); renderList(); });
        text.addEventListener('input', ()=>{ updateNote(n.id, { text: text.value }); });
        // actions
            el.querySelectorAll('.sticky-actions .sa').forEach(btn=>{
                // prevent header drag from activating on button press
                btn.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); });
            btn.addEventListener('click', (e)=>{
                    const act = btn.getAttribute('data-act');
                    if(act==='close'){
                        updateNote(n.id, { open:false });
                        const win = document.querySelector(`[data-sticky-id="${n.id}"]`);
                        if(win && win.parentNode) win.parentNode.removeChild(win);
                        renderList();
                        // Recompute slot layout/occupied flags so any clip-slot perimeter is cleared
                        try{ layoutAllSlots(); }catch{}
                    }
            });
        });
        // color dots
            el.querySelectorAll('.sticky-color .dot').forEach(dot=>{
            const c = dot.getAttribute('data-color');
                dot.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); });
                dot.addEventListener('click', ()=>{ n = updateNote(n.id, { color: c }) || n; el.className = `sticky-note c-${c}`; applyNoteVisuals(c); renderList(); });
        });
        // dragging
        const head = el.querySelector('.sticky-head');
        let dragging=false, start={x:0,y:0,left:0,top:0};
            const isInteractive = (t)=> !!(t && (t.closest('.sticky-actions') || t.closest('.sticky-color') || t.closest('.sticky-title') || t.closest('button') || t.closest('input') || t.closest('textarea')));
            head.addEventListener('pointerdown', (e)=>{
                if(isInteractive(e.target)) return;
                // If clipped, unclip and restore pre-size
                if(n.clippedSlot != null){
                    const prevSlot = n.clippedSlot;
                    const prevW = Math.max(300, n.preW || el.offsetWidth || 300);
                    const prevH = Math.max(140, n.preH || el.offsetHeight || 220);
                    n = updateNote(n.id, { clippedSlot: null, w: prevW, h: prevH }) || n;
                    el.style.width = prevW + 'px';
                    el.style.height = prevH + 'px';
                    // restore dynamic min width for freeform
                    try{ const dynMin = computeMinWidthFor(el); el.style.minWidth = dynMin + 'px'; if(prevW < dynMin){ el.style.width = dynMin + 'px'; } }catch{}
                    try{ layoutSlot(prevSlot); setOccupiedFlags(); }catch{}
                }
                dragging=true; head.setPointerCapture(e.pointerId); bringToFront(el); start={x:e.clientX,y:e.clientY,left:el.offsetLeft,top:el.offsetTop}; el.style.transition='none';
            });
        head.addEventListener('pointermove', (e)=>{ if(!dragging) return; const dx=e.clientX-start.x, dy=e.clientY-start.y; let L = start.left+dx, T=start.top+dy; const vw=window.innerWidth, vh=window.innerHeight; const M=4; L=Math.max(M, Math.min(vw - el.offsetWidth - M, L)); T=Math.max(M, Math.min(vh - el.offsetHeight - M, T)); el.style.left=L+'px'; el.style.top=T+'px';
            // slot hover highlight under center
            let hovered=-1; const cx=L+el.offsetWidth/2, cy=T+el.offsetHeight/2;
            try{ getSlots().forEach((s,i)=>{ const r=s.getBoundingClientRect(); if(cx>=r.left && cx<=r.right && cy>=r.top && cy<=r.bottom){ hovered=i; } }); }catch{}
            highlightSlot(hovered>=0?hovered:null);
        });
        head.addEventListener('pointerup', (e)=>{ if(!dragging) return; dragging=false; head.releasePointerCapture(e.pointerId);
            // snap to slot if released over one
            let target=-1; const cx=el.offsetLeft+el.offsetWidth/2, cy=el.offsetTop+el.offsetHeight/2;
            try{ getSlots().forEach((s,i)=>{ const r=s.getBoundingClientRect(); if(cx>=r.left && cx<=r.right && cy>=r.top && cy<=r.bottom){ target=i; } }); }catch{}
            highlightSlot(null);
            if(target>=0){ n = updateNote(n.id, { preW: el.offsetWidth, preH: el.offsetHeight, clippedSlot: target }) || n; try{ layoutSlot(target); setOccupiedFlags(); }catch{} }
            else{ updateNote(n.id, { x: el.offsetLeft, y: el.offsetTop }); }
            el.style.transition='';
        });
        // resize
            const res = el.querySelector('.sticky-resize');
        let resizing=false, rs={x:0,y:0,w:0,h:0};
            res.addEventListener('pointerdown', (e)=>{ if(n.clippedSlot!=null) return; e.preventDefault(); resizing=true; res.setPointerCapture(e.pointerId); bringToFront(el); rs={x:e.clientX,y:e.clientY,w:el.offsetWidth,h:el.offsetHeight}; });
            res.addEventListener('pointermove', (e)=>{ if(!resizing) return; const dx=e.clientX-rs.x, dy=e.clientY-rs.y; const dynMin = computeMinWidthFor(el); const vw=window.innerWidth, vh=window.innerHeight; const M=8; const maxW = Math.max(dynMin, vw - el.offsetLeft - M); const maxH = Math.max(MIN_H, vh - el.offsetTop - M); const W=Math.max(dynMin, Math.min(maxW, rs.w+dx)); const H=Math.max(MIN_H, Math.min(maxH, rs.h+dy)); el.style.width=W+'px'; el.style.height=H+'px'; });
        res.addEventListener('pointerup', (e)=>{ if(!resizing) return; resizing=false; res.releasePointerCapture(e.pointerId); updateNote(n.id, { w: el.offsetWidth, h: el.offsetHeight, x: el.offsetLeft, y: el.offsetTop }); });
        el.addEventListener('mousedown', ()=> bringToFront(el));
    }

    function renderList(){
        const q = (search?.value||'').toLowerCase();
        const arr = load().slice().sort((a,b)=> (b.updatedAt||0) - (a.updatedAt||0));
        const vis = q ? arr.filter(n=> (n.title||'').toLowerCase().includes(q) || (n.text||'').toLowerCase().includes(q)) : arr;
            if(listWrap){ listWrap.innerHTML = vis.map(n=>{
            const dt = new Date(n.updatedAt||n.createdAt||now()).toLocaleString();
            const snip = (n.text||'').replace(/\s+/g,' ').slice(0,80);
                return `<div class="sticky-item" data-open="${n.id}">
                    <div class="si-main">
                        <span class="sticky-dot c-${n.color||'yellow'}"></span>
                        <div>
                            <div><strong>${(n.title||'Untitled').replace(/[&<>]/g, ch=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[ch]))}</strong></div>
                            <div class="sticky-meta">${dt} — ${snip}</div>
                        </div>
                    </div>
                    <button class="sticky-del" data-del="${n.id}">Delete</button>
                </div>`;
        }).join('');
                listWrap.querySelectorAll('.sticky-item').forEach(it=> it.addEventListener('click', (ev)=>{
                    // ignore if delete was clicked
                    if((ev.target).closest && (ev.target).closest('.sticky-del')) return;
                const id = it.getAttribute('data-open');
                    const arr2 = load(); const n = arr2.find(x=>x.id===id); if(n){
                        updateNote(id, { open:true });
                        renderNoteWindow(n);
                        const el = document.querySelector(`[data-sticky-id="${id}"]`);
                        if(el) bringToFront(el);
                        // Auto-assign this opened note to the first empty slot (top-to-bottom)
                        try{ assignNoteToFirstEmptySlot(id); }catch{}
                    }
            }));
                listWrap.querySelectorAll('.sticky-del').forEach(btn=> btn.addEventListener('click', (e)=>{ e.stopPropagation(); const id = btn.getAttribute('data-del'); if(confirm('Delete this note permanently?')) deleteNote(id); }));
        }
        updateCount();
    }

        function positionDockAndPanel(){
            try{
                const GAP_TITLE_TO_DOCK = 6;   // px gap between title and dock
                const GAP_DOCK_TO_PANEL = 8;  // px gap between dock and panel top
                const GAP_DOCK_TO_RAIL  = 8;  // px gap between dock and rail top

                const r = titleBox?.getBoundingClientRect();
                const topDock = r ? Math.round(r.bottom + GAP_TITLE_TO_DOCK) : 40;
                const dockH = Math.round(dock?.getBoundingClientRect()?.height || 40);

                if(dock){
                    dock.style.top = `${topDock}px`;
                    dock.style.zIndex = '210';
                }
                if(panel){
                    panel.style.top = `${topDock + dockH + GAP_DOCK_TO_PANEL}px`;
                    // Keep panel above everything when visible
                    panel.style.zIndex = panel.classList.contains('hidden') ? '210' : '9999';
                }
                if(rail){
                    // Place rail under the dock; compute height to visually reach bottom even when scaled
                    const topRail = topDock + dockH + GAP_DOCK_TO_RAIL;
                    rail.style.top = `${topRail}px`;
                    // Clear bottom so explicit height can be applied
                    rail.style.bottom = '';
                    const cs = getComputedStyle(document.documentElement);
                    const scaleStr = (cs.getPropertyValue('--stickyScale') || '1').trim();
                    const s = Math.max(0.5, Math.min(1.5, parseFloat(scaleStr) || 1));
                    const paddingBottom = 8; // keep a small visual gutter at bottom
                    const avail = Math.max(0, Math.floor(window.innerHeight - topRail - paddingBottom));
                    // Account for scaleY: set pre-scale height so the scaled visual fills to bottom
                    const targetH = Math.ceil(avail / s);
                    rail.style.height = `${targetH}px`;
                    // Re-layout any clipped notes now that the rail position/height changed
                    try{ layoutAllSlots(); }catch{}
                }
                // Keep resizer/hoverzone aligned with current rail width and vertically centered on the rail
                try{
                    const handle = document.getElementById('stickyRailResizer');
                    const hz = document.getElementById('stickyRailHoverzone');
                    if(handle || hz){
                        const rr = rail?.getBoundingClientRect();
                        const cy = rr ? Math.round(rr.top + rr.height/2) : Math.round(window.innerHeight/2);
                        if(handle){ handle.style.top = `${cy}px`; }
                        if(hz){ hz.style.top = `${cy}px`; }
                    }
                }catch{}
                // Keep any pinned notes centered under the dock/title
                try{ centerPinnedNotes(topDock, dockH); }catch{}
            }catch{}
        }

        function togglePanel(show){
            if(!panel) return;
            positionDockAndPanel();
            panel.classList.toggle('hidden', !show);
            // Apply topmost z-index when shown
            panel.style.zIndex = panel.classList.contains('hidden') ? '210' : '9999';
        }

    // Dock wiring
        btnNew?.addEventListener('click', ()=>{
            const n = createNote({ title: 'Untitled', text: '' });
            renderList();
            const el = document.querySelector(`[data-sticky-id="${n.id}"]`);
            if(el) bringToFront(el);
            // Try to place into first empty slot automatically
            try{ if(assignNoteToFirstEmptySlot(n.id)) { /* placed into slot */ } else { /* left floating */ } }catch{}
        });
        btnList?.addEventListener('click', ()=>{
            // Toggle the panel and render list
            const wasHidden = panel.classList.contains('hidden');
            togglePanel(wasHidden);
            renderList();
            // If opening the panel, assign any open notes to empty slots
            if(wasHidden){ try{ assignOpenNotesToSlots(); }catch{} }
        });
    btnClose?.addEventListener('click', ()=> togglePanel(false));
    search?.addEventListener('input', renderList);

    // Clear all sticky notes — confirm then wipe storage and DOM
    btnClearAll?.addEventListener('click', ()=>{
        try{
            if(!confirm('Delete ALL sticky notes? This cannot be undone.')) return;
            // Clear storage
            save([]);
            // Remove any rendered note windows
            document.querySelectorAll('.sticky-note').forEach(el=>{ if(el && el.parentNode) el.parentNode.removeChild(el); });
            // Refresh UI
            renderList();
            try{ layoutAllSlots(); }catch{};
        }catch(e){ console.log('sdClearAll failed', e); }
    });

    // Load existing notes on startup
    setRailW(getRailW());
    positionDockAndPanel();
    try{ load().filter(n=> n.open!==false).forEach(renderNoteWindow); }catch{}
    try{ layoutAllSlots(); }catch{}
    renderList();

    // Try to avoid covering the current notepad; nudge dock below it
                // Keep dock top-right anchored under title; also keep notes on-screen when viewport changes (zoom/resize)
                window.addEventListener('resize', function(){
                    positionDockAndPanel();
                    try{
                        const vw = window.innerWidth, vh = window.innerHeight; const M=8;
                        document.querySelectorAll('.sticky-note').forEach(function(el){
                            // Clamp size to viewport
                            const w = Math.min(parseInt(el.style.width||el.offsetWidth)||300, vw - 2*M);
                            const h = Math.min(parseInt(el.style.height||el.offsetHeight)||220, vh - 2*M);
                            el.style.width = Math.max(300, w) + 'px';
                            el.style.height = Math.max(140, h) + 'px';
                            // Clamp position to viewport
                            let L = Math.max(M, Math.min(vw - el.offsetWidth - M, el.offsetLeft));
                            let T = Math.max(M, Math.min(vh - el.offsetHeight - M, el.offsetTop));
                            el.style.left = L + 'px';
                            el.style.top = T + 'px';
                            const id = el.getAttribute('data-sticky-id'); if(id) updateNote(id, { x: L, y: T, w: el.offsetWidth, h: el.offsetHeight });
                        });
                        try{ layoutAllSlots(); }catch{}
                        try{ centerPinnedNotes(); }catch{}
                    }catch{}
                });
                window.addEventListener('load', positionDockAndPanel);

                // Reposition when the news header changes (height/visibility/content)
                try{
                    const newsBar = document.getElementById('newsBar');
                    if(window.ResizeObserver && newsBar){
                        const ro = new ResizeObserver(()=> positionDockAndPanel());
                        ro.observe(newsBar);
                    }
                    if(window.MutationObserver && newsBar){
                        const mo = new MutationObserver(()=> positionDockAndPanel());
                        mo.observe(newsBar, { childList:true, subtree:true, attributes:true, characterData:true });
                    }
                    const newsToggle = document.getElementById('newsToggle');
                    newsToggle && newsToggle.addEventListener('click', ()=>{
                        // call twice to cover immediate display:none changes and ensuing layout
                        positionDockAndPanel();
                        setTimeout(positionDockAndPanel, 60);
                        try{ centerPinnedNotes(); }catch{}
                        // Also re-layout clipped notes after the toggle settles
                        setTimeout(()=>{ try{ layoutAllSlots(); }catch{} }, 120);
                    });
                }catch{}

                // Rail resizer wiring
                (function(){
                    const handle = document.getElementById('stickyRailResizer');
                    if(!handle) return;
                    let dragging=false; let startX=0; let startW=getRailW();
                    handle.addEventListener('pointerdown', (e)=>{
                        dragging=true; startX = e.clientX; startW = getRailW();
                        handle.classList.add('dragging');
                        try{ handle.setPointerCapture(e.pointerId); }catch{}
                        e.preventDefault();
                    });
                    window.addEventListener('pointermove', (e)=>{
                        if(!dragging) return; const dx = startX - e.clientX; setRailW(startW + dx);
                    });
                    window.addEventListener('pointerup', (e)=>{
                        if(!dragging) return; dragging=false; handle.classList.remove('dragging');
                        try{ handle.releasePointerCapture(e.pointerId); }catch{}
                    });
                    // Keyboard support
                    handle.setAttribute('tabindex','0');
                    handle.addEventListener('keydown', (e)=>{
                        const step = e.shiftKey ? 20 : 10;
                        if(e.key==='ArrowLeft'){ e.preventDefault(); setRailW(getRailW()+step); }
                        else if(e.key==='ArrowRight'){ e.preventDefault(); setRailW(getRailW()-step); }
                        else if(e.key==='Home'){ e.preventDefault(); setRailW(220); }
                        else if(e.key==='End'){ e.preventDefault(); setRailW(520); }
                    });
                    // Keep above when panel open
                    const mo = new MutationObserver(()=>{
                        try{ handle.style.zIndex = panel && !panel.classList.contains('hidden') ? '10000' : '211'; }catch{}
                    });
                    panel && mo.observe(panel, { attributes:true, attributeFilter:['class'] });
                })();

                // Track title box position changes (caused by --topSafeArea updates) and realign
                try{
                    let __lastTop = -1;
                    const watch = ()=>{
                        try{
                            const rb = titleBox?.getBoundingClientRect();
                            const t = rb ? Math.round(rb.top) : -1;
                            if(t !== __lastTop){ __lastTop = t; positionDockAndPanel(); }
                        }catch{}
                        requestAnimationFrame(watch);
                    };
                    requestAnimationFrame(watch);
                }catch{}
})();
</script>
<style>
/* Textbook-style AI output box (ID variant) */
#aiTextbookOutput{ background: linear-gradient(180deg,#fafaf6,#f3efe8); color:#111; border:1px solid rgba(0,0,0,0.08); padding:18px; border-radius:10px; font-family: 'Georgia', 'Times New Roman', serif; font-size:15px; line-height:1.6; box-shadow: 0 6px 18px rgba(0,0,0,0.06); color-scheme: light; }
#aiTextbookOutput .page{ background: linear-gradient(180deg,#fff,#f9f7f2); padding:14px; border-radius:6px; min-height:120px; white-space:pre-wrap; overflow:auto; }
#aiTextbookOutput .ascii-face{ font-family: monospace; font-size:12px; color:#333; margin-top:10px; display:flex; align-items:center; justify-content:flex-start; gap:8px }
#aiTextbookOutput .ascii-face .face{ background:#fff; border-radius:6px; padding:6px 10px; border:1px solid rgba(0,0,0,0.06); box-shadow: inset 0 1px 0 rgba(255,255,255,0.6); }
#aiTextbookOutput .ascii-face .mouth{ display:inline-block; min-width:28px; text-align:center; }
#aiTextbookOutput .controls{ margin-top:8px; display:flex; gap:8px; justify-content:flex-end }

/* Textbook-style AI output box (class variant when we augment existing element) */
.aiTextbookOutput{
    /* Dark-mode variant: match other panels */
    background: linear-gradient(180deg, rgba(14,21,34,.65), rgba(9,15,26,.6)) !important;
    color: var(--ink) !important;
    border: 1px solid var(--stroke) !important;
    padding: 12px !important;
    border-radius: 8px !important;
    font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial !important;
    font-size: 13px !important;
    line-height: 1.5 !important;
    box-shadow: var(--depth) !important;
}
.aiTextbookOutput .page{
    background: linear-gradient(180deg, rgba(10,16,24,.55), rgba(8,12,20,.55));
    padding: 10px; border-radius: 6px; /* the page will flex to available space */
    flex: 1 1 auto; min-height: 0; /* allow flexbox to constrain height and enable internal scrolling */
    white-space: pre-wrap; overflow: auto;
    color: var(--ink);
}
.aiTextbookOutput .ascii-face{
    font-family: monospace; font-size:12px; color:var(--ink); margin-top:6px; display:flex; align-items:center; justify-content:center; gap:8px; width:100%;
    flex: 0 0 auto; /* face should not grow; remain a fixed row below the page */
}
.aiTextbookOutput .ascii-face .face{
    background: linear-gradient(180deg, rgba(12,18,28,.6), rgba(8,12,18,.6));
    border-radius:6px; padding:8px 12px; border:1px solid rgba(255,255,255,0.03); box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
    color: var(--ink); font-size:20px; line-height:1; font-family: monospace;
}
.aiTextbookOutput .ascii-face .mouth{ display:inline-block; min-width:28px; text-align:center; position:relative; font-family: monospace }
.aiTextbookOutput .controls{ margin-top:8px; display:flex; gap:8px; justify-content:flex-end }
.aiTextbookOutput .face-inner{ display:flex; align-items:center; justify-content:center; gap:8px }
</style>

<script>
// Textbook output + typewriter + ASCII face + lightweight audio with controls + cancellation
(function(){
    const OUT_ID = 'resultsAiOutput';
    function ensureWrapper(){
        // If we've already created the textbook wrapper, return it
        const existing = document.getElementById('aiTextbookOutput');
        if(existing) return existing;
        const out = document.getElementById(OUT_ID);
        if(!out) return null;
        if(out.dataset && out.dataset.textbook === '1') return out;
    // augment the existing output element in-place so external code that references
    // `document.getElementById('resultsAiOutput')` continues to work
    const outEl = out;
    outEl.classList.add('aiTextbookOutput');
    const page = document.createElement('div'); page.className='page'; page.setAttribute('role','status'); page.setAttribute('aria-live','polite');
    // Ensure the page is the only scrollable area and can shrink properly inside flex containers
    page.style.flex = '1 1 auto'; page.style.minHeight = '0'; page.style.overflow = 'auto';
    const faceRow = document.createElement('div'); faceRow.className='ascii-face';
    const faceInner = document.createElement('div'); faceInner.className = 'face-inner';
    const faceBox = document.createElement('div'); faceBox.className='face'; faceBox.style.fontFamily='monospace'; faceBox.style.fontSize='20px';
    // Create eyes + mouth container; place the mouth between the eyes so it appears inside the face
    faceBox.innerHTML = "<span class='eyes'>(<span class='eye left'>•</span><span class='mouth'></span><span class='eye right'>•</span>)</span>";
    const mouthSpan = faceBox.querySelector('.mouth');
    // Put a simple underscore mouth; we'll toggle it open/closed while speaking
    mouthSpan.textContent = '___';
    faceInner.appendChild(faceBox);
    faceRow.appendChild(faceInner);
    const controls = document.createElement('div'); controls.className='controls';
        // Stop button
        const stopBtn = document.createElement('button'); stopBtn.type='button'; stopBtn.className='btn small'; stopBtn.textContent='Stop'; stopBtn.title='Stop animated output';
        // Audio toggle
        const audioToggle = document.createElement('button'); audioToggle.type='button'; audioToggle.className='btn small'; audioToggle.title='Toggle audio effects';
        const audioEnabled = (localStorage.getItem('ai.audio.enabled') === '1');
        audioToggle.textContent = audioEnabled ? 'Audio: On' : 'Audio: Off';
        audioToggle.dataset.enabled = audioEnabled ? '1' : '0';
        controls.appendChild(stopBtn); controls.appendChild(audioToggle);
    // hide controls UI per user's request (Stop / Audio buttons removed)
    try{ controls.style.display = 'none'; }catch(e){}

    // Apply flex layout to the output container so the page fills available vertical space up to the face
    try{ outEl.style.display = 'flex'; outEl.style.flexDirection = 'column'; outEl.style.gap = '8px'; outEl.style.height = outEl.style.height || '100%'; outEl.style.boxSizing = 'border-box'; }catch{}
    outEl.appendChild(page); outEl.appendChild(faceRow); outEl.appendChild(controls);
    outEl.dataset.textbook='1';
    outEl._page = page; outEl._faceBox = faceBox; outEl._mouthSpan = faceBox.querySelector('.mouth'); outEl._controls = controls; outEl._stopBtn = stopBtn; outEl._audioToggle = audioToggle;

    // Start semi-random eye movement and blinking when idle. This uses CSS variables
    // (--ex, --ey) to set small translations so blink (scaleY) composes with current translate.
    (function startEyeIdle(wrap){
        try{
            const out = wrap; if(!out) return;
            const faceBox = wrap._faceBox; if(!faceBox) return;
            const eyes = faceBox.querySelectorAll('.eye'); if(!eyes || !eyes.length) return;
            // Respect prefers-reduced-motion
            if(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

            let moveTimer = null, blinkTimer = null;
            function rand(min, max){ return min + Math.random()*(max-min); }

            function setEyeTranslate(e, x, y){
                try{ e.style.setProperty('--ex', x + 'px'); e.style.setProperty('--ey', y + 'px'); }catch(e){}
            }

            function doMove(){
                try{
                    // If typing is active, leave eyes neutral
                    if(out.classList.contains('ai-active')){
                        eyes.forEach(e=> setEyeTranslate(e, 0, 0));
                    } else {
                        // move both eyes in sequence (synchronously) using the same translation
                        const dx = Math.round(rand(-4, 6));
                        const dy = Math.round(rand(-2, 2));
                        eyes.forEach(e => setEyeTranslate(e, dx, dy));
                    }
                }catch(e){}
                scheduleMove();
            }

            function scheduleMove(){ moveTimer && clearTimeout(moveTimer); moveTimer = setTimeout(doMove, rand(700, 2200)); }

            function doBlink(){
                try{
                    if(out.classList.contains('ai-active')){ scheduleBlink(); return; }
                    eyes.forEach(e=> e.classList.add('blink'));
                    // quick blink close then open
                    setTimeout(()=>{ eyes.forEach(e=> e.classList.remove('blink')); }, 90 + Math.random()*80);
                }catch(e){}
                scheduleBlink();
            }

            function scheduleBlink(){ blinkTimer && clearTimeout(blinkTimer); blinkTimer = setTimeout(doBlink, rand(2400, 7600)); }

            // Start initial timers
            scheduleMove(); scheduleBlink();

            // expose cleanup so callers can cancel if needed
            wrap._clearEyeIdle = function(){ try{ moveTimer && clearTimeout(moveTimer); blinkTimer && clearTimeout(blinkTimer); eyes.forEach(e=>{ e.classList.remove('blink'); setEyeTranslate(e,0,0); }); }catch(e){} };
        }catch(e){}
    })(outEl);

    // control behaviour
    let currentController = null;
    stopBtn.addEventListener('click', ()=>{ try{ if(currentController) currentController.abort(); }catch{} });
    audioToggle.addEventListener('click', ()=>{
            try{
                const en = audioToggle.dataset.enabled === '1' ? false : true;
                audioToggle.dataset.enabled = en ? '1' : '0'; audioToggle.textContent = en ? 'Audio: On' : 'Audio: Off';
                localStorage.setItem('ai.audio.enabled', en ? '1' : '0');
            }catch{}
        });

    // Auto-enable audio by default for the textbook output if not explicitly set
    try{
        if(localStorage.getItem('ai.audio.enabled') === null){
            localStorage.setItem('ai.audio.enabled', '1');
            audioToggle.dataset.enabled = '1'; audioToggle.textContent = 'Audio: On';
        }
    }catch(e){}

    // Lightweight shared audio context and pulse engine (reuse across invocations)
    let __aiAudioCtx = null; let __aiAudioAllowed = false;
    function ensureAiAudio(){
        try{
            if(__aiAudioCtx) return __aiAudioCtx;
            const C = window.AudioContext || window.webkitAudioContext;
            if(!C) return null;
            __aiAudioCtx = new C();
            // Attempt to resume on user gesture if suspended
            if(__aiAudioCtx.state === 'suspended' && typeof __aiAudioCtx.resume === 'function'){
                // try to resume now; if blocked, caller gesture (Stop/Audio toggle) will resume
                __aiAudioCtx.resume().then(()=>{ __aiAudioAllowed = true; }).catch(()=>{ __aiAudioAllowed = false; });
            } else {
                __aiAudioAllowed = true;
            }
            return __aiAudioCtx;
        }catch(e){ return null; }
    }

    // visual audio bars animator: set random heights to show speaking activity
    function animateAudioBarsOnce(wrap, intensity){
        try{
            const bars = wrap._faceBox.querySelectorAll('.audio-bars .bar');
            if(!bars || !bars.length) return;
            bars.forEach(b => {
                const h = 4 + Math.round((Math.random() * (intensity||8)));
                b.style.height = h + 'px';
            });
        }catch(e){}
    }

        // expose helper to let showAiOutput set controller
        outEl._setController = (c)=>{ currentController = c; };

        // override textContent/innerText setters so older code that writes directly still
        // triggers the animated output rather than wiping our structure
        try{
            const descriptor = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent') || Object.getOwnPropertyDescriptor(Element.prototype, 'textContent');
            Object.defineProperty(outEl, 'textContent', {
                configurable: true,
                enumerable: false,
                get: function(){ return page.textContent; },
                set: function(v){
                    try{
                        // empty string => clear and stop
                        if(!v){ if(window.stopAiOutput) window.stopAiOutput(); page.textContent = ''; return; }
                        // otherwise, animate as spoken output
                        if(window.showAiOutput) { window.showAiOutput(String(v)); } else { page.textContent = String(v); }
                    }catch(e){ page.textContent = String(v); }
                }
            });
            Object.defineProperty(outEl, 'innerText', {
                configurable: true,
                enumerable: false,
                get: function(){ return page.innerText; },
                set: function(v){ try{ if(window.showAiOutput) window.showAiOutput(String(v)); else page.innerText = String(v); }catch(e){ page.innerText = String(v); } }
            });
        }catch(e){}

        return outEl;
    }

    function createNoiseEngine(){
        let ctx = null;
        try{ const AudioCtx = window.AudioContext || window.webkitAudioContext; ctx = new AudioCtx(); }catch(e){
            return { pulse:()=>{} };
        }

    // Master gain to control overall loudness
    const master = ctx.createGain(); master.gain.value = 6.0; /* set to 200% global volume (increased two-fold) */ master.connect(ctx.destination);

        // Create a short voiced/unvoiced pulse that combines an oscillator (voiced)
        // and filtered noise (unvoiced). The sound is intentionally noisy and
        // simplified — not real TTS — but with pitch glides and bandpass shaping
        // it approximates speech-like textures.
        function pulse(vol, opts){ try{
            opts = opts || {};
            const voiced = !!opts.voiced;
            const now = ctx.currentTime;
            // base duration (voiced tends to be a little longer)
            const dur = Math.max(0.04, (opts.dur || (voiced ? 0.10 : 0.055)) + (Math.random()*0.04));

            // per-pulse gain node (envelope)
            const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, now);
            const peak = Math.max(0.005, Math.min(0.16, (vol||0.04) * (voiced ? 1.2 : 1.0)));
            g.gain.linearRampToValueAtTime(peak, now + 0.008);
            g.gain.exponentialRampToValueAtTime(0.0001, now + dur + 0.02);
            g.connect(master);

            if(voiced){
                // Voiced: oscillator -> bandpass -> gain
                const osc = ctx.createOscillator();
                // use triangle or sawtooth for richer harmonic content
                osc.type = Math.random() < 0.5 ? 'triangle' : 'sawtooth';
                const baseHz = opts.pitch || (120 + Math.random()*240); // male-ish to mid range
                osc.frequency.setValueAtTime(baseHz, now);
                // gentle pitch glide for naturalness
                const glideTo = baseHz * (0.85 + Math.random()*0.35);
                osc.frequency.exponentialRampToValueAtTime(Math.max(60, glideTo), now + dur * (0.6 + Math.random()*0.3));

                const bp = ctx.createBiquadFilter(); bp.type = 'bandpass';
                bp.frequency.value = 500 + Math.random()*1600; // formant-ish region
                bp.Q.value = 6 + Math.random()*6;

                osc.connect(bp); bp.connect(g);
                osc.start(now); osc.stop(now + dur + 0.03);

                // small layer of noisy aspiration to blend
                const noiseBuf = ctx.createBuffer(1, Math.floor(ctx.sampleRate * dur), ctx.sampleRate);
                const ndata = noiseBuf.getChannelData(0);
                for(let i=0;i<ndata.length;i++) ndata[i] = (Math.random()*2 - 1) * (Math.random()*0.6);
                const nsrc = ctx.createBufferSource(); nsrc.buffer = noiseBuf;
                const nlp = ctx.createBiquadFilter(); nlp.type = 'lowpass'; nlp.frequency.value = 4000 + Math.random()*3000;
                nsrc.connect(nlp); nlp.connect(g);
                nsrc.start(now); nsrc.stop(now + dur + 0.02);

                // cleanup scheduled
                setTimeout(()=>{ try{ bp.disconnect(); osc.disconnect(); nsrc.disconnect(); nlp.disconnect(); g.disconnect(); }catch{} }, (dur + 0.06)*1000);

            } else {
                // Unvoiced: short noise burst shaped by highpass+bandpass to sound like fricatives
                const buffer = ctx.createBuffer(1, Math.floor(ctx.sampleRate * dur), ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for(let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (Math.random()*0.9);
                const src = ctx.createBufferSource(); src.buffer = buffer;
                const hp = ctx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = 1200 + Math.random()*3000;
                const bp = ctx.createBiquadFilter(); bp.type = 'bandpass'; bp.frequency.value = 2500 + Math.random()*3000; bp.Q.value = 2 + Math.random()*3;
                src.connect(hp); hp.connect(bp); bp.connect(g);
                src.start(now); src.stop(now + dur + 0.02);

                setTimeout(()=>{ try{ src.disconnect(); hp.disconnect(); bp.disconnect(); g.disconnect(); }catch{} }, (dur + 0.06)*1000);
            }
        }catch(e){ /* ignore audio errors */ } }

        return { pulse, ctx };
    }

    function typeWithMouth(text, opts, controller){
        const wrap = ensureWrapper(); if(!wrap) return Promise.resolve();
        const page = wrap._page; const mouth = wrap._mouthSpan; const audioToggle = wrap._audioToggle;
        const audioAllowed = audioToggle && audioToggle.dataset.enabled === '1';
        page.textContent = '';
        return new Promise((resolve)=>{
            let i=0; let charDelay = opts && opts.delay || 18; const audio = audioAllowed ? createNoiseEngine() : null;
            // ensure AudioContext exists and try resume on first use
            if(audioAllowed){ try{ ensureAiAudio(); }catch{} }
            if(audio){} // engine created on-demand in pulse
            function setMouth(open){
                try{
                    // simple moving mouth: open glyph while speaking, underscore when closed
                    mouth.textContent = open ? '▂' : '___';
                }catch(e){}
            }
            function scrollToBottom(){ try{ page.scrollTop = page.scrollHeight; }catch{} }
            function done(){ try{ setMouth(false); scrollToBottom(); }catch{}; resolve(); }
            function step(){
                if(controller && controller.aborted){ // immediate show full text and stop
                    page.textContent = text; scrollToBottom(); done(); return; }
                if(i>=text.length){ done(); return; }
                const ch = text[i++]; page.textContent += ch;
                // keep view pinned to bottom while typing
                try{ scrollToBottom(); }catch(e){}
                // open mouth for letters/punct that are speech-like
                const isLetter = /[A-Za-z0-9]/.test(ch);
                const isVowel = /[aeiouAEIOU]/.test(ch);
                const open = isLetter || isVowel || ch === ',' || ch === '-';
                setMouth(open);
                // animate visual bars and emit light pulse when mouth opens
                try{ animateAudioBarsOnce(wrap, open ? 10 : 3); }catch(e){}
                if(audio && open){ try{
                    // For vowels prefer voiced pulses with pitch glide; for other letters use mixed/short pulses
                    if(isVowel){ audio.pulse(0.035 + (Math.random()*0.02), { voiced:true, pitch: 160 + Math.random()*220, dur: 0.08 + Math.random()*0.06 }); }
                    else { audio.pulse(0.028 + (Math.random()*0.02), { voiced: Math.random() < 0.35, dur: 0.04 + Math.random()*0.04 }); }
                }catch{} }
                // compute delay
                let delay = charDelay;
                // longer pause after sentence end
                if(/[.?!]\s$/.test(page.textContent)){
                    // close mouth during pause
                    setMouth(false);
                    if(audio) try{ audio.pulse(0.008, { voiced:false, dur:0.04 }); }catch{};
                    delay = 520;
                }
                if(ch === '\n'){ setMouth(false); delay = 240; }
                setTimeout(step, delay);
            }
            step();
        });
    }

    window.showAiOutput = async function(text){
        const wrap = ensureWrapper(); if(!wrap) return;
        // cancel any existing output
        if(window.__aiOutputController && typeof window.__aiOutputController.abort === 'function'){
            try{ window.__aiOutputController.abort(); }catch{} }
        const controller = { aborted:false, abort: function(){ this.aborted = true; } };
        window.__aiOutputController = controller; wrap._setController && wrap._setController(controller);
        const page = wrap._page; page.scrollTop = 0; page.textContent = '';
        // mark output as active so idle animations pause while typing
        const outEl = document.getElementById(OUT_ID);
        try{ if(outEl) outEl.classList.add('ai-active'); }catch{}
        try{ await typeWithMouth(String(text||''), { delay: 16 }, controller); }catch(e){ page.textContent = text; }
        // Attempt to render any LaTeX present in the AI output
        try{ setTimeout(()=>{ try{ const el = wrap._page || wrap; window.renderMathIn && window.renderMathIn(el); }catch(e){} }, 60); }catch(e){}
        // clear controller after done
        if(window.__aiOutputController === controller) window.__aiOutputController = null;
        try{ if(outEl) outEl.classList.remove('ai-active'); }catch{}
    };

    // expose stop function
    window.stopAiOutput = function(){ try{ if(window.__aiOutputController) window.__aiOutputController.abort(); }catch{} };
})();
</script>