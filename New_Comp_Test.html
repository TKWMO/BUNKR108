<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <script>
        // Ensure callers can safely reference window.normalizeGreek (and common misspellings/variants)
        // before the real implementation is defined. These are safe passthroughs and will be
        // overwritten by the real implementations later in the file.
            try{
                const elCount = document.getElementById('savedCount'); if(elCount) elCount.textContent = String(arr.length);
                const elTotal = document.getElementById('savedTotalKb'); if(elTotal) elTotal.textContent = `Total: ${(totalBytes/1024).toFixed(1)} KB`;
            }catch(e){}
                if (!__ng_warned) {
                    try { console.warn('[notice] normalizeGreek fallback used before real implementation was parsed.'); } catch (e) {}
                    __ng_warned = true;
                }
                return s;
            };
            if (!window.normalizeGreek) window.normalizeGreek = fallback;
            // Common variants/misspellings observed in older scripts or third-party snippets
            if (!window.normalizegreek) window.normalizegreek = window.normalizeGreek;
            if (!window.normalizedGreek) window.normalizedGreek = window.normalizeGreek;
            if (!window.normalizedgreek) window.normalizedgreek = window.normalizeGreek;
        } catch (e) { /* noop in restrictive environments */ }
    </script>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <!-- Open Graph / Twitter preview metadata for link sharing -->
    <meta property="og:title" content="BUNKR 108 — AI-powered Study Interface" />
    <meta name="twitter:title" content="BUNKR 108 — AI-powered Study Interface" />
    <meta name="description" content="BUNKR 108 — AI-powered Study Interface for generating and reviewing multiple-choice questions locally in your browser." />
    <meta name="twitter:description" content="AI-powered, client-side MCQ generator and study tool. Run locally in your browser." />
    <meta property="og:description" content="AI-powered, client-side MCQ generator and study tool. Run locally in your browser." />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="BUNKR 108" />
    <meta name="twitter:card" content="summary" />
    <title>BUNKR 108 — AI-powered Study Interface</title>
    <!-- KaTeX for rendering LaTeX/math in quiz items and AI outputs -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="" crossorigin="anonymous">
    <script>
        // Lightweight dynamic loader for KaTeX + auto-render. Usage: window.renderMathIn(element, opts)
        (function(){
            if(window.renderMathIn) return;
            window.__katexReady = false; window.__katexQueue = [];
            function loadScript(url){ return new Promise((res,rej)=>{ const s=document.createElement('script'); s.src=url; s.async=true; s.onload=res; s.onerror=()=>rej(new Error('load failed '+url)); document.head.appendChild(s); }); }
            function _flush(){ try{ while(window.__katexQueue && window.__katexQueue.length){ const job = window.__katexQueue.shift(); try{ if(window.renderMathInElement) renderMathInElement(job.el, job.opts||{}); else if(window.katex && job.el) { /* best-effort: render inline $...$ by replacing via katex.renderToString is too invasive; prefer auto-render */ } }catch(e){ console.warn('katex render failed', e); } } }catch(e){ console.warn('katex flush error', e); } }
            async function _load(){ if(window.katex && window.renderMathInElement){ window.__katexReady = true; _flush(); return; } try{ await loadScript('https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js'); await loadScript('https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js'); window.__katexReady = true; _flush(); }catch(e){ console.warn('KaTeX load failed', e); }
            }
            // Safe render wrapper: decides whether to enable single-$ inline delimiters
            function _looksLikeMathBetweenDollar(s){
                // s is the content between $...$
                // Heuristic: require either a backslash (\command) or math-operator/special char
                try{
                    if(!s || typeof s !== 'string') return false;
                    if(/\\[a-zA-Z]+/.test(s)) return true; // \frac, \alpha, etc.
                    if(/[=+\-\^_{}<>\/]/.test(s)) return true;
                    // presence of digits with letters/operators suggests math (e.g., 2x, x^2)
                    if(/[0-9].*[a-zA-Z]|[a-zA-Z].*[0-9]/.test(s)) return true;
                    return false;
                }catch(e){ return false; }
            }
            window.renderMathIn = async function(el, opts){ try{ if(!el) return; const job = { el: el, opts: opts }; if(window.__katexReady && window.renderMathInElement){ try{
                        // Determine delimiters: always include display delimiters, but only include single-$
                        // when the content shows math-like patterns between $...$ to avoid false positives
                        const defaultDelims = [{left:'$$',right:'$$',display:true},{left:'\\[',right:'\\]',display:true},{left:'\\(',right:'\\)',display:false}];
                        let useDollar = false;
                        try{
                            const text = (el.textContent || el.innerText || '');
                            // find $...$ pairs
                            const re = /\$(.+?)\$/gs;
                            let m;
                            while((m = re.exec(text)) !== null){ if(_looksLikeMathBetweenDollar(m[1])){ useDollar = true; break; } }
                                try{
                                    // Prefer to keep the centered completion popup visible while the overlay fades.
                                    // If the popup was portaled to document.body, don't fade the box now — fade the overlay first,
                                    // then de-blur and fade out the popup after the overlay is removed.
                                    const comp = el.querySelector && el.querySelector('#fcCompleteContainer');
                                    const bodyComp = document.getElementById('fcCompleteContainer');
                                    const compInBody = !!(bodyComp && bodyComp.parentNode === document.body);
                                    const startOverlayFade = function(){
                                        try{
                                            el.style.transition = el.style.transition || 'opacity 320ms ease, transform 220ms ease';
                                            void el.offsetWidth;
                                            const onEnd = function(ev){
                                                try{
                                                    if(ev && ev.target !== el) return;
                                                    el.removeEventListener('transitionend', onEnd);
                                                    try{ if(document.body.contains(el)) document.body.removeChild(el); }catch(e){}
                                                    // If a portaled completion popup exists, perform de-blur then fade it out
                                                    try{
                                                        const popup = document.getElementById('fcCompleteContainer');
                                                        if(popup && popup.parentNode === document.body){
                                                            // de-blur the backdrop first (animate background/backdropFilter)
                                                            try{
                                                                popup.style.transition = popup.style.transition || 'background .28s ease, backdrop-filter .28s ease';
                                                                popup.style.background = 'rgba(0,0,0,0)';
                                                                popup.style.backdropFilter = 'none';
                                                            }catch(e){}
                                                            // then fade the inner box out
                                                            const inner = popup.firstElementChild || popup.querySelector('div');
                                                            if(inner){
                                                                try{ inner.style.transition = inner.style.transition || 'opacity .28s ease'; }catch(e){}
                                                                setTimeout(()=>{ try{ inner.style.opacity = '0'; }catch(e){} }, 180);
                                                            }
                                                            // remove popup after fade completes
                                                            setTimeout(()=>{ try{ if(document.body.contains(popup)) document.body.removeChild(popup); }catch(e){} _cleanup(); }, 520);
                                                            return;
                                                        }
                                                    }catch(e){}
                                                    _cleanup();
                                                }catch(e){}
                                            };
                                            el.addEventListener('transitionend', onEnd);
                                            requestAnimationFrame(()=>{ try{ el.style.opacity = '0'; el.style.transform = 'scale(0.995)'; }catch(e){} });
                                            // Fallback in case transitionend doesn't fire
                                            setTimeout(()=>{ try{ if(document.body.contains(el)) { try{ document.body.removeChild(el); }catch(e){} } _cleanup(); }catch(e){} }, 520);
                                        }catch(e){ try{ if(document.body.contains(el)) document.body.removeChild(el); }catch(e){} _cleanup(); }
                                    };

                                    if(comp && !compInBody){
                                        // completion popup is inside the overlay element — fade it first then fade overlay
                                        const box = comp.firstElementChild || comp.querySelector('div');
                                        if(box){ box.style.transition = box.style.transition || 'opacity .22s ease'; requestAnimationFrame(()=>{ try{ box.style.opacity = '0'; }catch(e){} }); }
                                        setTimeout(startOverlayFade, 220);
                                    } else {
                                        // If popup is portaled to body (compInBody true) or no popup exists, fade overlay immediately
                                        startOverlayFade();
                                    }
                                }catch(e){
                                    // fallback to immediate overlay fade
                                    try{ el.style.transition = el.style.transition || 'opacity 320ms ease, transform 220ms ease'; void el.offsetWidth; el.style.opacity = '0'; el.style.transform = 'scale(0.995)'; }catch(e){}
                                    setTimeout(()=>{ try{ if(document.body.contains(el)) document.body.removeChild(el); }catch(e){} _cleanup(); }, 520);
                                }
                if(!window.html2canvas){
                    // loadLib returns a Promise; call and handle rejection rather than using await here
                    try{ loadLib('https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js').catch(function(e){ console.warn('html2canvas load failed', e); }); }catch(e){ console.warn('html2canvas load failed', e); }
                }
                // Ensure jsPDF UMD
                if(!window.jspdf){
                    try{ loadLib('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js').catch(function(e){ console.warn('jsPDF load failed', e); }); }catch(e){ console.warn('jsPDF load failed', e); }
                }

                if(window.html2canvas && (window.jspdf || window.jspdf?.jsPDF || (window.jspdf && window.jspdf.jsPDF))){
                    try{
                        // append offscreen so fonts/styles apply
                        wrapper.style.position = 'fixed'; wrapper.style.left = '-5000px'; wrapper.style.top = '0'; document.body.appendChild(wrapper);
                        const canvas = await window.html2canvas(wrapper, { scale: 2, useCORS: true, logging: false });
                        // get image data
                        const imgData = canvas.toDataURL('image/jpeg', 0.95);
                        // Create jsPDF instance (UMD exposes window.jspdf.jsPDF)
                        const jsPDF = (window.jspdf && window.jspdf.jsPDF) ? window.jspdf.jsPDF : (window.jspdf ? window.jspdf : null);
                        if(!jsPDF && window.jspdf && window.jspdf.jsPDF) jsPDF = window.jspdf.jsPDF;
                        const pdf = new (jsPDF)({ unit: 'pt', format: 'a4' });
                        const pageW = pdf.internal.pageSize.getWidth(); const pageH = pdf.internal.pageSize.getHeight();
                        // scale image to page width while keeping aspect
                        const iw = canvas.width; const ih = canvas.height; const ratio = Math.min(pageW / iw, pageH / ih);
                        const imgW = iw * ratio; const imgH = ih * ratio;
                        pdf.addImage(imgData, 'JPEG', 20, 20, imgW - 40, imgH - 40);
                        const name = `${title.replace(/[^a-zA-Z0-9-_ ]/g,'').slice(0,120) || 'export'}.pdf`;
                        pdf.save(name);
                        wrapper.remove();
                        return;
                    }catch(e){ console.warn('Programmatic PDF generation failed', e); try{ wrapper.remove(); }catch(_){} }
                }

                // Fallback: open print preview in new window
                try{
                    const win = window.open('', '_blank');
                    if(!win){ alert('Popup blocked. Allow popups or use the browser Print dialog.'); return; }
                    const css = `<style>body{font-family:Arial,Helvetica,sans-serif;color:#111;padding:18px;max-width:900px;margin:0 auto} h1{font-size:20px;margin-bottom:12px} .q{margin-bottom:14px} .choice{margin-left:18px} .correct{color:#167f3a;font-weight:700} .wrong{color:#b91c1c;font-weight:700} .meta{color:#666;font-size:13px;margin-bottom:8px}</style>`;
                    win.document.write('<!doctype html><html><head><meta charset="utf-8"><title>'+encodeHTML(title)+'</title>'+css+'</head><body>');
                    win.document.write('<h1>' + encodeHTML(title) + '</h1>');
                    win.document.write(bodyHtml || '<div>(no content)</div>');
                    win.document.write('</body></html>');
                    win.document.close();
                    setTimeout(()=>{ try{ win.focus(); win.print(); }catch(e){ console.warn('print failed', e); } }, 400);
                    return;
                }catch(e){ console.error('fallback print failed', e); alert('Export failed: ' + (e?.message||e)); }
            }catch(e){ console.error('exportHtmlToPdf error', e); alert('Export failed: ' + (e?.message||e)); }
        }

        // Legacy export builders removed. New export implementation added below.
        // (buildPlainPreviewBody and buildAnswerKey were removed to allow a fresh reimplementation.)



        // New export implementation (ground-up)
        function collectPrintableHtml(highlightCorrect){
            // Prefer `seeAllContent` if populated
            try{
                const seeAll = document.getElementById('seeAllContent');
                if(seeAll && seeAll.textContent && seeAll.textContent.trim()){
                    const pre = encodeHTML(seeAll.textContent || '');
                    return `<div class="export-root"><pre style="white-space:pre-wrap;font-family:inherit">${pre}</pre></div>`;
                }
            }catch(e){}

            // If previewList has content, use its rendered HTML (sanitized minimally)
            try{
                const preview = document.getElementById('previewList');
                if(preview && preview.innerHTML && preview.innerHTML.trim()){
                    // Clone and strip interactive controls (buttons, inputs)
                    const clone = preview.cloneNode(true);
                    clone.querySelectorAll && clone.querySelectorAll('button,input,textarea,select').forEach(n=>{ try{ n.remove(); }catch(e){} });
                    return `<div class="export-root">${clone.innerHTML}</div>`;
                }
            }catch(e){}

            // Fallback: try to build from in-memory state
            try{
                const items = (window.__quizState && window.__quizState.items) ? window.__quizState.items : (window.state && window.state.items) ? window.state.items : [];
                if(!items || !items.length) return '<div class="hint">No parsed items.</div>';
                const letters = ['A','B','C','D','E','F','G'];
                const html = items.map((it, ix)=>{
                    const num = it.num || (ix+1);
                    const q = encodeHTML(it.q || it.text || '');
                    const choices = Array.isArray(it.choices) ? it.choices : [];
                    const choicesHtml = choices.map((c,i)=>{
                        const isCorrect = highlightCorrect && (typeof it.correctIdx === 'number') && i===it.correctIdx;
                        if(isCorrect) return `<div style="margin:6px 0"><strong>${letters[i]||i+1}.</strong> <span class=\"export-correct\">${encodeHTML(c)}</span></div>`;
                        return `<div style="margin:6px 0"><strong>${letters[i]||i+1}.</strong> ${encodeHTML(c)}</div>`;
                    }).join('');
                    return `<div style="margin-bottom:12px"><div><strong>Q${num}.</strong> ${q}</div>${choicesHtml}</div>`;
                }).join('');
                return `<div class="export-root">${html}</div>`;
            }catch(e){ return '<div class="hint">No parsed items.</div>'; }
        }

        function openPrintableWindow(title, bodyHtml){
            try{
                const win = window.open('', '_blank');
                if(!win){ alert('Popup blocked. Allow popups or use the browser Print dialog.'); return; }
                const css = `<style>body{font-family:Arial,Helvetica,sans-serif;color:#111;padding:18px;max-width:900px;margin:0 auto} h1{font-size:20px;margin-bottom:12px} .q{margin-bottom:14px} .choice{margin-left:18px} .export-correct{color:#167f3a;font-weight:700} .meta{color:#666;font-size:13px;margin-bottom:8px}</style>`;
                win.document.write('<!doctype html><html><head><meta charset="utf-8"><title>'+encodeHTML(title)+'</title>'+css+'</head><body>');
                win.document.write('<h1>' + encodeHTML(title) + '</h1>');
                win.document.write(bodyHtml || '<div>(no content)</div>');
                win.document.write('</body></html>');
                win.document.close();
                setTimeout(()=>{ try{ win.focus(); win.print(); }catch(e){ console.warn('print failed', e); } }, 400);
            }catch(e){ console.error('print preview failed', e); alert('Export failed: ' + (e?.message||e)); }
        }

        function exportPdfNew(){
            try{
                const highlight = !!(document.getElementById('exportPdfHighlight') && document.getElementById('exportPdfHighlight').checked);
                const html = collectPrintableHtml(highlight);
                openPrintableWindow('Preview — All Questions', html);
            }catch(e){ console.error('export failed', e); alert('Export failed: ' + (e?.message||e)); }
        }

        // Wire buttons after DOM ready
        function wire(){
            // Wire new Export PDF button
            try{
                const btn = document.getElementById('exportPdfBtn'); if(btn) btn.addEventListener('click', (e)=>{ e.preventDefault(); exportPdfNew(); });
                // Wire highlight label visual
                const hp = document.getElementById('exportPdfHighlight'); const hpl = document.getElementById('exportPdfHighlightLabel');
                if(hp && hpl){ const update = ()=>{ if(hp.checked) hpl.classList.add('export-on'); else hpl.classList.remove('export-on'); }; update(); hp.addEventListener('change', update); }
            }catch(e){}
        }
        if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', wire); else wire();
    })();
    // Ensure invert-timer toggle is robustly wired even if earlier nested initialization failed
    (function(){
        try{
            const menu = document.getElementById('invertTimerMenu');
            const toggle = document.getElementById('invertTimerToggle');
            const content = document.getElementById('invertTimerMenuContent');
            if(!menu || !toggle || !content) return;
            // Avoid double-binding
            if(toggle.dataset._invertWired === '1') return; toggle.dataset._invertWired = '1';

            function expand(){ menu.classList.add('expanded'); toggle.setAttribute('aria-expanded','true'); content.setAttribute('aria-hidden','false'); }
            function collapse(){ menu.classList.remove('expanded'); toggle.setAttribute('aria-expanded','false'); content.setAttribute('aria-hidden','true'); }

            toggle.addEventListener('click', function(e){ try{ e.preventDefault(); menu.classList.contains('expanded') ? collapse() : expand(); }catch(e){} });
            // Close on Escape when expanded
            document.addEventListener('keydown', function(ev){ try{ if(ev.key === 'Escape' && menu.classList.contains('expanded')){ collapse(); toggle.focus(); } }catch(e){} });
            // Initialize collapsed state
            try{ collapse(); }catch(e){}
        }catch(e){ /* no-op */ }
    })();
    </script>
    <style>
        .export-highlight-label{ transition: color .12s ease; color: var(--muted); }
    /* When export highlight is enabled, make the label visually prominent: bold + green */
    .export-highlight-label.export-on{ color: #16a34a; font-weight: 700; text-shadow: 0 1px 0 rgba(0,0,0,0.25); }

        :root {
            --bg: #070b12;
            --ink: #e9f0f7;
            --muted: #9fb0c5;
            --panel: #0c1320aa;
            /* Global, compact spacing for inline/stacked control rows */
                --control-gap: 4px; /* scaled x1.25 per user request */
            .flex-wrap {
                flex-wrap: wrap
            }
            --stroke: #1f2a44aa;
            --brand: #6aa9ff;
            --ok: #22c55e;
            --bad: #ef4444;
            --glass-blur: 14px;
            --depth: 0 12px 30px rgba(0, 0, 0, .35), inset 0 1px 0 rgba(255, 255, 255, .04);
            /* Themeable lighting + buttons */
            --glow1: rgba(74, 144, 255, .20);
            --glow2: rgba(112, 220, 255, .14);
            --glow3: rgba(130, 100, 255, .16);
            --btnTop: rgba(96, 165, 250, .35);
            --btnBottom: rgba(24, 60, 120, .65);
            --btnBorder: #1f3a64;
        }

        * {
            box-sizing: border-box
        }

        html,
            .flex-wrap {
                flex-wrap: wrap
            }
        body {
            height: 100%
        }

        body {
            margin: 0;
            color: var(--ink);
            font: 16px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Helvetica, Arial;
            overflow-x: hidden;
            background: #060a12;
            
        }

        /* fixed animated gradient layer (doesn't reset on scroll) */
        .bg-anim {
            position: fixed;
            /* Use viewport-based insets to avoid percent-based shrink on tab restore */
            top: -25vh; left: -25vw; right: -25vw; bottom: -25vh;
            z-index: -1;
            pointer-events: none;
            transform: translateZ(0);
            will-change: transform;
            filter: blur(60px) saturate(130%);
            background:
                radial-gradient(1100px 700px at 12% 18%, var(--glow1), transparent 90%),
                radial-gradient(900px 600px at 88% 12%, var(--glow2), transparent 92%),
                radial-gradient(900px 650px at 45% 88%, var(--glow3), transparent 90%);
            animation: bgDrift 22s ease-in-out infinite alternate;
        }
        /* Lighter effect on small screens to save battery/GPU */
        @media (max-width: 640px){
            .bg-anim{ filter: blur(40px) saturate(120%); }
        }

        /* Custom button colors */
        .btn#skipBtn {
            background: linear-gradient(180deg, var(--btnTop), var(--btnBottom));
            border-color: var(--btnBorder);
        }

        .btn#skipBtn:hover {
            filter: brightness(1.08);
        }

        .btn#submitBtn {
            background: linear-gradient(180deg, rgba(34, 197, 94, .6), rgba(16, 83, 44, .9));
            border-color: #22c55e;
        }

        .btn#submitBtn:hover {
            background: linear-gradient(180deg, rgba(54, 217, 114, .7), rgba(26, 93, 54, .95));
        }

        @keyframes bgDrift {
            0% {
                transform: translate3d(-1%, -1%, 0) scale(1.02);
            }

            50% {
                transform: translate3d(1%, 2%, 0) scale(1.035);
            }

            100% {
                transform: translate3d(3%, -1%, 0) scale(1.02);
            }
        }

        @media (prefers-reduced-motion: reduce) {
            .bg-anim {
                animation: none;
            }
        }

        .container {
            max-width: 1100px;
            margin: 24px auto;
            padding: 0 16px
        }

        /* When a quiz is running, hide the Random/Daily quiz controls to avoid accidental navigation */
        body.quiz-running #dailyQuizBtn,
        body.quiz-running #randomQuizBtn,
        body.quiz-running #randomGearWrap {
            display: none !important;
        }

            /* Ensure main column can shrink so its children (cards) can fill available width */
            .quizgrid .col:first-child { min-width: 0; }
        @media (max-width: 640px){ .container{ margin: 16px auto; padding: 0 12px; } }

        .card {
            background: var(--panel);
            border: 1px solid var(--stroke);
            border-radius: 18px;
            box-shadow: var(--depth);
            -webkit-backdrop-filter: blur(var(--glass-blur));
            backdrop-filter: blur(var(--glass-blur));
        }

        .pad {
            padding: 18px
        }

        h1 {
            margin: 0 0 6px;
            font-size: 26px;
            text-shadow: 0 1px 0 rgba(0, 0, 0, .35)
        }

        .hint {
            color: var(--muted);
            font-size: 13px
        }

        .row {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: stretch; /* ensure columns match height */
        }

        .col {
            flex: 1 1 300px;
            display: flex;
            flex-direction: column;
            min-height: 0; /* allow children to shrink */
        }

        textarea {
            width: 100%;
            height: 320px; /* base height */
            max-height: none;
            color: var(--ink);
            background: linear-gradient(180deg, rgba(14, 20, 32, .65), rgba(10, 16, 28, .55));
            border: 1px solid rgba(60, 80, 120, .35);
            border-radius: 14px;
            padding: 12px;
            resize: none; /* prevent manual extension */
            overflow: auto; /* allow scrolling */
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, .08)
        }
        @media (max-width: 640px){ textarea{ height: 220px; } }

        /* File input styling */
        .file-input{
            display:flex; align-items:center; gap:8px; width:100%;
            background: linear-gradient(180deg, rgba(14, 20, 32, .65), rgba(10, 16, 28, .55));
            border: 1px solid rgba(60, 80, 120, .35);
            border-radius: 10px; padding: 6px 8px;
        }
        .file-input input[type=file]{ display:none }
        .file-input .choose-btn{
            display:inline-flex; align-items:center; justify-content:center; padding:6px 10px; border-radius:8px;
            background: linear-gradient(180deg, var(--btnTop), var(--btnBottom));
            border: 1px solid var(--btnBorder); color: var(--ink); font-weight: 700; cursor:pointer;
            font-size: 13px; line-height: normal; box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
        }
          /* Let the Choose File button size to its text content while avoiding layout shifts
              - flex: 0 0 auto keeps it its intrinsic width
              - filename area uses flex:1 so it absorbs variable text (long filenames)
          */
          .file-input .choose-btn{ flex: 0 0 auto; width: auto; min-width: 0; padding:6px 10px; box-sizing: border-box; white-space:nowrap }
          /* Ensure filename area flexes and truncates gracefully when needed */
          .file-input .filename{ flex: 1 1 auto; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap }
          @media (max-width: 760px){ .file-input .choose-btn{ padding:8px 12px } }
        @media (max-width: 640px){ .file-input .choose-btn{ min-height: 44px; display:flex; align-items:center; } }
        .file-input .filename{ flex:1 1 auto; color: var(--muted); font-size: 12px; overflow:hidden; text-overflow: ellipsis; white-space:nowrap }

        .options-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 0px;
            margin-bottom: 10px;
            align-items: center
        }

        /* Theme the checkboxes inside option pills */
        .pill input[type="checkbox"]{ accent-color: var(--brand); }
    .pill input[type="checkbox"]:focus-visible{ outline: 2px solid var(--brand); outline-offset: 2px; border-radius: 4px }

    /* Removed brand accent on quiz radios to avoid color bleed; radios are custom-rendered in the quiz section */
    /* .choice input[type="radio"]{ accent-color: var(--brand); } */

/* Compact choice styling so options fit narrower cards and wrap neatly */
.choice{
    display:block;
    margin:6px 0;
    padding:8px 10px;
    border:1px solid rgba(70,90,130,.28);
    border-radius:10px;
    cursor:pointer;
    background:linear-gradient(180deg, rgba(14,20,32,.45), rgba(10,15,26,.45));
    font-size:14px;
    line-height:1.25;
    word-break:break-word;
    box-sizing:border-box;
}
.choice strong{ display:inline-block; width:2.2em; vertical-align: middle; white-space: nowrap; }
.choice.correct{ border-color:#155e37; background:linear-gradient(180deg, rgba(11,30,21,.65), rgba(6,20,14,.55)); }
.choice.wrong{ border-color:#7f1d1d; background:linear-gradient(180deg, rgba(26,15,16,.65), rgba(18,10,12,.55)); }

        .pill {
            padding: 6px 10px;
            border: 1px solid var(--btnBorder);
            background: linear-gradient(180deg, var(--btnTop), rgba(10, 16, 28, .7));
            border-radius: 999px;
            white-space: nowrap
        }

        /* Align the right column (Options + AI) with the top of the parent panel/header */
        #setup .row.mt-10{ margin-top: 0 } /* remove extra spacer pushing both cols down */
    #setup .row > .col:nth-child(2){ margin-top: -56px } /* lift options to top of parent card */
    /* Push designated bottom modules to the column bottom so both columns meet at the same baseline */
    #setup .row > .col .ai-file-panel, #setup .row > .col .saved-card { margin-top: auto }
    @media (max-width: 900px){ #setup .row > .col:nth-child(2){ margin-top: 0 } }

        /* Paste area wrapper to host the Index button */
        .paste-wrap{ position: relative }
        .paste-wrap .index-btn{
            position:absolute; right:10px; bottom:10px; z-index:2;
            padding:8px 12px; border-radius:999px; font-weight:800; font-size:12px; cursor:pointer;
            border:1px solid var(--btnBorder);
            background: linear-gradient(180deg, var(--btnTop), var(--btnBottom));
            color: var(--ink); box-shadow: var(--depth);
        }
        .paste-wrap .index-btn.saved{ pointer-events:none; filter:brightness(1.05) }

        /* Saved MCQs module styles */
     /* Lift the saved content card and its inline dropdown above other in-flow elements
         but keep it below the light-mode overlay so inversion still applies. */
     .saved-card{ position:relative; z-index: 2147483645; margin-top:10px; padding:10px; border-radius:12px; border:1px solid var(--btnBorder); background: linear-gradient(180deg, rgba(16,25,40,.75), rgba(10,16,28,.75)); box-shadow: var(--depth) }
    .saved-header{ display:flex; align-items:center; justify-content:space-between; gap:8px }
    /* Dropdown list container (overlay). Use fixed + very high z-index so nothing overlaps. */
    /* Use absolute so it scrolls with content, portal to body to avoid clipping; keep very high z-index */
     /* Use fixed positioning so the dropdown escapes ancestor stacking contexts and clipping
         (matches other inline dropdowns that are portaled to document.body). Position is
         computed in JS as viewport coordinates. Keep very high z-index so it appears above
         other UI modules but below global overlays when appropriate. */
    .saved-menu{ position:fixed; top: 0; left:0; z-index: 2147483645; width: auto; max-width: 96vw; box-sizing: border-box; max-height: 50vh; overflow:auto; border: 1px solid var(--btnBorder); border-radius: 12px; background: linear-gradient(180deg, rgba(16,25,40,.95), rgba(10,16,28,.95)); box-shadow: 0 10px 24px rgba(0,0,0,.45); display:none }
    .saved-menu.open{ display:block }
    .saved-list{ display:flex; flex-direction:column; gap:8px; padding:8px }
        .saved-item{ display:flex; align-items:center; justify-content:space-between; gap:8px; padding:4px 8px; border-radius:6px; border:1px solid rgba(60,80,120,.35); background: linear-gradient(180deg, rgba(14,20,32,.55), rgba(10,16,28,.55)) }
        .saved-item .si-main{ min-width:0 }
    .saved-item .si-title{ font-weight:700; color:var(--ink); cursor:text; line-height:1.2 }
    /* Inline last-revisited badge next to title: same size, grey, on one line */
    .saved-item .si-title .si-lastrev{ color: var(--muted); font-size: inherit; line-height: inherit; margin-left: 8px; white-space: nowrap }
    .saved-item .si-title[contenteditable="true"]:focus{ outline: 2px solid rgba(96,165,250,.35); outline-offset: 2px; border-radius: 4px }
        .saved-item .si-meta{ color:var(--muted); font-size:11px }
        .saved-item .si-actions{ display:flex; gap:6px; flex-shrink:0; align-items:center }

        /* Saved-row actions (Generate / Validate) and applied visual state */
    .saved-row{ display:flex; align-items:center; justify-content:space-between; padding:4px 6px; border-radius:6px }
    .saved-row .si-actions{ display:flex; gap:8px; align-items:center; flex-shrink:0 }
    .saved-row .si-actions .btn.small{ padding:4px 8px; font-size:11px; min-height:0; height:auto; line-height:1 }
        .saved-row.applied{ box-shadow: 0 6px 18px rgba(106,169,255,0.06), inset 0 1px 0 rgba(255,255,255,0.02); transform: translateY(-1px) }

    /* Persisted selection state for the chosen source used by Generate */
    .saved-row.selected{ box-shadow: 0 10px 30px rgba(106,169,255,0.10); border: 1px solid rgba(106,169,255,0.18); transform: translateY(-1px); }

        .btn {
            appearance: none;
            border: 1px solid rgba(78, 102, 146, .45);
            background: linear-gradient(180deg, rgba(24, 36, 56, .55), rgba(12, 20, 34, .65));
            color: var(--ink);
            padding: 10px 14px;
            border-radius: 14px;
            cursor: pointer;
            font-weight: 700;
            letter-spacing: .2px;
            transition: .12s
        }
        /* Circle wrapper for gear button to visually match the Random Quiz pill */
        .gear-circle{
            display:inline-flex; align-items:center; justify-content:center; overflow:hidden;
            width:36px; height:36px; border-radius:999px; padding:0; box-sizing:border-box;
            border: 1px solid rgba(78, 102, 146, .45);
            background: linear-gradient(180deg, rgba(24, 36, 56, .55), rgba(12, 20, 34, .65));
            color: var(--ink); cursor: pointer; margin-left:6px;
            box-shadow: var(--depth); transition: transform .12s ease, filter .12s ease;
        }
        .gear-circle:hover{ transform: translateY(-1px); filter:brightness(1.06) }
    .gear-circle .gear-btn{ background: transparent; border:0; padding:0; font-size:22px; line-height:0; color:inherit; width:100%; height:100%; border-radius:999px; display:inline-grid; place-items:center }
    /* ensure the inner glyph (font icon or svg) is block-level and scales to the available space */
    .gear-circle .gear-btn > *{ display:block; width:1em; height:1em }
        /* Mobile tap affordance */
    .btn, button, .theme-orb, .choose-btn { -webkit-tap-highlight-color: rgba(255,255,255,.1); }
    .btn.pill{ border-radius:999px; padding-left:14px; padding-right:14px }
    .mt-8{ margin-top:8px }
        @media (max-width: 640px){ .btn{ padding: 12px 14px; min-height: 44px; } }

        /* Compact TOC + Saved textbook styles (tight, minimal within TOC panel) */
    .tb-toc{ height:120px; overflow:auto; padding:8px; border-radius:10px; font-size:13px }
    .tb-log{ height:120px; overflow:auto; padding:10px; border-radius:10px }
        .compact-saved{ margin-top:10px; padding:8px; border-radius:10px; font-size:13px }
        .compact-row{ gap:8px; align-items:center }
    .btn.small{ padding:6px 12px; font-size:13px; border-radius:10px; min-height:36px; display:inline-flex; align-items:center; }
          .compact-select{ font-size:13px; padding:6px 8px }
          /* Tighter saved-select + action layout to avoid overlap with Show/Delete/Clear
              Keep visual theme consistent: compact padding, subtle border, and controlled max-width
              so the select won't grow past the action buttons on narrow panels. */
          .custom-select-wrap{ flex: 1; min-width: 0; }
          .custom-select-wrap{ position: relative }
          /* Ensure the saved actions sit inline and don't wrap; tighten button spacing */
          .saved-actions{ display:flex; gap:8px; align-items:center; flex: 0 0 auto }
          .saved-actions .btn.small{ padding:6px 10px; font-size:13px; border-radius:10px; min-width:56px }
          /* Make the native select visually match other controls and cap its maximum width */
                    .saved-select{ height:36px; border-radius:10px; background: #0c1526; color:var(--ink); border:1px solid var(--btnBorder); padding:6px 10px; box-shadow: inset 0 1px 0 rgba(255,255,255,.04); min-width: 160px; max-width: 100%; display: inline-block; vertical-align: middle }
                    /* Make the closed select look like other themed controls (custom chevron + no native chrome styling) */
                    .saved-select{ appearance: none; -webkit-appearance: none; -moz-appearance: none; position: relative; padding-right: 36px; background-image:
                                linear-gradient(45deg, rgba(233,240,247,.9) 50%, transparent 50%),
                                linear-gradient(-45deg, rgba(233,240,247,.9) 50%, transparent 50%),
                                linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0));
                    background-size: 8px 8px, 8px 8px, 100% 100%;
                    background-position: right 12px center, right 12px center, 0 0;
                    background-repeat: no-repeat;
                }
                /* Hide IE/Edge default arrow where supported */
                .saved-select::-ms-expand{ display: none }
                /* Options styling: browser support varies, but modern Chromium/Edge/Firefox respect these rules */
                .saved-select option, .saved-select optgroup { background: linear-gradient(180deg, rgba(16,25,40,.98), rgba(10,16,28,.98)); color: var(--ink); padding:6px 10px }
                .saved-select option:hover { background: linear-gradient(180deg, rgba(96,165,250,.06), rgba(24,60,120,.05)); color: var(--ink) }
                /* Selected/highlighted option styling (best-effort; exact behavior differs between browsers) */
                .saved-select option:checked, .saved-select option[selected] { background: linear-gradient(90deg, rgba(59,130,246,.95), rgba(37,99,235,.95)); color: #fff }
                /* Focus state to match other controls */
                .saved-select:focus{ outline: 2px solid rgba(96,165,250,.28); outline-offset: 2px }
                /* Attempt to style scrollbars inside the native dropdown on WebKit-based browsers */
                .saved-select option::-webkit-scrollbar, .saved-select::-webkit-scrollbar { width: 10px; height: 10px }
                .saved-select option::-webkit-scrollbar-track, .saved-select::-webkit-scrollbar-track { background: rgba(12,21,34,.9); border-radius:8px }
                .saved-select option::-webkit-scrollbar-thumb, .saved-select::-webkit-scrollbar-thumb { background: linear-gradient(180deg, rgba(110,150,200,.5), rgba(70,100,160,.5)); border-radius:8px; border:1px solid rgba(40,60,90,.35) }
          /* On very small screens allow select to shrink but keep actions usable */
          @media (max-width: 520px){ .custom-select-wrap{ max-width: 100%; flex: 1 1 58%; } .saved-actions{ gap:6px } .saved-actions .btn.small{ padding:6px 8px; min-width:48px } }
    /* Inline custom dropdown visuals */
    .custom-inline-dropdown{ display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:10px; border:1px solid var(--btnBorder); background: linear-gradient(180deg, rgba(14,20,32,.65), rgba(10,16,28,.65)); color:var(--ink); cursor:pointer; min-width:160px; width: 100%; box-shadow: var(--depth); }
    .custom-inline-dropdown .inline-selected{ flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis }
    .custom-inline-dropdown .inline-chevron{ opacity:.85 }
     /* Anchor the dropdown list to its parent wrapper (position:relative). Use a z-index
    slightly below the light-mode overlay so the list is affected by inversion.
    The overlay has pointer-events:none, so interactivity remains intact. This keeps
    the dropdown visually consistent with the rest of the UI when inverted display
    is enabled.
         while still appearing above other in-flow UI elements. */
     /* Use fixed positioning for the dropdown list so ancestor overflow or stacking contexts
         cannot clip it. Placement is computed by JS when opening so it remains visually
         anchored to the trigger while escaping any parent with overflow:hidden. The
         z-index keeps it below the light-mode overlay but above other page elements. */
    .custom-inline-list{ position:fixed; left:0; top:0; z-index: 2147483645; margin-top:0; min-width: 220px; box-sizing:border-box; background: linear-gradient(180deg, rgba(16,25,40,.98), rgba(10,16,28,.98)); border:1px solid var(--btnBorder); border-radius:10px; box-shadow: 0 10px 24px rgba(0,0,0,.45); padding:6px; max-height: 48vh; overflow:auto; will-change: transform, left, top; }
    .custom-inline-list .custom-inline-item{ padding:8px 10px; border-radius:8px; margin:4px 0; cursor:pointer; color:var(--ink); }
    .custom-inline-list .custom-inline-item:focus, .custom-inline-list .custom-inline-item:hover{ outline:none; background: linear-gradient(180deg, rgba(96,165,250,.06), rgba(24,60,120,.05)); }
    .custom-inline-list .custom-inline-item[aria-selected='true'], .custom-inline-list .custom-inline-item.selected{ background: linear-gradient(90deg, rgba(59,130,246,.95), rgba(37,99,235,.95)); color:#fff }
    .visually-hidden{ position:absolute !important; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0 }
        .compact-actions button{ margin-left:6px }
        .compact-details{ margin-top:6px; font-size:12px }
        .saved-sample.compact-sample{ margin-top:6px; max-height:84px; overflow:auto; padding:8px; background: linear-gradient(180deg, rgba(8,12,18,.4), rgba(6,10,14,.35)); border-radius:8px }
        .saved-row{ padding:6px; border-radius:8px }

    /* Saved header badge centering */
    .saved-header-left{ align-items:center }
    .saved-badge-wrap{ display:flex; align-items:center; justify-content:center; min-width:28px; height:28px; border-radius:8px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:2px 6px }
    #savedCount{ display:inline-block }

        /* Page-level title displayed above the content card and centered */
        .page-title{
            text-align:center;
            margin: 6px 0 0 0; /* remove bottom gap for content library title */
            font-size:20px;
            font-weight:800;
            color: var(--ink);
            letter-spacing: .4px;
            /* keep it visually separate from card */
            display:block;
        }
    /* Combined chooser + preview (stacked with horizontal divider) */
    .chooser-row{ display:flex; flex-direction:column; gap:12px }
    .chooser-left{ width:100%; }
    .chooser-right{ width:100%; }
    /* Horizontal divider between the top controls and bottom preview */
    .chooser-divider{ height:2px; background: linear-gradient(90deg, rgba(255,255,255,0.03), rgba(110,170,255,0.06), rgba(255,255,255,0.03)); border-radius:3px; margin: 10px 0; box-shadow: 0 2px 8px rgba(106,169,255,0.03), inset 0 1px 0 rgba(255,255,255,0.02); transition: box-shadow .12s ease, transform .12s ease }
    .chooser-divider:hover, .chooser-divider:focus{ box-shadow: 0 4px 18px rgba(106,169,255,0.08), inset 0 1px 0 rgba(255,255,255,0.03); transform: translateY(-1px) }
    @media (min-width: 900px){ .chooser-row{ gap:18px } }

        .btn:hover {
            transform: translateY(-1px)
        }

        .btn.primary {
            border-color: var(--btnBorder);
            background: linear-gradient(180deg, var(--btnTop), var(--btnBottom));
        }

        /* Full-screen ASCII watermark layer (behind UI, above .bg-anim) */
        .ascii-watermark{
            position: fixed; inset: 0; z-index: -2147483644; pointer-events: none;
            display:flex; align-items:center; justify-content:center; /* center base content */
            overflow: hidden; /* clip outside */
            mix-blend-mode: normal;
        }
        .ascii-watermark pre{
            margin:0; padding:0; display:none; white-space: pre; line-height: 1;
            color: rgba(255,255,255,.06);
            text-shadow: 0 1px 0 rgba(0,0,0,.22), 0 0 8px rgba(255,255,255,.025);
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace;
            font-size: 9px; /* smaller characters; cover-fit will keep full screen */
            transform-origin: center center; /* center for cover fit */
            will-change: transform;
            overflow: hidden;
        }
        .ascii-watermark pre .row{ display:block }
        .ascii-watermark .num, .ascii-watermark .fav{ color: rgba(255,255,255,.12); }
        .ascii-watermark canvas{ width:100%; height:100%; display:block }

        /* ASCII watermark removed per user request */

        /* Global top safe area (news bar height etc.) */
        :root{ --topSafeArea: 0px; }

        /* Theme capsule (left side) */
        .theme-capsule{
            position: fixed; left: calc(12px + env(safe-area-inset-left)); top: calc(12px + env(safe-area-inset-top) + var(--topSafeArea)); transform: none;
            display:flex; gap:10px; align-items:center; padding:8px 10px;
            border-radius: 9999px; border: 1px solid rgba(31,42,68,.6);
            background: linear-gradient(180deg, rgba(16,25,40,.65), rgba(10,16,28,.65));
            box-shadow: var(--depth);
            -webkit-backdrop-filter: blur(calc(var(--glass-blur)*.8));
            backdrop-filter: blur(calc(var(--glass-blur)*.8));
            z-index: 5;
        }
        /* Place the background toggle just below the theme capsule */
        #bgToggles{
            position: fixed;
            left: calc(12px + env(safe-area-inset-left));
            /* Use theme capsule height + the unified control gap for consistent spacing */
            top: calc(12px + env(safe-area-inset-top) + var(--topSafeArea) + var(--theme-capsule-h, 56px) + var(--control-gap));
            z-index: 6; /* above canvas and peers */
            display:flex; gap: var(--control-gap); align-items:flex-start; flex-direction: column; /* stack toggles vertically */
        }
        @media (max-width: 640px){ .theme-capsule{ left: calc(8px + env(safe-area-inset-left)); top: calc(8px + env(safe-area-inset-top) + var(--topSafeArea)); } }
        /* On small screens, the orbs are larger; update the capsule height variable and recompute */
        @media (max-width: 640px){ :root{ --theme-capsule-h: 60px; } }
        @media (max-width: 640px){ #bgToggles{ left: calc(8px + env(safe-area-inset-left)); top: calc(8px + env(safe-area-inset-top) + var(--topSafeArea) + var(--theme-capsule-h, 60px) + var(--control-gap)); } }
        .theme-orb{
            --c1: #5aa5ff; --c2: #46d3ff; --c3: #7a66ff; /* default fallbacks */
            --hx: 30%; --hy: 22%; /* specular highlight anchor (moves on hover) */
            width: 40px; height: 40px; border-radius: 50%; cursor: pointer; position: relative; overflow: hidden;
            /* Deeper 3D: strong inner shade + soft outer drop shadow */
            box-shadow:
                inset 0 -10px 22px rgba(0,0,0,.55), /* bottom occlusion */
                inset 0 10px 18px rgba(255,255,255,.06), /* top bounce */
                0 8px 16px rgba(0,0,0,.40); /* outer drop */
            border: 1px solid rgba(60,80,120,.6);
            transition: transform .14s ease, box-shadow .12s ease, filter .12s ease;
            /* Seamless base (no conic seam): neutral sphere core, colors are painted in ::before */
            background: radial-gradient(120% 120% at 50% 60%, #0f1726 0%, #0b1424 65%, #09111f 100%);
            background-clip: padding-box; isolation: isolate;
            filter: saturate(112%) contrast(105%);
        }
        @media (max-width: 640px){ .theme-orb{ width: 44px; height: 44px; } }
    /* Orb palette classes to avoid inline styles */
    .orb-ocean { --c1:#5aa5ff; --c2:#46d3ff; --c3:#7a66ff }
    .orb-sunset{ --c1:#ff7a7a; --c2:#ffb84d; --c3:#ffd86b }
    .orb-forest{ --c1:#2bd47a; --c2:#75e68c; --c3:#3fb2a0 }
    .orb-violet{ --c1:#8b5cf6; --c2:#60a5fa; --c3:#22d3ee }
    .orb-ember { --c1:#ff6b6b; --c2:#f59e0b; --c3:#fb923c }
    .orb-greyscale{ --c1:#d4d4d4; --c2:#9ca3af; --c3:#4b5563 }

    /* Palette editor (minimal, square, movable) */
    .palette-editor{ position:fixed; width:248px; border-radius:10px; padding:8px; z-index:2147483645; color:var(--ink);
        background: linear-gradient(180deg, rgba(16,24,38,.94), rgba(10,16,28,.90));
        border:1px solid rgba(255,255,255,0.06);
        box-shadow: 0 14px 36px rgba(2,6,12,0.55);
        -webkit-backdrop-filter: blur(8px); backdrop-filter: blur(8px);
        -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
        opacity: 1; transform: translateY(-4px) scale(.99);
    }
    /* Remove decorative overlay for a clean, minimal look */
    .palette-editor::after{ content:none }
    .palette-editor.hidden{ display:none }
    /* open/close animation hooks */
    .palette-editor.pe-anim{ transition: opacity .18s ease, transform .18s ease; will-change: opacity, transform; }
    .palette-editor.pe-show{ opacity:1; transform: translateY(0) scale(1); }

    .palette-editor .pe-header{ display:flex; align-items:center; justify-content:space-between; gap:6px; padding:6px 8px 6px 10px; cursor:default; font-weight:800; letter-spacing:.2px; min-height:34px }
    .palette-editor .pe-header:active{ cursor:default }
    .palette-editor .pe-header span{ font-size:13px; color: var(--ink) }
    .palette-editor .pe-body{ padding:6px 8px }
    /* prevent accidental double-click selection inside the editor; allow controls to remain interactive */
    .palette-editor input, .palette-editor button, .palette-editor input[type="color"]{ -webkit-user-select: auto; -moz-user-select: auto; -ms-user-select: auto; user-select: auto }
    .palette-editor .pe-row{ display:flex; gap:8px; align-items:flex-start; justify-content:space-between }
    .palette-editor label{ display:inline-flex; flex-direction:column; font-size:12px; gap:6px; align-items:flex-start; color: var(--muted); font-weight:700 }
    .palette-editor input[type=color]{ width:56px; height:34px; border-radius:8px; padding:2px; cursor:pointer;
        border:1px solid rgba(255,255,255,0.08); background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
        box-shadow: inset 0 1px 0 rgba(255,255,255,0.06), 0 8px 20px rgba(0,0,0,0.35); }
    .palette-editor input[type=color]::-webkit-color-swatch-wrapper{ padding:2px; border-radius:8px }
    .palette-editor input[type=color]::-webkit-color-swatch{ border:none; border-radius:8px }
    .palette-editor input[type=color]:focus{ outline: 2px solid rgba(96,165,250,.35); outline-offset: 2px }
    .palette-editor .pe-preview{ margin-top:8px; height:46px; border-radius:10px; border:1px solid rgba(255,255,255,0.04);
        /* reduce inset darkening and soften edges to avoid hard side lines */
        box-shadow: inset 0 2px 6px rgba(0,0,0,0.32), 0 6px 18px rgba(0,0,0,0.35);
        background: linear-gradient(90deg, #ddd, #999); position:relative; overflow:hidden }
    .palette-editor .pe-preview::before{ content:''; position:absolute; left:-20%; right:-20%; top:-60%; height: 120%;
        background: linear-gradient(180deg, rgba(255,255,255,.18), rgba(255,255,255,0)); transform: rotate(12deg); pointer-events:none }
    .palette-editor .pe-footer{ margin-top:8px; display:flex; justify-content:flex-end }
    /* Header buttons */
    #peReset.btn.small{ border-radius:999px; padding:6px 10px; font-size:12px }
    /* Circle close: ensure perfect centering regardless of font metrics */
    #peClose.btn.small{
        width:32px; height:32px; padding:0; border-radius:50%;
        font-weight:900; font-size:14px; line-height:1; display:inline-flex; align-items:center; justify-content:center; box-sizing:border-box;
        /* make it a true circular icon button that matches theme */
        border: 1px solid var(--btnBorder);
        background: linear-gradient(180deg, var(--btnTop), var(--btnBottom));
        color: var(--ink);
        cursor: pointer;
        box-shadow: 0 6px 14px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.03);
        transition: transform .08s ease, filter .12s ease, box-shadow .12s ease;
    }
    #peClose.btn.small:hover{ filter: brightness(1.06); transform: translateY(-1px); }
    #peClose.btn.small:focus{ outline: 2px solid rgba(96,165,250,.35); outline-offset: 2px }
    @media (max-width:640px){ .palette-editor{ width:92%; left:4% !important; right:auto !important } }

    /* In-DOM Custom Color Picker (invertable under light-mode) */
    #ccpPanel{ position: fixed; z-index:2147483645; width:280px; border-radius:12px; padding:10px; box-sizing:border-box;
        color: var(--ink);
        background: linear-gradient(180deg, rgba(16,24,38,.96), rgba(10,16,28,.92));
        border:1px solid rgba(255,255,255,0.06);
        box-shadow: 0 18px 42px rgba(2,6,12,0.55);
        -webkit-backdrop-filter: blur(10px); backdrop-filter: blur(10px);
    }
    #ccpPanel .row{ display:flex; align-items:center; gap:10px; margin:8px 0 }
    #ccpPanel .lbl{ width:22px; font-weight:800; font-size:11px; color:var(--muted) }
    #ccpPanel input[type=range]{ flex:1; appearance:none; height:6px; border-radius:999px; background:#0c1526; outline:none; border:1px solid rgba(255,255,255,.06) }
    #ccpPanel input[type=range]::-webkit-slider-thumb{ -webkit-appearance:none; appearance:none; width:14px; height:14px; border-radius:50%; background:var(--ink); border:1px solid rgba(0,0,0,.4) }
    #ccpPanel .preview{ height:34px; border-radius:8px; border:1px solid rgba(255,255,255,.08); box-shadow: inset 0 1px 0 rgba(255,255,255,.04) }

    /* Glassy radio / swatch styling - semi-transparent, blurred, and reflective */
    .glass-radio, input[type="radio"]{
        -webkit-appearance: none; appearance: none;
        width: 20px; height: 20px; border-radius: 50%; display:inline-block; vertical-align: middle;
        background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.08);
        box-shadow: inset 0 6px 14px rgba(255,255,255,0.03), inset 0 1px 0 rgba(255,255,255,0.06), 0 8px 26px rgba(2,6,12,0.45);
        backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px);
        cursor: pointer; transition: transform .12s ease, box-shadow .12s ease, background .12s ease;
    }
    .glass-radio:hover, input[type="radio"]:hover{ transform: translateY(-2px); box-shadow: inset 0 8px 18px rgba(255,255,255,0.04), 0 12px 32px rgba(2,6,12,0.5); }
    .glass-radio:focus, input[type="radio"]:focus{ outline: 2px solid rgba(96,165,250,0.16); outline-offset: 2px }
    .glass-radio.checked, input[type="radio"]:checked{
        background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
        border: 1px solid rgba(255,255,255,0.16);
        box-shadow: 0 10px 30px rgba(2,6,12,0.52), inset 0 1px 0 rgba(255,255,255,0.06);
    }

    /* Use circular preview swatch inside the custom picker to show selected color as glass */
    #ccpPanel .preview{ width:34px; flex:0 0 34px; border-radius:50%; display:inline-block; }
    #ccpPanel .actions{ display:flex; justify-content:flex-end; gap:8px; margin-top:10px }
    #ccpPanel .btn{ border-radius:10px; padding:8px 12px; font-weight:800; font-size:12px; border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); cursor:pointer }

    /* Utility classes to replace inline styles */
    .mt-6{ margin-top:6px }
    .mt-8{ margin-top:8px }
    .mt-10{ margin-top:10px }
    .mt-12{ margin-top:12px }
    .fs-12{ font-size:12px }
    .fs-14{ font-size:14px }
    .muted{ color: var(--muted) }
    .flex{ display:flex }
    .col{ display:flex; flex-direction:column }
    .center{ justify-content:center; align-items:center }
    .gap-8{ gap:8px }
    .gap-12{ gap:12px }
    .justify-between{ justify-content:space-between }
    .w-68{ width:68px }

    /* Prettier numeric inputs to match theme */
    .pill input[type="number"], input.themed-input[type="number"]{
        height: 30px; border-radius: 8px; background: #0c1526; color: var(--ink);
        border: 1px solid var(--btnBorder); padding: 4px 8px; font-size: 12px;
        box-shadow: inset 0 2px 6px rgba(0,0,0,.25);
    }
    .pill input[type="number"]:focus, input.themed-input[type="number"]:focus{
        outline: 2px solid var(--brand); outline-offset: 2px;
    }
    /* Hide default spinners for a cleaner look */
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button{ -webkit-appearance: none; margin: 0; }
    input[type="number"]{ -moz-appearance: textfield; appearance: textfield; }
        /* News bar styles (glassy) */
        .news-bar{ position: fixed; left:0; right:0; top: 0; z-index: 240; /* below theme capsule (z 5+) */
            width: 100vw; box-sizing: border-box; padding: 0 14px; height: 46px;
            border-bottom: 2px solid rgba(80,100,140,.6); border-radius: 0;
            background: linear-gradient(180deg, rgba(18,26,36,.68), rgba(6,10,14,.56));
            -webkit-backdrop-filter: blur(12px) saturate(120%); backdrop-filter: blur(12px) saturate(120%);
            box-shadow: 0 8px 32px rgba(0,0,0,.55);
            color: #e6eef8; overflow: hidden; white-space: nowrap; font-size:14px; line-height:46px }
        .news-bar::after{ content:''; position:absolute; inset:0; pointer-events:none; background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='160' height='160' viewBox='0 0 160 160'><filter id='n'><feTurbulence baseFrequency='0.9' seed='2' numOctaves='1' stitchTiles='stitch'/><feColorMatrix type='saturate' values='0'/><feComponentTransfer><feFuncA type='table' tableValues='0 0.06'/></feComponentTransfer></filter><rect width='100%' height='100%' filter='url(%23n)' opacity='0.18' /></svg>"); mix-blend-mode: overlay; opacity: .6; }
        .news-row{ position: relative; height: 100%; overflow: hidden; }
        .news-viewport{ position: relative; height: 100%; overflow: hidden; }
        .news-track{ position: absolute; left: 0; top: 0; height: 100%; white-space: nowrap; will-change: transform; }
        /* Increase headline size but keep bar height fixed: tighten gaps and date padding */
        .news-item{ display:inline-flex; gap:6px; align-items:center; color: var(--ink); text-decoration:none; font-size:15px }
        .news-item:hover{ text-decoration: underline }
        .news-date{ color: var(--muted); font-size: 11px; border: 1px solid rgba(60,80,120,.45); padding: 0 6px; border-radius: 999px; background: linear-gradient(180deg, rgba(16,25,40,.55), rgba(10,16,28,.55)); height: 22px; display: inline-flex; align-items: center; }
        .news-sep{ color: rgba(255,255,255,.25); display:inline-block; margin: 0 10px }
    /* Push all in-flow content below the top safe area */
    body{ padding-top: var(--topSafeArea); transition: padding-top .12s ease; }
    /* Content root: keep transform origin stable for any future effects */
    #contentRoot{ transform-origin: top center; transition: transform .15s ease; }
    /* Saved MCQs card should fill its column — use full width and include padding in box sizing */
    .saved-card{ margin-left:0; margin-right:0; width:100%; box-sizing: border-box; }
        /* soft blending of tri-colors plus subtle rim glow */
        .theme-orb::before{
            content:""; position:absolute; inset:-12%; border-radius:50%; pointer-events:none;
            background:
                radial-gradient(62% 58% at 28% 30%, var(--c1), transparent 70%),
                radial-gradient(62% 60% at 72% 30%, var(--c2), transparent 72%),
                radial-gradient(80% 70% at 50% 80%, var(--c3), transparent 74%),
                radial-gradient(120% 98% at 50% 102%, rgba(0,0,0,.35), rgba(0,0,0,0) 60%), /* inner rim shade bottom */
                radial-gradient(120% 120% at 50% -8%, rgba(255,255,255,.06), rgba(255,255,255,0) 60%); /* top rim glow */
            filter: blur(12px) saturate(118%);
            opacity: .92; /* stronger so colors fully blend and cover base */
        }
        /* layered specular highlight + inner ring */
        .theme-orb::after{
            content:""; position:absolute; inset:0; border-radius:50%; pointer-events:none;
            background:
                /* bright glint */ radial-gradient(18% 16% at var(--hx) var(--hy), rgba(255,255,255,.66), rgba(255,255,255,.12) 40%, rgba(255,255,255,0) 70%),
                /* soft highlight */ radial-gradient(120% 100% at calc(var(--hx) + 10%) calc(var(--hy) + 6%), rgba(255,255,255,.18), transparent 62%),
                /* inner ring to suggest curvature */ radial-gradient(80% 80% at 50% 52%, rgba(255,255,255,.08), rgba(255,255,255,0) 62%),
                /* ambient occlusion at bottom */ radial-gradient(120% 90% at 50% 110%, rgba(0,0,0,.45), transparent 55%);
        }
        .theme-orb .orb-label{
            position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none;
            font-weight: 800; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,.5), 0 0 10px rgba(0,0,0,.45);
            font-size: 14px; letter-spacing: .2px; transform: translateZ(0); transition: transform .14s ease;
        }
        .theme-orb:hover{
            --hx: 26%; --hy: 18%;
            transform: translateY(-1px) scale(1.06);
            box-shadow:
                inset 0 -12px 24px rgba(0,0,0,.6),
                inset 0 12px 20px rgba(255,255,255,.08),
                0 12px 22px rgba(0,0,0,.46);
            filter: saturate(118%) contrast(108%);
        }
        .theme-orb:hover .orb-label{ transform: scale(1.08); }
        .theme-orb.active{ outline: 2px solid rgba(255,255,255,.18); outline-offset: 2px; }

        .tag {
            display: inline-block;
            padding: 2px 8px;
            border: 1px solid rgba(70, 90, 130, .5);
            background: linear-gradient(180deg, rgba(16, 25, 40, .7), rgba(10, 16, 28, .7));
            border-radius: 999px;
            color: var(--muted);
            font-size: 12px;
            margin-right: 6px
        }
    /* Tagging UI removed for Phase 1: reserved styles were deleted */
    /* Make saved item actions compact so tags stand out */
    .saved-item .si-actions{ gap:6px; align-items:center }
    .saved-item .si-actions .si-addtag{ width:84px; padding:6px 8px; border-radius:8px }
    .saved-item .si-main .si-meta{ margin-top:4px; font-size:12px }
    /* Compact validator choice rows used in the validation output (no extra gaps) */
    .validator-choice{ margin:0; color:var(--muted); font-size:13px }
    .validator-choice{ padding:8px; border-radius:8px; border:1px solid rgba(70,90,130,.2); background: linear-gradient(180deg, rgba(10,16,24,.45), rgba(8,12,20,.45)); }
    .validator-choice.correct{ border-color: #155e37; background: linear-gradient(180deg, rgba(17,94,55,0.12), rgba(6,30,18,0.06)); color: var(--ink); }
    .validator-choice.wrong{ border-color: #7f1d1d; background: linear-gradient(180deg, rgba(127,29,29,0.08), rgba(40,12,12,0.03)); color: var(--ink); }

        /* quiz layout */
        .quizgrid {
            display: grid;
            /* make main content take all available space and keep sidebar fixed */
            grid-template-columns: 1fr 340px;
            gap: 16px
        }

        @media (max-width: 980px) {
            .quizgrid {
                grid-template-columns: 1fr
            }
        }

        .side {
            border: 1px solid var(--stroke);
            background: linear-gradient(180deg, rgba(14, 21, 34, .65), rgba(9, 15, 26, .6));
            border-radius: 14px;
            padding: 14px;
            -webkit-backdrop-filter: blur(calc(var(--glass-blur)*.8));
            backdrop-filter: blur(calc(var(--glass-blur)*.8));
        }

        .side h3 {
            margin: 0 0 8px;
            font-size: 16px
        }

        .side label {
            display: block;
            font-size: 12px;
            color: var(--muted);
            margin: 6px 0 4px
        }

        .side input,
        .side textarea {
            width: 100%;
            background: #0b1220;
            color: var(--ink);
            border: 1px solid #22324a;
            border-radius: 10px;
            padding: 8px
        }

        .side textarea {
            height: auto; /* allow natural/flex growth */
            max-height: none;
            flex: 1 1 auto; /* fill remaining space in sidebar */
            min-height: 0; /* enable child to shrink within flex container */
            resize: none;
            overflow: auto;
        }

        /* question cards */
        .qcard {
            /* Ensure question cards expand to fill the main column and match the results width */
            display: block; width: 100%; max-width: 100%; box-sizing: border-box;
            border: 1px solid rgba(70, 90, 130, .5);
            background: linear-gradient(180deg, rgba(14, 21, 34, .65), rgba(9, 15, 26, .6));
            border-radius: 16px;
            padding: 14px;
            margin: 12px 0;
            box-shadow: var(--depth)
        }

        .choice {
            display: block;
            margin: 12px 0;
            padding: 12px;
            border: 1px solid rgba(70, 90, 130, .5);
            border-radius: 10px;
            cursor: pointer;
            background: linear-gradient(180deg, rgba(14, 20, 32, .55), rgba(10, 15, 26, .55))
        }

        .choice.correct {
            border-color: #155e37;
            background: linear-gradient(180deg, rgba(11, 30, 21, .7), rgba(6, 20, 14, .65))
        }

        .choice.wrong {
            border-color: #7f1d1d;
            background: linear-gradient(180deg, rgba(26, 15, 16, .7), rgba(18, 10, 12, .65))
        }

        .choice input {
            margin-right: 8px
        }

        /* Ensure quiz choice rows have horizontally aligned radio dots and label text */
    .qcard .choice{ display:flex; align-items:center; gap:10px; }
    /* Fine-tune vertical alignment: ensure radio orb and text block center relative to total box height */
    .qcard .choice{ line-height:1.25; }
    .qcard .choice strong{ align-self:center; }
    /* Force radio to use flexbox centering instead of baseline quirks */
    .qcard .choice input[type="radio"]{ margin-top:0; }
    /* Elevate choice rows so radios sit above sticky notes / overlays without altering layout */
    .qcard .choice{ position:relative; z-index: 5000; }
        .qcard .choice input[type="radio"]{
            /* Override global glass style for clarity and alignment within choices */
            -webkit-appearance: none; appearance: none;
            accent-color: unset !important; /* kill UA accent so no stray green appears */
            width: 20px; height: 20px; flex: 0 0 20px;
            border-radius: 50%; box-sizing: border-box;
            border: 2px solid rgba(110,150,200,.65);
            background: transparent; background-color: transparent !important; position: relative; z-index: 6000;
            box-shadow: none !important; /* keep ring crisp; override global glass shadow */
            -webkit-backdrop-filter: none !important; backdrop-filter: none !important; /* prevent darkened center from glass blur */
            transform: none !important;
            vertical-align: middle;
            align-self: center; /* ensure radio centers within the full choice box */
        }
        .qcard .choice input[type="radio"]:focus{ outline: 2px solid rgba(96,165,250,.35); outline-offset: 2px }
        /* Default checked base (before correctness classes apply). Keep neutral to avoid bleed. */
        .qcard .choice input[type="radio"]:checked{
            border-color: rgba(110,150,200,.8) !important;
            background: none !important;
            box-shadow: none !important;
        }

        /* Smooth colored inner circle for correct / wrong states */
        /* Strong, explicit checked visuals: inner white dot plus colored ring. Use !important to override any earlier generic radio styling. */
        /* CORRECT: user's selected correct -> show white center + green ring */
        .qcard .choice.correct input[type="radio"]:checked{
            border-color: var(--ok) !important;
            background-image:
                radial-gradient(circle at center, #ffffff 0 46%, rgba(255,255,255,0) 48%),
                radial-gradient(circle at center, var(--ok) 60%, var(--ok) 78%, rgba(0,0,0,0) 80%) !important;
            background-repeat: no-repeat !important;
            background-position: center !important; background-size: 100% 100% !important;
            box-shadow: none !important; filter: none !important;
        }
        /* CORRECT: the revealed correct (not selected) -> green ring with transparent center */
        .qcard .choice.correct input[type="radio"]:not(:checked){
            border-color: var(--ok) !important;
            background: radial-gradient(circle at center,
                         rgba(0,0,0,0) 0%, rgba(0,0,0,0) 56%,
                         var(--ok) 60%, var(--ok) 78%,
                         rgba(0,0,0,0) 82%) !important;
            background-color: transparent !important; background-repeat: no-repeat !important; background-position: center !important; background-size: 100% 100% !important;
        }
        .qcard .choice.wrong input[type="radio"]:checked{
            border-color: var(--bad) !important;
            /* ensure no brand/green bleed; pure red ring with white center */
            background-image:
                radial-gradient(circle at center, #ffffff 0 46%, rgba(255,255,255,0) 48%),
                radial-gradient(circle at center, var(--bad) 60%, var(--bad) 78%, rgba(0,0,0,0) 80%) !important;
            background-repeat: no-repeat !important;
            background-position: center !important; background-size: 100% 100% !important;
            box-shadow: none !important;
        }
        /* Keep the option letter on a fixed column so text lines up nicely */
            .qcard .choice strong{ width: 1.8em; display:inline-block; vertical-align: middle; white-space: nowrap; }

    /* Choice body: make the text a block-level flex child so the radio vertically centers to the box, not the text baseline */
    .qcard .choice .choice-body{ display:block; flex:1 1 auto; min-width:0; align-self: center; }

        .footer {
            margin-top: 18px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px
        }

        .progress {
            height: 10px;
            background: linear-gradient(180deg, rgba(10, 16, 28, .8), rgba(8, 12, 20, .7));
            border: 1px solid rgba(70, 90, 130, .5);
            border-radius: 999px;
            overflow: hidden;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, .35)
        }

        .progress>div {
            height: 100%;
            background: linear-gradient(90deg, var(--brand), #6ee7b7);
            width: 0%
        }

        .hidden {
            display: none
        }

        /* skipped modal */
        .overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, .55);
            display: flex;
            align-items: center;
            justify-content: center;
            /* Ensure overlays appear above very high z-index UI like .saved-card */
            z-index: 2147483650;
            /* Respect notches and home indicators */
            padding: max(8px, env(safe-area-inset-top)) max(8px, env(safe-area-inset-right)) max(8px, env(safe-area-inset-bottom)) max(8px, env(safe-area-inset-left));
        }

        .panel {
            width: min(680px, 90vw);
            max-height: 80vh; /* fallback */
            overflow: auto;
            background: #0f1726;
            border: 1px solid #223048;
            border-radius: 14px;
            padding: 16px
        }
        /* Use dynamic viewport height when supported to avoid iOS address bar jumps */
        @supports (height: 100dvh){ .panel{ max-height: 80dvh; } }

        .list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            gap: 8px
        }

        .chip {
            padding: 8px;
            border-radius: 10px;
            border: 1px solid #2a3648;
            background: #0b1220;
            text-align: center;
            cursor: pointer
        }
        /* Copy Results button placed in top-right of results card */
        #results-card { position: relative; }
        /* Ensure Finished readout sits beneath overlays/popup layers */
        .finished-summary-layer{ position: relative; z-index: 1 }
        #copyResultsBtn { position: absolute; top: 16px; right: 16px; z-index: 2200000000; transform: none; }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #3b82f6;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            vertical-align: -3px;
            margin-right: 6px
        }

        @keyframes spin {
            to {
                transform: rotate(360deg)
            }
        }
    .key-badge{display:inline-flex;align-items:center;gap:8px;font-size:13px;color:var(--muted)}
    .key-badge .dot{width:10px;height:10px;border-radius:50%;background:#7c7c7c;box-shadow:0 0 0 6px rgba(0,0,0,0.06);box-sizing:border-box;line-height:0;vertical-align:middle}
        .key-badge.ok .dot{background:var(--ok)}
        .key-badge.missing .dot{background:var(--bad)}
        .btn[disabled]{opacity:.6;cursor:not-allowed;transform:none}
    </style>
        <style>
            /* Sticky Notes Dock + Windows */
            :root{ --stickyScale: 1; --stickyTopGap: 8px; --stickyRailW: 280px; }
            .sticky-dock{ position:fixed; right: calc(12px + env(safe-area-inset-right)); top: calc(12px + env(safe-area-inset-top) + 280px + var(--topSafeArea) + var(--stickyTopGap)); z-index:190; display:flex; gap:8px; align-items:center; padding:8px 10px; border-radius:999px; border:1px solid var(--btnBorder); background: linear-gradient(180deg, rgba(16,25,40,.72), rgba(10,16,28,.72)); box-shadow: var(--depth); -webkit-backdrop-filter: blur(8px); backdrop-filter: blur(8px); transform-origin: top right; transform: scaleY(var(--stickyScale)); }
            .sticky-dock .sd-btn{ appearance:none; border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); font-weight:800; font-size:12px; padding:6px 10px; border-radius:999px; cursor:pointer }
            .sticky-dock .sd-btn.small{ font-weight:700; padding:4px 8px; font-size:11px }
            .sticky-dock .sd-btn:hover{ filter:brightness(1.06) }
            .sticky-dock .sd-count{ min-width:20px; height:20px; border-radius:999px; background: rgba(255,255,255,.08); border:1px solid rgba(60,80,120,.45); display:inline-flex; align-items:center; justify-content:center; font-size:12px; color: var(--ink) }
            .sticky-panel{ position:fixed; right: calc(12px + env(safe-area-inset-right)); top: calc(64px + env(safe-area-inset-top) + 280px + var(--topSafeArea) + var(--stickyTopGap)); z-index:191; width: min(420px, 92vw); max-height: 50vh; overflow:auto; padding:10px; border-radius:14px; border:1px solid var(--btnBorder); background: linear-gradient(180deg, rgba(16,25,40,.92), rgba(10,16,28,.92)); box-shadow: var(--depth); transform-origin: top right; transform: scaleY(var(--stickyScale)); }
            .sticky-panel.hidden{ display:none }
            .sticky-panel .row{ display:flex; gap:8px; align-items:center }
            .sticky-panel .sd-input{ flex:1 1 auto; height:32px; border-radius:10px; background:#0c1526; color:var(--ink); border:1px solid var(--btnBorder); padding:6px 10px; font-size:12px }
            #sdClose.sd-btn.small{ width:28px; height:28px; padding:0; border-radius:50%; font-size:16px; line-height:26px; text-align:center; font-weight:900 }
            .sticky-list{ margin-top:8px; display:flex; flex-direction:column; gap:8px }
            .sticky-item{ display:flex; gap:8px; align-items:center; padding:8px; border:1px solid rgba(60,80,120,.35); border-radius:10px; background: linear-gradient(180deg, rgba(14,20,32,.55), rgba(10,16,28,.55)); cursor:pointer }
            .sticky-item:hover{ filter:brightness(1.05) }
            .sticky-dot{ width:12px; height:12px; flex: 0 0 12px; aspect-ratio: 1 / 1; display:inline-block; border-radius:50%; border:1px solid rgba(255,255,255,.12) }
            .sticky-meta{ color: var(--muted); font-size:11px }
            /* Note window */
            .sticky-note{ position:fixed; z-index:195; width:260px; min-width:180px; min-height:160px; border-radius:12px; box-shadow: 0 10px 24px rgba(0,0,0,.45); border:1px solid rgba(60,80,120,.45); background: #121a2a; display:flex; flex-direction:column; overflow:hidden }
            .sticky-note.min{ height:auto }
            /* When a note is clipped into the left magnet (slot 4), lower it to the rail plane so quiz UI (>=8000) clears above */
            .sticky-note[data-sticky-slot="4"]{ z-index:188 !important; }
            .sticky-head{ display:flex; align-items:center; justify-content:space-between; gap:8px; padding:8px 10px; cursor:grab; -webkit-user-select:none; user-select:none; background: linear-gradient(180deg, var(--btnTop), rgba(12,20,34,.65)); border-bottom:1px solid var(--btnBorder) }
            .sticky-title{ flex:1 1 auto; min-width:0; font-size:12px; font-weight:800; color: var(--ink); outline:none; background: transparent; border:0 }
            .sticky-actions{ display:flex; gap:6px; align-items:center; flex-shrink:0; white-space:nowrap }
            .sticky-actions .sa{ appearance:none; border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); font-weight:800; font-size:11px; padding:4px 8px; border-radius:8px; cursor:pointer }
            /* Aesthetic close button: compact circular × */
            .sticky-actions .sa[data-act="close"]{ width:22px; height:22px; padding:0; border-radius:50%; font-size:14px; line-height:20px; text-align:center; font-weight:900; }
            .sticky-actions .sa[data-act="close"]:hover{ filter:brightness(1.1) }
            .sticky-body{ flex:1 1 auto; display:flex }
            .sticky-text{ flex:1 1 auto; padding:8px 10px; border:0; outline:none; resize:none; color: var(--ink); background: linear-gradient(180deg, rgba(16,25,40,.82), rgba(10,16,28,.82)) }
            .sticky-resize{ position:absolute; right:6px; bottom:6px; width:12px; height:12px; cursor:nwse-resize; opacity:.7 }
            .sticky-resize::after{ content:""; position:absolute; inset:0; background: linear-gradient(135deg, rgba(233,240,247,.9) 0 2px, transparent 2px), linear-gradient(135deg, rgba(233,240,247,.6) 0 1px, transparent 1px); background-size: 100% 100%, 70% 70%; background-repeat:no-repeat }
            .sticky-color{ display:flex; gap:6px; align-items:center }
            .sticky-color .dot{ width:12px; height:12px; flex:0 0 12px; aspect-ratio:1 / 1; border-radius:50%; border:1px solid rgba(255,255,255,.12); cursor:pointer }
            /* color themes */
            .c-yellow{ background: #1e1a05; border-color: #635d2a }
            .c-green{ background: #0d1f14; border-color: #25573c }
            .c-pink{ background: #261320; border-color: #6a314f }
            .c-sky{ background: #0e1e2a; border-color: #2d5876 }
            .c-lav{ background: #1a162a; border-color: #4b3a7a }
        </style>

    <style>
    /* UI lock while TOS not accepted */
    .tos-overlay{ position:fixed; inset:0; background: rgba(2,6,12,0.55); -webkit-backdrop-filter: blur(4px); backdrop-filter: blur(4px); z-index:22000; display:flex; align-items:center; justify-content:center; }
    .tos-overlay.hidden{ display:none }
    .tos-unlock-panel{ background: linear-gradient(180deg, rgba(8,12,18,.98), rgba(6,10,14,.98)); border:1px solid rgba(255,255,255,0.04); padding:18px; border-radius:12px; max-width:520px; color:var(--ink); box-shadow: 0 12px 40px rgba(0,0,0,0.6); }
    .tos-unlock-panel p{ color:var(--muted); font-size:13px; margin:0 0 12px }
    .tos-unlock-text{ color:var(--muted); font-size:13px; margin:0 0 12px }
    .tos-unlock-actions{ display:flex; gap:10px; justify-content:center }
    /* Use a root class so we can selectively keep TOS buttons active */
    .tos-locked * { pointer-events: none !important; }
    /* Keep only the TOS unlock overlay and the modal interactive while locked */
    .tos-locked #tosOverlay .tos-unlock-panel,
    .tos-locked #tosOverlay .tos-unlock-panel *,
    .tos-locked #tosModal,
    .tos-locked #tosModal * { pointer-events: auto !important; }
    .tos-locked .page, .tos-locked .card, .tos-locked .api-key-bar, .tos-locked .card.pad { filter: blur(4px) brightness(.96); }
    </style>

    <style>
    /* TOS box styles */
    .tos-box{ margin-top:12px; }
    .tos-box .muted{ color:var(--muted); }
    .tos-box .btn.small{ padding:6px 8px; font-size:12px }
    .tos-box .flex { align-items:center }
    .tos-box .muted strong{ color:inherit }
    .tos-box .right{ margin-left:auto }
    </style>
        <style>
            /* Sticky rail on the right with 5 clip slots */
            .sticky-rail{ position:fixed; top: calc(var(--topSafeArea) + var(--stickyTopGap)); bottom: 0; right: calc(12px + env(safe-area-inset-right)); z-index:189; display:flex; flex-direction:column; gap:10px; pointer-events:none; padding-bottom: 8px; transform-origin: top right; transform: scaleY(var(--stickyScale)); }
            .clip-slot{ width: var(--stickyRailW); min-height: 120px; flex: 1 1 0; border-radius: 12px; border:1px dashed rgba(100,130,180,.55); background: linear-gradient(180deg, rgba(16,25,40,.55), rgba(10,16,28,.55)); box-shadow: inset 0 0 0 1px rgba(255,255,255,.04); opacity:.9; transition: filter .12s ease; pointer-events:none }
            .clip-slot:hover{ filter: brightness(1.06) }
            .clip-slot.slot-hover{ outline: 2px solid var(--brand); outline-offset: 2px }
            .clip-slot.occupied{ border: none; opacity:.94 }
            /* colored outlines to match sticky note color */
            .clip-slot.c-yellow{ outline: 2px solid #635d2a; outline-offset: 2px }
            .clip-slot.c-green{ outline: 2px solid #25573c; outline-offset: 2px }
            .clip-slot.c-pink{ outline: 2px solid #6a314f; outline-offset: 2px }
            .clip-slot.c-sky{ outline: 2px solid #2d5876; outline-offset: 2px }
            .clip-slot.c-lav{ outline: 2px solid #4b3a7a; outline-offset: 2px }
            /* Left-side single magnet tab (between top controls and radio) */
            :root{ --leftTabW: 260px; }
            #leftMagnet{ position:fixed; left: calc(12px + env(safe-area-inset-left)); top: 180px; height: 240px; width: var(--leftTabW); z-index:188; pointer-events:none; border-radius: 12px; border:1px dashed rgba(100,130,180,.55); background: linear-gradient(180deg, rgba(16,25,40,.55), rgba(10,16,28,.55)); box-shadow: inset 0 0 0 1px rgba(255,255,255,.04); opacity:.9 }
            #leftMagnet.slot-hover{ outline: 2px solid var(--brand); outline-offset: 2px }
            #leftMagnet.occupied{ border:none; opacity:.94 }
            /* Hoverzone + resizer to expand the magnet width (mirror of right-rail control) */
            .left-tab-hoverzone{ position:fixed; z-index:210; pointer-events:auto; opacity:0; width:40px; height:60px; left: calc(12px + env(safe-area-inset-left) + var(--leftTabW) + 8px); top: 50%; transform: translateY(-50%); }
            .left-tab-resizer{ position:fixed; z-index:211; width:28px; height:28px; border-radius:50%; border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); cursor: ew-resize; display:flex; align-items:center; justify-content:center; left: calc(12px + env(safe-area-inset-left) + var(--leftTabW) + 8px); top: 50%; transform: translateY(-50%); box-shadow: var(--depth); opacity:0; transition: opacity .15s ease, filter .12s ease; }
            .left-tab-resizer::before{ content:'\2192'; /* right arrow */ font-weight:900; font-size:14px; line-height:1; }
            .left-tab-hoverzone:hover + .left-tab-resizer{ opacity:1 }
            .left-tab-resizer:hover, .left-tab-resizer:focus{ opacity:1; filter:brightness(1.06) }
            html.booting #leftMagnet, html.booting .left-tab-resizer{ pointer-events:none; opacity:.85 }
        </style>
        <style>
            /* Boot overlay */
                .boot-overlay{ position:fixed; inset:0; z-index:99999; display:flex; align-items:center; justify-content:center; 
                    /* Palette-aware ambient */
                    background:
                        linear-gradient(180deg, rgba(0,0,0,.55), rgba(0,0,0,.55)),
                        radial-gradient(800px 500px at 20% 25%, var(--glow1), transparent 70%),
                        radial-gradient(700px 450px at 80% 30%, var(--glow2), transparent 75%),
                        radial-gradient(650px 420px at 50% 85%, var(--glow3), transparent 75%);
                    -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px); opacity:1; transition: opacity .6s ease; }
            .boot-overlay.hidden{ opacity:0; pointer-events:none; }
                        .boot-card{ text-align:center; max-width: min(760px, 92vw); padding: 20px; border-radius: 16px; border: 1px solid var(--btnBorder); 
                            /* fallback gradient */
                            background: linear-gradient(180deg, rgba(16,25,40,.55), rgba(10,16,28,.55));
      
                            /* If supported, gently blend brand button colors */
                            background: linear-gradient(180deg, color-mix(in srgb, var(--btnTop) 70%, transparent), color-mix(in srgb, var(--btnBottom) 70%, transparent));
                            box-shadow: var(--depth); }
                .boot-ascii{ text-align:center; margin: 0 0 4px; overflow: hidden; }
                .boot-ascii pre{ display:inline-block; width:max-content; min-width:max-content; max-width:100%; margin:0; padding:0; color: var(--ink); white-space: pre; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace; font-size: clamp(10px, 1.8vw, 18px); line-height: 1.03; letter-spacing: 0; text-shadow: 0 1px 0 rgba(0,0,0,.35); overflow: hidden; transform-origin: left top; }
                /* Slightly reduce bottom spacing under the big ASCII title to make room for animation */
                .boot-ascii pre{ display:inline-block; width:max-content; min-width:max-content; max-width:100%; margin:0 0 6px 0; padding:0; color: var(--ink); white-space: pre; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace; font-size: clamp(10px, 1.8vw, 18px); line-height: 1.03; letter-spacing: 0; text-shadow: 0 1px 0 rgba(0,0,0,.35); overflow: hidden; transform-origin: left top; }
                .boot-ascii pre::-webkit-scrollbar{ width:0; height:0 }
            .boot-sub{ color: var(--muted); font-size: clamp(12px, 3.4vw, 14px); margin-top: 18px; min-height: 1.4em; }
            .boot-phrase{ color: var(--ink); font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace; font-size: clamp(12px, 3.2vw, 16px); line-height: 1.35; min-height: 2.2em; opacity: 0; transition: opacity .35s ease; margin-top: 8px; white-space: normal; }
            .boot-phrase.show{ opacity: 1; }
            .spinner.lg{ width:28px; height:28px; border-width:3px; margin: 10px auto 0; display:inline-block }
                /* Spinner matches active brand */
                .boot-overlay .spinner{ border-color: var(--brand); border-top-color: transparent; }
                /* Hide page scrollbars while booting */
                html.booting, body.booting{ overflow: hidden !important; height: 100%; }

                /* While booting we keep sticky UI visible but non-interactive so the overlay feels modal
                   This leaves notes/dock/rail/title in the visual background but prevents pointer/focus interactions */
                html.booting .sticky-dock,
                html.booting .sticky-panel,
                html.booting .sticky-rail,
                html.booting .sticky-note,
                html.booting #stickyTitleBox {
                    /* Keep visible (no opacity change) but disable pointer and selection */
                    pointer-events: none !important;
                    -webkit-user-select: none !important;
                    user-select: none !important;
                    transform: translateY(6px) scale(.995);
                    transition: transform .18s ease;
                }
            @media (max-width: 640px){ .boot-card{ padding: 16px; } }
        </style>
        <style>
            /* Sticky rail resizer handle */
            .sticky-rail-resizer{
                position:fixed; z-index:211; width:28px; height:28px; border-radius:50%;
                border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom));
                color: var(--ink); cursor: ew-resize; display:flex; align-items:center; justify-content:center;
                right: calc(12px + env(safe-area-inset-right) + var(--stickyRailW) + 8px);
                top: 50%; transform: translateY(-50%);
                box-shadow: var(--depth);
                opacity: 0; transition: opacity .15s ease, filter .12s ease;
            }
            .sticky-rail-resizer::before{ content:'\2190'; /* left arrow */ font-weight:900; font-size:14px; line-height:1; }
            .sticky-rail-resizer:hover{ filter: brightness(1.06); opacity: 1; }
            .sticky-rail-resizer:active{ filter: brightness(1.1); }
            .sticky-rail-resizer:focus{ outline: 2px solid var(--brand); outline-offset: 2px; }
            /* Hide when boot overlay sets inert visuals to avoid confusing focus layering */
            html.booting .sticky-rail-resizer{ pointer-events:none; opacity:.85; transform: translateY(calc(-50% + 6px)) scale(.995); }
            /* Hover zone to reveal resizer */
            .sticky-rail-hoverzone{ position:fixed; z-index:210; pointer-events:auto; opacity:0; width:40px; height:60px; right: calc(12px + env(safe-area-inset-right) + var(--stickyRailW) + 8px); top: 50%; transform: translateY(-50%); }
            .sticky-rail-hoverzone:hover + .sticky-rail-resizer{ opacity: 1; }
            .sticky-rail-resizer:hover, .sticky-rail-resizer:focus{ opacity: 1; }
            /* small fixed-size ASCII animation area that matches spinner footprint */
            /* Wider boot ascii anim so five characters fit comfortably */
            .boot-ascii-anim{ display:inline-block; width:140px; height:48px; margin: 10px auto 0; text-align:center; font-family: ui-monospace, 'Courier New', monospace; font-size:28px; line-height:44px; letter-spacing:-0.5px; color:var(--muted); overflow:hidden }
            /* Ancient glyph styling (red, glowing) for special sprinkle frames */
            .boot-ascii-anim .ancient{ color:#ff5a5a; text-shadow: 0 0 4px rgba(255,75,75,.9), 0 0 8px rgba(255,75,75,.6); font-weight:800 }
            /* Fixed-width slot styling so glyphs and dots align exactly */
            .boot-ascii-anim{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace; font-variant-ligatures: none; }
            .boot-ascii-anim .slot{ display:inline-block; width:1ch; min-width:1ch; text-align:center; line-height:14px; vertical-align:middle; }
            .boot-ascii-anim .empty{ color: transparent }
            /* Flip-clock digits (text-only) */
            .boot-ascii-anim .digits{ display:inline-block; }
            .boot-ascii-anim .digits{ display:flex; justify-content:space-between; align-items:center; width:100%; box-sizing:border-box }
            .boot-ascii-anim .digit{ display:inline-flex; flex:0 0 20%; max-width:20%; box-sizing:border-box; justify-content:center; align-items:center; text-align:center; line-height:44px; vertical-align:middle; transform-origin: center top; transition: transform .14s ease; font-variant-numeric: tabular-nums; white-space:nowrap }
            .boot-ascii-anim .digit.ancient{ /* use symbol-capable fonts so glyphs render consistently */
                font-family: 'Segoe UI Historic', 'Noto Sans Symbols2', 'Segoe UI Symbol', serif; 
                font-weight:900; font-size:30px; line-height:44px; justify-content:center; display:inline-flex; }
            .boot-ascii-anim .digit.flip{ transform: rotateX(-90deg); }
        </style>
                <style>
                    /* Hide only the root page scrollbar; preserve inner scrollbars */
                    html, body { -ms-overflow-style: none; }
                    html::-webkit-scrollbar, body::-webkit-scrollbar { width: 0 !important; height: 0 !important; }
                </style>
    <style>
      /* ASCII title banner */
    .ascii-title{ text-align:center; margin: 10px 0; overflow: hidden; -webkit-user-select:none; user-select:none; }
      .ascii-title pre{
          display:block; width:100%; margin:0; padding:0; border-radius:0;
          border: none; background: transparent; box-shadow: none;
          color: var(--ink);
          font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace;
          font-size: clamp(10px, 1.6vw, 20px); line-height: 1.03;
          letter-spacing: .3px;
          text-shadow: 0 1px 0 rgba(0,0,0,.35);
          white-space: pre; /* preserve exact ASCII */
          overflow: hidden; /* hide scrollbars entirely */
          overscroll-behavior: contain; /* avoid overscroll glow */
      }
      /* WebKit hide scrollbars on banner */
      #asciiBanner::-webkit-scrollbar { width: 0; height: 0; }
  /* Global API key bar above the main module */
    .api-key-bar {
        width: 100%;
        box-sizing: border-box;
    margin: 0 0 12px 0;
        padding: 10px 12px;
    border: 1px solid rgba(60,80,120,.35);
    border-radius: 12px;
    background: linear-gradient(180deg, rgba(16,25,40,.70), rgba(10,16,28,.70));
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        backdrop-filter: blur(8px);
            display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
  }
        .api-key-bar input[type="password"]{
                            flex: 1 0 520px; min-width: 320px; padding: 8px 10px; border-radius: 10px;
    border: 1px solid #22324a; background:#0b1220; color: var(--ink);
  }

            /* Paste area: center the action button under the textarea */
            .paste-wrap{ display:flex; flex-direction:column; align-items:center; gap:10px; }
            .paste-wrap .index-btn{ margin: 0 auto; padding:8px 12px; border-radius:10px; background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); border:1px solid var(--btnBorder); color:var(--ink); font-weight:700; cursor:pointer }
            .paste-wrap .index-btn.saved{ background: linear-gradient(180deg, rgba(60,160,120,0.12), rgba(30,120,80,0.12)); }
        @media (max-width: 760px){
            .api-key-bar input[type="password"]{ flex: 1 1 100%; min-width: 0; width: 100%; }
            .api-key-bar .spacer{ display:none }
        }
    .api-key-dot{width:12px;height:12px;border-radius:50%;display:inline-block;margin-right:0;background:#7c7c7c;box-shadow:0 0 0 6px rgba(0,0,0,0.06);box-sizing:border-box;line-height:0;vertical-align:middle}
    .api-key-dot.ok{background:var(--ok)}
    .api-key-dot.missing{background:var(--bad)}
  .api-key-bar label{ font-size:12px; color: var(--muted); display:flex; gap:6px; align-items:center }
    .api-key-bar .spacer{ flex:1 1 auto }
            /* Redesigned toggle switch: transform-centered knob to avoid misalignment */
            .switch{ --sw-w: 42px; --sw-h: 22px; --knob: 16px; --pad: 3px; display:inline-flex; align-items:center; gap:6px; cursor:pointer; -webkit-user-select:none; user-select:none; flex: 0 0 auto; white-space: nowrap }
            .switch input{ display:none }
            .switch .slider{
                position: relative; width: var(--sw-w); height: var(--sw-h); border-radius: 999px; box-sizing: border-box;
                background: rgba(60,80,120,.45); border: 1px solid rgba(60,80,120,.65);
                box-shadow: inset 0 1px 2px rgba(0,0,0,.25);
                transition: background .15s ease, border-color .15s ease;
            }
            .switch .slider::after{
                content:''; position:absolute; top: 50%; left: calc(var(--pad) + var(--knob)/2);
                width: var(--knob); height: var(--knob); border-radius:50%; box-sizing: border-box; transform: translate(-50%, -50%);
                background:#e9f0f7; box-shadow: 0 1px 2px rgba(0,0,0,.35);
                transition: left .15s ease, background .15s ease;
            }
            .switch input:checked + .slider{ background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); border-color: var(--btnBorder); }
            .switch input:checked + .slider::after{ left: calc(var(--sw-w) - var(--pad) - var(--knob)/2); }
            .switch:focus-within .slider{ outline: 2px solid rgba(96,165,250,.35); outline-offset: 2px; }

  /* Optional .docx/.pdf generator panel */
  .ai-file-panel{
        margin-top: 10px;
        padding: 8px;
    border: 1px solid rgba(60,80,120,.35);
    border-radius: 12px;
    background: linear-gradient(180deg, rgba(16,25,40,.65), rgba(10,16,28,.65));
        max-width: 100%;
            overflow-x: hidden; /* never overflow parent width */
            overflow-wrap: anywhere;
            word-break: break-word;
        /* Fixed module height as requested */
        min-height: 430px;
        max-height: 430px;
        /* Allow internal scrolling when content exceeds the fixed height */
        /* Use flex layout so inner elements can size correctly and the log can stretch */
        display: flex;
        flex-direction: column;
  }
    /* Inline AI fixer panel (left column) */
    .ai-fix-panel{
        margin-top: 10px;
        padding: 12px;
        border: 1px solid var(--btnBorder);
        border-radius: 12px;
        background: linear-gradient(180deg, rgba(16,25,40,.70), rgba(10,16,28,.70));
        -webkit-backdrop-filter: blur(calc(var(--glass-blur)*.6));
        backdrop-filter: blur(calc(var(--glass-blur)*.6));
        width: 100%;
    }
    #aiFixPanel .btn-wide{ min-width: 260px; }
    .ai-file-row{ display:flex; flex-wrap:wrap; gap:12px; align-items:center }
    .ai-file-row > * { flex: 0 1 auto }
    /* Make all controls in the AI file row a consistent height and allow them to shrink/wrap
       so number-entry controls don't force overflow. Number inputs are compact and centered. */
    .ai-file-row .btn, .ai-file-row .btn.small, .ai-file-row .pill, .ai-file-row .file-input .choose-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        height: 36px;
        min-height: 36px;
        line-height: 1;
        padding-top: 0; padding-bottom: 0;
        box-sizing: border-box;
    }
    /* Make numeric entry compact and consistent with buttons */
    .ai-file-row input[type="number"], .ai-file-row input[type="number"].themed-input {
        height: 30px;
        min-height: 30px;
        line-height: 1;
        padding: 4px 8px;
        width: 52px; /* small fixed width for neat alignment */
        min-width: 44px;
        max-width: 84px;
        text-align: center;
        border-radius: 8px;
        box-sizing: border-box;
        flex: 0 0 auto;
    }
    /* Allow the large primary generate button to shrink on narrow viewports but keep height consistent */
    .ai-file-row #aiFileGenBtn, .ai-file-row #aiFileGenBtn.ai-fixed { height: 36px; min-height:36px; }
    /* On small screens let controls stack/wrap and let the main button grow to full width */
    @media (max-width: 760px){
        .ai-file-row .btn { flex: 1 1 auto; }
        .ai-file-row .ai-file-status{ flex: 1 1 100%; min-width: 140px }
    }
    /* Keep status column from changing width as messages update */
    .ai-file-status{ color: var(--muted); font-size: 13px; min-width: 240px; width: 240px; max-width: 240px; overflow:hidden; text-overflow: ellipsis; white-space: nowrap }
    /* Ensure filename truncates and does not push layout */
        .file-input{ display:flex; align-items:center; gap:8px; min-width: 0 }
        .file-input .filename{ flex:1 1 auto; overflow:hidden; white-space:nowrap; text-overflow:ellipsis; min-width: 0; max-width: 100% }
        @media (max-width: 760px){
            #aiFileGenBtn{ flex: 1 1 auto; width:auto; max-width:100% }
            .ai-file-status{ width:auto; min-width:160px; flex: 0 0 160px }
        }
    /* Clean scrollbars */
    /* Remove non-standard scrollbar props in Chrome/Safari; keep WebKit track/thumb below */
    *::-webkit-scrollbar { width: 10px; height: 10px; }
    *::-webkit-scrollbar-track { background: rgba(20,28,44,.6); border-radius: 8px; }
    *::-webkit-scrollbar-thumb {
        background: linear-gradient(180deg, rgba(110,150,200,.55), rgba(70,100,160,.55));
        border-radius: 8px;
        border: 1px solid rgba(40,60,90,.5);
    }

        /* Utility classes used to replace inline styles */
        .mt-0{ margin-top:0 }
        .mt-4{ margin-top:4px }
        .mt-6{ margin-top:6px }
        .mt-8{ margin-top:8px }
        .mt-10{ margin-top:10px }
        .mt-12{ margin-top:12px }
        .mb-6{ margin-bottom:6px }
        .mb-8{ margin-bottom:8px }
        .ml-6{ margin-left:6px }
        .ml-8{ margin-left:8px }
        .fs-12{ font-size:12px }
        .fs-14{ font-size:14px }
        .muted{ color: var(--muted) }
        .text-center{ text-align:center }
        .flex{ display:flex }
        .col{ display:flex; flex-direction:column }
        .center{ justify-content:center; align-items:center }
        .gap-8{ gap:8px }
        .gap-12{ gap:12px }
        .justify-between{ justify-content:space-between }
        .justify-start{ justify-content:flex-start }
        .justify-end{ justify-content:flex-end }
        .flex-1{ flex:1 1 auto }
        .flex-1-260{ flex:1 1 260px }
        .minh-320{ min-height:320px }
        .maxw-600{ max-width:600px }
        .maxw-420{ max-width:420px }
        .w-100{ width:100% }
        .btn-wide{ min-width:260px }

        /* Component blocks previously inline-styled */
        #aiValidateOutput2, #resultsAiOutput{
            white-space:pre-wrap;background:#071022;padding:12px;border-radius:10px;border:1px solid #22324a;min-height:36px;color:var(--ink);
            text-align:left;width:100%;box-sizing:border-box;overflow:auto
        }
        #aiPreviewContent{
            white-space:pre-wrap;background:#071022;padding:10px;border-radius:8px;border:1px solid #22324a;max-height:30vh;overflow:auto;margin-top:10px;color:var(--ink)
        }
        #aiFileDebug{
            margin-top:8px;
            background:#071022;
            padding:8px;
            border-radius:8px;
            border:1px solid #22324a;
                /* Flexible log area that expands to fill remaining vertical space in the panel */
                /* It will scroll internally when content overflows. */
                flex: 1 1 auto;
                min-height: 0; /* allow flex child to shrink properly */
                overflow: auto;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace;
            font-size:12px; color:var(--muted); width:100%; max-width:100%; box-sizing:border-box;
            white-space:pre-wrap; overflow-wrap:anywhere; word-break:break-word;
        }
        #resultsAiOutput{
            display: flex;
            flex-direction: column;
            gap: 10px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace;
            white-space: pre-wrap;
            width: 100%;
            height: 100%;
            min-height: 220px; /* moderate baseline so columns remain balanced */
            max-height: calc(100vh - 320px);
            margin-top: 4px;
            box-sizing: border-box;
        }
    *::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(180deg, rgba(130,170,220,.65), rgba(90,120,180,.65));
    }
    /* Stabilize the AI file gen button width to prevent row reflow on label changes */
    #aiFileGenBtn.ai-fixed { width: 360px; max-width: 360px; flex: 0 0 360px; overflow:hidden }
    .ai-file-panel * { max-width: 100%; box-sizing: border-box }
</style>
    <style>
        /* Bottom-left Ambient Radio Player */
    #radioPlayer{ --rpClockGap: 18px; position:fixed; left: calc(12px + env(safe-area-inset-left)); bottom: calc(12px + env(safe-area-inset-bottom) + var(--rpRaise, 0px)); z-index:2200; width: 320px; max-width: 92vw; display:flex; flex-direction: column; gap:8px; padding:10px 12px; box-sizing:border-box;
        /* Ensure the radio player paints above sticky notes and doesn't affect layout
           by creating a local stacking context and promoting to its own layer. */
        isolation: isolate;
        will-change: transform, opacity;
        transform: translateZ(0);
        pointer-events: auto;
            background: linear-gradient(180deg, rgba(16,24,38,.9), rgba(10,16,28,.85)); border: 1px solid var(--btnBorder); border-radius: 14px; box-shadow: var(--depth); -webkit-backdrop-filter: blur(10px); backdrop-filter: blur(10px);
        }
    #radioPlayer .rp-btn{ appearance:none; border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); font-weight:700; font-size:12px; padding:6px 10px; border-radius:8px; cursor:pointer; line-height:1 }
        #radioPlayer .rp-btn:hover{ filter: brightness(1.06) }
    #radioPlayer .rp-btn.small{ font-size:11px; padding:4px 8px }
        #radioPlayer .rp-select{ height: 30px; border-radius: 8px; background: #0c1526; color: var(--ink); border:1px solid var(--btnBorder); padding:4px 8px; font-size:12px; flex: 1 1 auto; min-width: 120px }
    #radioPlayer .rp-vol{ flex: 1 1 120px; min-width: 60px; max-width: 100%; height: 6px; appearance: none; background: linear-gradient(90deg, var(--brand) 0%, var(--brand) var(--rpVolPercent, 40%), rgba(255,255,255,0.15) var(--rpVolPercent, 40%), rgba(255,255,255,0.15) 100%); border-radius: 999px; outline: none; accent-color: var(--brand) }
    /* WebKit */
    #radioPlayer .rp-vol::-webkit-slider-runnable-track{ height:6px; background: transparent; border-radius:999px }
    #radioPlayer .rp-vol::-webkit-slider-thumb{ -webkit-appearance:none; appearance:none; width:14px; height:14px; background: var(--ink); border:2px solid var(--brand); border-radius:50%; margin-top:-4px; box-shadow: 0 0 6px rgba(106,169,255,.35) }
    #radioPlayer.playing .rp-vol::-webkit-slider-thumb{ box-shadow: 0 0 8px var(--brand) }
    /* Firefox */
    #radioPlayer .rp-vol::-moz-range-track{ height:6px; background: rgba(255,255,255,0.15); border-radius:999px }
    #radioPlayer .rp-vol::-moz-range-progress{ height:6px; background: var(--brand); border-radius:999px }
    #radioPlayer .rp-vol::-moz-range-thumb{ width:14px; height:14px; background: var(--ink); border:2px solid var(--brand); border-radius:50% }
        #radioPlayer .rp-meta{ min-height: 16px }
        #radioPlayer #rpNow{ color: var(--muted); font-size: 12px; white-space: nowrap; text-overflow: ellipsis; overflow: hidden }
        /* Broadcasting subtext */
        #radioPlayer #rpCast{ color: var(--muted); font-size: 12px }
    /* Keep YouTube audio player from affecting layout */
    /* YouTube container removed */
    /* Generic attempt select styling */
    .attempt-select{ min-width: 160px; height: 34px; border-radius: 10px; padding: 6px 12px; background: linear-gradient(180deg, var(--btnTop), rgba(10,16,28,.72)); color: var(--ink); border: 1px solid var(--btnBorder); box-shadow: inset 0 1px 0 rgba(255,255,255,.06); font-weight: 600 }
    .attempt-select:focus{ outline: 2px solid rgba(96,165,250,.35); outline-offset: 2px }
    /* Subtle custom chevron (no asset) */
    select.attempt-select{ -webkit-appearance: none; -moz-appearance: none; appearance: none; background-position: right 12px center, 0 0; background-repeat: no-repeat; padding-right: 32px }
    select.attempt-select{
        background-image:
            linear-gradient(45deg, rgba(233,240,247,.9) 50%, transparent 50%),
            linear-gradient(-45deg, rgba(233,240,247,.9) 50%, transparent 50%),
            linear-gradient(180deg, rgba(255,255,255,.18), rgba(255,255,255,0));
        background-size: 8px 8px, 8px 8px, 100% 100%;
        background-position: calc(100% - 18px) 48%, calc(100% - 12px) 48%, 0 0;
    }
    /* Custom attempts dropdown (styled open list) */
    .visually-hidden{ position:absolute !important; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0 }
    .attempt-dd{ position:relative; display:inline-flex; align-items:center }
    .attempt-trigger{ appearance:none; border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); padding: 8px 12px; border-radius: 12px; cursor:pointer; font-weight:800; letter-spacing:.2px; box-shadow: inset 0 1px 0 rgba(255,255,255,.06) }
    .attempt-trigger:hover{ filter: brightness(1.06) }
    .attempt-trigger .chev{ margin-left:8px; opacity:.85 }
    .attempt-menu{ position:absolute; top: calc(100% + 6px); left:0; z-index: 2147483000; width: 100%; min-width: 100%; max-width: 92vw; box-sizing: border-box; max-height: 260px; overflow:auto; border: 1px solid var(--btnBorder); border-radius: 12px; background: linear-gradient(180deg, rgba(16,25,40,.95), rgba(10,16,28,.95)); box-shadow: 0 10px 24px rgba(0,0,0,.45); display:none }
    .attempt-dd.open .attempt-menu{ display:block }
    .attempt-option{ padding:8px 12px; cursor:pointer; display:flex; align-items:center; gap:8px; border-bottom: 1px solid rgba(60,80,120,.18) }
    .attempt-option:last-child{ border-bottom: 0 }
    .attempt-option:hover{ background: linear-gradient(180deg, rgba(96,165,250,.18), rgba(24,60,120,.12)) }
    .attempt-option .tag{ margin-right: 6px }
    /* Add a bit more space above the Results/Attempts card */
    #results-card{ margin-top: 12px; width: 100%; max-width: 100%; box-sizing: border-box; }
     /* Narrow scoped layout fixes for the missed-question list so each card
         only sizes to its visible content (matches the parsed preview). */
    #attemptMissedList{ display:flex; flex-direction:column; gap:12px }
    /* Make missed cards fill the available width of the results panel (match Results readout) */
    #attemptMissedList .qcard{ display:block; width:100%; max-width:100%; padding:12px 14px; box-sizing:border-box; margin:6px 0 }
     /* Ensure the hint row inside missed cards wraps and does not force extra height
         (this will apply once inline styles are removed from the renderer). */
    /* Match preview hint styling: keep it simple so missed cards use the same visual as preview cards */
    #attemptMissedList .qcard .hint{ display:block !important; margin-top:6px !important; color:var(--muted) }
    /* ASCII antenna */
    #radioPlayer .ascii-ant{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace; white-space: pre; line-height: 1.05; color: var(--ink); background: rgba(0,0,0,.12); border:1px solid rgba(90,110,140,.25); border-radius:10px; padding:6px 8px; text-align:center; overflow:hidden; max-width:100% }
    #radioPlayer .ascii-ant pre{ margin:0; display:inline-block; text-align:left }
    /* Prevent selection on radio ASCII */
    #radioPlayer .ascii-ant, #radioPlayer .ascii-ant pre, #rpAscii{ -webkit-user-select:none; user-select:none }
    @keyframes waves{ 0%{ opacity: 0 } 50%{ opacity: .95 } 100%{ opacity: 0 } }
    /* Pulse the ASCII block while playing */
    #radioPlayer.playing .ascii-ant pre{ animation: antPulse 1.4s ease-in-out infinite }
    @keyframes antPulse{ 0%{ opacity:.85; text-shadow: 0 0 0 rgba(106,169,255,0) } 50%{ opacity:1; text-shadow: 0 0 8px var(--brand) } 100%{ opacity:.85; text-shadow: 0 0 0 rgba(106,169,255,0) } }
    
    /* ASCII Clock (sits underneath the radio, same width) */
    /* Unboxed appearance: no border/background/shadow */
    #asciiClock{ position:fixed; left: calc(12px + env(safe-area-inset-left)); bottom: calc(12px + env(safe-area-inset-bottom)); z-index:179; box-sizing:border-box; padding:0; border-radius: 0; border:none; background: transparent; box-shadow: none; -webkit-backdrop-filter: none; backdrop-filter: none; display:inline-block }
    /* Clock text size set to 10px */
    #asciiClock pre{ margin:0; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace; white-space: pre; line-height:1; color: var(--ink); letter-spacing: -0.5px; font-size: 10px }
    /* Prevent selection on clock ASCII */
    #asciiClock, #asciiClock pre{ -webkit-user-select:none; user-select:none }
    @keyframes clockBob{ 0%{ transform: translateY(0) } 50%{ transform: translateY(-1px) } 100%{ transform: translateY(0) } }
    #asciiClock.playing pre{ animation: clockBob 3s ease-in-out infinite }
    /* Controls row */
    #radioPlayer .rp-row{ display:flex; align-items:center; gap:8px }
    #radioPlayer .rp-row>*{ flex: 0 0 auto }
    /* Let the volume slider flex within the row even when others are fixed */
    #radioPlayer .rp-row .rp-vol{ flex: 1 1 120px; min-width:60px; max-width:100% }
    /* Skip button styling: match size of main play/pause button */
    #radioPlayer #rpSkip{ flex: 0 0 auto; display:none; padding: 6px 10px; font-weight:700; font-size:12px; line-height:1; border-radius:8px; border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); cursor:pointer }
    #radioPlayer.twilight #rpSkip{ display:inline-block }
    /* Reduce select width when Twilight (Skip visible), let it grow otherwise */
    /* Twilight: let the genre select shrink to fit its visible text */
    #radioPlayer.twilight #rpGenre{ flex: 0 0 auto; width: auto; max-width: 150px; min-width: 0 }
    #radioPlayer.twilight #rpGenre.rp-select{ padding: 3px 6px; font-size: 11px }
    #radioPlayer:not(.twilight) #rpGenre{ flex: 1 1 auto }
    #radioPlayer .rp-gear{ appearance:none; border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); font-weight:700; font-size:11px; padding:4px 8px; border-radius:8px; cursor:pointer; line-height:1 }
    #radioPlayer .rp-gear[hidden]{ display:none }
    #radioPlayer .rp-custom{ display:none; padding:8px; border:1px solid var(--btnBorder); border-radius:10px; background: rgba(0,0,0,.16) }
    #radioPlayer .rp-custom.show{ display:block }
    #radioPlayer .rp-custom .row{ display:flex; gap:8px; align-items:center; margin:6px 0 }
    #radioPlayer .rp-custom label{ width:64px; color: var(--muted); font-size:12px }
    #radioPlayer .rp-custom input, #radioPlayer .rp-custom textarea{ flex:1 1 auto; background:#0c1526; color:var(--ink); border:1px solid var(--btnBorder); border-radius:6px; padding:6px 8px; font-size:12px }
    #radioPlayer .rp-custom textarea{ min-height:28px; max-height:360px; resize:vertical; overflow:hidden; height:auto }
    /* Autosizing single-line start: when content grows, JS will expand height to fit without showing scrollbars */
    #radioPlayer .rp-custom textarea.autosize-textarea{ min-height:28px; overflow:hidden; resize:vertical }
    #radioPlayer .rp-custom .actions{ display:flex; gap:8px; justify-content:flex-end; margin-top:6px }
    #radioPlayer .rp-hint{ color: var(--muted); font-size:11px; margin-top:4px }
        /* Title row */
        #radioPlayer .rp-title{ display:flex; align-items:center; gap:8px; font-weight:800; color: var(--ink); letter-spacing:.3px; font-size:13px }
        #radioPlayer .rp-title .dot{ width:8px; height:8px; border-radius:50%; background: var(--brand); box-shadow: 0 0 12px var(--brand) }
    #radioPlayer.min .rp-meta, #radioPlayer.min .ascii-ant{ display:none }
    #radioPlayer.min{ padding-top:8px; padding-bottom:8px }
        @media (max-width: 640px){ #radioPlayer{ width: min(92vw, 340px); padding:6px 8px } #radioPlayer .rp-vol{ width: 80px } }
    </style>

</head>
<body>
        <!-- Ambient Radio Player (bottom-left boxed) -->
        <div id="radioPlayer" role="complementary" aria-label="HF Skywave Long-Range Radio">
            <div class="rp-title"><span class="dot"></span> HF Skywave Long-Range Radio <button id="rpToggle" class="rp-btn small" title="Hide/Show">Hide</button></div>
            <div class="rp-meta">
                <div id="rpNow">Radio ready</div>
                <div id="rpCast">Not receiving</div>
            </div>
                                                <div class="ascii-ant" aria-hidden="true"><pre id="rpAscii"></pre></div>
            <div class="rp-row">
                <select id="rpGenre" class="rp-select" title="Genre" aria-label="Genre">
                    <option value="">Select genre</option>
                    <option value="custom">Custom</option>
                </select>
                <button id="rpSkip" class="rp-btn small" title="Skip to next episode">Skip</button>
                <button id="rpGear" class="rp-gear" title="Custom station settings" hidden>⚙︎</button>
                <button id="rpPlay" class="rp-btn" title="Play/Pause" aria-label="Play">▶</button>
                <input id="rpVol" class="rp-vol" type="range" min="0" max="1" step="0.01" value="0.4" title="Volume" aria-label="Volume" />
            </div>
            <div id="rpCustom" class="rp-custom" aria-hidden="true">
                <div class="row"><label for="rpCustName">Name</label><input id="rpCustName" type="text" placeholder="My Custom Station" /></div>
                <div class="row"><label for="rpCustUrls">URLs</label><textarea id="rpCustUrls" class="autosize-textarea" rows="1" placeholder="One or more direct stream URLs (https).\nExample: https://example.com/stream.mp3\nYou can paste multiple, one per line."></textarea></div>
                <div class="rp-hint">Requirements: HTTPS direct stream (MP3/AAC), CORS-friendly, no login. Avoid web pages or shortlinks; use the actual .mp3/.aac stream URL.</div>
                <div class="actions">
                    <button id="rpCustSave" class="rp-btn small">Save</button>
                    <button id="rpCustClear" class="rp-btn small">Clear</button>
                </div>
            </div>
            <audio id="bgRadio" preload="none" crossorigin="anonymous"></audio>
            <!-- Hidden YouTube player container for Twilight Zone playlist -->
            <!-- YouTube integration removed -->
        </div>

        <!-- Random Category Modal -->
        <div id="randomCategoryModal" class="modal hidden" role="dialog" aria-modal="true" aria-label="Random quiz settings">
            <div class="modal-backdrop"></div>
            <div class="modal-panel">
                <div class="modal-header"><h3>Random Quiz — category / search</h3><button id="randomCategoryClose" class="btn">Close</button></div>
                <div class="modal-body">
                    <div class="hint">Narrow the random quiz to pages matching a Wikipedia search. Type a few words, choose from results, and click Save.</div>
                    <div style="margin-top:12px; display:flex; gap:8px; align-items:center">
                        <input id="categorySearch" placeholder="Search Wikipedia (e.g., 'biochemistry enzymes')" style="flex:1; padding:8px; font-size:14px" />
                        <button id="categoryClear" class="btn">Clear</button>
                    </div>
                    <div id="categorySearchResults" aria-live="polite"></div>
                    <div style="margin-top:10px; display:flex; gap:8px; justify-content:flex-end"><button id="categorySaveBtn" class="btn primary">Save</button></div>
                </div>
            </div>
        </div>

        <!-- Blocky ASCII Digital Clock (just above the radio) -->
        <div id="asciiClock" aria-label="Local time clock" title="Local time clock"><pre id="asciiClockPre">00:00</pre></div>
        <!-- Boot overlay shown before the main interface -->
                <div id="bootOverlay" class="boot-overlay" aria-live="polite">
            <div class="boot-card">
                    <div class="boot-ascii" aria-hidden="false" role="img" aria-label="BUNKR 108 title banner">
    <pre id="bootAscii">
_______   __    __  __    __  __    __  _______           __     ______    ______  
|       \ |  \  |  \|  \  |  \|  \  /  \|       \        _/  \   /      \  /      \ 
| $$$$$$$\| $$  | $$| $$\ | $$| $$ /  $$| $$$$$$$\      |   $$  |  $$$$$$\|  $$$$$$\
| $$__/ $$| $$  | $$| $$$\| $$| $$/  $$ | $$__| $$       \$$$$  | $$$\| $$| $$__/ $$
| $$    $$| $$  | $$| $$$$\ $$| $$  $$  | $$    $$        | $$  | $$$$\ $$ >$$    $$
| $$$$$$$\| $$  | $$| $$\$$ $$| $$$$$\  | $$$$$$$\        | $$  | $$\$$\$$|  $$$$$$ 
| $$__/ $$| $$__/ $$| $$ \$$$$| $$ \$$\ | $$  | $$       _| $$_ | $$_\$$$$| $$__/ $$
| $$    $$ \$$    $$| $$  \$$$| $$  \$$\| $$  | $$      |   $$ \ \$$  \$$$ \$$    $$
 \$$$$$$$   \$$$$$$  \$$   \$$ \$$   \$$ \$$   \$$       \$$$$$$  \$$$$$$   \$$$$$$ 
    </pre>
                    </div>
                <!-- ASCII animation (replaces spinner) - keeps same footprint as .spinner.lg -->
                <pre id="bootAsciiAnim" aria-hidden="true" class="boot-ascii-anim">[   ]</pre>
                <div class="boot-sub">Initializing…</div>
                <div id="bootPhrase" class="boot-phrase" role="status"></div>
            </div>
        </div>
        <script>
            // Ensure the Daily button outline animates unless the user prefers reduced motion.
            // Defer until DOMContentLoaded so the element exists when we query it.
            (function(){
                function initOutline(){
                    try{
                        const btn = document.getElementById('dailyQuizBtn');
                        if(!btn) return;
                        const mq = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)');
                        const canAnimate = !(mq && mq.matches);
                        if(canAnimate) btn.classList.add('animate-outline');
                        // keep API key dot above any background layers
                        const dot = btn.querySelector('.api-key-dot'); if(dot) dot.style.zIndex = 4;
                        // respond to changes in preference
                        if(mq && mq.addEventListener) mq.addEventListener('change', e => { if(e.matches) btn.classList.remove('animate-outline'); else btn.classList.add('animate-outline'); });
                        // Leave the button background to CSS so it matches other .btn elements
                    }catch(e){}
                }
                if(document.readyState === 'complete' || document.readyState === 'interactive') setTimeout(initOutline, 0); else document.addEventListener('DOMContentLoaded', initOutline);
            })();

            // Also ensure the small Always-toggle and its +/− menu toggle can be elevated
            // above the focus overlay when hovered, matching the behavior of #enableFocusBtn.
            (function(){
                function attachElevate(el){
                    if(!el) return;
                    let placeholder = null;
                    function elevate(){
                        try{
                            if(!document.body.classList.contains('focus-mode-active')) return;
                            if(el.dataset.elevated) return;
                            const r = el.getBoundingClientRect();
                            placeholder = document.createElement('div');
                            placeholder.className = 'focus-btn-placeholder';
                            placeholder.style.width = r.width + 'px';
                            placeholder.style.height = r.height + 'px';
                            placeholder.style.display = getComputedStyle(el).display || 'inline-block';
                            el.parentNode.insertBefore(placeholder, el);
                            document.body.appendChild(el);
                            el.style.position = 'fixed';
                            el.style.left = Math.round(r.left) + 'px';
                            el.style.top = Math.round(r.top) + 'px';
                            el.style.zIndex = '100001';
                            el.dataset.elevated = '1';
                        }catch(e){}
                    }
                    function restore(){
                        try{
                            if(!el.dataset.elevated) return;
                            if(placeholder && placeholder.parentNode){ placeholder.parentNode.insertBefore(el, placeholder); placeholder.parentNode.removeChild(placeholder); }
                            placeholder = null;
                            el.style.position = '';
                            el.style.left = '';
                            el.style.top = '';
                            el.style.zIndex = '';
                            delete el.dataset.elevated;
                        }catch(e){}
                    }
                    el.addEventListener('mouseenter', elevate);
                    el.addEventListener('focus', elevate);
                    el.addEventListener('mouseleave', restore);
                    el.addEventListener('blur', restore);
                    window.addEventListener('resize', function(){ try{ if(el.dataset.elevated && placeholder){ const r = placeholder.getBoundingClientRect(); el.style.left = Math.round(r.left) + 'px'; el.style.top = Math.round(r.top) + 'px'; } }catch(e){} });
                    document.addEventListener('focus-mode-off', restore);
                }
                // Ensure attach even if elements are added later dynamically
                function ensureAttach(id){
                    try{
                        const el = document.getElementById(id);
                        if(el){ attachElevate(el); return; }
                        // watch for the element being added to the DOM
                        if(window.MutationObserver){
                            const mo = new MutationObserver((records, obs)=>{
                                try{ const found = document.getElementById(id); if(found){ attachElevate(found); obs.disconnect(); } }catch(e){}
                            });
                            mo.observe(document.body, { childList:true, subtree:true });
                        } else {
                            // fallback: check on DOMContentLoaded
                            document.addEventListener('DOMContentLoaded', ()=>{ try{ const f = document.getElementById(id); if(f) attachElevate(f); }catch(e){} }, { once:true });
                        }
                    }catch(e){}
                }
                ensureAttach('focusAlwaysMenuToggle');
                ensureAttach('alwaysEnableFocusBtn');
            })();

            // Keep Flashcards panel visible ONLY when the main setup (main menu) is shown
            (function flashcardsPanelVisibility(){
                function update(){
                    try{
                        const panel = document.getElementById('flashcardsPanel');
                        const setupEl = document.getElementById('setup');
                        const isMain = !!setupEl && !setupEl.classList.contains('hidden') && !document.body.classList.contains('quiz-running');
                        if(!panel) return;
                        // Use the project's hidden class convention so other code that toggles .hidden stays compatible
                        if(isMain) panel.classList.remove('hidden'); else panel.classList.add('hidden');
                    }catch(e){}
                }
                try{ const bodyObserver = new MutationObserver(update); bodyObserver.observe(document.body, { attributes: true, attributeFilter: ['class'] }); }catch(e){}
                try{ const setupEl = document.getElementById('setup'); if(setupEl){ const so = new MutationObserver(update); so.observe(setupEl, { attributes: true, attributeFilter: ['class','style'] }); } }catch(e){}
                // Also respond to explicit navigation controls that may not mutate attributes in a detectable way
                document.addEventListener('click', function(ev){ try{ const t = ev.target; if(!t) return; if(t.closest && (t.closest('#backSetup') || t.closest('#resetToMenuBtn') || t.closest('#fcStartSession') || t.closest('#fcFromParsed'))){ setTimeout(update, 30); } }catch(e){} }, true);
                if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', update, { once:true }); else update();
                window.addEventListener('focus', update);
            })();
            // On small mobile screens, set default zoom to ~50% for improved fit
            (function(){
                try{
                    var isSmall = Math.min(window.innerWidth, window.innerHeight) <= 640;
                    if(!isSmall) return;
                    var vp = document.querySelector('meta[name="viewport"]');
                    if(!vp) return;
                    var base = 'width=device-width, viewport-fit=cover';
                    vp.setAttribute('content', base + ', initial-scale=0.5, minimum-scale=0.5, maximum-scale=3, user-scalable=yes');
                }catch(e){}
            })();

            // Blocky ASCII Digital Clock
            (function(){
                const pre = document.getElementById('asciiClockPre'); const clockBox = document.getElementById('asciiClock'); if(!pre||!clockBox) return;
                const DIG = {
                    '0':[' ██ ','█  █','█  █','█  █',' ██ '],
                    '1':['  █ ',' ██ ','  █ ','  █ ',' ███'],
                    '2':[' ██ ','█  █','  █ ',' █  ','████'],
                    '3':['███ ','   █',' ██ ','   █','███ '],
                    '4':['█  █','█  █','████','   █','   █'],
                    '5':['████','█   ','███ ','   █','███ '],
                    '6':[' ██ ','█   ','███ ','█  █',' ██ '],
                    '7':['████','   █','  █ ',' █  ',' █  '],
                    '8':[' ██ ','█  █',' ██ ','█  █',' ██ '],
                    '9':[' ██ ','█  █',' ███','   █',' ██ '],
                    ':':['    ',' ██ ','    ',' ██ ','    '],
                    ' ':['    ','    ','    ','    ','    ']
                };
                let tickId=null;
                function two(n){ return (n<10?'0':'')+n; }
                // Lightweight runtime diagnostics: FPS, avg frame ms, event-loop lag, heap, uptime
                const fpsSamples = []; const maxFpsSamples = 60; let lastRaf = performance.now(); let rafRunning = true;
                let avgFrameMs = 0; let fps = 0;
                function rafTick(ts){
                    try{
                        const dt = ts - lastRaf; lastRaf = ts;
                        fpsSamples.push(dt);
                        if(fpsSamples.length>maxFpsSamples) fpsSamples.shift();
                        const sum = fpsSamples.reduce((a,b)=>a+b,0);
                        avgFrameMs = sum / fpsSamples.length;
                        fps = avgFrameMs ? Math.round(1000/avgFrameMs * 10)/10 : 0;
                    }catch(e){}
                    if(rafRunning) requestAnimationFrame(rafTick);
                }
                try{ requestAnimationFrame(rafTick); }catch(e){}

                // Event-loop lag sampler (measured via setTimeout drift)
                let lagSamples = []; const maxLag = 30; let avgLag = 0;
                function sampleLag(){
                    const want = 50; const t0 = performance.now();
                    setTimeout(()=>{
                        const drift = Math.max(0, performance.now() - t0 - want);
                        lagSamples.push(drift);
                        if(lagSamples.length>maxLag) lagSamples.shift();
                        avgLag = Math.round((lagSamples.reduce((a,b)=>a+b,0)/lagSamples.length)*10)/10;
                        // schedule next
                        setTimeout(sampleLag, 250);
                    }, want);
                }
                try{ sampleLag(); }catch(e){}

                const pageStart = performance.timing && performance.timing.navigationStart ? performance.timing.navigationStart : Date.now();

                function fmtMs(n){ return (Math.round(n*10)/10)+"ms" }

                function render(){
                    const d = new Date(); const hh = two(d.getHours()); const mm = two(d.getMinutes());
                    const chars = [hh[0],hh[1], ':', mm[0],mm[1]]; // static colon, no blink
                    // Left block (clock)
                    const left = ['', '', '', '', ''];
                    for(const ch of chars){ const glyph = DIG[ch] || DIG['0']; for(let r=0;r<5;r++){ left[r] += glyph[r] + ' '; } }
                    // Right block (filler details)
                    const rp = document.getElementById('radioPlayer');
                    const genreEl = document.getElementById('rpGenre');
                    const volEl = document.getElementById('rpVol');
                    const isPlaying = !!(rp && rp.classList.contains('playing'));
                    const mode = genreEl ? (genreEl.value === 'twilight' ? 'Twilight' : genreEl.value.charAt(0).toUpperCase()+genreEl.value.slice(1)) : '—';
                    const volPct = volEl ? Math.round((parseFloat(volEl.value||'0')||0)*100) : 0;
                    const wkd = d.toLocaleDateString(undefined, { weekday:'short' });
                    const mon = d.toLocaleDateString(undefined, { month:'short' });
                    const day = d.getDate();
                    const utc = `${two(d.getUTCHours())}:${two(d.getUTCMinutes())}:${two(d.getUTCSeconds())}`;
                    const right = [
                        `Date ${wkd} ${mon} ${two(day)}`,
                        `UTC  ${utc}`,
                        `Mode ${mode}`,
                        `Status ${isPlaying? 'Playing':'Paused'}`,
                        `Vol  ${volPct}%`
                    ];
                    // Diagnostics column (keep 5 rows to match right)
                    const usedMB = (performance && performance.memory && performance.memory.usedJSHeapSize) ? Math.round(performance.memory.usedJSHeapSize/1024/1024) : null;
                    const totalMB = (performance && performance.memory && performance.memory.jsHeapSizeLimit) ? Math.round(performance.memory.jsHeapSizeLimit/1024/1024) : null;
                    const uptimeMs = Date.now() - pageStart; const uptimeS = Math.floor(uptimeMs/1000);
                    const hhU = Math.floor(uptimeS/3600); const mmU = Math.floor((uptimeS%3600)/60); const ssU = uptimeS%60;
                    const uptime = `${hhU.toString().padStart(2,'0')}:${mmU.toString().padStart(2,'0')}:${ssU.toString().padStart(2,'0')}`;
                    // Build diagnostics with explicit label/value columns to ensure consistent alignment
                    const diagLabels = ['FPS', 'Frm', 'Lag', 'Heap', 'Uptime'];
                    const diagVals = [
                        (Math.round(fps*10)/10).toString(),
                        (Math.round(avgFrameMs*10)/10) + 'ms',
                        (avgLag !== null ? avgLag : '0') + 'ms',
                        (usedMB!==null? usedMB+'MB' : 'n/a'),
                        uptime
                    ];
                    const diag = diagLabels.map((lab,i)=> (lab.padEnd(6) + diagVals[i]));
                    // Join clock columns (left + right) and render diagnostics in a third column
                    const sep = ' │ ';
                    const sep2 = ' │ ';
                    // Build main column strings and compute padding so the diag column aligns
                    const mains = [];
                    for(let r=0;r<5;r++){ mains.push(left[r] + sep + right[r]); }
                    const colWidth = Math.max(...mains.map(m=>m.length));
                    const lines = [];
                    for(let r=0;r<5;r++){
                        const pad = Math.max(0, colWidth - mains[r].length);
                        lines.push(mains[r] + ' '.repeat(pad) + sep2 + diag[r]);
                    }
                    pre.textContent = lines.join('\n');
                    // bob while playing like radio
                    try{ if(isPlaying) clockBox.classList.add('playing'); else clockBox.classList.remove('playing'); }catch{}
                }
                function start(){ if(tickId) return; render(); tickId = setInterval(render, 500); }
                function stop(){ if(tickId){ clearInterval(tickId); tickId=null; } }
                // Keep the clock above radio if the radio size changes (toggle min)
                const rp = document.getElementById('radioPlayer');
                function positionClock(){
                    try{
                        if(rp){
                            // Raise radio by clock height so the clock sits underneath
                            const clkH = clockBox.getBoundingClientRect().height;
                            // Read gap from CSS variable --rpClockGap (px) on the radio, default to 12
                            let gap = 12;
                            try{ const cs = getComputedStyle(rp); const g = cs.getPropertyValue('--rpClockGap'); if(g) gap = parseInt(g)||gap; }catch{}
                            rp.style.setProperty('--rpRaise', (Math.round(clkH) + gap) + 'px');
                        }
                    }catch{}
                }
                start();
                positionClock();
                window.addEventListener('resize', ()=>{ positionClock(); });
                // Update position on radio toggle
                document.getElementById('rpToggle')?.addEventListener('click', ()=> setTimeout(positionClock, 200));
                // Optional: expose for debugging
                try{ window.asciiClock = { start, stop, render }; }catch{}
            })();
        </script>
        <script>
            // Ambient Radio Player logic (royalty-free stations + Twilight Zone YouTube mode)
            (function(){
                const $ = id => document.getElementById(id);
                const wrap = $('radioPlayer'); if(!wrap) return;
                const audio = $('bgRadio'); const playBtn = $('rpPlay'); const vol = $('rpVol'); const genreSel = $('rpGenre'); const now = $('rpNow'); const cast = $('rpCast'); const tog = $('rpToggle'); const skipBtn = $('rpSkip');
                const rpAscii = $('rpAscii');
                // Expose ASCII controls so Twilight (YouTube) can start/stop the animation
                let asciiStart = null, asciiStop = null;
                const gearBtn = $('rpGear');
                const custPanel = $('rpCustom');
                const custName = $('rpCustName');
                const custUrls = $('rpCustUrls');
                const custSave = $('rpCustSave');
                const custClear = $('rpCustClear');

                // Autosize helper for the custom URLs textarea: start single-line and grow vertically
                function autosizeTextarea(el){
                    try{
                        if(!el) return;
                        // reset to let the browser compute the scrollHeight
                        el.style.height = 'auto';
                        // ensure a small minimum (approx a single line)
                        const sh = Math.max(24, el.scrollHeight || 24);
                        el.style.height = sh + 'px';
                    }catch(e){}
                }
                if(custUrls){
                    // ensure the starter attributes/classes are present
                    custUrls.classList.add('autosize-textarea');
                    custUrls.setAttribute('rows','1');
                    // run once to seed initial height
                    autosizeTextarea(custUrls);
                    // grow as the user types/pastes
                    ['input','change','paste'].forEach(ev=> custUrls.addEventListener(ev, ()=> autosizeTextarea(custUrls)));
                }
                const hasMS = 'mediaSession' in navigator;

                // YouTube/Twilight integration removed. Stubs and safe placeholders kept for compatibility.
                let ytPlayer = null;
                let ytVol = 0.4;
                let ytApiLoading = false;
                let ytPendingStart = false;
                let ytContainer = null;
                let ytDiv = null;
                function isTwilight(){ return false; }
                function showYT(show) { /* noop - YouTube removed */ }
                function ensureYTApi(cb){ if(cb) cb && cb(); }
                function initYT(){ /* noop - YouTube removed */ }
                function playRandomFromPlaylist(player, ensureShuffle){ /* noop */ }
                function playOrResumeYT(){ /* noop */ }
                function formatTwilightTitle(title){ return 'Twilight Zone (Broadcast)'; }

                // Measure and fit text into the `now` element width using a canvas.
                function measureTextWidth(font, text){
                    try{
                        const c = document.createElement('canvas'); const ctx = c.getContext('2d'); ctx.font = font; return ctx.measureText(text).width;
                    }catch{ return text.length * 7; }
                }

                function getElementFont(el){
                    try{ const s = window.getComputedStyle(el); return `${s.fontWeight} ${s.fontSize} ${s.fontFamily}`; }catch{ return '700 12px system-ui'; }
                }

                function truncateToFit(el, fullText){
                    if(!el) return fullText;
                    try{
                        const ell = '…';
                        const font = getElementFont(el);
                        const maxW = el.clientWidth - 4; // small padding buffer
                        if(measureTextWidth(font, fullText) <= maxW) return fullText;
                        // binary search for maximum chars that fit
                        let lo = 0, hi = fullText.length; let best = '';
                        while(lo <= hi){
                            const mid = Math.floor((lo + hi) / 2);
                            const s = fullText.slice(0, mid).trim() + ell;
                            if(measureTextWidth(font, s) <= maxW){ best = s; lo = mid + 1; } else { hi = mid - 1; }
                        }
                        return best || fullText.slice(0, Math.max(0, Math.floor(el.clientWidth/7))).trim() + ell;
                    }catch{ return fullText; }
                }

                function setNowText(text){
                    try{
                        const full = String(text||'').trim();
                        // Hide when empty
                        if(!full){ if(now){ now.textContent=''; now.title=''; now.style.display='none'; } return; }
                        // Simply set the full text as-is (no truncation or dynamic shrinking)
                        if(now){ now.textContent = full; now.title = full; now.style.display = 'inline-block'; }
                    }catch(e){ try{ now.textContent = String(text||''); }catch{} }
                }

                // Curated public/royalty-free stations (subject to stream availability)
                // Classical: Radio Swiss Classic (public service; non-commercial; metadata via stream)
                // Jazz: Swiss Jazz (public service)
                // Blues: 1.FM Blues (free stream)
                // Bossa: SomaFM Bossa Nova
                const stations = {
                    classical: [
                        { name:'Radio Swiss Classic', urls:['https://stream.srg-ssr.ch/m/rsc_de/mp3_128'] },
                        { name:'Abacus.fm Classical', urls:['https://uk5.internet-radio.com/proxy/abacusclassics?mp=/stream','https://uk6.internet-radio.com/proxy/abacusclassics?mp=/stream'] },
                        { name:'Radio Swiss Classic (alt)', urls:['https://stream.srg-ssr.ch/m/rsc_it/mp3_128','https://stream.srg-ssr.ch/m/rsc_fr/mp3_128'] }
                    ],
                    jazz: [
                        { name:'Radio Swiss Jazz', urls:['https://stream.srg-ssr.ch/m/rsj/mp3_128'] },
                        { name:'Radio Swiss Jazz (alt)', urls:['https://stream.srg-ssr.ch/m/rsj_aacp_96'] },
                        { name:'1.FM - Adore Jazz', urls:['https://strm112.1.fm/adorejazz_mobile_mp3'] }
                    ],
                    // New: Bossa Nova
                    bossa: [
                        { name:'SomaFM: Bossa Nova', urls:['https://ice5.somafm.com/bossa-128-mp3'] }
                    ]
                };

                const KEY = {
                    genre:'rp.genre',
                    idx:'rp.idx',
                    vol:'rp.vol',
                    playing:'rp.playing',
                    customName:'rp.custom.name',
                    customUrls:'rp.custom.urls'
                };

                function parseUrls(text){
                    return (text||'')
                        .split(/\r?\n|,/)
                        .map(s=>s.trim())
                        .filter(s=>/^https:\/\//i.test(s));
                }

                function getCustomStation(){
                    try{
                        // Primary: new custom keys; Fallback: legacy yacht keys
                        const name = (localStorage.getItem(KEY.customName) || localStorage.getItem('rp.yacht.name') || '').trim();
                        const urlsText = (localStorage.getItem(KEY.customUrls) || localStorage.getItem('rp.yacht.urls') || '');
                        const urls = parseUrls(urlsText);
                        if(name && urls.length){ return [{ name, urls }]; }
                    }catch{}
                    return null;
                }

                function isTwilight(){ return genreSel.value==='twilight'; }
                function updateTwilightUI(){
                    const t = isTwilight();
                    try{ wrap.classList.toggle('twilight', t); }catch{}
                    if(skipBtn){ skipBtn.style.display = t ? '' : 'none'; }
                    // When Twilight, shrink the select to its content width to avoid extra blank space
                    try{
                        const sel = genreSel;
                        if(sel){
                            if(t){
                                // Measure selected option text width and set select width accordingly
                                const opt = sel.options[sel.selectedIndex];
                                const span = document.createElement('span'); span.style.visibility='hidden'; span.style.position='absolute'; span.style.whiteSpace='nowrap'; span.style.font = getComputedStyle(sel).font; span.textContent = opt ? opt.text : sel.value;
                                document.body.appendChild(span);
                                const w = Math.min(150, Math.max(64, Math.ceil(span.getBoundingClientRect().width) + 36));
                                sel.style.width = w + 'px';
                                document.body.removeChild(span);
                            } else {
                                sel.style.width = '';
                            }
                        }
                    }catch{}
                }
                function getList(){
                    // Return the list of stations for the currently selected genre.
                    // Important: if no genre is selected (empty string / falsy), return an empty array
                    // so the player does not silently fall back to the 'classical' list (Radio Swiss Classic).
                    const g = (genreSel && typeof genreSel.value !== 'undefined') ? String(genreSel.value).trim() : '';
                    if(!g) return []; // no selection
                    if(g === 'custom'){
                        const cust = getCustomStation();
                        return cust || [];
                    }
                    return stations[g] || [];
                }
                function getIdx(){ const list = getList(); let i=0; try{ i = parseInt(localStorage.getItem(KEY.idx)||'0',10);}catch{} return isFinite(i)? (i % list.length + list.length)%list.length : 0; }
                function setIdx(i){ try{ localStorage.setItem(KEY.idx, String(i)); }catch{} }
                function setGenre(g){ try{ localStorage.setItem(KEY.genre, g); }catch{} }
                function setVol(v){ try{ localStorage.setItem(KEY.vol, String(v)); }catch{} }
                function setPlaying(p){ try{ localStorage.setItem(KEY.playing, p?'1':'0'); }catch{} }

                // Hide/Show toggle
                if(tog){
                    tog.addEventListener('click', function(){
                        const min = wrap.classList.toggle('min');
                        tog.textContent = min ? 'Show' : 'Hide';
                        // Persist the collapsed state so user's preference survives reloads
                        try{ localStorage.setItem('rp.min', min ? '1' : '0'); }catch(e){}
                    });
                }

                // Receiving/Broadcasting animated ellipsis; message depends on mode
                let castTimer = null, castDots = 0;
                function startCastAnim(){
                    stopCastAnim();
                    // set immediately so UI updates without waiting for first interval
                    castDots = 1;
                    cast.textContent = (isTwilight() ? 'Broadcasting' : 'Receiving skywave signals') + ' .';
                    castTimer = setInterval(()=>{
                        castDots = (castDots + 1) % 4; // 0..3
                        const dots = castDots===0? '' : castDots===1? ' .' : castDots===2? ' ..' : ' ...';
                        const base = isTwilight() ? 'Broadcasting' : 'Receiving skywave signals';
                        cast.textContent = base + dots;
                    }, 600);
                }
                function stopCastAnim(){ if(castTimer){ clearInterval(castTimer); castTimer=null; } cast.textContent = idleText(); }
                function idleText(){ return isTwilight() ? 'Not broadcasting' : 'Not receiving'; }

                let curIdx = 0, curAlt = 0;
                function pick(list, i){ return list[(i % list.length + list.length) % list.length]; }
                function showYT(show){ if(ytContainer){ ytContainer.hidden = !show; ytContainer.setAttribute('aria-hidden', show? 'false':'true'); } }
                function load(i, alt){
                    const list = getList();
                    if(!list.length){
                        // No stations available for the current selection. Do not auto-select or load anything.
                        if(genreSel && genreSel.value === 'custom'){
                            setNowText('Custom station not set (click ⚙︎)');
                        } else {
                            setNowText('No station selected — add a custom station (⚙︎).');
                        }
                        return;
                    }
                    curIdx = (i % list.length + list.length) % list.length; curAlt = Math.max(0, alt|0);
                    const st = pick(list, curIdx);
                    const urls = Array.isArray(st.urls) ? st.urls : (st.url ? [st.url] : []);
                    if(!urls.length){ setNowText(st.name + ' (no source)'); return; }
                    let u = urls[Math.min(curAlt, urls.length-1)];
                    // Append timestamp to prevent caching / force live stream
                    try{ u += (u.includes('?') ? '&' : '?') + '_t=' + Date.now(); }catch(e){}
                    audio.src = u; audio.load();
                    setNowText(st.name + (urls.length>1 ? ` (alt ${curAlt+1}/${urls.length})` : ''));
                    setIdx(curIdx);
                    updateMediaSessionMeta();
                }

                function play(){
                    if(isTwilight()){
                        showYT(true); playOrResumeYT(); startCastAnim(); setPlaying(true);
                        return;
                    }
                    audio.play().then(()=>{ wrap.classList.add('playing'); playBtn.textContent = '⏸'; playBtn.setAttribute('aria-label','Pause'); startCastAnim(); setPlaying(true); if(hasMS){ try{ navigator.mediaSession.playbackState = 'playing'; }catch{} } }).catch(err=>{
                        // Autoplay might be blocked; update UI but don't error spam
                        console.warn('Radio play blocked or failed', err); wrap.classList.remove('playing'); playBtn.textContent='▶'; playBtn.setAttribute('aria-label','Play'); cast.textContent=idleText(); stopCastAnim(); setPlaying(false);
                    });
                }
                function pause(){
                    if(isTwilight()){
                        try{ ytPlayer && ytPlayer.pauseVideo && ytPlayer.pauseVideo(); }catch{}
                        wrap.classList.remove('playing'); playBtn.textContent='▶'; playBtn.setAttribute('aria-label','Play'); cast.textContent=idleText(); stopCastAnim(); setPlaying(false); if(hasMS){ try{ navigator.mediaSession.playbackState = 'paused'; }catch{} }
                        return;
                    }
                    audio.pause(); wrap.classList.remove('playing'); playBtn.textContent='▶'; playBtn.setAttribute('aria-label','Play'); cast.textContent=idleText(); stopCastAnim(); setPlaying(false); if(hasMS){ try{ navigator.mediaSession.playbackState = 'paused'; }catch{} }
                }
                function toggle(){ if(isTwilight()) { if(ytPlayer && ytPlayer.getPlayerState && ytPlayer.getPlayerState()===1) pause(); else play(); } else { if(audio.paused) play(); else pause(); } }

                // Volume
                function applyVol(v){
                    const x = Math.max(0, Math.min(1, parseFloat(v)||0));
                    if(isTwilight()){
                        ytVol = x; try{ ytPlayer && ytPlayer.setVolume && ytPlayer.setVolume(Math.round(x*100)); }catch{}
                    } else {
                        audio.volume = x;
                    }
                    vol.value = String(x); setVol(x);
                    try{ wrap.style.setProperty('--rpVolPercent', (x*100).toFixed(0) + '%'); }catch{}
                }
                vol.addEventListener('input', ()=> applyVol(vol.value));

                // Controls
                playBtn.addEventListener('click', toggle);
                if(skipBtn){
                    skipBtn.addEventListener('click', ()=>{
                        if(!isTwilight()) return;
                        ensureYTApi(()=>{ initYT(); if(ytPlayer){
                            try{
                                const st = ytPlayer.getPlayerState ? ytPlayer.getPlayerState() : -1;
                                if(st!==1){
                                    // If not already playing, start randomly in the playlist
                                    playRandomFromPlaylist(ytPlayer, true);
                                } else {
                                    // Advance to next item (shuffle ensures randomness)
                                    ytPlayer.nextVideo();
                                }
                            }catch{ try{ ytPlayer.playVideo && ytPlayer.playVideo(); }catch{} }
                        }});
                    });
                }
                genreSel.addEventListener('change', ()=>{
                    setGenre(genreSel.value);
                    updateTwilightUI();
                    // Show gear only for Custom
                    if(gearBtn){ gearBtn.hidden = genreSel.value!=='custom'; }
                    // If switching to Twilight, we do not use audio element
                    if(isTwilight()){
                        showYT(true);
                        try{ 
                            // Stop and unload any existing audio stream to avoid bleed-through
                            audio.pause();
                            audio.removeAttribute('src');
                            audio.load();
                        }catch{}
                        if(localStorage.getItem(KEY.playing)==='1') playOrResumeYT(); else { cast.textContent=idleText(); stopCastAnim(); }
                        return;
                    } else {
                        showYT(false);
                        try{ ytPlayer && ytPlayer.pauseVideo && ytPlayer.pauseVideo(); }catch{}
                    }
                    load(0,0);
                    if(localStorage.getItem(KEY.playing)==='1') play();
                });

                // Restore state
                (function init(){
                    // Fallback if stored genre removed
                    // Don't pre-select Radio Swiss (first classical entry) for users who have not explicitly chosen a genre.
                    // Prefer a saved genre when present; otherwise prefer a saved custom station, then a neutral default ('jazz').
                    try{
                        const g = localStorage.getItem(KEY.genre);
                        // If a saved, valid genre exists, restore it. Otherwise, do NOT auto-select a genre.
                        // New users should explicitly pick a station before anything is saved or loaded.
                        if(g && (stations[g] || g === 'custom' || g === 'twilight')) {
                            genreSel.value = g;
                        } else {
                            const cust = getCustomStation();
                            // If the user has a saved custom station, show Custom; otherwise leave selection empty
                            genreSel.value = cust ? 'custom' : '';
                        }
                    }catch{
                        try{ genreSel.value = getCustomStation() ? 'custom' : ''; }catch{ genreSel.value = ''; }
                    }
                    updateTwilightUI();
                    if(gearBtn){ gearBtn.hidden = genreSel.value!=='custom'; }
                    try{ const v = localStorage.getItem(KEY.vol); if(v!=null) applyVol(v); else applyVol(vol.value); }catch{ applyVol(vol.value); }
                    if(isTwilight()){
                        showYT(true); ensureYTApi(()=>{ initYT(); });
                        try{ if(localStorage.getItem(KEY.playing)==='1'){ play(); } else { cast.textContent=idleText(); stopCastAnim(); } }catch{ cast.textContent=idleText(); stopCastAnim(); }
                    }else{
                        showYT(false);
                        load(getIdx(), 0);
                        try{ if(localStorage.getItem(KEY.playing)==='1'){ play(); } else { cast.textContent=idleText(); stopCastAnim(); } }catch{ cast.textContent=idleText(); stopCastAnim(); }
                    }
                    // End of init(): fall through to allow outer logic to auto-hide if desired
                })();

                // Auto-hide the radio player on initial page load unless the user explicitly chose to show it.
                // Default behavior: hidden (collapsed). If the user toggled Show before, they can persist that by
                // clicking the toggle which writes 'rp.min' to localStorage.
                try{
                    const pref = localStorage.getItem('rp.min');
                    // If pref === '0' -> show; otherwise (null or '1') -> hide by default
                    const shouldHide = pref !== '0';
                    if(shouldHide){
                        wrap.classList.add('min');
                        if(tog) tog.textContent = 'Show';
                        // Stop any playback so the hidden radio doesn't continue audio unexpectedly
                        try{ pause(); }catch(e){}
                    } else {
                        wrap.classList.remove('min');
                        if(tog) tog.textContent = 'Hide';
                    }
                }catch(e){}

                // --- Playback stall detection and auto-recovery (audio-only genres; disabled in Twilight mode) ---
                // Track last progress to detect stalls
                let _lastProgTs = Date.now();
                audio.addEventListener('timeupdate', ()=>{ if(!isTwilight()) _lastProgTs = Date.now(); });
                audio.addEventListener('progress', ()=>{ if(!isTwilight()) _lastProgTs = Date.now(); });
                audio.addEventListener('playing', ()=>{ if(!isTwilight()) _lastProgTs = Date.now(); });

                function _shouldBePlaying(){
                    try{ return localStorage.getItem(KEY.playing) === '1'; }catch{ return false; }
                }

                let _resumeCooldownUntil = 0;
                let _resumeAttempt = 0;
                function tryResume(reason){
                    if(isTwilight()) return; // only for audio element
                    if(!_shouldBePlaying()) return;
                    const nowTs = Date.now();
                    if(nowTs < _resumeCooldownUntil) return;
                    _resumeAttempt++;
                    const backoff = Math.min(30000, 1000 * _resumeAttempt);
                    _resumeCooldownUntil = nowTs + backoff;

                    // First, attempt a simple play()
                    try{ audio.play().catch(()=>{}); }catch{}

                    // Re-check shortly; if still stalled, reload then play
                    setTimeout(()=>{
                        if(!_shouldBePlaying()) return;
                        const stalled = audio.paused || ((Date.now() - _lastProgTs) > 5000 && audio.readyState < 3);
                        if(stalled){
                            try{ load(curIdx, curAlt); }catch{}
                            setTimeout(()=>{ if(_shouldBePlaying()){ try{ audio.play().catch(()=>{}); }catch{} } }, 400);
                        } else {
                            // recovered; reset attempts
                            _resumeAttempt = 0; _resumeCooldownUntil = 0;
                        }
                    }, 1500);
                }

                // Respond to potential stall-ish events
                ['stalled','suspend','waiting','emptied'].forEach(ev => {
                    audio.addEventListener(ev, ()=>{
                        if(!isTwilight() && _shouldBePlaying()){
                            // brief delay to allow natural buffering before forcing resume
                            setTimeout(()=> tryResume(ev), 800);
                        }
                    });
                });

                // Watchdog: periodically ensure playback is advancing when it should
                setInterval(()=>{
                    if(isTwilight() || !_shouldBePlaying()) return;
                    const stalled = audio.paused || ((Date.now() - _lastProgTs) > 15000 && audio.readyState < 3);
                    if(stalled) tryResume('watchdog');
                }, 4000);

                // Update metadata when stream updates (limited cross-origin)
                audio.addEventListener('playing', ()=> { if(isTwilight()) return; wrap.classList.add('playing'); startCastAnim(); if(hasMS){ try{ navigator.mediaSession.playbackState = 'playing'; }catch{} } });
                audio.addEventListener('pause',   ()=> { 
                    if(isTwilight()) return;
                    wrap.classList.remove('playing'); 
                    if(_shouldBePlaying()){
                        cast.textContent='Reconnecting…';
                        startCastAnim();
                    } else {
                        cast.textContent='Not receiving';
                        stopCastAnim();
                    }
                    if(hasMS){ try{ navigator.mediaSession.playbackState = 'paused'; }catch{} }
                });
                audio.addEventListener('ended',   ()=> { 
                    if(isTwilight()) return;
                    if(_shouldBePlaying()){
                        // Stream ended unexpectedly; attempt to resume same source
                        tryResume('ended');
                    } else {
                        pause();
                    }
                });

                // Robust UI state sync: some external controllers may change playback
                // without invoking our handlers. Poll actual player state and update UI.
                try{
                    let uiSyncInterval = null;
                    function syncUIState(){
                        try{
                            let playing = false;
                            if(isTwilight()){
                                try{ playing = !!(ytPlayer && ytPlayer.getPlayerState && ytPlayer.getPlayerState()===1); }catch{ playing = false; }
                            } else {
                                playing = !!(audio && !audio.paused && !audio.ended);
                            }
                            if(playing){
                                if(!wrap.classList.contains('playing')){
                                    wrap.classList.add('playing'); playBtn.textContent = '⏸'; playBtn.setAttribute('aria-label','Pause'); startCastAnim();
                                }
                            } else {
                                if(wrap.classList.contains('playing')){
                                    wrap.classList.remove('playing'); playBtn.textContent = '▶'; playBtn.setAttribute('aria-label','Play'); cast.textContent = idleText(); stopCastAnim();
                                }
                            }
                        }catch(e){}
                    }
                    uiSyncInterval = setInterval(syncUIState, 800);
                    document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible') setTimeout(syncUIState, 100); });
                }catch(e){}
                audio.addEventListener('error',   ()=> {
                    if(isTwilight()) return;
                    setNowText('Stream error'); wrap.classList.remove('playing'); playBtn.textContent='▶'; cast.textContent=idleText(); stopCastAnim();
                    const list = getList(); const st = pick(list, curIdx);
                    const urls = Array.isArray(st.urls) ? st.urls : (st.url ? [st.url] : []);
                    if(curAlt < urls.length-1){
                        // try next alternate URL for the same station
                        load(curIdx, curAlt+1);
                        if(localStorage.getItem(KEY.playing)==='1') play();
                        return;
                    }
                    // try next station in the same genre
                    if(list.length > 1){
                        load(curIdx+1, 0);
                        if(localStorage.getItem(KEY.playing)==='1') play();
                        setNowText((now && now.textContent ? now.textContent : '') + ' (auto)');
                        return;
                    }
                    // try a different genre as last resort; rotate through available genres
                    const order = ['classical','jazz','bossa','custom'];
                    let gi = order.indexOf(genreSel.value); if(gi < 0) gi = 0; gi = (gi + 1) % order.length; genreSel.value = order[gi]; setGenre(order[gi]);
                    load(0, 0);
                    if(localStorage.getItem(KEY.playing)==='1') play();
                    setNowText((now && now.textContent ? now.textContent : '') + ' (auto cross-genre)');
                });
                // when a stream ends or errors, just stay idle (no skip)

                // Re-apply colors on theme change (purely cosmetic)
                document.addEventListener('theme-changed', ()=>{
                    // No-op: CSS vars already drive visuals; this is here if future sync is needed
                });

                // Custom station settings panel
                if(gearBtn && custPanel){
                    gearBtn.addEventListener('click', ()=>{
                        const show = !custPanel.classList.contains('show');
                        custPanel.classList.toggle('show', show);
                        custPanel.setAttribute('aria-hidden', show? 'false':'true');
                        if(show){
                            try{
                                custName.value = (localStorage.getItem(KEY.customName) || localStorage.getItem('rp.yacht.name') || '');
                                custUrls.value = (localStorage.getItem(KEY.customUrls) || localStorage.getItem('rp.yacht.urls') || '');
                                // Ensure the textarea height matches any loaded content
                                try{ autosizeTextarea && autosizeTextarea(custUrls); }catch(e){}
                            }catch{}
                        }
                    });
                    if(custSave){
                        custSave.addEventListener('click', ()=>{
                            const name = custName.value.trim();
                            const urls = parseUrls(custUrls.value);
                            if(!name || !urls.length){
                                alert('Please enter a Name and at least one HTTPS direct stream URL.');
                                return;
                            }
                            try{
                                localStorage.setItem(KEY.customName, name);
                                localStorage.setItem(KEY.customUrls, urls.join('\n'));
                                // remove legacy keys
                                localStorage.removeItem('rp.yacht.name');
                                localStorage.removeItem('rp.yacht.urls');
                            }catch{}
                            // If currently on custom, reload the custom station
                            if(genreSel.value==='custom'){
                                load(0,0);
                                if(localStorage.getItem(KEY.playing)==='1') play();
                            }
                            custPanel.classList.remove('show');
                            custPanel.setAttribute('aria-hidden','true');
                        });
                    }
                    if(custClear){
                        custClear.addEventListener('click', ()=>{
                            try{ localStorage.removeItem(KEY.customName); localStorage.removeItem(KEY.customUrls); localStorage.removeItem('rp.yacht.name'); localStorage.removeItem('rp.yacht.urls'); }catch{}
                            if(genreSel.value==='custom'){
                                load(0,0);
                                if(localStorage.getItem(KEY.playing)==='1') play();
                            }
                            custPanel.classList.remove('show');
                            custPanel.setAttribute('aria-hidden','true');
                        });
                    }
                }

                // Media Session API: make hardware buttons (AirPods/keyboard media keys) control our player
                function updateMediaSessionMeta(){
                    if(!hasMS) return;
                    try{
                        const list = getList();
                        const st = pick(list, curIdx|0);
                        const genreMap = { classical:'Classical', jazz:'Jazz', bossa:'Bossa Nova', custom:'Custom' };
                        const label = genreMap[genreSel.value] || 'Ambient';
                        navigator.mediaSession.metadata = new MediaMetadata({
                            title: st && st.name ? st.name : 'Ambient Radio',
                            artist: label + ' — Study Focus',
                            album: 'HF Skywave Radio'
                        });
                    }catch{}
                }
                if(hasMS){
                    try{
                        // Use the central play/pause/toggle handlers so UI updates consistently
                        navigator.mediaSession.setActionHandler('play', ()=>{ try{ play(); }catch{} });
                        navigator.mediaSession.setActionHandler('pause', ()=>{ try{ pause(); }catch{} });
                        navigator.mediaSession.setActionHandler('stop', ()=>{ try{ pause(); }catch{} });
                        // We deliberately don’t bind next/previous to avoid accidental station changes
                        navigator.mediaSession.setActionHandler('previoustrack', null);
                        navigator.mediaSession.setActionHandler('nexttrack', null);
                    }catch{}
                }

                // Optional: listen for media-key keyboard events as a fallback
                window.addEventListener('keydown', (e)=>{
                    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
                    // ignore when typing in inputs/textareas/contenteditable
                    if(tag==='input' || tag==='textarea' || (e.target && e.target.isContentEditable)) return;
                    if(e.code==='MediaPlayPause'){
                        e.preventDefault(); try{ toggle(); }catch{}
                    } else if(e.code==='MediaTrackPlay'){
                        e.preventDefault(); try{ play(); }catch{}
                    } else if(e.code==='MediaTrackPause'){
                        e.preventDefault(); try{ pause(); }catch{}
                    }
                }, { passive:false });

                // ---------- ASCII HF Skywave animation ----------
                // Small, efficient ASCII renderer that draws a vertical tower, ground and an "ionosphere" layer.
                // Modes:
                //  - Receiving (default): pulses from edge -> ionosphere -> tower.
                //  - Broadcasting (Twilight): pulses from tower -> ionosphere -> edge.
                (function(){
                    if(!rpAscii) return;

                    // Character grid size, computed to fit container width
                    let COLS = 37;   // initial guess; refined on measure
                    let ROWS = 15;   // compact height
                    let towerX = Math.floor(COLS/2);
                    let groundY = ROWS - 1;
                    let ionoY = 2; // near top
                    let towerTopY = Math.max(ionoY+1, groundY - 7);

                    // Animation state
                    let pulses = []; // { t0:number } spawn time (ms)
                    const duration = 1700; // ms for a pulse to traverse path
                    const spawnEvery = 650; // ms between pulses while playing
                    let lastSpawn = 0;
                    let rafId = null;

                    // Island + water state
                    let islandSeq = [4,8,15,16,23,42];
                    let islandText = '';
                    function updateIslandText(){ islandText = islandSeq.join(' '); }
                    updateIslandText();
                    let lastNumChange = 0; // ms
                    let waterPhase = 0;    // integer phase for horizontal wave shift

                    function clearFrame(){
                        rpAscii.textContent = buildStatic();
                    }

                    function buildStatic(){
                        // Create blank grid
                        const grid = Array.from({length: ROWS}, ()=> Array(COLS).fill(' '));
                        // Water row (bottom)
                        const wave = ['~','~','-','-','_','_'];
                        for(let x=0;x<COLS;x++) grid[groundY][x] = wave[(x + waterPhase) % wave.length];
                        // Ionosphere line
                        for(let x=0;x<COLS;x++) grid[ionoY][x] = '~';
                        // Island (numbers) just above water, centered under tower
                        let txt = islandText;
                        if(txt.length > COLS) txt = txt.slice(0, COLS);
                        const start = Math.max(0, Math.floor((COLS - txt.length)/2));
                        for(let i=0;i<txt.length;i++) grid[groundY-1][start+i] = txt[i];
                        // Tower
                        for(let y=towerTopY; y<=groundY-1; y++) grid[y][towerX] = '|';
                        grid[towerTopY][towerX] = 'A'; // antenna tip
                        // Little base feet
                        if(towerX-1>=0) grid[groundY-1][towerX-1] = '/';
                        if(towerX+1<COLS) grid[groundY-1][towerX+1] = '\\';

                        return grid.map(r => r.join('')).join('\n');
                    }

                    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

                    // Per-pulse randomized path params (receiving): from edge -> ionosphere -> tower top
                    function makePathInbound(){
                        const dir = Math.random() < 0.5 ? -1 : 1; // which edge
                        const edgeX = dir > 0 ? COLS-2 : 1;
                        const edgeY = clamp(Math.round((ionoY + towerTopY)/2) + (Math.random()<0.5?-1:1), 1, groundY-2);
                        const offset = COLS * (0.16 + Math.random()*0.16);
                        const bounceX = clamp(towerX + Math.round(dir * offset), 2, COLS-3);
                        return { dir, edgeX, edgeY, bounceX };
                    }
                    // Per-pulse path for broadcast: from tower top -> ionosphere -> edge
                    function makePathOutbound(){
                        const dir = Math.random() < 0.5 ? -1 : 1;
                        const edgeX = dir > 0 ? COLS-2 : 1;
                        const edgeY = clamp(Math.round((ionoY + towerTopY)/2) + (Math.random()<0.5?-1:1), 1, groundY-2);
                        const offset = COLS * (0.16 + Math.random()*0.16);
                        const bounceX = clamp(towerX + Math.round(dir * offset), 2, COLS-3);
                        return { dir, edgeX, edgeY, bounceX };
                    }

                    // Evaluate pulse position along piecewise path using given path (edge -> ionosphere -> tower top)
                    function pulsePointInbound(p, path){
                        const p0 = {x: path.edgeX, y: path.edgeY};
                        const p1 = {x: path.bounceX, y: ionoY};
                        const p2 = {x: towerX, y: towerTopY};
                        const d01 = Math.hypot(p1.x-p0.x, p1.y-p0.y);
                        const d12 = Math.hypot(p2.x-p1.x, p2.y-p1.y);
                        const T01 = d01/(d01+d12);
                        if(p <= T01){
                            const t = p / T01;
                            return { x: Math.round(lerp(p0.x, p1.x, t)), y: Math.round(lerp(p0.y, p1.y, t)) };
                        }else{
                            const t = (p - T01) / (1 - T01);
                            return { x: Math.round(lerp(p1.x, p2.x, t)), y: Math.round(lerp(p1.y, p2.y, t)) };
                        }
                    }
                    // Outbound path: tower -> ionosphere -> edge
                    function pulsePointOutbound(p, path){
                        const p0 = {x: towerX, y: towerTopY};
                        const p1 = {x: path.bounceX, y: ionoY};
                        const p2 = {x: path.edgeX, y: path.edgeY};
                        const d01 = Math.hypot(p1.x-p0.x, p1.y-p0.y);
                        const d12 = Math.hypot(p2.x-p1.x, p2.y-p1.y);
                        const T01 = d01/(d01+d12);
                        if(p <= T01){
                            const t = p / T01;
                            return { x: Math.round(lerp(p0.x, p1.x, t)), y: Math.round(lerp(p0.y, p1.y, t)) };
                        }else{
                            const t = (p - T01) / (1 - T01);
                            return { x: Math.round(lerp(p1.x, p2.x, t)), y: Math.round(lerp(p1.y, p2.y, t)) };
                        }
                    }

                    function lerp(a,b,t){ return a + (b-a)*t; }

                    function render(nowMs){
                        // Spawn pulses while playing; use wrapper state so Twilight works
                        const isPlaying = !!(wrap && wrap.classList && wrap.classList.contains('playing')) || (!audio.paused && !audio.ended);
                        const useOutbound = isTwilight();
                        if(isPlaying && (nowMs - lastSpawn) >= spawnEvery){
                            pulses.push({ t0: nowMs, path: useOutbound ? makePathOutbound() : makePathInbound(), outbound: useOutbound });
                            lastSpawn = nowMs;
                        }

                        // Advance water and occasionally reshuffle island numbers while playing
                        if(isPlaying){
                            waterPhase = (Math.floor(nowMs / 180)) % 1024; // gentle horizontal drift
                            if(nowMs - lastNumChange > 12000){
                                // rotate numbers for a subtle change
                                islandSeq.push(islandSeq.shift());
                                updateIslandText();
                                lastNumChange = nowMs;
                            }
                        }

                        // Build static frame then overlay dynamic artifacts
                        const baseLines = buildStatic().split('\n');
                        const grid = baseLines.map(l => l.split(''));

                        // Groundwave arcs: draw the same arc visuals for both modes;
                        // the pulse path (inbound vs outbound) determines motion, so
                        // Twilight will effectively be the normal animation reversed.
                        if(isPlaying){
                            const r = Math.floor((nowMs/220)%6)+1; // radius 1..6
                            // Use the same inward-looking marks regardless of mode
                            if(towerX-r>=0 && groundY-2>=0){ grid[groundY-2][towerX-r] = '('; }
                            if(towerX-r-1>=0 && groundY-3>=0){ grid[groundY-3][towerX-r-1] = '('; }
                            if(towerX+r<COLS && groundY-2>=0){ grid[groundY-2][towerX+r] = ')'; }
                            if(towerX+r+1<COLS && groundY-3>=0){ grid[groundY-3][towerX+r+1] = ')'; }
                        }

                        // Draw pulses and faint trails
                        const tnow = nowMs;
                        const newP = [];
                        for(const pl of pulses){
                            const age = tnow - pl.t0;
                            const p = age / duration;
                            if(p >= 1.05){ continue; } // done
                            newP.push(pl);

                            // main head
                            const pt = (pl.outbound ? pulsePointOutbound : pulsePointInbound)(Math.min(1, p), pl.path);
                            putChar(grid, pt.x, pt.y, '*');
                            // trailing points for motion feel
                            const t1 = (pl.outbound ? pulsePointOutbound : pulsePointInbound)(Math.max(0, p-0.08), pl.path); putCharFaint(grid, t1.x, t1.y, '·');
                            const t2 = (pl.outbound ? pulsePointOutbound : pulsePointInbound)(Math.max(0, p-0.16), pl.path); putCharFaint(grid, t2.x, t2.y, '·');

                            // Unified ripple: draw at the ionosphere bounce point so
                            // outbound pulses look like the normal animation reversed.
                            if(p>0.48){
                                const pr = Math.min(1, (p-0.48)/0.52);
                                const cx = (pl.path && typeof pl.path.bounceX !== 'undefined') ? pl.path.bounceX : towerX;
                                const cy = ionoY;
                                const rad = 1 + Math.floor(pr*6);
                                drawRipple(grid, cx, cy, rad, pl.path.dir);
                            }
                        }
                        pulses = newP;

                        // No extra Twilight motif; animation is just the reversed normal path

                        // Theme-colored signals only: color '*', '·', '(', ')', 'o', 'O' with var(--brand)
                        function esc(ch){
                            return ch==='&' ? '&amp;' : ch==='<' ? '&lt;' : ch==='>' ? '&gt;' : ch;
                        }
                        let html = '';
                        for(let y=0;y<grid.length;y++){
                            const row = grid[y];
                            for(let x=0;x<row.length;x++){
                                const ch = row[x];
                                if(ch==='*' || ch==='·' || ch==='(' || ch===')' || ch==='o' || ch==='O') html += `<span style="color: var(--brand)">${esc(ch)}</span>`;
                                else html += esc(ch);
                            }
                            if(y<grid.length-1) html += '\n';
                        }
                        rpAscii.innerHTML = html;

                        rafId = requestAnimationFrame(render);
                    }

                    function putChar(grid,x,y,ch){ if(y>=0&&y<grid.length&&x>=0&&x<grid[0].length) grid[y][x]=ch; }
                    function putCharFaint(grid,x,y,ch){ if(y>=0&&y<grid.length&&x>=0&&x<grid[0].length) grid[y][x]= grid[y][x]===' ' ? ch : grid[y][x]; }
                    function drawRipple(grid, cx, cy, rad, dir){
                        // Draw a small diamond-ish outline at the ionosphere bounce point.
                        // Use subtle dots instead of parentheses so the top animation doesn't show '(' or ')'.
                        const pts = [
                            [cx-rad, cy], [cx+rad, cy],
                            [cx, cy-rad], [cx, cy+rad]
                        ];
                        for(const [x,y] of pts){ putCharFaint(grid,x,y, '·'); }
                        // small diagonals (subtle)
                        putCharFaint(grid, cx+rad-1, cy-1, '·');
                        putCharFaint(grid, cx+rad-1, cy+1, '·');
                        putCharFaint(grid, cx-rad+1, cy-1, '·');
                        putCharFaint(grid, cx-rad+1, cy+1, '·');
                    }

                    function startAscii(){
                        if(rafId!=null) return;
                        lastSpawn = performance.now();
                        rafId = requestAnimationFrame(render);
                    }
                    function stopAscii(){
                        if(rafId!=null){ cancelAnimationFrame(rafId); rafId=null; }
                        pulses.length = 0; clearFrame();
                    }

                    // Wire into audio state
                    audio.addEventListener('playing', startAscii);
                    audio.addEventListener('pause', stopAscii);
                    audio.addEventListener('ended', stopAscii);
                    audio.addEventListener('error', stopAscii);

                    // Expose to outer scope so Twilight (YouTube) can control the ASCII
                    try{
                        asciiStart = function(){ try{ startAscii(); }catch{} try{ wrap.classList.add('playing'); playBtn.textContent='⏸'; playBtn.setAttribute('aria-label','Pause'); startCastAnim(); }catch{} };
                        asciiStop = function(){ try{ stopAscii(); }catch{} try{ wrap.classList.remove('playing'); playBtn.textContent='▶'; playBtn.setAttribute('aria-label','Play'); cast.textContent=idleText(); stopCastAnim(); }catch{} };
                    }catch{}

                    // Fit to container to prevent overflow and draw initial tower
                    function measureAndFit(){
                        try{
                            const box = rpAscii.parentElement; if(!box) return;
                            const maxW = Math.max(60, box.clientWidth - 12);
                            // Measure monospace char width using hidden probe
                            const probe = document.createElement('span');
                            probe.style.visibility = 'hidden';
                            probe.style.position = 'absolute';
                            probe.style.whiteSpace = 'pre';
                            probe.style.fontFamily = getComputedStyle(box).fontFamily;
                            probe.textContent = 'X'.repeat(100);
                            box.appendChild(probe);
                            const chW = Math.max(6, probe.getBoundingClientRect().width / 100);
                            box.removeChild(probe);
                            const targetCols = Math.max(24, Math.min(60, Math.floor(maxW / chW) - 2));
                            COLS = targetCols;
                            ROWS = 15;
                            towerX = Math.floor(COLS/2);
                            groundY = ROWS - 1;
                            ionoY = 2;
                            towerTopY = Math.max(ionoY+1, groundY - 7);
                        }catch(e){ /* keep defaults if measure fails */ }
                    }

                    measureAndFit();
                    clearFrame();
                    // Re-measure on resize to keep within container
                    let resizeT; window.addEventListener('resize', ()=>{ clearTimeout(resizeT); resizeT = setTimeout(()=>{ measureAndFit(); clearFrame(); }, 120); });
                    // If restored state says playing, start animation too
                    if(localStorage.getItem(KEY.playing)==='1' && !audio.paused){ startAscii(); }
                })();
            })();
        </script>
    <div class="bg-anim" aria-hidden="true"></div>

    <!-- Semi-transparent dynamic ASCII watermark background -->
    <div class="ascii-watermark" aria-hidden="true">
        <canvas id="asciiCanvas"></canvas>
        <pre id="asciiWatermark"></pre>
    </div>

    <script>
    // High-performance canvas-based ASCII background renderer
    (function(){
        var FAVORITES = ['4','8','15','16','23','42'];
        var DIGIT_BIAS = 0.6;               // denser numbers
        var FAVORITE_RARITY = 0.008;        // rare favored tokens
        var UPDATE_MS = 90;
        var COLS = 220, ROWS = 64;          // logical grid size
        var BASE = ' .,:;!iIl|?%*#@~=+^/\\_-';

    var canvas = document.getElementById('asciiCanvas');
    var ctx = canvas.getContext('2d', { alpha: true });
    var grid = new Array(ROWS);
        var cellW = 8, cellH = 10;          // pixel cell size; adjusted on resize
        // Brand color (RGB) and base numeric alphas; per-cell jitter adjusts these slightly
        var brandRGB = { r:255, g:255, b:255 };
        var baseAlphaVal = 0.06; // baseline alpha for general chars
        var numAlphaVal  = 0.12; // baseline alpha for digits/favorites
    // Global jitter seed + draw phase (randomized to avoid aligned dark patches after restore)
    var jitterSeed = 1;
    var phaseX = 0.0, phaseY = 0.0; // cell-relative offsets added to glyph draw positions

        function updateCanvasColorsFromTheme(){
            // derive colors from CSS custom properties to mesh with active theme
            var cs = getComputedStyle(document.documentElement);
            var brand = cs.getPropertyValue('--brand').trim() || '#6aa9ff';
            // parse brand as rgb/hex and create two translucent variants
            try{
                var c = brand.startsWith('#') ? hexToRgb(brand) : cssToRgb(brand);
                if(c){
                    brandRGB = { r:c.r, g:c.g, b:c.b };
                }
            }catch(e){}
        }

        function hexToRgb(hex){
            var h = hex.replace('#','');
            if(h.length===3){ h = h[0]+h[0]+h[1]+h[1]+h[2]+h[2]; }
            var num = parseInt(h,16);
            return { r:(num>>16)&255, g:(num>>8)&255, b:num&255 };
        }
        function cssToRgb(str){
            var ctx2 = document.createElement('canvas').getContext('2d');
            ctx2.fillStyle = str; // browser parses any css color
            var v = ctx2.fillStyle; // returns standardized rgb(a)
            var m = v.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
            return m ? { r:+m[1], g:+m[2], b:+m[3] } : null;
        }

        function rand(arr){ return arr[(Math.random()*arr.length)|0]; }
        function randDigit(){ return String((Math.random()*10)|0); }
        function randBase(){ return BASE[(Math.random()*BASE.length)|0]; }

        function initGrid(){
            for(var r=0;r<ROWS;r++){
                var row = new Array(COLS);
                for(var c=0;c<COLS;c++) row[c] = makeCell();
                grid[r] = row;
            }
        }

        function makeCell(){
            if(Math.random() < FAVORITE_RARITY){
                return { ch: rand(FAVORITES), isNum: true };
            }
            var useDigit = Math.random() < DIGIT_BIAS;
            var ch = useDigit ? randDigit() : randBase();
            return { ch: ch, isNum: useDigit };
        }

        function resize(){
            var dpr = window.devicePixelRatio || 1;
            // On mobile, cap DPR to reduce fill rate for better performance/battery
            var smallScreen = Math.min(window.innerWidth, window.innerHeight) <= 768;
            if(smallScreen) dpr = Math.min(dpr, 1.5);
            var w = canvas.clientWidth, h = canvas.clientHeight;
            canvas.width = Math.max(1, (w*dpr)|0);
            canvas.height = Math.max(1, (h*dpr)|0);
            ctx.setTransform(dpr,0,0,dpr,0,0);
            // compute cell size to cover with current COLS/ROWS
            cellW = w / COLS;
            cellH = h / ROWS;
            // choose a monospace-like font size from cell height
            var fontPx = Math.max(6, Math.floor(cellH*0.9));
            ctx.font = fontPx + "px 'Roboto Mono', ui-monospace, Menlo, Monaco, 'Courier New', monospace";
            ctx.textBaseline = 'middle';
        }

        // Small deterministic brightness jitter to avoid blocky patches; varies with a global seed
        function jitterFactor(r,c){
            // 32-bit integer hash (xorshift/mix), returns 0..1
            var rr = (r|0) + (jitterSeed & 0xffff);
            var cc = (c|0) ^ ((jitterSeed>>>16) & 0xffff);
            var x = rr * 374761393 ^ cc * 668265263; x = (x ^ (x>>>13)) * 1274126177; x = x ^ (x>>>16);
            var n = (x >>> 0) / 4294967295; // 0..1
            // Map to a gentle 0.85..1.15 range to keep contrast subtle
            return 0.85 + n * 0.30;
        }
        function rgbaWithAlpha(a){ return 'rgba(' + brandRGB.r + ',' + brandRGB.g + ',' + brandRGB.b + ',' + a + ')'; }

        function drawFull(){
            ctx.clearRect(0,0,canvas.width,canvas.height);
            for(var r=0;r<ROWS;r++){
                for(var c=0;c<COLS;c++){
                    var cell = grid[r][c];
                    var jf = jitterFactor(r,c);
                    var a = (cell.isNum ? numAlphaVal : baseAlphaVal) * jf; if(a > 1) a = 1; if(a < 0) a = 0;
                    ctx.fillStyle = rgbaWithAlpha(a);
                    var offX = 0.1 + phaseX; if(offX < 0) offX = 0; if(offX > 0.3) offX = 0.3;
                    var offY = 0.54 + phaseY; if(offY < 0.35) offY = 0.35; if(offY > 0.75) offY = 0.75;
                    ctx.fillText(cell.ch, c*cellW + cellW*offX, r*cellH + cellH*offY);
                }
            }
        }

        // Adaptive rAF loop
        var rafId = null, lastTs = 0, changeAccumulator = 0;
        var changesPerSecond = 4000; // starting target; will adapt
        var maxPerFrame = 700;       // cap to avoid spikes

        function frame(ts){
            if(!lastTs) lastTs = ts;
            var dt = ts - lastTs; // ms
            lastTs = ts;
            // accumulate how many cells to mutate this frame
            changeAccumulator += (changesPerSecond * dt) / 500;
            var toMutate = Math.min(maxPerFrame, changeAccumulator | 0);
            if(toMutate > 0){
                changeAccumulator -= toMutate;
                for(var i=0;i<toMutate;i++){
                    var r = (Math.random()*ROWS)|0;
                    var c = (Math.random()*COLS)|0;
                    var cell = grid[r][c] = makeCell();
                    var x = c*cellW, y = r*cellH;
                    // Clear a slightly larger rect to avoid any AA overhang causing ghosting/doubling
                    ctx.clearRect(x - 2, y - 2, cellW + 4, cellH + 4);
                    var jf = jitterFactor(r,c);
                    var a = (cell.isNum ? numAlphaVal : baseAlphaVal) * jf; if(a > 1) a = 1; if(a < 0) a = 0;
                    ctx.fillStyle = rgbaWithAlpha(a);
                    var offX = 0.1 + phaseX; if(offX < 0) offX = 0; if(offX > 0.3) offX = 0.3;
                    var offY = 0.54 + phaseY; if(offY < 0.35) offY = 0.35; if(offY > 0.75) offY = 0.75;
                    ctx.fillText(cell.ch, x + cellW*offX, y + cellH*offY);
                }
            }
            // simple adaptive tuning based on dt
            var targetMs = 16.7;
            if(dt > targetMs*1.2) { changesPerSecond = Math.max(1000, changesPerSecond * 0.9); }
            else if(dt < targetMs*0.7) { changesPerSecond = Math.min(12000, changesPerSecond * 1.05); }
            rafId = requestAnimationFrame(frame);
        }

    function reseedVisuals(){
        jitterSeed = (Math.random()*0x7fffffff)|0;
        // small phase shift per resume so the global grid doesn’t anchor to the same subpixel origin
        phaseX = (Math.random()*0.20) - 0.10; // [-0.10, +0.10] of a cell width
        phaseY = (Math.random()*0.20) - 0.10; // [-0.10, +0.10] of a cell height
    }
    function start(){ updateCanvasColorsFromTheme(); reseedVisuals(); initGrid(); resize(); drawFull(); rafId = requestAnimationFrame(frame); }
        function onResize(){ cancelAnimationFrame(rafId); rafId = null; resize(); drawFull(); lastTs = 0; changeAccumulator = 0; rafId = requestAnimationFrame(frame); }

        var reduce = false; try{ reduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches; }catch(e){}
    if(reduce){ changesPerSecond = 1500; }
        // On small screens, start with a lower mutation budget to keep frames smooth
        try{
            var smallScreenInit = Math.min(window.innerWidth, window.innerHeight) <= 768;
            if(smallScreenInit){ changesPerSecond = Math.min(changesPerSecond, 3000); maxPerFrame = Math.min(maxPerFrame, 450); }
        }catch(e){}

        // Optional external controls
        window.__asciiBg = {
            start: function(){ if(!rafId){ start(); setHidden(false); try{ localStorage.setItem('__asciiBg','on'); }catch(e){} } },
            stop: function(){ if(rafId){ cancelAnimationFrame(rafId); rafId=null; } try{ localStorage.setItem('__asciiBg','off'); }catch(e){} },
            isRunning: function(){ return !!rafId; }
        };

        function setHidden(hide){
            try{
                var layer = document.querySelector('.ascii-watermark');
                if(layer){ layer.style.display = hide ? 'none' : ''; }
            }catch(e){}
        }

        window.addEventListener('load', function(){
            var pref = 'on'; try{ pref = localStorage.getItem('__asciiBg')||'on'; }catch(e){}
            if(pref === 'off'){ setHidden(true); }
            else { start(); }
            // listen for theme changes via click on orbs to update colors
            var orbs = document.querySelectorAll('.theme-capsule .theme-orb');
            orbs.forEach(function(o){ o.addEventListener('click', function(){ updateCanvasColorsFromTheme(); }); });
            // also respond to a custom theme change event so programmatic theme sets update the canvas
            try{ document.addEventListener('theme-changed', function(){ updateCanvasColorsFromTheme(); }); }catch(e){}
        });
        window.addEventListener('resize', onResize);
        // When returning to the tab, some browsers “shrink” fixed layers until a reflow; fix both layers
        function refreshGlowLayer(){ try{
            var glow = document.querySelector('.bg-anim'); if(!glow) return;
            // restart CSS animation to force reflow
            var prev = glow.style.animationName; glow.style.animationName = 'none';
            void glow.offsetWidth; // force reflow
            glow.style.animationName = '';
            // also reapply positional CSS to ensure viewport-calculated insets take effect
            glow.style.top = '-25vh'; glow.style.left = '-25vw'; glow.style.right = '-25vw'; glow.style.bottom = '-25vh';
        }catch(e){} }
        document.addEventListener('visibilitychange', function(){
            if(document.hidden){ if(rafId) cancelAnimationFrame(rafId); rafId = null; }
            else {
                // Resume animations based on user preference (not current rAF state)
                try{
                    var pref = localStorage.getItem('__asciiBg') || 'on';
                    if(pref !== 'off'){
                        refreshGlowLayer();
                        reseedVisuals(); initGrid(); onResize();
                    }
                }catch(e){
                    // Best-effort resume
                    refreshGlowLayer(); reseedVisuals(); initGrid(); onResize();
                }
            }
        });
        window.addEventListener('pageshow', function(){ refreshGlowLayer(); reseedVisuals(); initGrid(); onResize(); });
    })();
    </script>

    <!-- Sticky Notes Dock (top-right) -->
    <div id="stickyDock" class="sticky-dock" role="toolbar" aria-label="Sticky notes">
        <button id="sdNew" class="sd-btn" title="New note">New</button>
        <button id="sdList" class="sd-btn" title="All notes">All</button>
        <button id="sdClearAll" class="sd-btn" title="Clear all notes">Clear all</button>
        <span id="sdCount" class="sd-count" title="Saved notes">0</span>
    </div>
    <div id="stickyPanel" class="sticky-panel hidden" role="region" aria-label="All sticky notes">
        <div class="row">
            <input id="sdSearch" class="sd-input" type="search" placeholder="Search notes (title/text)…" />
            <button id="sdClose" class="sd-btn small" title="Close" aria-label="Close">×</button>
        </div>
        <div id="sdListWrap" class="sticky-list"></div>
    </div>

    <!-- Sticky rail: 4 clip points for pinning notes on the right -->
    <div id="stickyRail" class="sticky-rail" aria-label="Sticky clip rail">
        <div class="clip-slot" data-slot="0" title="Clip slot 1"></div>
        <div class="clip-slot" data-slot="1" title="Clip slot 2"></div>
        <div class="clip-slot" data-slot="2" title="Clip slot 3"></div>
        <div class="clip-slot" data-slot="3" title="Clip slot 4"></div>
    </div>
    <div id="stickyRailHoverzone" class="sticky-rail-hoverzone" aria-hidden="true"></div>
    <!-- Rail width resizer handle -->
    <button id="stickyRailResizer" class="sticky-rail-resizer" aria-label="Resize sticky tabs" title="Drag to resize sticky tabs width" aria-controls="stickyRail" data-min="220" data-max="520"></button>

    <!-- Left-side single magnet tab (shares clip-slot behavior; appears after rail so indices 0..3 stay stable) -->
    <div id="leftMagnet" class="clip-slot" data-slot="4" title="Left magnet tab (pin a note here)"></div>
    <div id="leftTabHoverzone" class="left-tab-hoverzone" aria-hidden="true"></div>
        <button id="leftTabResizer" class="left-tab-resizer" aria-label="Resize left magnet tab" title="Drag to resize left magnet width" aria-controls="leftMagnet" data-min="180" data-max="520"></button>

            <!-- Flip-clock digit card styling (boxes per digit with flip cover effect) -->
        <style id="bootFlipCardStyles">
            /* Scope to boot ASCII host so we don't affect other digits */
                #bootAsciiAnim{ display:block; overflow:visible; min-width: 260px; margin: 2px auto; }
                #bootAsciiAnim .digits{ display:flex; align-items:center; justify-content:center; gap:8px; flex-wrap:nowrap }
            #bootAsciiAnim .digit{
                position:relative;
                display:inline-flex; align-items:center; justify-content:center;
                    flex:0 0 auto;
                    width: 44px; height: 56px; /* smaller card so it never overlaps subtext */
                    font-size: 28px; line-height: 1; letter-spacing: .04em;
                    min-width: 40px; /* ensure visible box even with narrow glyphs */
                    padding:0;
                border-radius:8px;
                background: rgba(255,255,255,0.04);
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: inset 0 -1px 0 rgba(255,255,255,0.06), 0 10px 28px rgba(0,0,0,0.35);
                overflow:hidden;
                backface-visibility: hidden;
                transform-style: preserve-3d;
                -webkit-font-smoothing: antialiased;
                text-rendering: geometricPrecision;
                will-change: transform;
                transition: background 160ms ease, border-color 160ms ease;
            }
            /* Ancient glyphs appear inside the same card */
            #bootAsciiAnim .digit.ancient{ background: rgba(255,255,255,0.05); border-color: rgba(255,255,255,0.14) }

                        /* Split-flap illusion: we only show flaps during a flip (class .splitting) */
                        #bootAsciiAnim .digit::before, #bootAsciiAnim .digit::after{
                            position:absolute; left:0; right:0; display:flex; align-items:center; justify-content:center;
                            font: inherit; color: inherit; letter-spacing: inherit;
                            background: rgba(10,10,20,0.25);
                            border-top: 1px solid rgba(255,255,255,0.08);
                            border-bottom: 1px solid rgba(0,0,0,0.35);
                            pointer-events:none; backface-visibility:hidden; transform-style:preserve-3d; opacity:0;
                        }
                        /* top flap shows current value at flip start */
                        #bootAsciiAnim .digit.splitting::before{
                            content: attr(data-top);
                            top:0; height:50%;
                            transform-origin: bottom center;
                            transform: perspective(500px) rotateX(0deg);
                            overflow:hidden; opacity:1;
                        }
                        /* bottom flap initially shows current; later we swap content to next and flip it in */
                        #bootAsciiAnim .digit.splitting::after{
                            content: attr(data-bottom);
                            bottom:0; height:50%;
                            transform-origin: top center;
                            transform: perspective(500px) rotateX(90deg);
                            overflow:hidden; opacity:1;
                            box-shadow: 0 -8px 18px rgba(0,0,0,0.35);
                        }
                        /* Hide the base text while flaps are active so things don't look doubled */
                        #bootAsciiAnim .digit.splitting{ color: transparent; }
                        /* Stage 1: top flips up (old value) */
                        #bootAsciiAnim .digit.flip2::before{ animation: topFlipOut 160ms ease forwards; }
                        /* Stage 2: after we switch data-bottom to the next value, flip it in */
                        #bootAsciiAnim .digit.bottomIn::after{ animation: bottomFlipIn 220ms ease forwards; }
                @keyframes topFlipOut{
                    0%{ transform: perspective(500px) rotateX(0deg); }
                    100%{ transform: perspective(500px) rotateX(-90deg); }
                }
                @keyframes bottomFlipIn{
                    0%{ transform: perspective(500px) rotateX(90deg); }
                    100%{ transform: perspective(500px) rotateX(0deg); }
                }
        </style>


    <script>
            // Boot overlay controller: cycles phrases, then fades into the app
                            (function(){
                                // Only show boot overlay on initial page load (per-tab)
                                var overlay = document.getElementById('bootOverlay');
                                try{
                                    var skip = sessionStorage.getItem('__bootPlayed') === '1';
                                    if(skip){ if(overlay && overlay.parentNode){ overlay.parentNode.removeChild(overlay); } return; }
                                }catch(e){}
                                // Prevent page scroll while boot overlay is visible
                                try{ document.documentElement.classList.add('booting'); document.body.classList.add('booting'); }catch(e){}
                                // Make sticky UI inert (non-focusable / non-interactive) while boot overlay runs
                                try{ if(typeof setStickyInert === 'function') setStickyInert(true); }catch(e){}
                                // Mark as played for this session
                                try{ sessionStorage.setItem('__bootPlayed','1'); }catch(e){}
                // Small ASCII animation for the boot card (replaces spinner)
                // Flip-clock style: countdown from 108.00 with random decreasing steps.
                // Every ~5–6 seconds, all digits briefly switch to hieroglyphs, then return to the current value (no reset)
                // so the countdown can approach ~2.00. On overlay end, flash glyphs, then flip back to 108.00.
                // Entirely text-based and per-digit flip animation via CSS.
                var _bootAnimId = null;
                (function(){
                    // Five-character MMSSS timer (3-digit minutes + 2-digit seconds), starting at 108:00 → "10800"
                    var START_MIN = 108;
                    var START_SECS = START_MIN * 60; // 6480
                    var currentSecs = START_SECS;
                    var inGlitch = false;
                    var nextGlitchTs = Date.now() + 9500; // placeholder; start() will align with cycle end
                    var TICK = 80; // faster tick for more responsive flips
                    // Only the specified symbols
                    var GLYPH_SET = ['𓇋','𓎛','𓄿','𓏏','𓌙'];

                    function seedString(){ return '108.00'; }
                    // Render 5 characters total: 3-digit minutes + 2-digit seconds (no punctuation)
                    function fmtFiveFromSecs(total){
                        total = Math.max(0, Math.floor(total));
                        var mins = Math.floor(total / 60);
                        var secs = total % 60;
                        return String(mins).padStart(3,'0').slice(-3) + String(secs).padStart(2,'0');
                    }
                    function el(){ return document.getElementById('bootAsciiAnim'); }
                    function ensureStructure(str){
                        var host = el(); if(!host) return null;
                        // Ensure exactly 5 slots so glyphs fill full array
                        var slots = 5;
                        var chars = (str||'').toString().split('');
                        // If provided string shorter or longer, pad/truncate to slots
                        if(chars.length < slots){
                            while(chars.length < slots) chars.push(' ');
                        } else if(chars.length > slots){
                            chars = chars.slice(0, slots);
                        }
                        var html = '<span class="digits">' + chars.map(function(ch){ return '<span class="digit">'+ch+'</span>'; }).join('') + '</span>';
                        host.innerHTML = html; return host.querySelectorAll('.digit');
                    }
                    function spans(){ var host = el(); return host ? host.querySelectorAll('.digit') : null; }
                    // Per-digit staggered updates: leftmost slow, rightmost fast
                    var digitDelays = [220, 140, 80, 40, 12]; // ms delays for indices 0..4
                    function updateDigits(str, order){
                        var sp = spans(); if(!sp || sp.length !== 5){ sp = ensureStructure(str); }
                        if(!sp) return;
                        var cur = Array.prototype.map.call(sp, function(s){ return s.textContent || ' '; });
                        var target = (str||'').toString().split('');
                        // Ensure target is length 5
                        if(target.length < 5){ while(target.length<5) target.push(' '); }
                        if(target.length > 5) target = target.slice(0,5);
                        // If an order (scramble) was provided, respect it for timing positions
                        var orderMap = null;
                        if(Array.isArray(order) && order.length===5){ orderMap = order.slice(); }
                        for(let i=0;i<5;i++){
                            if(cur[i] === target[i]) continue;
                            (function(idx){
                                var d = sp[idx];
                                var baseDelay = digitDelays[idx] || 60;
                                // If orderMap provided, place earlier items slightly earlier
                                var extra = 0;
                                if(orderMap){ var pos = orderMap.indexOf(idx); if(pos>=0) extra = pos*8; }
                                // Prepare split-flap: start with current value on both halves
                                try{
                                    d.setAttribute('data-top', cur[idx]);
                                    d.setAttribute('data-bottom', cur[idx]);
                                    d.classList.add('splitting');
                                    d.classList.remove('ancient');
                                }catch(e){}
                                // Start split-flap animation; then swap bottom content to next and flip it in
                                setTimeout(function(){
                                    if(inGlitch) return; // don't fight the glyph flash
                                    try{ d.classList.add('flip2'); }catch(e){}
                                    // After top flap lifts, switch bottom to the next value and flip it in
                                    setTimeout(function(){
                                        if(inGlitch) return;
                                        try{
                                            d.setAttribute('data-bottom', target[idx]);
                                            d.classList.add('bottomIn');
                                        }catch(e){}
                                        // After bottom finishes, commit the new text and clear classes
                                        setTimeout(function(){
                                            if(inGlitch) return;
                                            try{
                                                d.textContent = target[idx];
                                                d.classList.remove('flip2','bottomIn','splitting');
                                            }catch(e){}
                                        }, 240);
                                    }, 160);
                                }, baseDelay + extra);
                            })(i);
                        }
                    }
                    function randomStepSecs(){
                        // kept for compatibility when occasional large jumps are desired
                        var r = Math.random(); var step;
                        if(currentSecs > 1800)      step = 30 + Math.floor(r*60);
                        else if(currentSecs > 600)  step = 10 + Math.floor(r*20);
                        else if(currentSecs > 120)  step = 5 + Math.floor(r*6);
                        else                        step = 1 + Math.floor(r*4);
                        return step;
                    }
                    // Time accumulator to produce approximately 1-second decrements while tick() runs faster
                    var tickAcc = 0;
                    var lastTickTs = Date.now();
                    var secondToggle = false; // for every-other-second small jump
                    // Cycle controls: base cycle (will be adapted to popup duration in start())
                    var CYCLE_MS = 10000;
                    // Global speed multiplier for the countdown (1 = real-time). Will be computed in start() based on `total` so the countdown reaches zero before popup ends.
                    var SPEED_MULT = 1;
                    var accelUntil = 0;     // timestamp until acceleration applies
                    var accelFactor = 1;    // 1 = normal, >1 = accelerated
                    var viewHoldUntil = 0;  // timestamp to hold a randomly lowered number for ~2s
                    var _cycleTimerId = null;
                    var cyclesSinceGlitch = 0; // count cycles to defer glyphs until we've advanced
                    // Strict cycle scheduling for 10s loop + glyph linger
                    var GLYPH_LINGER_MS = 2000; // show hieroglyphs ~2s near cycle end
                    try{ window.__bootGlyphLingerMs = GLYPH_LINGER_MS; }catch(e){}
                    // Timestamps
                    var overallStartTs = Date.now(); // marks beginning of the boot animation (used for adaptive speed)
                    var cycleStartTs = overallStartTs;
                    var finalGlyphTs = 0; // epoch ms when final hieroglyphs should appear
                    var shownFinalGlyph = false;
                    var nextStepTs = 0; // next jump update (stepBase-derived)
                    var glitchEndTs = 0; // when to end glyph display
                    // Only show glyphs when explicitly allowed (force=true) or when the final glyph time has arrived.
                    // This prevents accidental mid-cycle flashes caused by stray calls.
                    // Synchronized split-flap flip to the ancient glyphs and hold for lingerMs (ms).
                    // If `force` is false, only allow the glyphs when finalGlyphTs has passed.
                    function toGlyphs(force, lingerMs){
                        try{
                            var now = Date.now();
                            if(!force && finalGlyphTs && now < finalGlyphTs) return;
                        }catch(e){}
                        var sp = spans(); if(!sp || sp.length !== 5){ sp = ensureStructure(fmtFiveFromSecs(currentSecs)); }
                        if(!sp) return;
                        // Prepare top/bottom with current values and start splitting for all digits at once
                        var cur = Array.prototype.map.call(sp, function(s){ return s.textContent || ' '; });
                        for(var i=0;i<5;i++){
                            try{
                                sp[i].setAttribute('data-top', cur[i]);
                                sp[i].setAttribute('data-bottom', cur[i]);
                                sp[i].classList.add('splitting');
                                sp[i].classList.remove('ancient');
                            }catch(e){}
                        }
                        // Kick top flap out for all digits together (stage 1)
                        setTimeout(function(){
                            for(var i=0;i<5;i++){ try{ sp[i].classList.add('flip2'); }catch(e){} }
                        }, 20);
                        // After top flip completes, swap bottom content to glyphs and flip in (stage 2)
                        setTimeout(function(){
                            for(var i=0;i<5;i++){
                                try{
                                    sp[i].setAttribute('data-bottom', GLYPH_SET[i] || ' ');
                                    sp[i].classList.add('bottomIn');
                                }catch(e){}
                            }
                        }, 200); // slightly after topFlipOut (160ms)
                        // After bottom flip finishes, commit glyphs and leave them visible (ancient)
                        setTimeout(function(){
                            for(var i=0;i<5;i++){
                                try{
                                    sp[i].textContent = GLYPH_SET[i] || ' ';
                                    sp[i].classList.remove('flip2','bottomIn','splitting');
                                    sp[i].classList.add('ancient');
                                }catch(e){}
                            }
                            // Mark inGlitch and set end timestamp
                            try{ inGlitch = true; glitchEndTs = Date.now() + (typeof lingerMs === 'number' ? Math.max(200, lingerMs) : GLYPH_LINGER_MS); }catch(e){}
                        }, 460); // 200 + 260ms ~ bottomFlipIn duration
                    }
                    function resetToSeedRandom(){
                        var t = fmtFiveFromSecs(START_SECS); // "10800"
                        var order = Array.from({length:t.length}, function(_,i){ return i; });
                        for(var i=order.length-1;i>0;i--){ var j=(Math.random()*(i+1))|0; var tmp=order[i]; order[i]=order[j]; order[j]=tmp; }
                        updateDigits(t, order);
                    }
                    function tick(){
                        try{
                            var now = Date.now();
                            // If currently showing glyphs, end after linger interval, then reset cycle
                            if(inGlitch){
                                if(now >= glitchEndTs){
                                    inGlitch = false;
                                    // Recalculate currentSecs from overall elapsed so countdown continues smoothly
                                    var elapsedRealAfter = Math.floor((now - overallStartTs) / 1000);
                                    var virtualDecAfter = elapsedRealAfter * SPEED_MULT;
                                    currentSecs = Math.max(0, START_SECS - virtualDecAfter);
                                    updateDigits(fmtFiveFromSecs(currentSecs));
                                    // start a fresh cycle window for gating next glitch
                                    cycleStartTs = now;
                                    nextGlitchTs = cycleStartTs + Math.max( Math.min(CYCLE_MS - GLYPH_LINGER_MS, CYCLE_MS - 200), 200 );
                                    var stepBaseAfter = Math.max(200, Math.floor((CYCLE_MS - GLYPH_LINGER_MS) / 8));
                                    nextStepTs = now + stepBaseAfter + Math.floor(Math.random() * Math.max(1, Math.floor(stepBaseAfter / 2)));
                                    lastTickTs = now; tickAcc = 0; secondToggle = false;
                                }
                                return;
                            }
                            // Only show hieroglyphs at the final reserved time (derived from popup duration)
                            if(!shownFinalGlyph && finalGlyphTs && now >= finalGlyphTs){
                                shownFinalGlyph = true;
                                // Flip all glyphs synchronously and hold for GLYPH_LINGER_MS
                                toGlyphs(true, GLYPH_LINGER_MS);
                                // Final state: stop all further ticking so nothing flips back to numbers
                                try{ if(_bootAnimId){ clearInterval(_bootAnimId); _bootAnimId = null; } }catch(e){}
                                try{ if(_cycleTimerId){ clearInterval(_cycleTimerId); _cycleTimerId = null; } }catch(e){}
                                return;
                            }
                            // Update visible time every ~0.9–1.1s using accelerated scale (50×)
                            if(nextStepTs === 0){ var stepBase = Math.max(200, Math.floor((CYCLE_MS - GLYPH_LINGER_MS) / 8)); nextStepTs = now + stepBase + Math.floor(Math.random() * Math.max(1, Math.floor(stepBase/2))); }
                            if(now >= nextStepTs){
                                // Use overall elapsed time since the boot animation started so the virtual countdown scales to the full popup duration
                                var elapsedReal = Math.floor((now - overallStartTs) / 1000); // seconds since boot start
                                var virtualDec = elapsedReal * SPEED_MULT; // accelerated seconds to subtract
                                var newSecs = Math.max(0, START_SECS - virtualDec);
                                if(newSecs !== currentSecs){
                                    currentSecs = newSecs;
                                    updateDigits(fmtFiveFromSecs(currentSecs));
                                }
                                var stepBase2 = Math.max(200, Math.floor((CYCLE_MS - GLYPH_LINGER_MS) / 8));
                                nextStepTs = now + stepBase2 + Math.floor(Math.random() * Math.max(1, Math.floor(stepBase2/2)));
                            }
                        }catch(e){}
                    }
                    function _cycleKick(){
                        try{
                            // Count this cycle (used to defer glyph glitches until we've made progress)
                            cyclesSinceGlitch++;
                            // Start a short accelerated phase (stronger: 6-8x) for ~2.5s
                            accelFactor = 6 + Math.floor(Math.random()*3); // 6,7,8
                            accelUntil = Date.now() + 2500;
                            // Apply a larger proportional reduction to make meaningful progress each cycle
                            if(currentSecs > 10){
                                // Remove ~15%–40% of remaining time to drive it toward zero faster
                                var pct = 0.15 + Math.random()*0.25; // 0.15..0.40
                                var bigReduce = Math.max(5, Math.floor(currentSecs * pct));
                                currentSecs = Math.max(0, currentSecs - bigReduce);
                            } else {
                                currentSecs = 0;
                            }
                            updateDigits(fmtFiveFromSecs(currentSecs));
                            // Hold this view briefly so user can read it (~1.2s)
                            viewHoldUntil = Date.now() + 1200;
                            // Previously scheduled mid-cycle glitches removed: final glyphs will only be shown at finalGlyphTs
                            // (no-op here)
                        }catch(e){}
                    }

                    function start(){
                        var host = el(); if(!host) return;
                        var now = Date.now();
                        currentSecs = START_SECS; inGlitch = false;
                        // mark overall boot start
                        overallStartTs = now;
                        // Use outer `total` (ms) to calibrate running time
                        var TOTAL_LOAD_MS = (typeof total === 'number' && total > 0) ? Math.max(2000, Math.floor(total)) : 30000;
                        // Reserve final glyph linger window; compute effective run time for counting
                        var effectiveRunMs = Math.max(800, TOTAL_LOAD_MS - GLYPH_LINGER_MS);
                        // Compute SPEED_MULT so START_SECS virtual seconds elapse across effectiveRunMs
                        SPEED_MULT = Math.max(1, Math.ceil(START_SECS / (effectiveRunMs / 1000)));

                        // Fit cycle length to TOTAL_LOAD_MS aiming for ~10s cycles but always at least 2s
                        var approxCycleCount = Math.max(1, Math.round(TOTAL_LOAD_MS / 10000));
                        CYCLE_MS = Math.max(2000, Math.floor(TOTAL_LOAD_MS / approxCycleCount));

                        // Initialize cycle timestamps
                        cycleStartTs = now;
                        // Compute absolute final glyph time (show hieroglyphs only once at end)
                        finalGlyphTs = overallStartTs + Math.max(200, Math.floor(TOTAL_LOAD_MS - GLYPH_LINGER_MS));
                        shownFinalGlyph = false;
                        // Keep a legacy nextGlitchTs value for compatibility but it will not be used to trigger glyphs
                        nextGlitchTs = cycleStartTs + Math.max( Math.min(CYCLE_MS - GLYPH_LINGER_MS, CYCLE_MS - 200), 200 );
                        // Per-step interval scales with cycle length
                        var stepBase = Math.max(200, Math.floor((CYCLE_MS - GLYPH_LINGER_MS) / 8));
                        nextStepTs = now + stepBase + Math.floor(Math.random() * Math.max(1, Math.floor(stepBase / 2)));

                        glitchEndTs = 0;
                        tickAcc = 0; lastTickTs = now; secondToggle = false;
                        ensureStructure(fmtFiveFromSecs(currentSecs));
                        _bootAnimId = setInterval(tick, TICK);
                        // Disable any legacy cycle timer
                        if(_cycleTimerId) { clearInterval(_cycleTimerId); _cycleTimerId = null; }
                    }

                    // Stop the ticker and show glyphs for an optional linger (ms). If lingerMs omitted, use a short default.
                    function stop(lingerMs){
                        try{
                            if(_bootAnimId) clearInterval(_bootAnimId); _bootAnimId=null;
                            if(_cycleTimerId) clearInterval(_cycleTimerId); _cycleTimerId = null;
                            // Immediately switch to glyphs and mark inGlitch; do NOT reset here — reset will occur after overlay removal
                            var ms = (typeof lingerMs === 'number') ? Math.max(200, lingerMs) : GLYPH_LINGER_MS;
                            toGlyphs(true, ms);
                        }catch(e){}
                    }
                    startBootAnim = start; stopBootAnim = stop;
                })();
                var phrases = [
    "[BOOT] Don’t tell me what I can’t do… initializing.",
    "[FETCH] We have to go back… requesting previous state.",
    "[HANDSHAKE] See you in another life, brother… establishing session.",
    "[TASK] Everything happens for a reason… scheduling job.",
    "[CRON/108] Push the button… next run in 108 minutes.",
    "[VALIDATE] The numbers are bad… checksum failing: 4 8 15 16 23 42.",
    "[ROUTE] Destiny calls… recalculating path.",
    "[FAILSAFE] System failure imminent… engage protocol.",
    "[ORIENT] Orientation video loading… buffering truths.",
    "[PROTOCOL] Initiative guidelines applied… compliance passing.",
    "[I/O] The Hatch is opening… streaming secrets.",
    "[TIMER] 108 minutes remain… watchdog armed.",
    "[INPUT] Enter the code… awaiting six integers.",
    "[REBOOT] Station reboot complete… services restored.",
    "[VARIANTS] What if we’re the variables… enabling A/B routes.",
    "[IMMUTABLE] There is no reset… write-once mode set.",
    "[MERGE] Everything that rises must converge… resolving branches.",
    "[LOCK] The past can’t be changed… git history protected.",
    "[BOUND] You can’t escape the Island… sandbox enforced.",
    "[GUARD] The light must be protected… rate limiter engaged.",
    "[CHOICE] Fate vs. free will… prompting user decision.",
    "[POLICY] You’re not supposed to leave… egress blocked by rule.",
    "[SECRET] What lies in the shadow of the statue… decrypting payload.",
    "[RETRO] You all, everybody… broadcasting to subscribers.",
    "[WATCH] Monsters are real… anomaly detector online.",
    "[SEED] I made my own luck… seeding RNG.",
    "[CACHE] I remember… warm cache restored.",
    "[TIME] Time’s not a straight line… enabling jitter buffer.",
    "[INTENT] We were brought here for a reason… classifier confident.",
    "[HOME] There is no place like home… redirecting to root.",
    "[RELEASE] You can let go now… freeing resources.",
    "[INBOUND] They’re coming… opening inbound ports.",
    "[CYCLE] The end is the beginning… restarting event loop.",
    "[PING] 815 responding… round-trip stable.",
    "[TRIGGER] Button 42 pressed… executing failsafe.",
    "[MAP] Reconstructing flight path 815… plotting vectors.",
    "[CAST] Oceanic check-in… session tokens refreshed.",
    "[GUARDIAN] Smoke on the stack… firewall tightening.",
    "[LAMBDA] The Moth emerges… escalating privileges.",
    "[SYNC] See you in another timeline… state sync complete."
                ];
                overlay = overlay || document.getElementById('bootOverlay');
                if(!overlay) return;
                var phraseEl = document.getElementById('bootPhrase');
                var subEl = overlay.querySelector('.boot-sub');
                // Fit ASCII title to boot card width by scaling
                function fitBootAscii(){
                    try{
                        var pre = document.getElementById('bootAscii'); if(!pre) return;
                        var container = pre.parentElement; if(!container) return;
                        // prepare for measurement
                        var priorDisplay = pre.style.display;
                        pre.style.display = 'inline-block';
                        pre.style.transform = 'none';
                        pre.style.transformOrigin = '50% 0%';
                        container.style.height = 'auto';
                        // Measure natural width (max-content) while unscaled
                        // leave horizontal slack to avoid rounding overflow and shadow bleed
                        var cw = (container.clientWidth || container.offsetWidth || 0) - 10;
                        var naturalRect = pre.getBoundingClientRect();
                        var naturalWidth = naturalRect.width || (pre.scrollWidth || 1);
                        var scale = Math.min(1, cw / naturalWidth);
                        // Apply a stronger fudge factor to guarantee fit
                        scale = Math.max(0.1, Math.min(1, scale * 0.975));
                        pre.style.transform = 'scale(' + scale + ')';
                        var rect = pre.getBoundingClientRect();
                        // Reserve slightly more than measured to avoid clipping bottom row
                        container.style.height = Math.ceil(rect.height + 2) + 'px';
                        // Keep inline-block to preserve measured scrollWidth behavior
                        pre.style.display = 'inline-block';
                        // Safety pass: if rect width still exceeds container width, correct using rect-based ratio
                        var rw = pre.getBoundingClientRect().width;
                        var cw2 = (container.clientWidth || container.offsetWidth || 0) - 10;
                        if(rw > cw2){
                            var scale2 = Math.max(0.1, scale * (cw2 / rw) * 0.98);
                            pre.style.transform = 'scale(' + scale2 + ')';
                            var rect2 = pre.getBoundingClientRect();
                            container.style.height = Math.ceil(rect2.height + 2) + 'px';
                            scale = scale2; rect = rect2; // use final values
                        }
                        // Final centering: translateX so the scaled rect is centered inside container
                        var cRect = container.getBoundingClientRect();
                        var desiredLeft = (cRect.width - rect.width) / 2;
                        var currentLeft = rect.left - cRect.left;
                        var dx = desiredLeft - currentLeft;
                        pre.style.transform = 'translateX(' + dx.toFixed(2) + 'px) scale(' + scale + ')';
                    }catch(e){}
                }
                var i = 0, elapsed = 0;
                var total = 30000 + Math.random()*15000; // 30–45s

                function durationFor(text){
                    var len = (text||'').length;
                    // Base + per-char time; clamped to reasonable reading window
                    var ms = 1400 + len*55; // ~0.055s per char
                    if(ms < 2200) ms = 2200; // min 2.2s
                    if(ms > 7200) ms = 7200; // max 7.2s
                    return ms;
                }

                function showNext(){
                    if(!overlay) return;
                    var text = phrases[i % phrases.length];
                    var seg = durationFor(text);
                    if(elapsed + seg > total){ seg = Math.max(1400, total - elapsed); }
                    if(seg <= 0){ endBoot(); return; }
                    phraseEl.classList.remove('show');
                    // fade out then swap
                    setTimeout(function(){ phraseEl.textContent = text; phraseEl.classList.add('show'); }, 180);
                    elapsed += seg;
                    i++;
                    setTimeout(function(){
                        if(elapsed >= total) { endBoot(); }
                        else { showNext(); }
                    }, seg);
                }

                function endBoot(){
                    if(!overlay) return;
                    subEl.textContent = 'Ready.';
                    try{
                        // Use a safe, globally exposed linger value so we don't ReferenceError on an inner-scope var
                        var __linger = (typeof window!== 'undefined' && typeof window.__bootGlyphLingerMs === 'number') ? window.__bootGlyphLingerMs : 2000;
                        // Show hieroglyphs for the configured linger window before starting the overlay fade
                        if(typeof stopBootAnim === 'function') stopBootAnim(__linger);
                    }catch(e){}
                    // Start hiding the overlay after the glyph linger completes so users see glyphs 1-2s before disappearance
                    var __linger2 = (typeof window!== 'undefined' && typeof window.__bootGlyphLingerMs === 'number') ? window.__bootGlyphLingerMs : 2000;
                    setTimeout(function(){
                        try{ overlay.classList.add('hidden'); }catch(e){}
                        // remove from DOM after the CSS hide transition (keep previous 650ms fallback)
                        setTimeout(function(){
                            try{ if(overlay && overlay.parentNode){ overlay.parentNode.removeChild(overlay); } }catch(e){}
                            overlay = null;
                            try{ document.documentElement.classList.remove('booting'); document.body.classList.remove('booting'); }catch(e){}
                            try{ if(typeof setStickyInert === 'function') setStickyInert(false); }catch(e){}
                            // After boot ends, ensure sticky notes layout is computed and reflowed
                            try{ if(typeof layoutAllSlots === 'function') { layoutAllSlots(); } }catch(e){}
                            // Reset the numeric display back to seed once overlay is fully removed
                            try{ resetToSeedRandom(); inGlitch = false; shownFinalGlyph = false; }catch(e){}
                        }, 650);
                    }, __linger2);
                }

                // Start sequence after a brief tick so initial paint happens
                setTimeout(function(){
                    subEl.textContent = 'Loading modules…';
                    fitBootAscii();
                    try{ if(typeof startBootAnim === 'function') startBootAnim(); }catch(e){}
                    showNext();
                }, 120);
                // Keep API key dots updated: green when key present, red when missing
                function updateApiDots(){
                    try{
                        let key = null;
                        if(typeof getEffectiveGemKey === 'function'){
                            key = getEffectiveGemKey();
                        }
                        if(!key){ try{ key = localStorage.getItem('gemini.key'); }catch{} }
                        const randomDot = document.getElementById('randomKeyDot');
                        const dailyDot = document.getElementById('dailyKeyDot');
                        if(randomDot){ randomDot.classList.remove('missing','present'); randomDot.classList.add(key ? 'present' : 'missing'); }
                        if(dailyDot){ dailyDot.classList.remove('missing','present'); dailyDot.classList.add(key ? 'present' : 'missing'); }
                        // enable/disable gear button when key absent OR when API key is disabled via toggle
                        try{
                            const gear = document.getElementById('randomGearBtn');
                            const enabledToggle = document.getElementById('globalGemEnable');
                            const enabled = !!(enabledToggle && enabledToggle.checked);
                            const ok = !!key && enabled;
                            if(gear){
                                gear.disabled = !ok;
                                gear.setAttribute('aria-disabled', (!ok) ? 'true' : 'false');
                                gear.classList.toggle('disabled', !ok);
                                if(!ok){ gear.setAttribute('tabindex','-1'); } else { gear.removeAttribute('tabindex'); }
                            }
                        }catch(e){}
                    }catch(e){}
                }
                // update now and on storage events or input changes
                try{ updateApiDots(); window.addEventListener('storage', (e)=>{ if(e.key === 'gemini.key') updateApiDots(); }); const gk = document.getElementById('globalGemKey'); if(gk) gk.addEventListener('input', ()=>{ setTimeout(updateApiDots,10); }); const ge = document.getElementById('globalGemEnable'); if(ge) ge.addEventListener('change', ()=>{ setTimeout(updateApiDots,10); }); }catch(e){}
                // Re-fit after fonts are ready in case metrics shift
                try{ if(document.fonts && document.fonts.ready){ document.fonts.ready.then(function(){ fitBootAscii(); }); } }catch(e){}
                window.addEventListener('resize', function(){ if(!overlay) return; fitBootAscii(); });
            })();
        </script>


    <!-- Theme capsule: 6 tricolor orbs with numeric overlays controlling background and button colors -->
    <div class="theme-capsule" id="themeCapsule" aria-label="Theme colors">
       <div class="theme-orb orb-ocean" data-theme="ocean" title="Ocean"></div>
       <div class="theme-orb orb-sunset" data-theme="sunset" title="Sunset"></div>
        <div class="theme-orb orb-forest" data-theme="forest" title="Forest"></div>
       <div class="theme-orb orb-violet" data-theme="violet" title="Violet"></div>
       <div class="theme-orb orb-ember" data-theme="ember" title="Ember"></div>
    <div class="theme-orb orb-custom" data-theme="Custom" title="Custom (double-click to customize)"></div>
    </div>
    <div id="paletteEditor" class="palette-editor hidden" role="dialog" aria-label="Custom palette editor">
        <div class="pe-header" id="peHeader" tabindex="0">
            <span>Customize Interface</span>
            <div style="display:flex; gap:6px; align-items:center">
                <button id="peReset" class="btn small" title="Reset">Reset</button>
                <button id="peClose" class="btn small" aria-label="Close">×</button>
            </div>
        </div>
        <div class="pe-body">
            <div class="pe-row">
                <label for="peC1">C1<input id="peC1" type="color" /></label>
                <label for="peC2">C2<input id="peC2" type="color" /></label>
                <label for="peC3">C3<input id="peC3" type="color" /></label>
            </div>
            <div class="pe-preview" id="pePreview" aria-hidden="true"></div>
        </div>
    </div>
    <div class="mt-8 flex gap-8" id="bgToggles">
    <!-- Group the inverted display controls in a single horizontal row -->
    <div id="invertControlsRow" class="inline-controls-row">
        <!-- Light Mode toggle: inverts the UI while preserving palette colors for the theme orbs -->
        <button id="enableLightModeBtn" class="btn pill" title="Enable Inverted Display" aria-pressed="false">Enable Inverted Display</button>
        <!-- Invert Timer mini side-menu (sits to the right of the inverted display button) -->
        <div id="invertTimerMenu" class="news-side-menu" aria-hidden="false" style="display:inline-flex">
            <button id="invertTimerToggle" class="btn pill news-menu-toggle" aria-expanded="false" aria-controls="invertTimerMenuContent" title="Set auto-flip speed">⏱</button>
            <div id="invertTimerMenuContent" class="news-side-menu-content" role="menu" aria-hidden="true">
                <div class="news-side-pill minimalist" role="presentation">
                    <label for="invertTimerValue" class="visually-hidden">Interval value</label>
                    <input id="invertTimerValue" class="invert-input" type="number" min="0" step="1" value="10" aria-label="Interval value" title="0 disables auto-flip" />
                    <label for="invertTimerUnit" class="visually-hidden">Interval unit</label>
                    <select id="invertTimerUnit" class="invert-select" aria-label="Interval unit">
                        <option value="s" selected>s</option>
                        <option value="ms">ms</option>
                    </select>
                    <button id="invertTimerApply" class="icon-btn" title="Set auto-flip" aria-label="Set auto-flip">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                            <path d="M20 6L9 17l-5-5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>
    <script>
    (function(){
        const KEY = '__custom_orb_greyscale_v1';
            function toHex(rgb){
            if(!rgb) return '#999999';
            rgb = rgb.trim();
            if(rgb[0] === '#') return rgb;
            const m = rgb.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
            if(m){ const r = parseInt(m[1]), g = parseInt(m[2]), b = parseInt(m[3]); return '#'+((1<<24)+(r<<16)|(g<<8)|b).toString(16).slice(1); }
            return rgb;
        }

        // mix two hex colors (linear RGB) by t in [0..1]
        function mixHex(a,b,t){
            try{
                if(!a||!b) return a||b||'#000000';
                const pa = a.replace('#',''); const pb = b.replace('#','');
                const na = pa.length===3 ? pa.split('').map(c=>c+c).join('') : pa;
                const nb = pb.length===3 ? pb.split('').map(c=>c+c).join('') : pb;
                const ar = parseInt(na.substring(0,2),16), ag = parseInt(na.substring(2,4),16), ab = parseInt(na.substring(4,6),16);
                const br = parseInt(nb.substring(0,2),16), bg = parseInt(nb.substring(2,4),16), bb = parseInt(nb.substring(4,6),16);
                const rr = Math.round(ar*(1-t)+br*t); const rg = Math.round(ag*(1-t)+bg*t); const rb = Math.round(ab*(1-t)+bb*t);
                const toHex2 = (n)=> (n<16? '0'+n.toString(16) : n.toString(16));
                return '#'+toHex2(rr)+toHex2(rg)+toHex2(rb);
            }catch(e){ return a; }
        }

        function makeSmoothGradient(c1,c2,c3){
            // produce many small blended stops across the strip to avoid banding/seams
            try{
                const steps = 18; // even number gives symmetric midpoint
                const stops = [];
                for(let i=0;i<=steps;i++){
                    const t = i / steps; // 0..1
                    let col;
                    if(t <= 0.5){ col = mixHex(c1, c2, t * 2); }
                    else { col = mixHex(c2, c3, (t - 0.5) * 2); }
                    const pct = (t * 100).toFixed(2).replace(/\.00$/,'') + '%';
                    stops.push(`${col} ${pct}`);
                }
                return `linear-gradient(90deg, ${stops.join(', ')})`;
            }catch(e){
                // fallback to simpler multi-stop
                const a1 = mixHex(c1,c2,0.25);
                const a2 = mixHex(c1,c2,0.55);
                const b1 = mixHex(c2,c3,0.45);
                const b2 = mixHex(c2,c3,0.75);
                return `linear-gradient(90deg, ${c1} 0%, ${a1} 20%, ${a2} 40%, ${c2} 50%, ${b1} 60%, ${b2} 80%, ${c3} 100%)`;
            }
        }

        function readStored(){ try{ const s = localStorage.getItem(KEY); return s ? JSON.parse(s) : null; }catch(e){ return null; } }
        function writeStored(obj){ try{ localStorage.setItem(KEY, JSON.stringify(obj)); }catch(e){} }

        function init(){
            // Prefer the explicit custom orb (orb-custom / data-theme="custom") so only it is bound
            // to the palette editor. Fall back to any greyscale-marked orb, and only as a last resort
            // pick the first orb to avoid accidental binding to Ocean.
            let orb = document.querySelector('.theme-orb.orb-custom') || document.querySelector('.theme-orb[data-theme="custom"]');
            if(!orb) orb = document.querySelector('.theme-orb.orb-greyscale') || document.querySelector('.theme-orb[data-theme="greyscale"]');
            if(!orb) orb = document.querySelector('.theme-orb');
            const editor = document.getElementById('paletteEditor');
            if(!orb || !editor) return;
            const header = document.getElementById('peHeader');
            const c1 = document.getElementById('peC1');
            const c2 = document.getElementById('peC2');
            const c3 = document.getElementById('peC3');
            const preview = document.getElementById('pePreview');
            const closeBtn = document.getElementById('peClose');
            const resetBtn = document.getElementById('peReset');

            // defaults
            const defaults = { c1: '#d4d4d4', c2: '#9ca3af', c3: '#4b5563' };

            // If a stored custom palette exists, always paint the custom orb itself so
            // it visually reflects the saved palette on every reload. However, only
            // apply the palette to the global UI variables (brand/glow/button colors)
            // when the user's persisted theme selection is actually 'custom'/'greyscale'.
            const stored = readStored();
            try{
                if(stored && stored.colors){
                    // Always set the orb's inline color vars so the orb preview stays persistent
                    try{
                        orb.style.setProperty('--c1', stored.colors.c1);
                        orb.style.setProperty('--c2', stored.colors.c2);
                        orb.style.setProperty('--c3', stored.colors.c3);
                    }catch(e){}
                    // Only promote to document-level UI variables when the user selected custom
                    const savedTheme = (localStorage.getItem('__theme') || '').toString().toLowerCase();
                    const shouldApplyStored = (savedTheme === 'custom' || savedTheme === 'greyscale');
                    if(shouldApplyStored){
                        try{ document.documentElement.style.setProperty('--brand', stored.colors.c1); }catch(e){}
                        try{ document.documentElement.style.setProperty('--glow1', hexToRgbaLocal(stored.colors.c1, 0.20)); }catch(e){}
                        try{ document.documentElement.style.setProperty('--glow2', hexToRgbaLocal(stored.colors.c2, 0.14)); }catch(e){}
                        try{ document.documentElement.style.setProperty('--glow3', hexToRgbaLocal(stored.colors.c3, 0.16)); }catch(e){}
                        try{ document.documentElement.style.setProperty('--btnTop', hexToRgbaLocal(stored.colors.c1, 0.30)); }catch(e){}
                        try{ document.documentElement.style.setProperty('--btnBottom', hexToRgbaLocal(stored.colors.c2, 0.28)); }catch(e){}
                        // dye outlines and button borders to match custom palette
                        try{ document.documentElement.style.setProperty('--btnBorder', mixHex(stored.colors.c2, stored.colors.c3, 0.65)); }catch(e){}
                    }
                }
            }catch(e){}

            function loadInputsFromOrb(){ const cs = getComputedStyle(orb); c1.value = toHex(cs.getPropertyValue('--c1')||defaults.c1); c2.value = toHex(cs.getPropertyValue('--c2')||defaults.c2); c3.value = toHex(cs.getPropertyValue('--c3')||defaults.c3); preview.style.background = makeSmoothGradient(c1.value, c2.value, c3.value); }

            loadInputsFromOrb();

            function hexToRgba(h, a){ try{ if(!h) return `rgba(0,0,0,${a})`; h = h.replace('#',''); if(h.length===3) h = h.split('').map(ch=>ch+ch).join(''); const r = parseInt(h.substring(0,2),16); const g = parseInt(h.substring(2,4),16); const b = parseInt(h.substring(4,6),16); return `rgba(${r}, ${g}, ${b}, ${a})`; }catch(e){ return `rgba(0,0,0,${a})`; } }

            function applyColors(){ try{
                // update orb pigments
                orb.style.setProperty('--c1', c1.value);
                orb.style.setProperty('--c2', c2.value);
                orb.style.setProperty('--c3', c3.value);
                // update some commonly-used UI accent variables so the palette affects the wider interface
                try{ document.documentElement.style.setProperty('--brand', c1.value); }catch(e){}
                try{ document.documentElement.style.setProperty('--glow1', hexToRgba(c1.value, 0.20)); document.documentElement.style.setProperty('--glow2', hexToRgba(c2.value, 0.14)); document.documentElement.style.setProperty('--glow3', hexToRgba(c3.value, 0.16)); }catch(e){}
                // attempt to set button gradient endpoints (subtle tint)
                try{ document.documentElement.style.setProperty('--btnTop', hexToRgba(c1.value, 0.36)); document.documentElement.style.setProperty('--btnBottom', hexToRgba(c2.value, 0.28)); }catch(e){}
                // set a dyed border color derived from the darker palette stops so outlines follow the custom scheme
                try{ document.documentElement.style.setProperty('--btnBorder', mixHex(c2.value, c3.value, 0.65)); }catch(e){}
                preview.style.background = makeSmoothGradient(c1.value, c2.value, c3.value);
                writeStored({ colors: { c1: c1.value, c2: c2.value, c3: c3.value }, pos: getPos() });
            }catch(e){} }

            c1.addEventListener('input', applyColors); c2.addEventListener('input', applyColors); c3.addEventListener('input', applyColors);

            // open editor near orb
            function openEditor(){ try{
                editor.classList.remove('hidden'); editor.classList.add('pe-anim');
                // run on next frame to trigger transition
                requestAnimationFrame(()=> editor.classList.add('pe-show'));
                loadInputsFromOrb();
                // Position the editor: prefer any stored position, otherwise place it to the right of the orb.
                try{
                    const rect = orb.getBoundingClientRect();
                    const left = Math.min(window.innerWidth - editor.offsetWidth - 12, Math.max(8, Math.round(rect.right + 8)));
                    const top = Math.min(window.innerHeight - editor.offsetHeight - 12, Math.max(8, Math.round(rect.top)));
                    editor.style.left = left + 'px'; editor.style.top = top + 'px';
                    // restore stored pos if present (preserve original placement across sessions)
                    const st = readStored(); if(st && st.pos){ try{ if(typeof st.pos.left === 'number') editor.style.left = st.pos.left + 'px'; if(typeof st.pos.top === 'number') editor.style.top = st.pos.top + 'px'; }catch(e){} }
                }catch(e){}
            }catch(e){} }

            function closeEditor(){ try{
                // animate out, then hide
                editor.classList.add('pe-anim'); editor.classList.remove('pe-show');
                const onEnd = function(ev){ try{ if(ev && ev.target !== editor) return; editor.removeEventListener('transitionend', onEnd); editor.classList.add('hidden'); }catch(e){} };
                editor.addEventListener('transitionend', onEnd);
                // fallback timeout
                setTimeout(()=>{ try{ if(!editor.classList.contains('pe-show')) editor.classList.add('hidden'); }catch(e){} }, 240);
            }catch(e){} }

            // allow closing via global Escape key regardless of focus
            document.addEventListener('keydown', (ev)=>{ try{ if(ev.key === 'Escape' && editor && !editor.classList.contains('hidden')){ closeEditor(); } }catch(e){} });

            // Open the palette editor only on a double-click to avoid accidental popups
            orb.addEventListener('dblclick', (e)=>{ e.preventDefault(); openEditor(); });
            closeBtn.addEventListener('click', (e)=>{ e.preventDefault(); closeEditor(); });

            resetBtn.addEventListener('click', (e)=>{ e.preventDefault(); c1.value = defaults.c1; c2.value = defaults.c2; c3.value = defaults.c3; applyColors(); });

            // Dragging of the palette editor has been disabled — the editor is fixed in place.
            function getPos(){ try{ return { left: parseFloat(editor.style.left)||0, top: parseFloat(editor.style.top)||0 }; }catch(e){ return { left:0, top:0 }; } }

            // ensure accessible keyboard close
            header.addEventListener('keydown', (ev)=>{ if(ev.key==='Escape'){ closeEditor(); } });

            // on load, if stored pos exists and editor visible (hidden by default) do nothing

            // --- Custom in-DOM color picker (invertable) ---
            (function(){
                // Convert helpers
                function hexToRgb(h){ try{ h=h.replace('#',''); if(h.length===3) h=h.split('').map(ch=>ch+ch).join(''); const r=parseInt(h.substr(0,2),16), g=parseInt(h.substr(2,2),16), b=parseInt(h.substr(4,2),16); return {r,g,b}; }catch(e){ return {r:0,g:0,b:0}; } }
                function rgbToHex(r,g,b){ const to=(n)=>{ n=Math.max(0,Math.min(255,Math.round(n))); const s=n.toString(16); return s.length===1?'0'+s:s; }; return '#'+to(r)+to(g)+to(b); }
                function rgbToHsl(r,g,b){ r/=255; g/=255; b/=255; const max=Math.max(r,g,b), min=Math.min(r,g,b); let h,s,l=(max+min)/2; if(max===min){ h=s=0; } else { const d=max-min; s=l>0.5? d/(2-max-min) : d/(max+min); switch(max){ case r: h=(g-b)/d+(g<b?6:0); break; case g: h=(b-r)/d+2; break; case b: h=(r-g)/d+4; break; } h/=6; } return { h: Math.round(h*360), s: Math.round(s*100), l: Math.round(l*100) }; }
                function hslToRgb(h,s,l){ h/=360; s/=100; l/=100; const hue2rgb=(p,q,t)=>{ if(t<0) t+=1; if(t>1) t-=1; if(t<1/6) return p+(q-p)*6*t; if(t<1/2) return q; if(t<2/3) return p+(q-p)*(2/3 - t)*6; return p; }; let r,g,b; if(s===0){ r=g=b=l; } else { const q=l<0.5? l*(1+s) : l+s-l*s; const p=2*l-q; r=hue2rgb(p,q,h+1/3); g=hue2rgb(p,q,h); b=hue2rgb(p,q,h-1/3); } return { r: Math.round(r*255), g: Math.round(g*255), b: Math.round(b*255) }; }

                let panel = null; let target = null; let hInp=null, sInp=null, lInp=null, preview=null; let apply=null, cancel=null;
                function ensurePanel(){
                    if(panel) return panel;
                    panel = document.createElement('div'); panel.id='ccpPanel'; panel.setAttribute('role','dialog'); panel.setAttribute('aria-label','Color picker');
                    panel.innerHTML = `
                        <div class="row"><div class="lbl">H</div><input id="ccpH" type="range" min="0" max="360" value="0"></div>
                        <div class="row"><div class="lbl">S</div><input id="ccpS" type="range" min="0" max="100" value="100"></div>
                        <div class="row"><div class="lbl">L</div><input id="ccpL" type="range" min="0" max="100" value="50"></div>
                        <div class="row"><div class="preview" id="ccpPrev" style="flex:1"></div></div>
                        <div class="actions"><button class="btn" id="ccpCancel">Cancel</button><button class="btn" id="ccpApply">Apply</button></div>
                    `;
                    document.body.appendChild(panel);
                    hInp = panel.querySelector('#ccpH'); sInp = panel.querySelector('#ccpS'); lInp = panel.querySelector('#ccpL');
                    preview = panel.querySelector('#ccpPrev'); apply = panel.querySelector('#ccpApply'); cancel = panel.querySelector('#ccpCancel');
                    function update(){
                        const h = parseInt(hInp.value||'0',10), s = parseInt(sInp.value||'0',10), l = parseInt(lInp.value||'0',10);
                        const {r,g,b} = hslToRgb(h,s,l); const hex = rgbToHex(r,g,b);
                        preview.style.background = hex;
                        return hex;
                    }
                    ['input','change'].forEach(ev=>{ hInp.addEventListener(ev, update); sInp.addEventListener(ev, update); lInp.addEventListener(ev, update); });
                    apply.addEventListener('click', ()=>{ if(!target) return; const hex = update(); try{ target.value = hex; target.dispatchEvent(new Event('input',{bubbles:true})); }catch(e){} close(); });
                    cancel.addEventListener('click', ()=> close());
                    function onKey(ev){ if(ev.key==='Escape'){ ev.preventDefault(); close(); } }
                    panel.addEventListener('keydown', onKey);
                    panel.__update = update;
                    return panel;
                }
                function positionNear(el){ try{ const r = el.getBoundingClientRect(); const w = panel.offsetWidth||280; const h = panel.offsetHeight||170; let left = Math.min(window.innerWidth - w - 8, Math.max(8, Math.round(r.left))); let top = Math.min(window.innerHeight - h - 8, Math.max(8, Math.round(r.bottom + 6))); panel.style.left = left+'px'; panel.style.top = top+'px'; }catch(e){} }
                function openFor(input){ try{
                    target = input; ensurePanel();
                    const rgb = hexToRgb(String(input.value||'#ffffff')); const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
                    hInp.value = String(hsl.h); sInp.value = String(hsl.s); lInp.value = String(hsl.l);
                    panel.__update && panel.__update();
                    positionNear(input);
                    panel.style.display = 'block';
                    setTimeout(()=>{ try{ panel.focus(); }catch(e){} }, 0);
                    // Close on outside click
                    const onDoc = (ev)=>{ try{ if(panel && !panel.contains(ev.target)) close(); }catch(e){} };
                    document.addEventListener('mousedown', onDoc, { once:true });
                    panel.__onDoc = onDoc;
                }catch(e){}
                }
                function close(){ try{ if(panel){ panel.style.display='none'; if(panel.__onDoc){ document.removeEventListener('mousedown', panel.__onDoc); panel.__onDoc=null; } } target=null; }catch(e){} }

                function intercept(input){
                    if(!input) return;
                    // Prevent native picker by disabling during pointer down
                    input.addEventListener('mousedown', (ev)=>{ try{ ev.preventDefault(); ev.stopPropagation(); input.disabled = true; setTimeout(()=>{ input.disabled = false; }, 0); openFor(input); }catch(e){} });
                    // Also intercept keyboard activation
                    input.addEventListener('keydown', (ev)=>{ try{ if(ev.key==='Enter' || ev.key===' '){ ev.preventDefault(); openFor(input); } }catch(e){} });
                }

                intercept(c1); intercept(c2); intercept(c3);
            })();
        }

        if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init); else init();
    })();
    </script>
    <button id="asciiBgToggle" class="btn pill" title="Toggle animated ASCII background">Turn off animated background</button>
            <div class="news-inline">
                <div class="news-controls-vertical">
                    <div class="news-toggle-row">
                        <button id="newsToggle" class="btn pill" title="Enable or disable the top news bar">Disable news</button>
                        <!-- Collapsible side pill for news sources: toggle expands into a horizontal pill containing options -->
                        <div id="newsSideMenu" class="news-side-menu" aria-hidden="false">
                                <button id="newsMenuToggle" class="btn pill news-menu-toggle" aria-expanded="false" aria-controls="newsSideMenuContent" title="Show news options">+</button>
                                <div id="newsSideMenuContent" class="news-side-menu-content" role="menu" aria-hidden="true">
                                        <div class="news-side-pill" role="presentation">
                                                <button class="btn small news-source-opt" data-source="pubmed" id="newsSourcePubMed" role="menuitem">PubMed</button>
                                                <button class="btn small news-source-opt" data-source="arxiv" id="newsSourceArxiv" role="menuitem">arXiv</button>
                                        </div>
                                </div>
                        </div>
                    </div>
                    <div id="focusInlineContainer" class="focus-inline">
                        <button id="enableFocusBtn" class="btn pill" title="Enable focus mode">Enable focus mode</button>
                        <!-- Side menu for Always Enable Focus Mode (mirrors news side-menu behavior) -->
                        <div id="focusAlwaysMenu" class="news-side-menu" aria-hidden="false">
                            <button id="focusAlwaysMenuToggle" class="btn pill news-menu-toggle" aria-expanded="false" aria-controls="focusAlwaysMenuContent" title="Always enable focus options">+</button>
                            <div id="focusAlwaysMenuContent" class="news-side-menu-content" role="menu" aria-hidden="true">
                                <div class="news-side-pill" role="presentation">
                                    <button id="alwaysEnableFocusBtn" class="btn small" role="menuitem">Always Enable Focus Mode</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
    </div>
    <style id="newsSideMenuStyles">
    /* Side-extending pill menu (left edge) */
    /* place inline next to other controls (e.g. #newsToggle) so it aligns horizontally */
    .news-side-menu{ position:relative; left:auto; top:auto; transform:none; display:inline-flex; align-items:center; gap:var(--control-gap); pointer-events:auto }
     /* Make the small plus toggle visually match the nearby Disable news button (size + vertical alignment)
         This is intentionally narrow and only updates the toggle itself so overall layout is unchanged. */
    .news-menu-toggle{ border-radius:999px; border:1px solid rgba(255,255,255,0.06); background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); color:var(--ink); font-size:14px; display:inline-flex; align-items:center; justify-content:center; cursor:pointer; padding:10px 14px; line-height:1; align-self:center; margin:0; /* ensure breathing room from neighbors so outline doesn't overlap */ margin-left: var(--control-gap); margin-right: var(--control-gap); }
    .news-side-menu-content{ transform-origin:left center; transform:scaleX(0); transition:transform 220ms cubic-bezier(.2,.9,.2,1), opacity 180ms ease; opacity:0; display:flex; align-items:center; }
    .news-side-menu.expanded .news-side-menu-content{ transform:scaleX(1); opacity:1 }
    .news-side-pill{ display:flex; flex-direction:row; gap:var(--control-gap); align-items:center; padding:6px 10px; border-radius:999px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); box-shadow: 0 6px 18px rgba(0,0,0,0.35); }
    /* Blur and deepen shadow beneath side menus for better contrast */
    #invertTimerMenu .news-side-menu-content,
    #newsSideMenu .news-side-menu-content{ -webkit-backdrop-filter: blur(10px); backdrop-filter: blur(10px); }
    /* Minimalist capsule styling */
    #invertTimerMenu .news-side-pill.minimalist{ padding:6px 8px; gap:8px; border-radius:12px; background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02)); border:1px solid rgba(255,255,255,0.03); box-shadow: 0 8px 20px rgba(2,6,12,0.45); }
    /* Compact controls inside timer capsule (minimal aesthetics) */
    #invertTimerMenu .invert-input, #invertTimerMenu .invert-select{ height:30px; min-height:30px; padding:6px 8px; font-size:13px; border-radius:8px; background: transparent; color:var(--ink); border:1px solid rgba(255,255,255,0.06); backdrop-filter: blur(6px); }
    #invertTimerMenu .invert-input{ width:56px; text-align:center }
    #invertTimerMenu .invert-select{ width:54px }
    /* Icon-only apply button */
    .icon-btn{ display:inline-grid; place-items:center; width:34px; height:34px; padding:0; border-radius:10px; border:1px solid rgba(255,255,255,0.04); background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01)); color: var(--ink); cursor:pointer }
    .icon-btn svg{ color: var(--ink); opacity:.95 }
    /* Make the inner buttons capsule shaped (pills) and align horizontally */
    .news-side-pill .btn{ border-radius:999px; padding:8px 12px; white-space:nowrap; font-weight:700; box-shadow: inset 0 1px 0 rgba(255,255,255,0.02); background:transparent; }
    /* Make toggle visually change to minus when expanded via JS (no extra close button) */
    .news-menu-toggle:focus, .news-side-pill .btn:focus{ outline: 3px solid rgba(96,165,250,0.18); outline-offset:3px }
    @media (max-width:720px){ .news-side-menu{ left:6px } .news-side-pill{ padding:6px 8px } }
    /* Inline wrapper so the Disable news button and the + toggle sit side-by-side */
    .news-inline{ display:inline-flex; gap:var(--control-gap); align-items:center }
    /* Inline wrapper for the focus button + always-enable menu */
    .focus-inline{ display:inline-flex; gap:var(--control-gap); align-items:center }
    /* Stack Disable news and Enable focus controls vertically to keep focus button below the news toggle */
    .news-controls-vertical{ display:flex; flex-direction:column; gap:var(--control-gap); align-items:flex-start }
    /* Row that places the Disable news button and the small '+' toggle side-by-side */
    .news-toggle-row{ display:flex; gap:var(--control-gap); align-items:center }
    /* Keep the Inverted Display button and its timer toggle on the same line */
    .inline-controls-row{ display:inline-flex; gap:var(--control-gap); align-items:center; flex-wrap: nowrap }
    /* Normalize child margins so gap solely controls spacing */
    .news-inline > *,
    .focus-inline > *,
    .news-controls-vertical > *,
    .news-toggle-row > *,
    .inline-controls-row > *{ margin:0 !important }
    /* Ensure the global bg toggles row also uses compact spacing */
    #bgToggles{ gap: var(--control-gap) !important }
    /* Per-question TTS button: hide visually until card hover or keyboard focus */
    .qcard .tts-btn{
        opacity: 0;
        transform: translateY(-2px);
        transition: opacity .16s ease, transform .12s ease;
        /* Keep the button interactive for keyboard users even when visually hidden */
        pointer-events: auto;
        color: inherit;
    }
    .qcard:hover .tts-btn,
    .qcard:focus-within .tts-btn{
        opacity: 1;
        transform: translateY(0);
    }
    /* Always Enable Focus Mode ON state: green text + glowing outline */
    #alwaysEnableFocusBtn.always-on{ color: #16a34a; border: 1px solid rgba(22,163,74,0.28); box-shadow: 0 6px 20px rgba(22,163,74,0.18), 0 0 8px rgba(22,163,74,0.12); }
    </style>
    <script>
    (function(){
        const menu = document.getElementById('newsSideMenu');
        const toggle = document.getElementById('newsMenuToggle');
        const content = document.getElementById('newsSideMenuContent');
        if(!menu || !toggle || !content) return;
        function expand(){
            menu.classList.add('expanded');
            toggle.setAttribute('aria-expanded','true');
            content.setAttribute('aria-hidden','false');
            toggle.textContent = '−';
        }
        function collapse(){
            menu.classList.remove('expanded');
            toggle.setAttribute('aria-expanded','false');
            content.setAttribute('aria-hidden','true');
    (function(){
        // Invert Timer controller: repeatedly toggles the inverted display at a chosen interval
        const menu = document.getElementById('invertTimerMenu');
        const toggle = document.getElementById('invertTimerToggle');
        const content = document.getElementById('invertTimerMenuContent');
        if(!menu || !toggle || !content) return;

        let timerId = 0;
        const KEY = '__invertTimerMs';

        function expand(){ menu.classList.add('expanded'); toggle.setAttribute('aria-expanded','true'); content.setAttribute('aria-hidden','false'); }
        function collapse(){ menu.classList.remove('expanded'); toggle.setAttribute('aria-expanded','false'); content.setAttribute('aria-hidden','true'); }

        function setTimer(ms){
            try{ if(timerId){ clearInterval(timerId); timerId = 0; } }catch{}
            try{ localStorage.setItem(KEY, String(ms||0)); }catch{}
            // Visual feedback on the small toggle (title reflects current rate)
            try{ toggle.title = ms ? `Auto-flip every ${(ms/1000).toFixed(ms<1000?1:0)}s` : 'Set auto-flip speed'; }catch{}
            if(ms && ms > 0){
                timerId = setInterval(()=>{
                    try{
                        // Use the official button click to ensure overlay is created/removed correctly
                        const btn = document.getElementById('enableLightModeBtn');
                        if(btn){ btn.click(); }
                    }catch(e){}
                }, ms);
            }
            // Update the apply button icon/state so it toggles between Check (set) and X (disable)
            try{
                const ab = document.getElementById('invertTimerApply');
                if(ab){
                    if(ms && ms > 0){
                        ab.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
                        ab.title = 'Disable auto-flip';
                        ab.setAttribute('aria-label','Disable auto-flip');
                    } else {
                        ab.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M20 6L9 17l-5-5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
                        ab.title = 'Set auto-flip';
                        ab.setAttribute('aria-label','Set auto-flip');
                    }
                }
            }catch(e){}
        }

        // wire expand/collapse
        toggle.addEventListener('click', (e)=>{ e.preventDefault(); if(menu.classList.contains('expanded')) collapse(); else expand(); });

        // New compact input UI
        const valInput = document.getElementById('invertTimerValue');
        const unitSel = document.getElementById('invertTimerUnit');
        const applyBtn = document.getElementById('invertTimerApply');

        function applyFromInputs(){
            let n = parseFloat(valInput && valInput.value || '0');
            if(!isFinite(n) || n < 0) n = 0;
            const unit = (unitSel && unitSel.value) || 's';
            const ms = unit === 'ms' ? Math.round(n) : Math.round(n * 1000);
            setTimer(ms);
            collapse();
            try{ toggle.focus(); }catch{}
        }

        if(applyBtn) applyBtn.addEventListener('click', (e)=>{ e.preventDefault();
            try{
                // If a timer is currently set (persisted), treat this as the 'disable' action
                const cur = parseInt(localStorage.getItem(KEY)||'0',10) || 0;
                if(cur && cur > 0){
                    // turn off timer and reset input to zero
                    try{ if(valInput) valInput.value = '0'; if(unitSel) unitSel.value = 's'; }catch(_){}
                    try{ setTimer(0); }catch(_){}
                    try{ collapse(); toggle.focus(); }catch(_){}
                    return;
                }
            }catch(e){}
            applyFromInputs();
        });
        if(valInput) valInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); applyFromInputs(); } });
        if(unitSel) unitSel.addEventListener('change', ()=>{ /* no-op until Set is clicked */ });

        // init from saved preference and reflect into inputs
        try{
            const saved = parseInt(localStorage.getItem(KEY)||'0',10)||0;
            if(saved) setTimer(saved); else setTimer(0);
            // populate inputs from saved value
            if(valInput && unitSel){
                if(saved % 1000 === 0){ unitSel.value = 's'; valInput.value = String(saved/1000); }
                else { unitSel.value = 'ms'; valInput.value = String(saved); }
            }
        }catch{}
    })();
            toggle.textContent = '+';
        }
        toggle.addEventListener('click', ()=>{ menu.classList.contains('expanded') ? collapse() : expand(); });
        // Close on Escape when expanded
        document.addEventListener('keydown', (ev)=>{ if(ev.key === 'Escape' && menu.classList.contains('expanded')){ collapse(); toggle.focus(); } });
        // If a menu item is clicked, collapse after action
        document.querySelectorAll('#newsSideMenu .news-source-opt').forEach(b=> b.addEventListener('click', ()=>{ collapse(); toggle.focus(); }));
        // Initialize collapsed
        collapse();
    })();
    // Focus-always side menu wiring
    (function(){
        const menu = document.getElementById('focusAlwaysMenu');
        const toggle = document.getElementById('focusAlwaysMenuToggle');
        const content = document.getElementById('focusAlwaysMenuContent');
        const alwaysBtn = document.getElementById('alwaysEnableFocusBtn');
        if(!menu || !toggle || !content || !alwaysBtn) return;
        function expand(){ menu.classList.add('expanded'); toggle.setAttribute('aria-expanded','true'); toggle.textContent = '-'; content.setAttribute('aria-hidden','false'); }
        function collapse(){ menu.classList.remove('expanded'); toggle.setAttribute('aria-expanded','false'); toggle.textContent = '+'; content.setAttribute('aria-hidden','true'); }
        toggle.addEventListener('click', ()=>{ menu.classList.contains('expanded') ? collapse() : expand(); });
        document.addEventListener('keydown', (ev)=>{ if(ev.key === 'Escape' && menu.classList.contains('expanded')){ collapse(); toggle.focus(); } });
        // Toggle persistent preference
        const ALWAYS_KEY = '__ui_always_focus_v1';
        function setAlwaysState(on){
            try{
                if(on) alwaysBtn.classList.add('always-on'); else alwaysBtn.classList.remove('always-on');
                try{ localStorage.setItem(ALWAYS_KEY, on ? '1':'0'); }catch(e){}
                // Inform focus-mode controller in this tab and update a shared hint
                try{ window.__alwaysFocus = !!on; document.dispatchEvent(new CustomEvent('always-focus-changed', { detail:{ on: !!on } })); }catch(e){}
            }catch(e){}
        }
        try{ const s = localStorage.getItem(ALWAYS_KEY); setAlwaysState(s === '1'); }catch(e){}
        alwaysBtn.addEventListener('click', ()=>{ try{ const isOn = alwaysBtn.classList.contains('always-on'); const newState = !isOn; setAlwaysState(newState);
            // Immediately apply the runtime focus-mode change when the Always toggle is changed
            try{ if(typeof window.__setFocusMode === 'function'){ window.__setFocusMode(!!newState); } }catch(e){}
            // collapse menu and return focus to the toggle
            try{ if(menu.classList.contains('expanded')) collapse(); toggle.focus(); }catch(e){} }catch(e){} });
        // Collapse by default
        collapse();
    })();
    </script>

    <!-- Focus Mode: darken everything except quiz view -->
    <style id="focusModeStyles">
    /* Fullscreen dark overlay used for focus mode */
    #focusOverlay{ position:fixed; inset:0; z-index:99990; background:rgba(0,0,0,0.88); opacity:0; visibility:hidden; transition:opacity .32s ease, visibility .32s ease; pointer-events:none; }
    /* When active, show overlay and lift #quiz above it */
    body.focus-mode-active #focusOverlay{ opacity:1; visibility:visible }
    body.focus-mode-active #quiz{ position:relative; z-index:100000; pointer-events:auto }
    /* Make the enable button visually pressed when active */
    #enableFocusBtn[aria-pressed="true"]{ box-shadow: 0 6px 18px rgba(0,0,0,0.16); transform: translateY(-1px); }
    /* Ensure quiz-child panels maintain normal pointer events above overlay */
    body.focus-mode-active #quiz *{ pointer-events:auto }
    /* When hovering the Disable/Enable Focus button while in focus mode,
       lift the button above the overlay so it appears on the same plane
       as the quiz view (and remains clickable). This only activates on
       hover/focus to avoid exposing other controls unintentionally. */
    body.focus-mode-active #enableFocusBtn{
        transition: transform .12s ease, box-shadow .12s ease, z-index 0s;
    }
    body.focus-mode-active #enableFocusBtn:hover,
    body.focus-mode-active #enableFocusBtn:focus{
        position: relative;
        z-index: 100001; /* above #quiz (100000) */
        transform: translateY(-6px) scale(1.02);
        box-shadow: 0 18px 40px rgba(0,0,0,0.6);
        /* ensure it receives pointer events even if its container is inert */
        pointer-events: auto;
    }

    /* Ensure the small Always-toggle and its +/- menu toggle also render above the overlay
       when focus mode is active. Give the inline container a higher stacking context so
       its child buttons can appear above #quiz without needing to be moved to body. */
    body.focus-mode-active #focusInlineContainer{ position: relative; z-index: 100002; pointer-events: auto }
    body.focus-mode-active #focusInlineContainer .news-side-menu{ position: relative; z-index: 100003 }
    body.focus-mode-active #focusInlineContainer .news-menu-toggle,
    body.focus-mode-active #focusInlineContainer #alwaysEnableFocusBtn{ position: relative; z-index: 200004 }
    body.focus-mode-active #focusInlineContainer .news-menu-toggle:hover,
    body.focus-mode-active #focusInlineContainer #alwaysEnableFocusBtn:hover{ transform: translateY(-6px); box-shadow: 0 18px 40px rgba(0,0,0,0.6); }

    /* When mini-quiz is active, ensure the modal is above everything */
    body.mini-quiz-active #miniQuizModal{ z-index: 2147483000; }
    </style>

    <script>
    (function(){
        // Focus mode toggle: show a fullscreen dark overlay but keep #quiz visible above it
        const KEY = '__ui_focus_mode_v1';

        // Initialize focus-mode wiring in a safe, idempotent way.
        function initFocusMode(){
            let btn = document.getElementById('enableFocusBtn');
            // If the button isn't in the DOM yet, retry after DOMContentLoaded
            if(!btn){
                if(document.readyState === 'loading'){
                    document.addEventListener('DOMContentLoaded', initFocusMode, { once:true });
                }
                return;
            }

            function ensureOverlay(){
                let ov = document.getElementById('focusOverlay');
                if(!ov){ ov = document.createElement('div'); ov.id = 'focusOverlay'; document.body.appendChild(ov); }
                return ov;
            }

            function setState(on){
                try{
                    ensureOverlay();
                    if(on){ document.body.classList.add('focus-mode-active'); }
                    else { document.body.classList.remove('focus-mode-active'); }
                    btn.setAttribute('aria-pressed', on ? 'true' : 'false');
                    btn.textContent = on ? 'Disable focus mode' : 'Enable focus mode';
                    try{ localStorage.setItem(KEY, on ? '1' : '0'); }catch(e){}
                }catch(e){ console.warn('focus-mode toggle failed', e); }
            }

            // Expose a global setter so other modules can disable focus mode (useful when returning to setup)
            try{ window.__setFocusMode = function(on){ try{ setState(!!on); }catch(e){} }; }catch(e){}

            // Auto-disable focus mode whenever the main setup view becomes visible
            try{
                let setupEl = document.getElementById('setup');
                function disableOnSetupVisible(){
                    try{
                        const el = setupEl || document.getElementById('setup');
                        if(!el) return;
                        if(!el.classList.contains('hidden')){
                            try{ setState(false); }catch(e){}
                        }
                    }catch(e){}
                }
                // Observe class changes so we catch transitions into setup
                if(window.MutationObserver){
                    if(setupEl){
                        const mo2 = new MutationObserver(()=> disableOnSetupVisible());
                        mo2.observe(setupEl, { attributes:true, attributeFilter:['class'] });
                    } else {
                        // If setup not present yet, wait for it to be added then observe
                        const docMo = new MutationObserver((records, obs)=>{
                            setupEl = document.getElementById('setup');
                            if(setupEl){ const mo3 = new MutationObserver(()=> disableOnSetupVisible()); mo3.observe(setupEl, { attributes:true, attributeFilter:['class'] }); obs.disconnect(); disableOnSetupVisible(); }
                        });
                        docMo.observe(document.body, { childList:true, subtree:true });
                    }
                }
                // Run once now in case we're already on setup
                disableOnSetupVisible();
            }catch(e){}

            // Toggle handler
            btn.addEventListener('click', function(e){ e.preventDefault(); setState(!document.body.classList.contains('focus-mode-active')); });

            // Elevate on hover/focus: move the button to document.body while hovered so it can
            // escape ancestor stacking contexts and render above the focus overlay.
            (function(){
                let placeholder = null;
                function elevate(){
                    try{
                        if(!document.body.classList.contains('focus-mode-active')) return;
                        if(btn.dataset.elevated) return;
                        const r = btn.getBoundingClientRect();
                        // create a placeholder so layout doesn't jump
                        placeholder = document.createElement('div');
                        placeholder.className = 'focus-btn-placeholder';
                        placeholder.style.width = r.width + 'px';
                        placeholder.style.height = r.height + 'px';
                        placeholder.style.display = getComputedStyle(btn).display || 'inline-block';
                        btn.parentNode.insertBefore(placeholder, btn);
                        // move button to body and fix its position
                        document.body.appendChild(btn);
                        btn.style.position = 'fixed';
                        btn.style.left = Math.round(r.left) + 'px';
                        btn.style.top = Math.round(r.top) + 'px';
                        btn.style.zIndex = '100001';
                        btn.dataset.elevated = '1';
                    }catch(e){}
                }
                function restore(){
                    try{
                        if(!btn.dataset.elevated) return;
                        if(placeholder && placeholder.parentNode){ placeholder.parentNode.insertBefore(btn, placeholder); placeholder.parentNode.removeChild(placeholder); }
                        placeholder = null;
                        // reset styles
                        btn.style.position = '';
                        btn.style.left = '';
                        btn.style.top = '';
                        btn.style.zIndex = '';
                        delete btn.dataset.elevated;
                    }catch(e){}
                }
                btn.addEventListener('mouseenter', elevate);
                btn.addEventListener('focus', elevate);
                btn.addEventListener('mouseleave', restore);
                btn.addEventListener('blur', restore);
                // Keep button positioned over placeholder if window resizes while elevated
                window.addEventListener('resize', function(){ try{ if(btn.dataset.elevated && placeholder){ const r = placeholder.getBoundingClientRect(); btn.style.left = Math.round(r.left) + 'px'; btn.style.top = Math.round(r.top) + 'px'; } }catch(e){} });
                // Ensure we restore when focus-mode is turned off
                document.addEventListener('focus-mode-off', restore);
            })();

            // Initialize respecting the "Always Enable Focus" preference (do not force on from prior session unless Always is enabled)
            const ALWAYS_KEY = '__ui_always_focus_v1';
            let __alwaysFocus = false;
            function __loadAlways(){ try{ __alwaysFocus = localStorage.getItem(ALWAYS_KEY) === '1'; const ab = document.getElementById('alwaysEnableFocusBtn'); if(ab) ab.classList.toggle('always-on', __alwaysFocus); }catch(e){} }
            try{ __loadAlways(); window.addEventListener('storage', (ev)=>{ if(ev.key === ALWAYS_KEY) __loadAlways(); }); }catch(e){}
            // Define a global suppression flag consumed by this controller; when true, focus mode will not auto-enable
            try{ if(typeof window.__suppressFocus === 'undefined') window.__suppressFocus = false; }catch(e){}
            // React to in-tab changes from the Always toggle controller
            try{ document.addEventListener('always-focus-changed', (ev)=>{ try{ __alwaysFocus = !!(ev && ev.detail && ev.detail.on); window.__alwaysFocus = __alwaysFocus; updateBtnVisibility(); }catch(e){} }); }catch(e){}
            // On load: if Always is ON and not suppressed, enable focus; otherwise ensure it's OFF so users aren't forced into it
            try{ window.__alwaysFocus = __alwaysFocus; if(__alwaysFocus && !window.__suppressFocus){ setState(true); } else { setState(false); } }catch(e){}

            // Visibility: show the enableFocusBtn only when #quiz is visible (not .hidden)
            let quizEl = document.getElementById('quiz');
            function updateBtnVisibility(){
                try{
                    // Re-resolve the elements in case they were re-created
                    if(!quizEl) quizEl = document.getElementById('quiz');
                    if(!quizEl) { btn.style.display = 'none'; return; }
                    const hidden = quizEl.classList.contains('hidden');
                    const disp = hidden ? 'none' : 'inline-flex';
                    btn.style.display = disp;
                    // keep the Always-focus container in sync with the button visibility
                    try{ const fic = document.getElementById('focusInlineContainer'); if(fic) fic.style.display = disp; }catch(e){}
                    // If a quiz becomes visible and Always-enable is on, turn on focus mode unless suppressed
                    try{ if(!hidden && typeof __alwaysFocus !== 'undefined' && __alwaysFocus && !window.__suppressFocus){ setState(true); } }catch(e){}
                }catch(e){ }
            }

            // Observe class changes on #quiz so the button appears/disappears automatically
            if(window.MutationObserver){
                const mo = new MutationObserver((changes)=>{ updateBtnVisibility(); });
                // If quizEl not present yet, watch the document for added nodes and then observe quiz
                if(!quizEl){
                    const docMo = new MutationObserver(()=>{
                        quizEl = document.getElementById('quiz');
                        if(quizEl){ mo.observe(quizEl, { attributes:true, attributeFilter:['class'] }); docMo.disconnect(); updateBtnVisibility(); }
                    });
                    docMo.observe(document.body, { childList:true, subtree:true });
                } else {
                    mo.observe(quizEl, { attributes:true, attributeFilter:['class'] });
                }
            }
            // Run once on init
            updateBtnVisibility();
        }

        // Kick off initialization (idempotent)
        try{ initFocusMode(); }catch(e){ setTimeout(initFocusMode, 60); }
    })();
    </script>

    <!-- Light Mode CSS + Toggle Script (inline per user request) -->
    <style id="lightModeStyles">
    /* Overlay-based light-mode inversion using opacity transitions to avoid layout effects.
       The overlay uses mix-blend-mode:difference with a white fill which visually inverts
       underlying pixels while leaving layout/positioning unchanged. Opacity is animated
       so toggling fades the inversion in/out.
    */
    #lightModeOverlay{
        position:fixed; inset:0; z-index:2147483646; pointer-events:none; background:#fff; mix-blend-mode:difference;
        opacity:0; visibility:hidden; transition: opacity .36s ease, visibility .36s ease; will-change: opacity;
    }

    /* Visible state: overlay fades in via opacity. No display toggling to preserve transition. */
    body.light-mode-active #lightModeOverlay{ opacity:1; visibility:visible }

    /* Lift palette orbs above the overlay so their original hues remain unchanged. Labels are inverted separately. */
    body.light-mode-active .theme-orb{ position: relative; z-index:2147483647; }
    body.light-mode-active .theme-orb::before,
    body.light-mode-active .theme-orb::after{ z-index:2147483647; }

    /* Invert orb label text so it contrasts the preserved orb background */
    body.light-mode-active .theme-orb .orb-label{ filter: invert(1); }

    /* Provide a helper class for any element that must keep exact palette colors (place above the overlay). */
    body.light-mode-active .preserve-palette{ position:relative; z-index:2147483647; }

    /* Keep small AI/API indicator dots visually normal (double-invert) when light-mode overlay is active. */
    body.light-mode-active .api-key-dot,
    body.light-mode-active .key-dot,
    body.light-mode-active #aiExplanationKeyDot,
    body.light-mode-active .key-badge .dot,
    body.light-mode-active #dailyKeyDot,
    body.light-mode-active #randomKeyDot,
    body.light-mode-active .rp-title .dot,
    body.light-mode-active .sticky-dot {
        -webkit-filter: invert(1) !important;
        filter: invert(1) !important;
    }

    /* Transition alt-color/filter changes so they fade in/out at the same rate as the overlay. */
    .theme-orb .orb-label,
    .preserve-palette,
    .api-key-dot,
    .key-dot,
    #aiExplanationKeyDot,
    .key-badge .dot,
    #dailyKeyDot,
    #randomKeyDot,
    .rp-title .dot,
    .sticky-dot {
        -webkit-transition: -webkit-filter .36s ease, filter .36s ease, color .36s ease, background-color .36s ease, opacity .36s ease;
        transition: -webkit-filter .36s ease, filter .36s ease, color .36s ease, background-color .36s ease, opacity .36s ease;
        will-change: filter, color, background-color, opacity;
    }

     /* Ensure Saved MCQs dropdown inherits inversion like the rest of the UI.
         No special filter overrides here; it's rendered below the overlay. */

    /* Small visual for toggled state */
    #enableLightModeBtn[aria-pressed="true"]{ box-shadow: 0 6px 18px rgba(0,0,0,0.16); transform: translateY(-1px); }
    /* Light-mode: let the palette editor, its gradient preview, and its color pickers invert with the UI. */
    </style>

    <script>
    (function(){
        const KEY = '__ui_light_mode';
        const btn = document.getElementById('enableLightModeBtn');
        if(!btn) return;

        // Ensure the overlay element exists (created on-demand)
        function ensureOverlay(){
            let ov = document.getElementById('lightModeOverlay');
            if(!ov){ ov = document.createElement('div'); ov.id = 'lightModeOverlay'; document.body.appendChild(ov); }
            return ov;
        }

        // Remove overlay after fade-out to keep DOM tidy. If toggled back on quickly, cancel removal.
        function removeOverlayAfterFade(ov){
            if(!ov) return;
            try{
                const onEnd = function(e){
                    if(e && e.target !== ov) return;
                    ov.removeEventListener('transitionend', onEnd);
                    // Only remove when fully transparent
                    const comp = getComputedStyle(ov);
                    if(comp && comp.opacity === '0'){
                        try{ ov.remove(); }catch(e){}
                    }
                };
                ov.addEventListener('transitionend', onEnd);
                // As a safety, also set a timeout to remove after transition length
                setTimeout(()=>{ try{ if(document.body.contains(ov) && getComputedStyle(ov).opacity === '0') ov.remove(); }catch(e){} }, 520);
            }catch(e){}
        }

        function setState(on){
            try{
                const ov = ensureOverlay();
                if(on){
                    // Cancel any pending removal by ensuring overlay is present, then trigger class change in next frame to allow transition
                    try{ ov.style.transition = ov.style.transition || ''; }catch(e){}
                    requestAnimationFrame(()=>{ document.body.classList.add('light-mode-active'); });
                } else {
                    // fade out
                    document.body.classList.remove('light-mode-active');
                    // remove overlay after fade completes
                    removeOverlayAfterFade(ov);
                }
                btn.setAttribute('aria-pressed', on ? 'true' : 'false');
                btn.textContent = on ? 'Disable Inverted Display' : 'Enable Inverted Display';
                try{ localStorage.setItem(KEY, on ? '1' : '0'); }catch(e){}
            }catch(e){ console.warn('light-mode toggle failed', e); }
        }

        btn.addEventListener('click', function(e){ e.preventDefault(); setState(!document.body.classList.contains('light-mode-active')); });

        // initialize from saved preference
        try{ const s = localStorage.getItem(KEY); if(s === '1') setState(true); }catch(e){}
    })();
    </script>
    <button id="dailyQuizBtn" class="btn pill" title="Generate a daily random quiz" data-label="Daily Random Quiz" aria-label="Daily Random Quiz"><span id="dailyKeyDot" class="api-key-dot missing" aria-hidden="true"></span></button>
        <span class="random-controls">
            <button id="randomQuizBtn" class="btn pill" title="Generate a random quiz now" data-label="Random Quiz" aria-label="Random Quiz"><span id="randomKeyDot" class="api-key-dot missing" aria-hidden="true"></span></button>
            <span class="gear-badge" id="randomGearWrap"><span class="gear-circle" aria-hidden="true"><button id="randomGearBtn" class="gear-btn" title="Random quiz settings" aria-label="Random quiz settings">⚙︎</button></span></span>
        </span>
    </div>

    <!-- Top News Bar (NPR) - full width at very top -->
    <div id="newsBar" class="news-bar" role="region" aria-label="Top news headlines">
        <div id="newsRow" class="news-row"></div>
    </div>
    <div id="contentRoot" class="container mt-6">
    
        <script>
        // Unified Top Safe Area manager + NPR headlines fetcher
        (function(){
            const FEED = 'https://feeds.npr.org/1001/rss.xml';
            // Multiple CORS-safe proxy strategies (try in order)
            const PROXIES = [
                (u)=> `https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`,
                (u)=> `https://cors.isomorphic-git.org/${u}`,
                (u)=> `https://r.jina.ai/https://${u.replace(/^https?:\/\//,'')}`,
                (u)=> `https://r.jina.ai/http://${u.replace(/^https?:\/\//,'')}`,
            ];
            const PREF_KEY = '__newsBarPref'; // 'on' | 'off'
            const CACHE_KEY = '__newsCacheV2';
            const MAX_AGE_MS = 24 * 60 * 60 * 1000; // 24h rolling window
            const REFRESH_MS = 60 * 60 * 1000; // hourly updates
            const newsBar = document.getElementById('newsBar');
            const newsRow = document.getElementById('newsRow');
            const toggleBtn = document.getElementById('newsToggle');
            // Fixed ticker speed (px per second)
            const FIXED_NEWS_TICKER_SPEED = 48; // change this number to adjust scroll speed
            let tickerRAF = 0, tickerX = 0, tickerSpeed = FIXED_NEWS_TICKER_SPEED;
            let trackA = null, trackB = null;
            let itemsState = [];

            // Top offset manager computes and sets --topSafeArea so all fixed UI moves in sync
            function computeTopSafeArea(){
                let h = 0;
                try{
                    if(newsBar && newsBar.style.display !== 'none'){
                        const r = newsBar.getBoundingClientRect();
                        h = Math.max(0, Math.ceil(r.height));
                    }
                }catch{}
                // Sync both variables so either stylesheet path honors the offset
                document.documentElement.style.setProperty('--topSafeArea', h + 'px');
                document.documentElement.style.setProperty('--newsOffset', h + 'px');
                // Update sticky scaling tied to the safe area
                computeStickyScale();
                return h;
            }

            // -- Daily Random Quiz: fetch a random Wikipedia topic once per 24h, then ask Gemini to create a 10-question, 4-choice quiz
            const DAILY_TOPIC_KEY = '__dailyTopic'; // stores {topic, fetchedAt}
            const DAILY_QUIZ_KEY = '__dailyQuiz'; // stores generated quiz JSON

            // accept optional AbortSignal as first parameter
            async function fetchRandomWikipediaTitle(signal){
                // Use Wikipedia REST random endpoint to get a random page title
                try{
                    // If caller provided a search query via global preference, use search API instead
                    try{ var savedCategory = localStorage.getItem('random.category'); }catch{};
                    if(savedCategory && savedCategory.length){
                        // Use opensearch to find matches, fall back to random when no results
                        const qs = encodeURIComponent(savedCategory);
                        const url = `https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch=${qs}&utf8=&format=json&origin=*`;
                        const r = await fetch(url, signal ? { signal } : undefined);
                        if(r && r.ok){ const d = await r.json(); if(d && d.query && Array.isArray(d.query.search) && d.query.search.length){ return d.query.search[0].title; } }
                        // fallback to random if search failed
                    }
                    const resp = await fetch('https://en.wikipedia.org/api/rest_v1/page/random/title', signal ? { signal } : undefined);
                    if(!resp.ok) throw new Error('random title fetch failed');
                    const data = await resp.json(); // {items: [{id, key, title}] } or {title: '...'} depending on API
                    // handle shape variations
                    if(data && data.title) return data.title;
                    if(Array.isArray(data) && data.length && data[0].title) return data[0].title;
                    if(data && data.items && data.items[0] && data.items[0].title) return data.items[0].title;
                    // fallback: use Special:Random redirect hack
                    const r = await fetch('https://en.wikipedia.org/wiki/Special:Random', signal ? { redirect: 'follow', signal } : { redirect: 'follow' });
                    const final = r.url; const parts = final.split('/'); return decodeURIComponent(parts[parts.length-1].replace(/_/g,' '));
                }catch(e){ console.warn('Random wiki title failed', e); throw e; }
            }

            function getDailyTopic(){
                try{
                    const raw = localStorage.getItem(DAILY_TOPIC_KEY);
                    if(!raw) return null;
                    const obj = JSON.parse(raw);
                    if(!obj || !obj.topic || !obj.fetchedAt) return null;
                    const age = Date.now() - obj.fetchedAt;
                    if(age > 24*60*60*1000) return null;
                    return obj.topic;
                }catch(e){ return null; }
            }

            function saveDailyTopic(topic){ try{ localStorage.setItem(DAILY_TOPIC_KEY, JSON.stringify({ topic, fetchedAt: Date.now() })); }catch(e){} }

            // accept optional AbortSignal as third parameter
            async function askGeminiForQuiz(topic, apiKey, signal){
                // returns { questions: [{q, choices:[a,b,c,d], answerIndex}] }
                if(!topic) throw new Error('No topic');
                // Check for SDK availability and API key
                try{
                    if(!window.GoogleGenerativeAI) {
                        try{ const mod = await import('https://esm.run/@google/generative-ai'); window.GoogleGenerativeAI = mod.GoogleGenerativeAI; }catch(e){ throw new Error('Gemini SDK load failed'); }
                    }
                    const AI = window.GoogleGenerativeAI;
                    const client = apiKey ? new AI(apiKey) : null;
                    if(!client) throw new Error('No Gemini API key provided');
                    const model = client.getGenerativeModel({ model: 'gemini-2.5-flash' });

                    const prompt = `Create a JSON array of 10 multiple-choice questions about the following Wikipedia topic: "${topic}". `+
                        `Each item should be an object with fields: "question" (string), "choices" (array of 4 strings), and "answerIndex" (0-3 index of correct choice). `+
                        `Avoid using the exact phrasing from Wikipedia; make the questions educational and reasonably challenging for someone with general knowledge. Return ONLY valid JSON.`;

                    // Use the SDK's generateContent API (newer SDKs use generateContent)
                    // If a signal is provided, race the SDK call with a promise that rejects on abort
                    const genPromise = model.generateContent({ contents: [{ role: 'user', parts: [{ text: prompt }] }] });
                    let resp;
                    if(signal && signal.aborted){ throw new DOMException('Aborted', 'AbortError'); }
                    if(signal){
                        resp = await Promise.race([
                            genPromise,
                            new Promise((_, rej) => { signal.addEventListener('abort', ()=> rej(new DOMException('Aborted', 'AbortError')), { once: true }); })
                        ]);
                    } else {
                        resp = await genPromise;
                    }

                    // Robust extraction of text from multiple possible response shapes
                    let text = '';
                    try{
                        if(resp && typeof resp === 'object'){
                            // Common: resp.response.text() helper
                            if(resp.response && typeof resp.response.text === 'function'){
                                text = String((await resp.response.text()) || '');
                            } else if(resp.output && Array.isArray(resp.output) && resp.output.length){
                                // Older shape: output -> [{ content: [{ text: '...' }] }]
                                const out0 = resp.output[0];
                                if(out0 && out0.content && Array.isArray(out0.content)){
                                    text = out0.content.map(c=> c?.text || (typeof c === 'string' ? c : '')).join('\n');
                                } else {
                                    text = JSON.stringify(resp.output);
                                }
                            } else if(resp.response && resp.response.outputs && Array.isArray(resp.response.outputs)){
                                // Newer REST-like shape
                                text = resp.response.outputs.map(o=> (o.content||[]).map(c=>c.text||'').join('')).join('\n');
                            } else {
                                text = JSON.stringify(resp);
                            }
                        } else {
                            text = String(resp || '');
                        }
                    }catch(e){ text = JSON.stringify(resp); }

                    // Find first JSON substring in the returned text
                    const m = String(text).match(/\{[\s\S]*\}|\[[\s\S]*\]/);
                    if(!m) throw new Error('No JSON in model output: ' + (String(text).slice(0,300)) );
                    const parsed = JSON.parse(m[0]);
                    if(!Array.isArray(parsed) || parsed.length < 1) throw new Error('Parsed quiz invalid');
                    return { questions: parsed };
                }catch(e){ console.error('Quiz generation failed', e); throw e; }
            }

            // --- New feed fetchers: data.gov and arXiv ---
            // normalize to [{title,link,pubDate}]
            async function fetchPubMed(){
                try{
                    const apiKey = (function(){ try{ return localStorage.getItem('ncbi.apiKey'); }catch(e){ return null; } })();
                    const reldays = 2;
                    const retmax = 50;
                    const esearchUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=pubmed&retmode=json&reldate=${reldays}&datetype=edat&retmax=${retmax}${apiKey?('&api_key='+encodeURIComponent(apiKey)):''}`;
                    const esearchText = await fetchTextFromAny(esearchUrl);
                    const esearch = JSON.parse(esearchText);
                    let idlist = (esearch && esearch.esearchresult && Array.isArray(esearch.esearchresult.idlist)) ? esearch.esearchresult.idlist : [];
                    if(!idlist.length){
                        const altUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=pubmed&retmode=json&sort=pub+date&retmax=${retmax}${apiKey?('&api_key='+encodeURIComponent(apiKey)):''}`;
                        try{ const t = await fetchTextFromAny(altUrl); const alt = JSON.parse(t); idlist = idlist.concat((alt.esearchresult && Array.isArray(alt.esearchresult.idlist) ? alt.esearchresult.idlist : [])); }catch(e){}
                    }
                    idlist = idlist.slice(0, retmax);
                    if(!idlist || !idlist.length) throw new Error('No recent PubMed IDs');

                    // Prefer efetch XML to get reliable ArticleTitle and dates
                    try{
                        const efetchUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=pubmed&id=${encodeURIComponent(idlist.join(','))}&retmode=xml${apiKey?('&api_key='+encodeURIComponent(apiKey)):''}`;
                        const efetchText = await fetchTextFromAny(efetchUrl);
                        const xdoc = new DOMParser().parseFromString(efetchText, 'text/xml');
                        const articles = Array.from(xdoc.getElementsByTagName('PubmedArticle')||[]);
                        const out = [];
                        for(const art of articles){
                            try{
                                const pmidEl = art.getElementsByTagName('PMID')[0];
                                const pmid = pmidEl ? (pmidEl.textContent||'').trim() : null;
                                const titleEl = art.getElementsByTagName('ArticleTitle')[0];
                                const title = titleEl ? (titleEl.textContent||'').trim() : (pmid ? `PubMed ${pmid}` : '(no title)');
                                // attempt to get a publication date
                                let pubDate = '';
                                const pubDateEl = art.getElementsByTagName('PubDate')[0] || art.getElementsByTagName('DateCreated')[0];
                                if(pubDateEl){ pubDate = (pubDateEl.textContent||'').trim(); }
                                // fallback: try Article/Journal/JournalIssue/PubDate
                                if(!pubDate){
                                    try{
                                        const jpd = art.getElementsByTagName('PubDate')[0]; if(jpd){ pubDate = (jpd.textContent||'').trim(); }
                                    }catch(e){}
                                }
                                const link = pmid ? `https://pubmed.ncbi.nlm.nih.gov/${pmid}/` : '#';
                                out.push({ title, link, pubDate: pubDate || new Date().toString() });
                            }catch(e){ /* ignore per-article parse errors */ }
                        }
                        if(out && out.length) { try{ localStorage.setItem(CACHE_KEY+'_pubmed', JSON.stringify({ t: Date.now(), items: out })); }catch{}; return out; }
                    }catch(e){ /* efetch failed, fall back to esummary JSON below */ }

                    // Fallback: use esummary JSON
                    try{
                        const esummaryUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?db=pubmed&id=${encodeURIComponent(idlist.join(','))}&retmode=json${apiKey?('&api_key='+encodeURIComponent(apiKey)):''}`;
                        const sumText = await fetchTextFromAny(esummaryUrl);
                        const sumObj = JSON.parse(sumText);
                        const uids = sumObj.result && sumObj.result.uids ? sumObj.result.uids : [];
                        const results = [];
                        for(const uid of uids){
                            const rec = sumObj.result && sumObj.result[uid] ? sumObj.result[uid] : null;
                            const title = rec ? (rec.title || rec.fulljournalname || rec.sorttitle || '') : '';
                            const pubdate = rec ? (rec.pubdate || rec.epubdate || '') : '';
                            const link = `https://pubmed.ncbi.nlm.nih.gov/${uid}/`;
                            results.push({ title: (String(title||'').trim()) || `PubMed ${uid}`, link, pubDate: pubdate || new Date().toString() });
                        }
                        try{ localStorage.setItem(CACHE_KEY+'_pubmed', JSON.stringify({ t: Date.now(), items: results })); }catch{}
                        return results;
                    }catch(e){ /* final fallback to cache */ }

                    try{ const raw = localStorage.getItem(CACHE_KEY+'_pubmed'); if(raw){ return JSON.parse(raw).items||[]; } }catch{}
                    return [];
                }catch(e){
                    try{ const raw = localStorage.getItem(CACHE_KEY+'_pubmed'); if(raw){ return JSON.parse(raw).items||[]; } }catch{}
                    return [];
                }
            }

            async function fetchArxiv(){
                try{
                    const API = 'https://export.arxiv.org/api/query?search_query=all&start=0&max_results=50&sortBy=submittedDate&sortOrder=descending';
                    let text = null;
                    // 1) try a direct fetch first (may succeed if CORS allowed)
                    try{
                        const r = await fetch(API, { mode: 'cors' });
                        if(r && r.ok){ text = await r.text(); }
                    }catch(e){ /* ignore direct fetch errors */ }
                    // 2) if direct failed or returned very little, use proxy attempts via fetchTextFromAny
                    if(!text || text.length < 50){
                        try{ text = await fetchTextFromAny(API); }catch(e){ /* ignore */ }
                    }
                    if(!text) throw new Error('arXiv fetch failed (no text)');

                    // Try robust XML parsing (namespace tolerant)
                    let items = [];
                    try{
                        const doc = new DOMParser().parseFromString(text, 'text/xml');
                        let entries = [];
                        try{ entries = Array.from(doc.getElementsByTagNameNS('*','entry') || []); }catch(e){}
                        if(!entries || !entries.length){ try{ entries = Array.from(doc.getElementsByTagName('entry') || []); }catch(e){ entries = []; } }
                        items = entries.map(e=>{
                            try{
                                // title
                                let title = '';
                                try{
                                    const tns = e.getElementsByTagNameNS('*','title');
                                    if(tns && tns.length) title = (tns[0].textContent||'').replace(/\s+/g,' ').trim();
                                    else { const t0 = e.getElementsByTagName('title')[0]; if(t0) title = (t0.textContent||'').replace(/\s+/g,' ').trim(); }
                                }catch(err){ title = ''; }

                                // link
                                let link = '';
                                try{
                                    const linkEls = Array.from(e.getElementsByTagNameNS('*','link') || e.getElementsByTagName('link') || []);
                                    for(const le of linkEls){
                                        const rel = (le.getAttribute && le.getAttribute('rel')) || '';
                                        const href = (le.getAttribute && le.getAttribute('href')) || '';
                                        if(href && (!rel || rel === 'alternate')){ link = href; break; }
                                    }
                                }catch(err){}
                                if(!link){ try{ const idEl = e.getElementsByTagNameNS('*','id')[0] || e.getElementsByTagName('id')[0]; if(idEl) link = (idEl.textContent||'').trim(); }catch(err){} }
                                if(link && link.indexOf('export.arxiv.org')>=0) link = link.replace(/^https?:\/\/export\.arxiv\.org/, 'https://arxiv.org');

                                // pubDate
                                let pubDate = '';
                                try{
                                    const ud = e.getElementsByTagNameNS('*','updated')[0] || e.getElementsByTagName('updated')[0];
                                    const pd = e.getElementsByTagNameNS('*','published')[0] || e.getElementsByTagName('published')[0];
                                    if(ud && ud.textContent) pubDate = (ud.textContent||'').trim();
                                    else if(pd && pd.textContent) pubDate = (pd.textContent||'').trim();
                                }catch(err){ pubDate = ''; }
                                if(!pubDate) pubDate = new Date().toString();
                                return { title: title || '(no title)', link: link || '#', pubDate };
                            }catch(e){ return null; }
                        }).filter(Boolean).slice(0,50);
                    }catch(e){ /* xml parse failed */ }

                    // Loose regex fallback if XML parsing produced nothing
                    if(!items || !items.length){
                        try{
                            const matches = Array.from((text.matchAll(/<entry[\s\S]*?<\/entry>/gmi) || []));
                            const loose = matches.map(m=>{
                                const block = m[0];
                                const t = ((block.match(/<title[^>]*>([\s\S]*?)<\/title>/i) || [,''])[1]||'').replace(/\s+/g,' ').trim();
                                const idm = (block.match(/<id[^>]*>([\s\S]*?)<\/id>/i) || [,''])[1] || '';
                                const linkm = (block.match(/<link[^>]*href=["']?([^"'\s>]+)["']?[^>]*>/i) || [,''])[1] || idm || '';
                                const pubm = (block.match(/<(updated|published)[^>]*>([\s\S]*?)<\/(?:updated|published)>/i) || [,'',''])[2] || new Date().toString();
                                let link = (linkm||'').trim(); if(link.indexOf('export.arxiv.org')>=0) link = link.replace(/^https?:\/\/export\.arxiv\.org/, 'https://arxiv.org');
                                if(/^\/abs\//.test(link)) link = 'https://arxiv.org' + link;
                                if(link && link.startsWith('http://arxiv.org')) link = link.replace('http://', 'https://');
                                return { title: t||'(no title)', link: link||'#', pubDate: pubm };
                            }).filter(Boolean).slice(0,50);
                            if(loose && loose.length) items = loose;
                        }catch(e){}
                    }

                    // Normalize pubDate: if an item is older than MAX_AGE_MS, set its pubDate to now so prune24h doesn't remove everything
                    try{
                        const now = Date.now();
                        if(Array.isArray(items)){
                            items = items.map(it=>{
                                try{
                                    const pd = Date.parse(it.pubDate||'');
                                    if(!isFinite(pd) || (now - pd) > (typeof MAX_AGE_MS === 'number' ? MAX_AGE_MS : 24*60*60*1000)){
                                        it.pubDate = new Date().toString();
                                    }
                                }catch(e){}
                                return it;
                            });
                        }
                    }catch(e){}

                    // If still empty, return cached items or a sample fallback so the ticker isn't blank
                    if(!items || !items.length){
                        try{ const raw = localStorage.getItem(CACHE_KEY+'_arxiv'); if(raw){ const j = JSON.parse(raw); if(Array.isArray(j.items) && j.items.length) return j.items; } }catch(e){}
                        return [{ title: 'arXiv headlines unavailable (network/CORS); check console', link:'#', pubDate: new Date().toString() }];
                    }

                    try{ console.debug('[arXiv] returning', (items && items.length) || 0, 'items'); localStorage.setItem(CACHE_KEY+'_arxiv', JSON.stringify({ t: Date.now(), items })); }catch(e){}
                    return items;
                }catch(e){
                    try{ const raw = localStorage.getItem(CACHE_KEY+'_arxiv'); if(raw){ return JSON.parse(raw).items||[]; } }catch{ }
                    return [{ title: 'arXiv fetch failed — using cached/sample fallback', link:'#', pubDate: new Date().toString() }];
                }
            }

            // Dispatcher to fetch by source key
            async function fetchNewsBySource(source){
                if(!source) source = 'pubmed';
                if(source === 'pubmed') return await fetchPubMed();
                if(source === 'arxiv') return await fetchArxiv();
                return [];
            }

            // Cancellation support: store the current generation controller so Close can abort
            window.__currentGenerationController = null;
            function cancelCurrentGeneration(){
                try{
                    const c = window.__currentGenerationController;
                    if(c && typeof c.abort === 'function'){
                        try{ c.abort(); }catch(e){}
                    }
                    // Clear reference so subsequent calls are fresh
                    window.__currentGenerationController = null;
                }catch(e){}
            }

            async function ensureDailyQuiz(){
                try{
                    // Return cached quiz if present and fresh
                    const rawQuiz = localStorage.getItem(DAILY_QUIZ_KEY);
                    if(rawQuiz){
                        const qObj = JSON.parse(rawQuiz);
                        if(qObj && qObj.generatedAt && (Date.now() - qObj.generatedAt) < 24*60*60*1000 && qObj.topic && qObj.questions) return qObj;
                    }
                    // Need to generate
                    let topic = getDailyTopic();
                    if(!topic){ topic = await fetchRandomWikipediaTitle(); saveDailyTopic(topic); }
                    // Resolve Gemini API key: prefer global input, respect enable/remember toggles, then fallback to stored key/prompt
                    function getEffectiveGemKey(){
                        try{
                            const input = document.getElementById('globalGemKey');
                            const enable = document.getElementById('globalGemEnable');
                            const remember = document.getElementById('globalGemRemember');
                            // If explicit "enable" checkbox exists and is unchecked, treat as disabled
                            if(enable && enable.checked === false) return null;
                            // Prefer the visible input value when present
                            if(input && String(input.value||'').trim()){
                                const v = String(input.value).trim();
                                // store if user opted to remember
                                try{ if(remember && remember.checked) localStorage.setItem('gemini.key', v); }catch(e){}
                                return v;
                            }
                            // Fallback to previously stored key
                            try{ const stored = localStorage.getItem('gemini.key'); if(stored) return stored; }catch(e){}
                            return null;
                        }catch(e){ return null; }
                    }

                    let gemKey = getEffectiveGemKey();
                    if(!gemKey){
                        try{ gemKey = prompt('Enter Gemini API key to generate the daily quiz (will be stored in your browser)'); if(gemKey) try{ localStorage.setItem('gemini.key', gemKey); }catch(e){} }catch(e){}
                    }
                    if(!gemKey) throw new Error('Gemini API key required');
                    // Create an AbortController for this generation and expose it (or reuse existing)
                    let controller = window.__currentGenerationController;
                    if(!controller){ controller = new AbortController(); window.__currentGenerationController = controller; }
                    const result = await askGeminiForQuiz(topic, gemKey, controller.signal);
                    const store = { topic, questions: result.questions, generatedAt: Date.now() };
                    try{ localStorage.setItem(DAILY_QUIZ_KEY, JSON.stringify(store)); }catch(e){}
                    return store;
                }catch(e){ console.warn('ensureDailyQuiz failed', e); throw e; }
            }

            // Render quiz into preview area (reuse existing preview card)
            async function showDailyQuiz(){
                const previewCard = document.getElementById('preview');
                const previewList = document.getElementById('previewList');
                const dailyBtn = document.getElementById('dailyQuizBtn');
                const modal = document.getElementById('dailyBuildModal');
                const statusEl = document.getElementById('dailyBuildStatus');
                const closeBtn = document.getElementById('dailyBuildClose');
                function log(...args){ try{ debugLog(...args); }catch(e){ console.log(...args); } }
                // helper to open/close modal
                function openModal(){ try{ modal.classList.remove('hidden'); document.documentElement.classList.add('modal-open'); }catch{} }
                function closeModal(){ try{ modal.classList.add('hidden'); document.documentElement.classList.remove('modal-open'); }catch{} }

                // disable button and show spinner/status
                try{
                    if(dailyBtn) { dailyBtn.disabled = true; }
                    openModal(); if(statusEl) statusEl.textContent = 'Initializing…';
                    // Record when modal was shown so we can enforce a minimum visible duration
                    let modalShownAt = Date.now();
                    const MIN_VISIBLE_MS = 10000; // keep modal visible at least this long (10s)
                    // Close button should be interactable immediately and cancels generation when clicked
                    try{ if(closeBtn){ closeBtn.disabled = false; closeBtn.addEventListener('click', ()=>{ statusEl && (statusEl.textContent = 'Canceled by user'); cancelCurrentGeneration(); try{ if(dailyBtn) dailyBtn.disabled = false; }catch{}; try{ modal.classList.add('hidden'); }catch{} }); } }catch(e){}
                    if(previewCard) previewCard.classList.remove('hidden');
                    if(previewList) previewList.innerHTML = '<div class="hint">Generating daily quiz…</div>';

                    log('Daily quiz: starting generation');
                    statusEl && (statusEl.textContent = 'Resolving topic and key…');
                    // Show the topic early in the modal: use cached topic if present, otherwise try a fast fetch
                    try{
                        const topicSpan = document.getElementById('dailyBuildTopic');
                        let earlyTopic = null;
                        try{ earlyTopic = getDailyTopic(); }catch{}
                        earlyTopic = normalizeTopic(earlyTopic);
                        if(topicSpan){
                            if(earlyTopic){
                                topicSpan.textContent = earlyTopic;
                                // ensure normal (non-inverted) colors for Daily
                                topicSpan.classList.remove('inverse');
                                // retrigger rainbow animation
                                topicSpan.classList.remove('rainbow'); void topicSpan.offsetWidth; topicSpan.classList.add('rainbow');
                                // Fit the title line to the modal width
                                try{ fitTitleToContainer(document.getElementById('dailyBuildTitle')); }catch(e){}
                            } else {
                                topicSpan.textContent = 'choosing...';
                                topicSpan.classList.remove('inverse');
                                topicSpan.classList.remove('rainbow'); void topicSpan.offsetWidth; topicSpan.classList.add('rainbow');
                                statusEl && (statusEl.textContent = 'Choosing a topic…');
                                try{
                                    // ensure a controller exists so this fetch can be aborted
                                    let ctr = window.__currentGenerationController;
                                    if(!ctr){ ctr = new AbortController(); window.__currentGenerationController = ctr; }
                                    const fetched = await fetchRandomWikipediaTitle(ctr.signal);
                                    if(fetched){
                                        const nf = normalizeTopic(fetched);
                                        topicSpan.textContent = nf;
                                        // ensure normal colors for Daily
                                        topicSpan.classList.remove('inverse');
                                        try{ saveDailyTopic(fetched); }catch{};
                                        statusEl && (statusEl.textContent = 'Topic resolved: ' + nf);
                                        try{ fitTitleToContainer(document.getElementById('dailyBuildTitle')); }catch(e){}
                                    }
                                }catch(e){ console.warn('Early topic fetch failed', e); }
                            }
                        }
                    }catch(e){ console.warn('Failed to set early topic', e); }

                    // Ensure quiz (this will fetch topic and call Gemini)
                    let quiz;
                    try{
                        quiz = await ensureDailyQuiz();
                    }catch(e){
                        if(e && e.name === 'AbortError'){
                            statusEl && (statusEl.textContent = 'Canceled');
                            try{ if(previewList) previewList.innerHTML = '<div class="hint">Generation canceled.</div>'; }catch{};
                            return;
                        }
                        throw e;
                    }
                    // Normalize stored topic for display and output
                    const finalTopic = normalizeTopic(quiz && quiz.topic ? quiz.topic : '');
                    // After obtaining the final quiz/topic, update title and ensure it fits
                    try{
                        const titleEl = document.getElementById('dailyBuildTitle');
                        const topicSlug = String(finalTopic||'').trim();
                        const wikiUrl = topicSlug ? ('https://en.wikipedia.org/wiki/' + encodeURIComponent(topicSlug.replace(/\s+/g,'_'))) : '';
                        if(titleEl){
                            if(wikiUrl){
                                titleEl.innerHTML = `Today's Random Quiz is about <a href="${wikiUrl}" target="_blank" rel="noopener noreferrer"><span id="dailyBuildTopic" class="rainbow">${escapeHtml(finalTopic)}</span></a>!`;
                            } else {
                                titleEl.innerHTML = `Today's Random Quiz is about <span id="dailyBuildTopic" class="rainbow">${escapeHtml(finalTopic)}</span>!`;
                            }
                        }
                        fitTitleToContainer(document.getElementById('dailyBuildTitle'));
                    }catch(e){}
                    log('Daily quiz: generation complete, formatting output');
                    statusEl && (statusEl.textContent = 'Formatting questions…');

                    const arr = quiz.questions || [];
                    // Build formatted question text for the paste area: Qn., options as - , and ANSWER KEY
                    let text = '';
                    text += `Daily Quiz: ${finalTopic}\n\n`;
                    const count = Math.min(arr.length, 10);
                    for(let i=0;i<count;i++){
                        const it = arr[i] || {};
                        const qnum = i+1;
                        const qText = (it.question || '').replace(/\n+/g,' ');
                        text += `Q${qnum}. ${qText}\n`;
                        (it.choices||[]).forEach((c)=>{ text += `- ${String(c||'').replace(/\n+/g,' ')}\n`; });
                        text += '\n';
                    }
                    // Answer key
                    text += 'ANSWER KEY\n';
                    for(let i=0;i<count;i++){
                        const it = arr[i] || {};
                        const ansIdx = typeof it.answerIndex === 'number' ? it.answerIndex : (it.answerIndex==null && it.answer ? (Array.isArray(it.choices)? it.choices.indexOf(it.answer) : 0) : 0);
                        const letter = String.fromCharCode(65 + (ansIdx||0));
                        text += `${i+1}. ${letter}\n`;
                    }

                    // Write to the Generate MCQ debug output as well
                    log('Daily quiz: injecting formatted questions into paste area');
                    const paste = document.getElementById('paste');
                    if(paste){ paste.value = text; }

                    // Also render a preview in the preview panel as before
                    try{
                        const finalTopicSlug2 = String(finalTopic||'').trim();
                        const finalWiki = finalTopicSlug2 ? ('https://en.wikipedia.org/wiki/' + encodeURIComponent(finalTopicSlug2.replace(/\s+/g,'_'))) : '';
                        let html = `<h2 class="mb-6 mt-0">Daily Quiz: ${ finalWiki ? ('<a href="' + finalWiki + '" target="_blank" rel="noopener noreferrer">' + escapeHtml(finalTopic) + '</a>') : escapeHtml(finalTopic) }</h2>`;
                        html += '<ol>';
                        for(let i=0;i<count;i++){
                            const it = arr[i];
                            html += `<li class="qcard"><div class="hint">${escapeHtml(it.question||'')}</div><ul>`;
                            (it.choices||[]).forEach((c,ci)=>{ html += `<li class="choice">${String.fromCharCode(65+ci)}. ${escapeHtml(c)}</li>`; });
                            html += '</ul></li>';
                        }
                        html += '</ol>';
                        if(previewList) previewList.innerHTML = html;
                        // Render LaTeX/math only for the math segments inside the preview.
                        // Uses the lightweight KaTeX loader wrapper defined in the page (with heuristics).
                        try{ if(window.renderMathIn && previewList){ window.renderMathIn(previewList); } }catch(e){ console.warn('renderMathIn preview (daily) failed', e); }
                        document.getElementById('previewCount').textContent = String(arr.length||0);
                    }catch(e){ log('Daily quiz: preview render failed', e); }

                    // Trigger Parse & Preview automatically if available
                    try{ const parseBtn = document.getElementById('parseBtn'); if(parseBtn){ parseBtn.click(); log('Daily quiz: triggered Parse & Preview'); } }
                    catch(e){ log('Daily quiz: failed to trigger parse', e); }

                    statusEl && (statusEl.textContent = 'Done');
                    // Close the modal after the minimum visible duration has passed
                    try{
                        const elapsed = Date.now() - (modalShownAt || 0);
                        const remaining = Math.max(0, (MIN_VISIBLE_MS || 10000) - elapsed);
                        setTimeout(()=>{ try{ closeModal(); }catch{} }, remaining);
                    }catch(e){ try{ closeModal(); }catch{} }
                }catch(e){
                    try{ debugLog('Daily quiz failed:', e && e.message ? e.message : e); }catch{};
                    if(previewList) previewList.innerHTML = `<div class="hint">Failed to generate quiz: ${String(e.message||e)}</div>`;
                    const errMsg = (e && e.message) ? e.message : String(e);
                    statusEl && (statusEl.textContent = 'Failed: ' + errMsg);
                    // Keep modal open for user to read error; enable close
                }finally{
                    try{ if(dailyBtn) dailyBtn.disabled = false; }catch{}
                }

                // Close button should always allow closing
                try{ document.getElementById('dailyBuildClose')?.addEventListener('click', ()=>{ document.getElementById('dailyBuildModal')?.classList.add('hidden'); cancelCurrentGeneration(); }); }catch(e){}
            }

            // showRandomQuiz: same UI/flow as showDailyQuiz but always forces a fresh random topic and generation
            async function showRandomQuiz(){
                const previewCard = document.getElementById('preview');
                const previewList = document.getElementById('previewList');
                const randomBtn = document.getElementById('randomQuizBtn');
                const modal = document.getElementById('dailyBuildModal');
                const statusEl = document.getElementById('dailyBuildStatus');
                function log(...args){ try{ debugLog(...args); }catch(e){ console.log(...args); } }
                function openModal(){ try{ modal.classList.remove('hidden'); document.documentElement.classList.add('modal-open'); }catch{} }
                function closeModal(){ try{ modal.classList.add('hidden'); document.documentElement.classList.remove('modal-open'); }catch{} }

                try{
                    if(randomBtn) { randomBtn.disabled = true; }
                    openModal(); if(statusEl) statusEl.textContent = 'Initializing…';
                    // Record when modal was shown so we can enforce a minimum visible duration
                    let modalShownAt = Date.now();
                    const MIN_VISIBLE_MS = 10000; // keep modal visible at least this long (10s)
                    // Close button should be interactable immediately and cancels generation when clicked
                    try{ const closeBtn = document.getElementById('dailyBuildClose'); if(closeBtn){ closeBtn.disabled = false; closeBtn.addEventListener('click', ()=>{ statusEl && (statusEl.textContent = 'Canceled by user'); cancelCurrentGeneration(); try{ if(randomBtn) randomBtn.disabled = false; }catch{}; try{ modal.classList.add('hidden'); }catch{} }); } }catch(e){}
                    if(previewCard) previewCard.classList.remove('hidden');
                    if(previewList) previewList.innerHTML = '<div class="hint">Generating random quiz…</div>';

                    log('Random quiz: selecting topic');
                    statusEl && (statusEl.textContent = 'Choosing a topic…');
                    // Always fetch a fresh topic and normalize it for display
                    let topic = 'choosing...';
                    try{ 
                        // allow aborting the topic fetch
                        let ctr = window.__currentGenerationController;
                        if(!ctr){ ctr = new AbortController(); window.__currentGenerationController = ctr; }
                        topic = await fetchRandomWikipediaTitle(ctr.signal);
                    }catch(e){ console.warn('Random topic fetch failed', e); topic = 'random topic'; }
                    const normTopic = normalizeTopic(topic);
                    const topicSpan = document.getElementById('dailyBuildTopic');
                    if(topicSpan){
                        topicSpan.textContent = normTopic;
                        // use inverted colors for Random Quiz
                        topicSpan.classList.add('inverse');
                        topicSpan.classList.remove('rainbow'); void topicSpan.offsetWidth; topicSpan.classList.add('rainbow');
                        try{
                            const titleEl = document.getElementById('dailyBuildTitle');
                            const slug = String(normTopic||'').trim();
                            const wiki = slug ? ('https://en.wikipedia.org/wiki/' + encodeURIComponent(slug.replace(/\s+/g,'_'))) : '';
                            if(titleEl){
                                if(wiki){
                                    titleEl.innerHTML = `This random quiz is about <a href="${wiki}" target="_blank" rel="noopener noreferrer"><span id="dailyBuildTopic" class="rainbow inverse">${escapeHtml(normTopic)}</span></a>!`;
                                } else {
                                    titleEl.innerHTML = `This random quiz is about <span id="dailyBuildTopic" class="rainbow inverse">${escapeHtml(normTopic)}</span>!`;
                                }
                            }
                            fitTitleToContainer(document.getElementById('dailyBuildTitle'));
                        }catch(e){}
                    }

                    statusEl && (statusEl.textContent = 'Generating quiz…');
                    // Resolve Gemini API key via existing helper
                    let gemKey = (typeof getEffectiveGemKey === 'function') ? getEffectiveGemKey() : null;
                    if(!gemKey){ try{ gemKey = prompt('Enter Gemini API key to generate the random quiz (will be stored in your browser)'); if(gemKey) try{ localStorage.setItem('gemini.key', gemKey); }catch(e){} }catch(e){} }
                    if(!gemKey) throw new Error('Gemini API key required');

                    // Create or reuse controller for this run (ensureDailyQuiz uses the same global controller when applicable)
                    let localController = window.__currentGenerationController;
                    if(!localController){ localController = new AbortController(); window.__currentGenerationController = localController; }
                    let result;
                    try{
                        result = await askGeminiForQuiz(topic, gemKey, localController.signal);
                    }catch(e){
                        if(e && e.name === 'AbortError'){
                            statusEl && (statusEl.textContent = 'Canceled');
                            if(previewList) previewList.innerHTML = '<div class="hint">Generation canceled.</div>';
                            return;
                        }
                        throw e;
                    }
                    statusEl && (statusEl.textContent = 'Formatting questions…');

                    const arr = result.questions || [];
                    // Build formatted question text for the paste area: Qn., options as - , and ANSWER KEY
                    let text = '';
                    text += `Random Quiz: ${normTopic}\n\n`;
                    const count = Math.min(arr.length, 10);
                    for(let i=0;i<count;i++){
                        const it = arr[i] || {};
                        const qnum = i+1;
                        const qText = (it.question || '').replace(/\n+/g,' ');
                        text += `Q${qnum}. ${qText}\n`;
                        (it.choices||[]).forEach((c)=>{ text += `- ${String(c||'').replace(/\n+/g,' ')}\n`; });
                        text += '\n';
                    }
                    // Answer key
                    text += 'ANSWER KEY\n';
                    for(let i=0;i<count;i++){
                        const it = arr[i] || {};
                        const ansIdx = typeof it.answerIndex === 'number' ? it.answerIndex : (it.answerIndex==null && it.answer ? (Array.isArray(it.choices)? it.choices.indexOf(it.answer) : 0) : 0);
                        const letter = String.fromCharCode(65 + (ansIdx||0));
                        text += `${i+1}. ${letter}\n`;
                    }

                    log('Random quiz: injecting formatted questions into paste area');
                    const paste = document.getElementById('paste');
                    if(paste){ paste.value = text; }

                    // Also render a preview in the preview panel
                    try{
                        const normSlug = String(normTopic||'').trim();
                        const normWiki = normSlug ? ('https://en.wikipedia.org/wiki/' + encodeURIComponent(normSlug.replace(/\s+/g,'_'))) : '';
                        let html = `<h2 class="mb-6 mt-0">Random Quiz: ${ normWiki ? ('<a href="' + normWiki + '" target="_blank" rel="noopener noreferrer">' + escapeHtml(normTopic) + '</a>') : escapeHtml(normTopic) }</h2>`;
                        html += '<ol>';
                        for(let i=0;i<count;i++){
                            const it = arr[i];
                            html += `<li class="qcard"><div class="hint">${escapeHtml(it.question||'')}</div><ul>`;
                            (it.choices||[]).forEach((c,ci)=>{ html += `<li class="choice">${String.fromCharCode(65+ci)}. ${escapeHtml(c)}</li>`; });
                            html += '</ul></li>';
                        }
                        html += '</ol>';
                        if(previewList) previewList.innerHTML = html;
                        // Render LaTeX/math only for the math segments inside the preview.
                        try{ if(window.renderMathIn && previewList){ window.renderMathIn(previewList); } }catch(e){ console.warn('renderMathIn preview (random) failed', e); }
                        document.getElementById('previewCount').textContent = String(arr.length||0);
                    }catch(e){ log('Random quiz: preview render failed', e); }

                    // Trigger Parse & Preview automatically if available
                    try{ const parseBtn = document.getElementById('parseBtn'); if(parseBtn){ parseBtn.click(); log('Random quiz: triggered Parse & Preview'); } }
                    catch(e){ log('Random quiz: failed to trigger parse', e); }

                    statusEl && (statusEl.textContent = 'Done');
                    // Close the modal after the minimum visible duration has passed
                    try{
                        const elapsed = Date.now() - (modalShownAt || 0);
                        const remaining = Math.max(0, (MIN_VISIBLE_MS || 10000) - elapsed);
                        setTimeout(()=>{ try{ closeModal(); }catch{} }, remaining);
                    }catch(e){ try{ closeModal(); }catch{} }
                }catch(e){
                    try{ debugLog('Random quiz failed:', e && e.message ? e.message : e); }catch{};
                    if(previewList) previewList.innerHTML = `<div class="hint">Failed to generate quiz: ${String(e.message||e)}</div>`;
                    const errMsg = (e && e.message) ? e.message : String(e);
                    statusEl && (statusEl.textContent = 'Failed: ' + errMsg);
                    // Keep modal open for user to read error; enable close
                }finally{
                    try{ if(randomBtn) randomBtn.disabled = false; }catch{}
                }
            }

            // Utility: simple HTML escape
            function escapeHtml(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

            // Normalize topic strings: convert underscores to spaces and trim
            function normalizeTopic(t){ try{ return String(t||'').replace(/_/g,' ').trim(); }catch(e){ return String(t||''); } }

            // Classify a Wikipedia topic title into a coarse data type by querying categories.
            // Returns one of: person, place, event, science, media, organism, organization, concept, other
            async function classifyTopic(title){
                try{
                    const t = String(title||'').trim();
                    if(!t) return 'other';
                    // Query categories via Wikipedia API (CORS friendly with origin=*)
                    const url = 'https://en.wikipedia.org/w/api.php?action=query&titles=' + encodeURIComponent(t) + '&prop=categories&cllimit=50&format=json&origin=*';
                    const controller = new AbortController();
                    const to = setTimeout(()=>controller.abort(), 3500);
                    const res = await fetch(url, { signal: controller.signal });
                    clearTimeout(to);
                    if(!res.ok) throw new Error('HTTP '+res.status);
                    const data = await res.json();
                    const pages = data && data.query && data.query.pages ? data.query.pages : null;
                    const cats = [];
                    if(pages){
                        for(const k in pages){
                            const p = pages[k];
                            if(p && Array.isArray(p.categories)){
                                p.categories.forEach(c=>{ if(c && c.title) cats.push(c.title.replace(/^Category:/i,'')); });
                            }
                        }
                    }
                    const catStr = (cats||[]).join('||').toLowerCase();
                    // Heuristics based on category keywords
                    if(/births|living people|deaths|born|died/.test(catStr)) return 'person';
                    if(/cities|towns|villages|municipalities|places|countries|geography|populated places|settlements|islands|boroughs/.test(catStr)) return 'place';
                    if(/films|novels|books|albums|songs|television|media|film|episode|series|music|video games/.test(catStr)) return 'media';
                    if(/wars|battles|election|events|historic|history|anniversary/.test(catStr)) return 'event';
                    if(/species|flora|fauna|mammals|birds|reptiles|insects|plants|fungi|taxonomy|taxa/.test(catStr)) return 'organism';
                    if(/chemistry|chemical|compound|enzyme|protein|biochemistry|biology|physics|mathematics|science|geology|ecology|medicine/.test(catStr)) return 'science';
                    if(/companies|organizations|institutes|universities|colleges|schools|corporations|associations|organizations/.test(catStr)) return 'organization';
                    if(/concepts|philosophy|theory|concept|principles|terminology/.test(catStr)) return 'concept';
                    return 'other';
                }catch(e){
                    // Fallback: simple heuristics
                    try{
                        const s = String(title||'');
                        if(/\b(University|College|Institute|School|Hospital|Company|Corporation)\b/i.test(s)) return 'organization';
                        if(/\b(\d{4}|BC|AD)\b/.test(s)) return 'event';
                        if(/\b(Protein|Enzyme|Chemistry|Biology|Physics|Math|Mathematics|Molecular)\b/i.test(s)) return 'science';
                        if(/\b(\w+idae|\w+ales|species|genus)\b/i.test(s)) return 'organism';
                        if(s.split(' ').length === 1 && /^[A-Z][a-z]+$/.test(s)) return 'concept';
                    }catch(err){}
                    return 'other';
                }
            }

            // Apply classification result to an anchor element by adding a topic-type-... class and tooltip
            async function classifyAndApply(anchorEl, title){
                try{
                    if(!anchorEl) return;
                    anchorEl.classList.add('topic-link');
                    const t = String(title||anchorEl.textContent||'').trim();
                    const typ = await classifyTopic(t);
                    anchorEl.classList.add('topic-type-' + typ);
                    anchorEl.setAttribute('data-topic-type', typ);
                    anchorEl.setAttribute('title', (typ ? (typ.charAt(0).toUpperCase()+typ.slice(1)) : 'Topic') + ' — opens in Wikipedia');
                }catch(e){ /* ignore */ }
            }

            // Fit the title text to the modal width by scaling font-size responsively.
            // Attempts to keep the title on one line by shrinking font-size (down to minPx).
            // If it would become smaller than minPx, it falls back to allowing wrapping.
            function fitTitleToContainer(titleEl, opts){
                try{
                    if(!titleEl) return;
                    opts = opts || {};
                    const maxPx = typeof opts.maxPx === 'number' ? opts.maxPx : 48;
                    const minPx = typeof opts.minPx === 'number' ? opts.minPx : 14;
                    const innerSpan = titleEl.querySelector('.rainbow') || titleEl.querySelector('#dailyBuildTopic');
                    // Ensure we try to fit on a single line first
                    titleEl.style.whiteSpace = 'nowrap';

                    // Measure natural width at the max font size by creating a hidden clone
                    const clone = titleEl.cloneNode(true);
                    clone.style.position = 'absolute';
                    clone.style.left = '-9999px';
                    clone.style.top = '0';
                    clone.style.visibility = 'hidden';
                    clone.style.whiteSpace = 'nowrap';
                    clone.style.fontSize = maxPx + 'px';
                    // Ensure clone doesn't inherit layout constraints
                    clone.style.width = 'auto';
                    clone.style.maxWidth = 'none';
                    // Inner rainbow should show text for measurement
                    const topicSpan = clone.querySelector('.rainbow');
                    if(topicSpan) topicSpan.style.fontSize = 'inherit';
                    document.body.appendChild(clone);
                    const naturalW = clone.getBoundingClientRect().width || clone.offsetWidth || clone.scrollWidth || 0;
                    document.body.removeChild(clone);

                    const containerW = titleEl.clientWidth || (titleEl.getBoundingClientRect && titleEl.getBoundingClientRect().width) || 400;
                    if(!naturalW || naturalW <= containerW){
                        // Fits at maxPx
                        titleEl.style.fontSize = maxPx + 'px';
                        if(innerSpan) innerSpan.style.fontSize = 'inherit';
                        return;
                    }

                    // Compute desired font size that would make naturalW scale to containerW
                    let desired = Math.floor(maxPx * (containerW / naturalW));
                    if(desired < minPx){
                        // Too small — allow wrapping and use a readable min size
                        titleEl.style.whiteSpace = 'normal';
                        titleEl.style.fontSize = minPx + 'px';
                        if(innerSpan) innerSpan.style.fontSize = 'inherit';
                        return;
                    }

                    // Apply desired size and ensure it fits; if not, decrement until it does or minPx reached
                    titleEl.style.fontSize = desired + 'px';
                    if(innerSpan) innerSpan.style.fontSize = 'inherit';
                    for(let i=0;i<12;i++){
                        const sw = titleEl.scrollWidth || titleEl.getBoundingClientRect().width;
                        const cw = titleEl.clientWidth || titleEl.getBoundingClientRect().width;
                        if(sw <= cw) break;
                        desired = Math.max(minPx, desired - 1);
                        titleEl.style.fontSize = desired + 'px';
                        if(desired === minPx){ titleEl.style.whiteSpace = 'normal'; break; }
                    }
                }catch(e){ console.warn('fitTitleToContainer failed', e); }
            }

            // Wire the button
            document.getElementById('dailyQuizBtn')?.addEventListener('click', ()=>{ showDailyQuiz().catch(()=>{}); });
            document.getElementById('randomQuizBtn')?.addEventListener('click', ()=>{ showRandomQuiz().catch(()=>{}); });

            // Flashcards button removed: the Flashcards panel is now always visible below Preview.

            // Random category gear wiring
            (function(){
                const gear = document.getElementById('randomGearBtn');
                const gearWrap = document.getElementById('randomGearWrap');
                const modal = document.getElementById('randomCategoryModal');
                const close = document.getElementById('randomCategoryClose');
                const input = document.getElementById('categorySearch');
                const results = document.getElementById('categorySearchResults');
                const saveBtn = document.getElementById('categorySaveBtn');
                const clearBtn = document.getElementById('categoryClear');
                function open(){ try{ if(gear && gear.disabled) return; modal.classList.remove('hidden'); document.documentElement.classList.add('modal-open'); input.focus(); }catch{} }
                function closeModal(){ try{ modal.classList.add('hidden'); document.documentElement.classList.remove('modal-open'); }catch{} }
                function setBadge(on){ try{ if(on) gearWrap.classList.add('active'); else gearWrap.classList.remove('active'); }catch{} }
                // load saved category
                try{ const saved = localStorage.getItem('random.category'); setBadge(!!saved); }catch(e){}

                gear?.addEventListener('click', (ev)=>{ try{ if(gear.disabled) { ev.preventDefault(); ev.stopImmediatePropagation(); return; } open(); }catch(e){} });
                // prevent keyboard activation when disabled
                gear?.addEventListener('keydown', (ev)=>{ try{ if((ev.key === 'Enter' || ev.key === ' ') && gear.disabled){ ev.preventDefault(); ev.stopImmediatePropagation(); } }catch(e){} });
                close?.addEventListener('click', ()=>{ closeModal(); });
                clearBtn?.addEventListener('click', ()=>{ try{ localStorage.removeItem('random.category'); results.innerHTML=''; input.value=''; setBadge(false); }catch(e){} });

                // Debounced search
                let deb = 0; let lastQ = '';
                input?.addEventListener('input', (ev)=>{
                    const q = String(input.value||'').trim(); lastQ = q;
                    if(deb) clearTimeout(deb);
                    if(!q){ results.innerHTML = '<div class="hint">Type to search Wikipedia.</div>'; return; }
                    deb = setTimeout(async ()=>{
                        try{
                            results.innerHTML = '<div class="hint">Searching…</div>';
                            const url = `https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(q)}&utf8=&format=json&origin=*`;
                            const r = await fetch(url);
                            if(!r.ok) throw new Error('search failed');
                            const d = await r.json();
                            const arr = (d && d.query && d.query.search) || [];
                            if(!arr.length){ results.innerHTML = '<div class="hint">No results</div>'; return; }
                            results.innerHTML = '';
                            arr.slice(0,12).forEach(it=>{
                                const div = document.createElement('div'); div.className='result'; div.textContent = it.title; div.addEventListener('click', ()=>{
                                    // select this as the category
                                    input.value = it.title; results.querySelectorAll('.selected').forEach(n=>n.classList.remove('selected'));
                                    div.classList.add('selected');
                                });
                                results.appendChild(div);
                            });
                        }catch(e){ results.innerHTML = '<div class="hint">Search failed</div>'; }
                    }, 350);
                });

                // Save selected/typed value
                saveBtn?.addEventListener('click', ()=>{
                    try{
                        const v = String(input.value||'').trim();
                        if(!v){ alert('Please enter or select a query to save.'); return; }
                        localStorage.setItem('random.category', v);
                        setBadge(true);
                        closeModal();
                    }catch(e){ console.warn('Save category failed', e); }
                });
            })();

            // Observe size/content changes to keep the safe area fresh
            let ro = null; let mo = null; let lastH = -1; let rafId = 0;
            function scheduleMeasure(){
                if(rafId) cancelAnimationFrame(rafId);
                rafId = requestAnimationFrame(()=>{ rafId = 0; const h = computeTopSafeArea(); if(h !== lastH) lastH = h; });
            }
            function startObservers(){
                try{
                    if(window.ResizeObserver && newsBar){
                        ro = new ResizeObserver(scheduleMeasure); ro.observe(newsBar);
                    }
                }catch{}
                try{
                    if(window.MutationObserver && newsBar){
                        mo = new MutationObserver(scheduleMeasure);
                        mo.observe(newsBar, { childList: true, subtree: true, attributes: true, characterData: true });
                    }
                }catch{}
                window.addEventListener('resize', ()=>{ scheduleMeasure(); computeStickyScale(); try{ if(typeof positionDockAndPanel==='function') positionDockAndPanel(); }catch{} });
            }

            function setNewsEnabled(on){
                try{ localStorage.setItem(PREF_KEY, on ? 'on' : 'off'); }catch{}
                if(newsBar) newsBar.style.display = on ? '' : 'none';
                if(toggleBtn) toggleBtn.textContent = on ? 'Disable news' : 'Enable news';
                // Apply offset immediately so elements jump to the correct spot without lag
                try{ computeTopSafeArea(); }catch{}
                scheduleMeasure();
                // Also reposition sticky elements that depend on top safe area
                try{ if(typeof positionDockAndPanel === 'function') positionDockAndPanel(); }catch{}
                // One more pass on next tick to catch any async layout changes
                setTimeout(()=>{ try{ computeTopSafeArea(); if(typeof positionDockAndPanel === 'function') positionDockAndPanel(); }catch{} }, 50);
            }

            // Compute sticky notes scale so their vertical footprint adapts to the news header
            function computeStickyScale(){
                try{
                    const cs = getComputedStyle(document.documentElement);
                    const topPx = parseFloat(cs.getPropertyValue('--topSafeArea')) || 0;
                    const vh = Math.max(480, window.innerHeight || document.documentElement.clientHeight || 0);
                    // Dedicate up to ~12% vertical compression when a large header is present;
                    // clamp scale to [0.85, 1.00] for readability.
                    const ratio = topPx / Math.max(1, vh);
                    const scale = Math.max(0.85, Math.min(1.0, 1.0 - ratio * 1.6));
                    document.documentElement.style.setProperty('--stickyScale', scale.toFixed(3));
                    // Maintain a small visual gap above the rail/dock/panel
                    const gap = Math.min(16, 8 + Math.round(topPx * 0.08));
                    document.documentElement.style.setProperty('--stickyTopGap', gap + 'px');
                }catch{}
            }

            function formatDate(d){
                try{ const dt = new Date(d); return dt.toLocaleDateString(undefined, { month:'short', day:'numeric' }); }catch{ return ''; }
            }
            function prune24h(items){
                const now = Date.now();
                return (items||[]).filter(it=>{ let t = Date.parse(it.pubDate||''); if(!isFinite(t)) t = now; return (now - t) <= MAX_AGE_MS; });
            }
            function dedupe(items){
                const seen = new Set();
                return (items||[]).filter(it=>{ const k = (it.title||'').trim(); if(!k || seen.has(k)) return false; seen.add(k); return true; });
            }
            // Headlines fetch/render
            function parseFeedXML(text){
                try{
                    const doc = new DOMParser().parseFromString(text, 'text/xml');
                    // RSS 2.0 <item>
                    let nodes = Array.from(doc.querySelectorAll('channel > item, item'));
                    if(nodes && nodes.length){
                        return nodes.map(it=>({
                            title: (it.querySelector('title')?.textContent||'').trim(),
                            link: (it.querySelector('link')?.textContent||'').trim(),
                            pubDate: (it.querySelector('pubDate')?.textContent||it.querySelector('dc\:date')?.textContent||'').trim()
                        }));
                    }
                    // Atom <entry>
                    nodes = Array.from(doc.querySelectorAll('feed > entry, entry'));
                    if(nodes && nodes.length){
                        return nodes.map(it=>({
                            title: (it.querySelector('title')?.textContent||'').trim(),
                            link: (it.querySelector('link[rel="alternate"][href]')?.getAttribute('href') || it.querySelector('link[href]')?.getAttribute('href') || '#').trim(),
                            pubDate: (it.querySelector('updated')?.textContent||it.querySelector('published')?.textContent||'').trim()
                        }));
                    }
                }catch(e){ /* fallthrough */ }
                return [];
            }
            async function fetchTextFromAny(url){
                // Try direct first (may fail due to CORS); then proxies
                const attempts = [ async ()=>{
                    try{ const r = await fetch(url, { mode:'cors' }); if(!r.ok) throw new Error('HTTP '+r.status); return await r.text(); }catch(e){ throw e; }
                }];
                PROXIES.forEach(build=>{
                    attempts.push(async ()=>{ const u = build(url); const r = await fetch(u, { mode:'cors' }); if(!r.ok) throw new Error('HTTP '+r.status); return await r.text(); });
                });
                let lastErr = null;
                for(const fn of attempts){
                    try{ const txt = await fn(); if(txt && txt.length>20) return txt; }catch(e){ lastErr = e; }
                }
                throw lastErr || new Error('All fetch attempts failed');
            }
            
            function buildTicker(items){
                if(!newsRow) return;
                newsRow.innerHTML = '';
                const viewport = document.createElement('div'); viewport.className = 'news-viewport'; newsRow.appendChild(viewport);
                trackA = document.createElement('div'); trackA.className = 'news-track';
                trackB = document.createElement('div'); trackB.className = 'news-track';
                const makeFrag = (arr) => {
                    const frag = document.createDocumentFragment();
                    arr.forEach((it, idx)=>{
                        const a = document.createElement('a'); a.className='news-item'; a.target='_blank'; a.rel='noopener noreferrer'; a.href = it.link || '#';
                            // include date+time inline (no boxed pill)
                            const dateText = (function(dt){
                                try{
                                    const d = new Date(dt);
                                    // Use the shared global source so formatting can vary by source
                                    const src = (typeof window !== 'undefined' && window.__currentNewsSource) ? window.__currentNewsSource : null;
                                    if(src === 'pubmed') return '';
                                    // For arXiv show date only (no hour/minute). For others keep time.
                                    if(src === 'arxiv'){
                                        return d.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
                                    }
                                    return d.toLocaleString(undefined, { month:'short', day:'numeric', hour:'2-digit', minute:'2-digit' });
                                }catch{
                                    return '';
                                }
                            })(it.pubDate);
                            if(dateText){
                                const date = document.createElement('span'); date.className='news-date-inline';
                                date.textContent = dateText;
                                a.appendChild(date);
                            }
                            const title = document.createElement('span'); title.textContent = it.title || 'Untitled';
                            a.appendChild(title); frag.appendChild(a);
                        const sep = document.createElement('span'); sep.className='news-sep'; sep.textContent='•'; frag.appendChild(sep);
                    });
                    return frag;
                };
                trackA.appendChild(makeFrag(items));
                trackB.appendChild(makeFrag(items));
                viewport.appendChild(trackA); viewport.appendChild(trackB);
                // Position B right after A
                requestAnimationFrame(()=>{
                    const wA = trackA.getBoundingClientRect().width;
                    const vw = viewport.getBoundingClientRect().width;
                    // Fixed speed — do not adapt to content width
                    tickerSpeed = FIXED_NEWS_TICKER_SPEED;
                    console.debug('[news] tickerSpeed(px/s)=', tickerSpeed, 'trackWidth=', Math.round(wA));
                    trackA.style.transform = 'translateX(0px)';
                    trackB.style.transform = `translateX(${Math.max(0, Math.ceil(wA))}px)`;
                });
                // Pause on hover
                viewport.addEventListener('mouseenter', ()=>{ cancelTicker(); });
                viewport.addEventListener('mouseleave', ()=>{ startTicker(); });
                scheduleMeasure();
            }
            function startTicker(){
                cancelTicker();
                let lastTs = performance.now();
                const step = (ts)=>{
                    const dt = Math.max(0, ts - lastTs) / 1000; lastTs = ts;
                    const dx = tickerSpeed * dt; tickerX -= dx;
                    if(trackA && trackB){
                        const wA = trackA.getBoundingClientRect().width;
                        const wB = trackB.getBoundingClientRect().width;
                        // wrap when A completely off-screen
                        if(-tickerX >= wA){ tickerX += wA; }
                        const xA = Math.floor(tickerX);
                        const xB = Math.floor(tickerX + wA);
                        trackA.style.transform = `translateX(${xA}px)`;
                        trackB.style.transform = `translateX(${xB}px)`;
                    }
                    tickerRAF = requestAnimationFrame(step);
                };
                tickerRAF = requestAnimationFrame(step);
            }
            function cancelTicker(){ if(tickerRAF){ cancelAnimationFrame(tickerRAF); tickerRAF=0; } }
            function applyItems(items){
                itemsState = items.slice();
                if(itemsState.length === 0){
                    newsRow.innerHTML = '';
                    const hint = document.createElement('span'); hint.className='news-item'; hint.textContent = 'No headlines available right now.';
                    newsRow.appendChild(hint);
                    cancelTicker();
                    scheduleMeasure();
                    return;
                }
                buildTicker(itemsState);
                startTicker();
            }
            function init(){
                // Prevent double-initialization when this script is included/executed more than once.
                if(window.__newsInitDone) return;
                window.__newsInitDone = true;
                // Remember which news source to use (pubmed | arxiv)
                // allow a shared global value so other blocks can read it safely
                if(!window.__currentNewsSource) window.__currentNewsSource = 'pubmed';
                let currentNewsSource = window.__currentNewsSource;
                // Sequence counter to ignore stale/overlapping fetch results
                // Increment before each network fetch; only the latest seq may update UI.
                let newsReqSeq = 0;
                try{ currentNewsSource = localStorage.getItem('__newsSourcePref') || 'pubmed'; }catch(e){}
                // keep the global in sync
                window.__currentNewsSource = currentNewsSource;

                function setActiveNewsButton(){
                    try{
                        document.querySelectorAll('.news-source-opt').forEach(b=>{
                            try{ b.classList.toggle('active', (b.dataset && b.dataset.source) === currentNewsSource); }catch(e){}
                        });
                    }catch(e){}
                }

                async function reloadNews(){
                    // capture a sequence id so we can detect stale completions
                    const mySeq = ++newsReqSeq;
                    try{
                        const fresh = await fetchNewsBySource(currentNewsSource);
                        // If a newer request started while we were fetching, ignore this result
                        if(mySeq !== newsReqSeq){ console.debug('[news] ignoring stale fetch result for', currentNewsSource); return; }
                        const merged = dedupe(prune24h([...(fresh||[]), ...(itemsState||[])]));
                        applyItems(merged);
                    }catch(e){
                        console.warn('reloadNews failed', e);
                        try{ const raw = localStorage.getItem(CACHE_KEY+'_'+currentNewsSource); if(raw){ const cached = JSON.parse(raw).items||[]; if(mySeq === newsReqSeq) applyItems(cached); return; } }catch{}
                        if(mySeq === newsReqSeq) applyItems([]);
                    }
                }

                // Initialize news enabled state from saved preference (default: ON for first run)
                try{
                    const saved = localStorage.getItem(PREF_KEY);
                    const initialOn = (saved === null || saved === 'on');
                    setNewsEnabled(initialOn);
                }catch(e){
                    // on error, enable by default
                    try{ setNewsEnabled(true); }catch(_){}
                }
                startObservers();
                // initial load via selected source
                setActiveNewsButton();
                reloadNews().finally(()=>{
                    // Keep the user's saved preference; just ensure layout measurement runs
                    scheduleMeasure();
                });

                // hourly refresh: merge with current, prune 24h, rebuild ticker
                setInterval(async ()=>{
                    try{
                        const fresh = await fetchNewsBySource(currentNewsSource);
                        const merged = dedupe(prune24h([...(fresh||[]), ...(itemsState||[])]));
                        applyItems(merged);
                    }catch(e){ console.warn('periodic news refresh failed', e); }
                }, REFRESH_MS);

                // wire the enabled toggle
                if(toggleBtn){ toggleBtn.addEventListener('click', ()=>{
                    const on = !(newsBar && newsBar.style.display !== 'none');
                    setNewsEnabled(on);
                }); }

                // wire the source option buttons
                try{
                    document.querySelectorAll('.news-source-opt').forEach(btn=>{
                        try{
                            btn.addEventListener('click', async ()=>{
                                const src = btn.dataset && btn.dataset.source ? btn.dataset.source : 'pubmed';
                                // short-circuit if already active
                                if(currentNewsSource === src) return;
                                currentNewsSource = src;
                                window.__currentNewsSource = src;
                                try{ localStorage.setItem('__newsSourcePref', src); }catch(e){}
                                setActiveNewsButton();

                                // Pause the ticker and show loading hint
                                try{ cancelTicker(); }catch(e){}
                                const prevContent = newsRow.innerHTML;
                                try{
                                    newsRow.innerHTML = '';
                                    const loading = document.createElement('div'); loading.className = 'news-loading hint'; loading.textContent = 'Loading ' + src + ' headlines…';
                                    newsRow.appendChild(loading);
                                }catch(e){}

                                // disable controls while fetching
                                const opts = Array.from(document.querySelectorAll('.news-source-opt'));
                                opts.forEach(o=>{ try{ o.disabled = true; o.classList.add('disabled'); }catch(e){} });

                                // attempt reload; restore UI afterwards
                                try{
                                    await reloadNews();
                                }catch(e){
                                    console.warn('news reload failed on click', e);
                                    // leave loading hint but add notice
                                    try{ const el = newsRow.querySelector('.news-loading'); if(el) el.textContent = 'Failed to load ' + src + ' headlines.'; }catch(e){}
                                } finally {
                                    // re-enable buttons
                                    opts.forEach(o=>{ try{ o.disabled = false; o.classList.remove('disabled'); }catch(e){} });
                                }
                            });
                        }catch(e){}
                    });
                }catch(e){}
            }
            if(document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', init, { once:true }); } else { init(); }
        })();
        </script>
        <!-- Main Title: BUNKR 108 ASCII (restored) -->
        <style>
            /* Tweakable gap under the ASCII title. Try: 0px, 4px, 8px, 12px */
            :root{ --asciiTitleGap: 0px; }
            /* Increase top margin to move title away from the news bar; reduce bottom gap via --asciiTitleGap */
            .page-ascii-title{ margin:18px auto var(--asciiTitleGap); padding:0 2px; color: var(--ink); overflow:visible; pointer-events:none; -webkit-user-select:none; user-select:none; position:relative; display:flex; justify-content:center; align-items:flex-start; }
            .page-ascii-title pre{ margin:0; display:block; font-family: "Courier New", Consolas, monospace; font-weight:700; line-height:1.0; letter-spacing:0.35px; text-shadow:0 1px 0 #000; font-size:24px; white-space:pre; -webkit-user-select:none; user-select:none; transform-origin: top center; will-change: transform; }
            @media (max-width: 800px){ .page-ascii-title pre{ font-size:10px; } }
            @media (max-width: 480px){ .page-ascii-title pre{ font-size:9px; } }
            /* Site credit styling placed under title/boot overlays */
            /* Place credit directly under the title with no gap above; keep 6px below to separate from API bar */
            .site-credit{ margin:0 auto 12px; text-align:center; color:var(--ink); opacity:0.95; font-size:15px; font-weight:600; display:block; -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none; user-select:none; }
            @media (max-width:480px){ .site-credit{ font-size:13px; } }
        </style>
        <div id="mainAsciiTitle" class="page-ascii-title" aria-label="BUNKR 108 title banner">
            <pre>
888888b.   888     888 888b    888 888    d8P  8888888b.         d888    .d8888b.   .d8888b.  
888  "88b  888     888 8888b   888 888   d8P   888   Y88b       d8888   d88P  Y88b d88P  Y88b 
888  .88P  888     888 88888b  888 888  d8P    888    888         888   888    888 Y88b. d88P 
8888888K.  888     888 888Y88b 888 888d88K     888   d88P         888   888    888  "Y88888"  
888  "Y88b 888     888 888 Y88b888 8888888b    8888888P"          888   888    888 .d8P""Y8b. 
888    888 888     888 888  Y88888 888  Y88b   888 T88b           888   888    888 888    888 
888   d88P Y88b. .d88P 888   Y8888 888   Y88b  888  T88b          888   Y88b  d88P Y88b  d88P 
8888888P"   "Y88888P"  888    Y888 888    Y88b 888   T88b       8888888  "Y8888P"   "Y8888P"</pre>
        </div>
    <div class="site-credit" id="pageCredit">Created by <strong>Ethan Shaw</strong></div>
        <script>
        // Keep the ASCII title matched to the module width by scaling DOWN via transform (more reliable)
        (function initAsciiTitleFit(){
            function getEls(){
                const title = document.getElementById('mainAsciiTitle');
                const pre = title ? title.querySelector('pre') : null;
                const module = document.querySelector('.api-key-bar') || document.getElementById('setup') || document.querySelector('.card.pad');
                return { title, pre, module };
            }
            function measureNaturalWidth(pre){
                // Temporarily take the <pre> out of normal flow to measure its max-content width
                const prev = {
                    position: pre.style.position,
                    left: pre.style.left,
                    top: pre.style.top,
                    width: pre.style.width,
                    transform: pre.style.transform,
                    display: pre.style.display
                };
                try{
                    pre.style.position = 'fixed';
                    pre.style.left = '-99999px';
                    pre.style.top = '0';
                    pre.style.width = 'max-content';
                    pre.style.transform = 'none';
                    pre.style.display = 'inline-block';
                    // Use scrollWidth; fallback to bounding rect
                    return Math.max(pre.scrollWidth || 0, pre.getBoundingClientRect().width || 0) || 1;
                } finally {
                    pre.style.position = prev.position;
                    pre.style.left = prev.left;
                    pre.style.top = prev.top;
                    pre.style.width = prev.width;
                    pre.style.transform = prev.transform;
                    pre.style.display = prev.display;
                }
            }
            function fitOnce(){
                try{
                    const { title, pre, module } = getEls();
                    if(!title || !pre || !module) return;
                    const inset = 4; // px of breathing room to avoid any overhang
                    const modRect = module.getBoundingClientRect();
                    const targetW = Math.max(0, Math.round(modRect.width) - inset);
                    // Constrain container to target width but allow centering via margin:auto
                    // Use maxWidth instead of fixed width so the container can be horizontally centered.
                    title.style.width = 'auto';
                    title.style.maxWidth = targetW + 'px';
                    // Measure natural unscaled width
                    const naturalW = measureNaturalWidth(pre);
                    // Compute scale: only downscale; never upscale here
                    let scale = 1;
                    if(naturalW > 0 && targetW > 0){
                        scale = Math.min(1, (targetW / naturalW) * 0.992); // slight fudge to guarantee <= target
                        if(scale < 0.05) scale = 0.05; // hard floor to avoid zeroing out
                    }
                    // Apply transform; center horizontally by translating the scaled box
                    pre.style.transform = 'none';
                    // Force a reflow so getBoundingClientRect reflects unscaled position
                    const preRect0 = pre.getBoundingClientRect();
                    // Apply scale first
                    pre.style.transform = 'scale(' + scale + ')';
                    const titleRect = title.getBoundingClientRect();
                    const preRect = pre.getBoundingClientRect();
                    // Rely on flexbox for horizontal centering. Just apply scale transform.
                    pre.style.transform = 'scale(' + scale + ')';
                    // Reserve height so layout below doesn't jump; add extra pad to avoid clipping
                    const finalRect = pre.getBoundingClientRect();
                    // Respect the CSS gap when reserving height: the container's margin-bottom is external.
                    // Add a larger pad (12px) to ensure tall glyphs are not clipped when scaled.
                    title.style.height = Math.ceil(finalRect.height + 12) + 'px';
                    // Update or create invisible measurement box for diagnostics
                    let box = title.querySelector('#asciiMeasureBox');
                    if(!box){
                        box = document.createElement('div');
                        box.id = 'asciiMeasureBox';
                        box.style.position = 'absolute';
                        box.style.top = '0'; box.style.left = '0';
                        box.style.border = '1px dashed rgba(255,255,255,0)';
                        box.style.pointerEvents = 'none'; box.style.userSelect = 'none';
                        title.appendChild(box);
                    }
                    box.style.width = Math.round(Math.min(finalRect.width, targetW)) + 'px';
                    box.style.height = Math.round(finalRect.height) + 'px';
                    box.dataset.size = `${Math.round(Math.min(finalRect.width, targetW))}x${Math.round(finalRect.height)}`;
                }catch{}
            }
            function fitWithRetries(){
                fitOnce();
                // A couple of delayed passes to catch late layout/font shifts
                setTimeout(fitOnce, 60);
                setTimeout(fitOnce, 180);
            }
            function ready(cb){
                if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', cb, { once:true });
                else cb();
            }
            ready(()=>{
                fitWithRetries();
                window.addEventListener('resize', fitWithRetries);
                // Observe width changes of the target module
                try{
                    const ro = new ResizeObserver(fitWithRetries);
                    const target = document.querySelector('.api-key-bar') || document.getElementById('setup') || document.querySelector('.card.pad');
                    if(target) ro.observe(target);
                }catch{}
                // Ensure the page credit sits immediately under the ASCII title on startup
                try{
                    function ensureCreditUnderTitle(){
                        try{
                            const title = document.getElementById('mainAsciiTitle');
                            const credit = document.getElementById('pageCredit');
                            if(!title || !credit) return;
                            // If credit isn't the next sibling after title, move it there
                            if(title.nextElementSibling !== credit){
                                title.parentNode.insertBefore(credit, title.nextSibling);
                            }
                            // Ensure visual centering and modest spacing
                            credit.style.textAlign = 'center';
                            if(!credit.style.marginTop) credit.style.marginTop = '6px';
                        }catch{}
                    }
                    ensureCreditUnderTitle();
                    // Retry briefly in case other startup code rearranges nodes
                    setTimeout(ensureCreditUnderTitle, 60);
                    setTimeout(ensureCreditUnderTitle, 250);
                }catch{}
                // Re-fit after fonts are ready
                try{ if(document.fonts && document.fonts.ready){ document.fonts.ready.then(()=> fitWithRetries()); } }catch{}
            });
        })();
        </script>
        <!-- Global Gemini API Key (used by any AI feature below) - inside container so it matches width -->
        <div class="api-key-bar">
            <span id="globalKeyDot" class="api-key-dot missing" aria-hidden="true"></span>
            <strong class="fs-14">Gemini API Key</strong>
            <input type="password" id="globalGemKey" placeholder="AIza..." />
            <label class="switch" title="Remember key on this device">
                <input type="checkbox" id="globalGemRemember">
                <span class="slider"></span>
                <span class="switch-label ml-6 fs-12 muted">remember</span>
            </label>
            <label class="switch" title="Enable/disable the API key">
                <input type="checkbox" id="globalGemEnable">
                <span class="slider"></span>
                <span class="switch-label ml-6 fs-12 muted" id="globalGemEnableLabel">disabled</span>
            </label>
        </div>
        <!-- (compact widget removed; expanded TOS box inserted below AI Elements section) -->
        <div class="card pad" id="setup">
            <h1>Load MCQs → Quiz</h1>
            <div class="hint">Format: <span class="tag">Q1. …</span> options start with <span class="tag">-</span>, plus
                an <strong>ANSWER KEY</strong> like <span class="tag">1. B</span>.</div>
            <div class="row mt-10">
                <div class="col">
                    <label>Paste your document</label>
                    <div class="paste-wrap">
                    <textarea id="paste" class="flex-1 minh-320 maxw-600 w-100" placeholder="Q1. Why is protein purification essential in biochemistry?
- It prevents oxidation of DNA
- It allows isolation and study of specific proteins free from contaminants
- It enables bacterial transformation
- It increases cell growth rate
Q2. …
...
ANSWER KEY
1. B
2. C
..."></textarea>
                        <button id="indexPasteBtn" class="index-btn" type="button" title="Save this pasted document">Save MCQ</button>
                    </div>
                    <label class="mt-10">…or load a file (.txt)</label>
                    <div class="file-input">
                        <label class="choose-btn" for="file">Choose File</label>
                        <span class="filename" id="fileNameTxt">No file chosen</span>
                        <input type="file" id="file" accept=".txt" />
                    </div>
                    <!-- AI: Reformat & Assign Answers (same column, same width) -->
                    <div id="aiFixPanel" class="ai-fix-panel mt-10" role="region" aria-label="Reformat MCQs and Assign Answers">
                        <div class="flex center gap-12">
                            <div class="key-badge missing" id="fixKeyBadge" title="Shows whether a Gemini API key is present"><span class="dot"></span><span class="hint">No key set</span></div>
                            <button id="aiFixBtn" class="btn primary btn-wide" type="button" disabled>Reformat & Assign Answers (AI)</button>
                        </div>
                        <div id="aiFixStatus" class="hint mt-8 text-center" role="status" aria-live="polite"></div>
                        <div class="hint mt-6 text-center">Cleans up your pasted MCQ text to the required format (Qn., options with “-”, and an ANSWER KEY). If missing, it assigns a single correct answer per question. Output replaces the text above.</div>
                    </div>
                </div>
                <div class="col">
                    <div class="hint">Options</div>
                    <div class="options-container">
                        <label class="pill"><input type="checkbox" id="shuffleQ" checked> Shuffle questions</label>
                        <label class="pill"><input type="checkbox" id="shuffleA" checked> Shuffle answers</label>
                        <label class="pill"><input type="checkbox" id="instant" checked> Instant feedback</label>
                    </div>
                    <div class="row">
                        <button class="btn primary" id="parseBtn">Parse & Preview</button>
                        <button class="btn" id="startBtn">Start Quiz</button>
                        <button class="btn" id="sampleBtn">Load Sample Snippet</button>
                    </div>
                    <!-- Optional AI file → MCQs generator (docx/pdf) -->
<div class="ai-file-panel">
    <div class="ai-file-row">
    <div class="file-input flex-1-260">
            <label class="choose-btn" for="aiFile">Choose File</label>
            <span class="filename" id="aiFileName">No file chosen</span>
    <input type="file" id="aiFile" multiple accept=".pdf,application/pdf,.docx,application/vnd.openxmlformats-officedocument.wordprocessingml.document,.pptx,application/vnd.openxmlformats-officedocument.presentationml.presentation,image/png,image/jpeg,image/webp,image/gif,image/*">
        </div>
    <!-- Drop target: allow dragging textbook chapters here to feed the Generate MCQs flow -->
    <div id="aiFileTbDrop" class="dropzone ml-8" title="Drop content chapters here to use as source for MCQ generation" aria-label="Drop content chapters here"></div>
    <div class="flex gap-8 center flex-wrap">
    <button id="aiAutoBtn" class="btn pill" title="Let AI choose the question count (defaults to 4 options)" aria-pressed="false">Auto</button>
    <label class="pill" title="Enable OCR on scanned pages"><input type="checkbox" id="aiOcrToggle" checked> OCR images</label>
    <label class="pill" title="How many questions to generate">
            <span class="muted fs-12 mr-4">Questions</span>
            <input type="number" id="aiQCount" min="1" max="50" step="1" value="30" class="w-68" />
        </label>
        <label class="pill" title="How many answer options per question">
            <span class="muted fs-12 mr-4">Options/Q</span>
            <input type="number" id="aiOptCount" min="2" max="6" step="1" value="4" class="w-68" />
        </label>
        <button class="btn primary ai-fixed" id="aiFileGenBtn" title="Use Gemini 2.5-flash to read .docx/.pdf/.pptx and create MCQs">Generate MCQs from .docx/.pdf/.pptx (AI)</button>
    </div>
            <div class="key-badge missing" id="fileGenKeyBadge" title="Shows whether a Gemini API key is present"><span class="dot"></span><span class="hint">No key set</span></div>
    <div class="ai-file-status" id="aiFileStatus" role="status" aria-live="polite"></div>
  </div>
  
        <!-- Visible debug output for the file-gen flow (helps when DevTools isn't open) -->
            <pre id="aiFileDebug"></pre>

            <!-- AI output preview modal (hidden by default) -->
            <div id="aiPreviewModal" class="hidden" aria-hidden="true">
                <div class="overlay">
                    <div class="panel">
                        <div class="flex justify-between center">
                            <h3 id="aiPreviewTitle">AI Output Preview</h3>
                            <button class="btn" id="aiPreviewClose">Close</button>
                        </div>
                                    <div class="hint mt-8" id="aiPreviewHint"></div>
                                    <!-- Tag input removed in Phase 1 -->
                                    <pre id="aiPreviewContent"></pre>
                                    <div class="flex gap-8 justify-end mt-12">
                                        <button class="btn" id="aiPreviewCancel">Cancel</button>
                                        <button class="btn" id="aiPreviewSave">Save generated</button>
                                        <button class="btn primary" id="aiPreviewInsert">Insert full output</button>
                                    </div>
                    </div>
                </div>
            </div>
    <div class="hint mt-6">
        Upload a <strong>.docx</strong>, <strong>.pdf</strong>, or <strong>.pptx</strong>. Gemini will conservatively extract content and return a set of
    questions formatted for this tool (Qn. lines, <code>-</code> options, and an <strong>ANSWER KEY</strong>).
  </div>
  </div>

  <!-- Saved MCQs retrieval module (separate, dropdown, outside AI panel) -->

<style>
/* Reduce/auto-size option buttons inside the AI file panel so they fit the parent width */
.ai-file-panel .ai-file-row{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .ai-file-panel .ai-file-row .btn,
    .ai-file-panel .ai-file-row .pill,
    .ai-file-panel .ai-file-row label.pill,
    .ai-file-panel .ai-file-row .pill,
    .ai-file-panel .ai-file-row .btn{
        box-sizing: border-box;
        flex: 0 1 auto;
        max-width: 100%;
        padding: 6px 8px;
        font-size: 13px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        border-radius:8px; /* slightly smaller, consistent pill shape */
    }
/* Ensure checkbox label contents align center with sibling controls */
.ai-file-panel .ai-file-row label.pill{
    display: inline-flex;
    align-items: center; /* vertical centering */
    justify-content: center; /* horizontal centering of inner content */
    gap: 8px;
}
.ai-file-panel .ai-file-row label.pill input[type="checkbox"]{
    width: 16px;
    height: 16px;
    margin: 0;
    vertical-align: middle;
}
/* Center numeric values inside the compact number-entry controls used in the AI file row */
.ai-file-panel .ai-file-row label.pill input[type="number"],
.ai-file-panel .ai-file-row input.w-68 {
    text-align: center;
    padding-left: 6px; /* keep a small inner gap while visually centered */
    padding-right: 6px;
    box-sizing: border-box;
}
/* Let the file-input area shrink when space is tight */
.ai-file-panel .file-input{ min-width: 0; }
/* Reduce the Choose File module height inside the AI panel to match other controls */
.ai-file-panel .file-input{ display:flex; align-items:center; gap:8px; padding:6px 8px; box-sizing:border-box; height:36px }
.ai-file-panel .file-input.flex-1-260{ flex: 0 1 auto; min-width: 0; }
    .ai-file-panel .file-input .choose-btn{
    /* Match global .file-input .choose-btn sizing so the AI panel button is identical */
    display:inline-flex; align-items:center; justify-content:center;
    padding:6px 8px;
    border-radius:8px;
    background: linear-gradient(180deg, var(--btnTop), var(--btnBottom));
    border: 1px solid var(--btnBorder);
    color: var(--ink);
    font-weight:700;
    cursor:pointer;
    font-size:12px;
    line-height:normal;
    box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    flex: 0 0 auto;
    width: auto;
    min-width: 0;
    height: auto;
    min-height: 28px;
    vertical-align: middle;
}
.ai-file-panel .file-input .filename{ display:inline-flex; align-items:center; padding-left:8px; color:var(--muted); font-size:12px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; min-width:0; line-height:1 }
@media (max-width:640px){ .ai-file-panel .file-input .choose-btn{ min-height:36px } }
</style>
  <div id="savedMcqs" class="saved-card" role="region" aria-label="Saved MCQs">
    <div class="saved-header">
        <div class="flex center gap-8 saved-header-left">
            <strong>Saved MCQs</strong>
            <div class="saved-badge-wrap">
                <span class="muted fs-12" id="savedCount">0</span>
            </div>
            <div id="savedTotalKb" class="muted fs-12" title="Total size of saved MCQs">Total: 0.0 KB</div>
        </div>
        <div class="flex gap-8">
            <button id="toggleSavedBtn" class="btn small" aria-expanded="false" aria-controls="savedMenu">Show</button>
            <button id="exportAllSavedBtn" class="btn small" title="Export all saved MCQs to a single ZIP">Export all</button>
            <button id="clearSavedBtn" class="btn small" title="Remove all saved MCQ sets">Clear</button>
        </div>
    </div>
    <div id="savedMenu" class="saved-menu" role="listbox" aria-label="Saved MCQs Menu">
        <div id="savedList" class="saved-list"></div>
        <!-- footer removed to keep saved list compact (no extra spacing or divider) -->
    </div>
  </div>

                </div>
            </div>
        </div>
<style>
/* Ensure consistent vertical spacing between top-level card modules */
.card + .card { margin-top: 12px; }
/* add space between the main setup card and the preview section */
#preview { margin-top: 12px; }
/* Flashcards panel spacing: equal top and bottom margins to avoid asymmetric gaps */
#flashcardsPanel { margin: 12px 0; clear: both; }

</style>
<!-- Ensure missed/validation qcards shrink to fit content (don't stretch full width) -->
<style>
    /* Stack missed items vertically and make each card fill the results panel width
       so missed-answer cards match the Results readout width. */
    #attemptMissedList {
        display: flex;
        flex-direction: column;
        gap: 12px;
        align-items: stretch; /* allow children to grow to full width */
        width: 100%;
        box-sizing: border-box;
    }
    /* Make each missed card expand to the container width (match Results panel) */
    #attemptMissedList .qcard {
        display: block;
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
        margin: 6px 0; /* vertical spacing between cards */
        padding: 12px 14px; /* align with Results card padding */
    }
    /* Prevent the 'hint' row from using flex:space-between which forces wide layout; keep it compact */
    #attemptMissedList .qcard .hint {
        display: block !important;
        margin-top: 6px !important;
        color: var(--muted);
    }
</style>
<style>
/* Simple modal for See All questions */
.modal{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:20000 }
.modal.hidden{ display:none }
.modal{ position: fixed; inset: 0; display:flex; align-items: center; justify-content: center; z-index: 22010; }
.modal-backdrop{ position:absolute; inset:0; background:rgba(2,6,12,0.6); -webkit-backdrop-filter: blur(4px); backdrop-filter: blur(4px); }
.modal-panel{ position:relative; z-index:2; width: min(920px, 96vw); max-height: calc(100vh - 96px); overflow:auto; -webkit-overflow-scrolling: touch; overscroll-behavior: contain; touch-action: auto; border-radius:12px; padding:16px; background: linear-gradient(180deg, rgba(8,12,18,.98), rgba(6,10,14,.98)); border:1px solid rgba(255,255,255,0.04); box-shadow: 0 12px 40px rgba(0,0,0,0.6); }
.modal-open, html.modal-open{ /* modal-open intentionally does not lock overflow so modal-panel can scroll on touch devices */ display:block }
.modal-open body, html.modal-open body{ /* intentionally no-op but keep rule non-empty for linters */ min-height:100% }
.modal-header{ display:flex; justify-content:space-between; align-items:center; margin-bottom:12px }
.modal-body{ color:var(--ink); font-size:14px; line-height:1.4; }
.seeall-item{ padding:8px 6px; border-bottom:1px dashed rgba(255,255,255,0.02); }
.seeall-item h4{ margin:0 0 6px 0; font-size:14px }
.seeall-item pre{ margin:0; white-space:pre-wrap; font-family:monospace; font-size:13px }
/* concise choice rows inside the See-All modal */
.seeall-choices{ margin-top:6px }
.seeall-choice{ margin:6px 0; font-size:13px; color:var(--muted); }
.seeall-choice strong{ display:inline-block; width:2.2em; color:var(--muted); font-weight:700 }
.seeall-choice.correct{ color: #4dd17a; }
.seeall-choice.correct strong{ color: #4dd17a }
</style>
<style>
/* TOS modal and widget styles */
.tos-body pre{ white-space: pre-wrap; font-family: inherit; font-size:13px; }
.tos-widget{ display:flex; align-items:center; gap:8px; justify-content:flex-end; margin:8px auto; max-width:960px; }
.tos-status{ color:var(--muted); font-size:13px }
.tos-widget .tos-actions{ display:flex; gap:6px }
.tos-widget .btn.small{ padding:6px 8px; font-size:12px }
</style>
    <!-- Flashcards / SRS Panel (moved above Preview) -->
    <section id="flashcardsPanel" class="card pad">
        <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;">
            <div style="display:flex;align-items:center;gap:12px">
                <h3 class="mt-0" style="margin:0">Flashcards & SRS</h3>
                <div id="fcDeckInfo" class="hint" style="font-size:13px;color:var(--muted);">No deck loaded.</div>
            </div>
            <div style="display:flex;gap:8px;align-items:center">
                <button id="fcStartSession" class="btn primary small" disabled>Start Session</button>
                <div class="dropdown">
                    <button id="fcExportCsv" class="btn small">Export CSV</button>
                    <button id="fcExportApkg" class="btn small">Export APKG (shim)</button>
                </div>
            </div>
        </div>

        <div id="fcCardArea" style="display:none;margin-top:12px;">
            <!-- Flashcard Timer: centered above the card; click to toggle Always vs Hover-only -->
            <style>
                /* Flashcard timer styles */
                .fc-timer-row{ display:flex; justify-content:center; margin:-4px 0 8px; }
                .fc-timer{
                    font: 600 13px ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
                    color: var(--ink, #e6edf3);
                    background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
                    border: 1px solid rgba(255,255,255,0.10);
                    padding: 6px 10px; border-radius: 999px;
                    box-shadow: 0 8px 24px rgba(0,0,0,0.35);
                    cursor: pointer; -webkit-user-select: none; user-select: none;
                    transition: opacity .16s ease, transform .16s ease, box-shadow .16s ease;
                }
                .fc-timer:hover{ transform: translateY(-1px); box-shadow: 0 10px 28px rgba(0,0,0,0.45); }
                .fc-timer.hover-only{ opacity: 0; pointer-events: none; }
                #fcCardArea:hover .fc-timer.hover-only{ opacity: 1; pointer-events: auto; }
                .fc-timer.pulse{ animation: fcTimerPulse 300ms ease; }
                @keyframes fcTimerPulse{ 0%{ transform: scale(1); } 50%{ transform: scale(1.07); } 100%{ transform: scale(1); } }
            </style>
            <div id="fcTimerRow" class="fc-timer-row"><div id="fcTimer" class="fc-timer" title="Click to toggle: Always visible ↔ Show on hover">00:00</div></div>
            <div id="fcCard" style="min-height:180px;border-radius:12px;padding:18px;background:linear-gradient(180deg, rgba(8,12,18,1), rgba(6,10,14,1));border:1px solid rgba(255,255,255,0.04);box-shadow: 0 8px 32px rgba(0,0,0,0.6);">
                <div id="fcFront" style="font-weight:700;font-size:16px;color:var(--ink);">Question</div>
                <div id="fcBack" style="margin-top:12px;color:var(--muted);display:none;">Answer</div>
            </div>
            <div style="display:flex;gap:8px;margin-top:10px;align-items:center">
                <button id="fcFlip" class="btn">Flip</button>
                <div style="margin-left:auto;display:flex;gap:6px;">
                    <button id="fcAgain" class="btn" title="Again">Again</button>
                    <button id="fcHard" class="btn" title="Hard">Hard</button>
                    <button id="fcGood" class="btn primary" title="Good">Good</button>
                    <button id="fcEasy" class="btn" title="Easy">Easy</button>
                </div>
            </div>
            <div id="fcProgress" class="hint mt-8">Session: <span id="fcProgressText">0 / 0</span></div>
        </div>
    </section>

        <div id="preview" class="card pad hidden">
            <h2 class="mb-6 mt-0">Preview</h2>
            <div id="previewList"></div>
            <div class="footer">
                <span class="hint"><span id="previewCount">0</span> items parsed.</span>
                <div style="flex:1;display:flex;justify-content:center;align-items:center;gap:10px">
                    <button class="btn" id="exportPdfBtn" title="Export preview to PDF">Export PDF</button>
                    <div style="display:flex;align-items:center;gap:8px">
                        <label class="switch" title="Highlight correct answers in exported PDF (green)">
                            <input type="checkbox" id="exportPdfHighlight" />
                            <span class="slider"></span>
                        </label>
                        <span id="exportPdfHighlightLabel" class="export-highlight-label muted fs-12">Highlight correct answers</span>
                    </div>
                </div>
                <button class="btn primary" id="seeAllBtn">See all</button>
            </div>
        </div>

    <!-- Random Quiz settings gear -->
    <style>
    /* Gear button next to Random button */
    .gear-btn{ display:inline-flex; align-items:center; justify-content:center; width:42px; height:42px; border-radius:50%; border:1px solid rgba(0,0,0,0.08); background:var(--card); cursor:pointer; margin-left:0; font-size:18px; line-height:1; color:#fff }
    .gear-badge{ position:relative; display:inline-block }
    /* badge removed per request; keep wrapper for layout only */
    /* Category modal */
    #randomCategoryModal .modal-panel{ max-width:640px }
    #categorySearchResults{ max-height:240px; overflow:auto; margin-top:8px; border:1px solid rgba(0,0,0,0.06); padding:6px; border-radius:6px; background:var(--card) }
    #categorySearchResults .result{ padding:8px; cursor:pointer; border-bottom:1px dashed rgba(0,0,0,0.03) }
    #categorySearchResults .result:last-child{ border-bottom:none }
    #categorySearchResults .result:hover{ background:rgba(0,0,0,0.02) }
    /* container that keeps random + gear together */
    .random-controls{ display:inline-flex; align-items:center; gap: var(--control-gap); margin-left: var(--control-gap); }
    .gear-btn.disabled{ opacity:0.45; pointer-events:none }
    /* API key dot indicators */
    .api-key-dot{ display:inline-block; width:10px; height:10px; border-radius:50%; margin-right:8px; vertical-align:middle; box-shadow: 0 0 6px rgba(0,0,0,0.15); }
    /* Force daily/random key dots to a consistent size so they match visually inside pill buttons */
    #dailyKeyDot, #randomKeyDot { width:10px !important; height:10px !important; margin-right:8px !important; }
    /* Ensure perfect circular shape, no CSS transforms, and proper vertical centering beside text */
    #dailyKeyDot, #randomKeyDot { display:inline-block !important; vertical-align:middle !important; border-radius:50% !important; transform:none !important; box-shadow: 0 0 6px rgba(0,0,0,0.12) !important; }
    /* If dots appear inside .btn.pill, ensure the button doesn't apply a conflicting transform that skews the dot */
    .btn.pill { transform: none; }
    .api-key-dot.missing{ background:#ff6b6b; box-shadow:0 0 8px rgba(255,107,107,0.5); }
    .api-key-dot.present{ background:#4dd17a; box-shadow:0 0 10px rgba(77,209,122,0.5); }
    </style>

    <style>
    /* Persist green/red outlines for choice rows even when the inverted/light overlay is active.
       Approach: render a pseudo-element (::after) that draws the colored outline and subtle overlay
       in front of the choice. When the global inverted overlay is active, double-invert only this
       pseudo-element so the outline keeps its native green/red hues while the card background
       remains subject to the inversion overlay (keeps the question background dark as requested).
    */
    .choice{ position: relative; overflow: visible; }

    .choice.correct::after,
    .choice.wrong::after{
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        border-radius: 10px; /* match .choice rounding */
        transition: -webkit-filter .36s ease, filter .36s ease, box-shadow .18s ease, background-color .18s ease;
        will-change: box-shadow, filter, background-color;
        z-index: 1; /* place above the choice content but below any interactive markers */
    }

    /* Outer glow + subtle tinted overlay (very low opacity so underlying card stays readable) */
    .choice.correct::after{
        /* Reduced halo thickness from 6px to 3px per request */
        box-shadow: 0 0 0 3px rgba(77,209,122,0.12);
        background: linear-gradient(180deg, rgba(77,209,122,0.04), rgba(77,209,122,0.02));
    }
    .choice.wrong::after{
        /* Match reduced halo thickness for wrong state */
        box-shadow: 0 0 0 3px rgba(255,107,107,0.12);
        background: linear-gradient(180deg, rgba(255,107,107,0.04), rgba(255,107,107,0.02));
    }

    /* When the global light-mode overlay is active, lift the choice element and its
       colored pseudo-element above the overlay so the green/red tint renders normally
       on top of the (inverted) question background. We use the same z-index level as
       other preserved-palette elements elsewhere on the page. This preserves the
       dark inverted card background while making the outline/overlay green or red.
    */
    body.light-mode-active .choice.correct,
    body.light-mode-active .choice.wrong{
        position: relative;
        /* keep the choice container BELOW the global invert overlay so its contents are inverted,
           then we selectively double-invert the green/red indicator pseudo-element only. */
        z-index: 2147483644; /* below #lightModeOverlay (2147483646) */
        /* ensure no filter is applied to the element itself */
        -webkit-filter: none !important;
        filter: none !important;
    }

    body.light-mode-active .choice.correct::after,
    body.light-mode-active .choice.wrong::after{
        /* keep the indicator just under the overlay and double-invert it so it renders true green/red */
        z-index: 2147483645; /* below overlay (2147483646), above base content */
        -webkit-filter: invert(1) !important;
        filter: invert(1) !important;
    }

    /* Fix inverted-mode background tint: when inverted display is active, we neutralize the
       base element background (so it doesn't get color-inverted) and paint the intended
       green/red background via a ::before layer that is also double-inverted. This keeps
       the inside fill color consistent with the outline (true green/red) in inverted view. */
    body.light-mode-active .choice.correct,
    body.light-mode-active .choice.wrong{
        background: transparent !important; /* avoid inverted base gradient */
    }
    body.light-mode-active .choice.correct::before,
    body.light-mode-active .choice.wrong::before{
        content: "";
        position: absolute;
        inset: 0;
        border-radius: 12px;
        pointer-events: none;
        z-index: 2147483644; /* under the outline (::after), above base content */
        /* Apply the same gradients as normal mode, but double-invert to cancel the global invert */
    }
    body.light-mode-active .choice.correct::before{
        /* Light-theme friendly green fill */
        background: linear-gradient(180deg, rgba(188, 245, 212, .65), rgba(152, 234, 190, .55));
        -webkit-filter: invert(1) !important;
        filter: invert(1) !important;
    }
    body.light-mode-active .choice.wrong::before{
        /* Light-theme friendly red fill */
        background: linear-gradient(180deg, rgba(255, 214, 214, .65), rgba(250, 190, 190, .55));
        -webkit-filter: invert(1) !important;
        filter: invert(1) !important;
    }

    /* Keep the inner tag/label content above the pseudo-element so text/icons remain readable */
    .choice > * { position: relative; z-index: 2147483649; }
    </style>

    <style>
    /* Ensure radios keep true green/red fills and borders even when global light-mode inversion is active */
    /* Neutralize default checked visuals under inverted mode to prevent brand/UA tints */
    body.light-mode-active .qcard .choice input[type="radio"]:checked{
        border-color: rgba(110,150,200,.8) !important;
        background: none !important;
        box-shadow: none !important;
    }
    body.light-mode-active .qcard .choice.correct input[type="radio"]{
        border-color: var(--ok) !important;
        /* Do NOT invert the base radio so the transparent center sees the green overlay behind */
        -webkit-filter: none !important; filter: none !important;
    }
    body.light-mode-active .qcard .choice.wrong input[type="radio"]{
        border-color: var(--bad) !important;
        -webkit-filter: invert(1) !important;
        filter: invert(1) !important;
    }
    /* Ensure wrong un-checked radios also stay red ring + white center in inverted mode */
    body.light-mode-active .qcard .choice.wrong input[type="radio"]:not(:checked){
        border-color: var(--bad) !important;
        background-image: radial-gradient(circle at center, #ffffff 0 46%, rgba(255,255,255,0) 48%),
                          radial-gradient(circle at center, var(--bad) 60%, var(--bad) 78%, rgba(0,0,0,0) 80%) !important;
        background-repeat: no-repeat !important; background-position: center !important; background-size: 100% 100% !important;
        -webkit-filter: invert(1) !important; filter: invert(1) !important;
    }
    /* And for the checked state, draw the smooth inner circle and double-invert so the hue stays correct */
    /* Mirror the checked visuals under inverted (light-mode) by applying the same layered backgrounds and double-inverting so hues remain correct. */
    /* In inverted mode: if the user CHECKED the correct, show white center + ring, and double-invert to preserve hues */
    body.light-mode-active .qcard .choice.correct input[type="radio"]:checked{
        border-color: var(--ok) !important;
        background-image:
            radial-gradient(circle at center, #ffffff 0 46%, rgba(255,255,255,0) 48%),
            radial-gradient(circle at center, var(--ok) 60%, var(--ok) 78%, rgba(0,0,0,0) 80%) !important;
        background-repeat: no-repeat !important; background-position: center !important; background-size: 100% 100% !important;
        -webkit-filter: invert(1) !important; filter: invert(1) !important;
    }
    /* In inverted mode: revealed correct that is NOT selected -> green ring with transparent center; double-invert ring to keep it green */
    body.light-mode-active .qcard .choice.correct input[type="radio"]:not(:checked){
        border-color: var(--ok) !important;
        background: radial-gradient(circle at center,
                     rgba(0,0,0,0) 0%, rgba(0,0,0,0) 56%,
                     var(--ok) 60%, var(--ok) 78%,
                     rgba(0,0,0,0) 82%) !important;
        background-color: transparent !important; background-repeat: no-repeat !important; background-position: center !important; background-size: 100% 100% !important;
        -webkit-filter: invert(1) !important; filter: invert(1) !important;
    }
    body.light-mode-active .qcard .choice.wrong input[type="radio"]:checked{
        border-color: var(--bad) !important;
        background-image:
            radial-gradient(circle at center, #ffffff 0 46%, rgba(255,255,255,0) 48%),
            radial-gradient(circle at center, var(--bad) 60%, var(--bad) 78%, rgba(0,0,0,0) 80%) !important;
        background-repeat: no-repeat !important; background-position: center !important; background-size: 100% 100% !important;
        -webkit-filter: invert(1) !important; filter: invert(1) !important;
    }
    </style>


        <!-- Daily-build modal (shown while building questions) -->
        <div id="dailyBuildModal" class="modal hidden" role="dialog" aria-modal="true" aria-label="Building questions">
            <div class="modal-backdrop"></div>
            <div class="modal-panel" style="max-width:880px; width:90%;">
                    <div class="modal-header"><h3>Building questions…</h3><button id="dailyBuildClose" class="btn">Close</button></div>
                <div class="modal-body">
                        <div id="dailyBuildTitle" class="daily-title" style="margin-bottom:10px; font-weight:800;">Today's Random Quiz is about&nbsp;<span id="dailyBuildTopic" class="rainbow">choosing...</span>!</div>
                    <div id="dailyBuildSpinner" style="display:flex;align-items:center;gap:12px">
                        <span class="spinner" aria-hidden="true"></span>
                        <div id="dailyBuildStatus">Preparing…</div>
                    </div>
                    <div class="hint mt-6">This dialog displays progress while the daily quiz is generated. Messages are also logged to the Generate MCQ debug output.</div>
                </div>
            </div>
        </div>
    <style>
    /* Animated full-width rainbow gradient for topic line */
     /* Make the title large and responsive: all words on the line use the same size.
         The title spans the full modal width and centers its content. */
     /* Use block + centered text so the sentence and topic are rendered inline like normal text.
         Increase line-height slightly to avoid glyph clipping while keeping no extra vertical space. */
    .daily-title{ font-size: clamp(22px, 5vw, 48px); color: var(--ink); width: 100%; display: block; text-align: center; margin: 0; overflow: visible; font-weight:700; line-height:1.35; padding:6px 0 8px 0; }
    /* Create a moving gradient background that spans the full width of the title area.
       The text uses background-clip:text with transparent color to show the gradient fill.
       We apply the gradient to a child span (.rainbow) but stretch it so the animation moves
       across the entire title area regardless of the text length. */
    .daily-title .rainbow{
        /* behave exactly like inline text so baseline/descenders match surrounding words */
        display: inline;
        color: transparent;
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        /* Use a wide repeating gradient and animate its offset continuously. */
        /* Tileable gradient: start and end color are the same so repeats seamlessly.
           Colors chosen as three anchor regions (warm -> gold -> cool) with smooth stops.
           background-size is set to 300% and we animate exactly by that amount to avoid seams. */
        background-image: linear-gradient(90deg,
            rgb(255,99,71) 0%,    /* warm red (A) */
            rgb(255,165,64) 30%,  /* orange */
            rgb(255,205,86) 45%,  /* gold (A->G midpoint) */
            rgb(144,210,255) 70%, /* light blue (G->B midpoint) */
            rgb(91,170,255) 85%,  /* sky blue */
            rgb(255,99,71) 100%   /* repeat warm red (A) to tile */
        );
        /* Background size equals the animation travel; animate by -300% to loop seamlessly */
        background-size: 300% 100%;
        background-repeat: repeat-x;
        /* Slower, smoother continuous left-to-right animation for gentle fades */
        animation: rainbowMove 16s linear infinite;
        will-change: background-position, transform;
        /* Inherit size and line-height from the title so all text on the line is the same size and aligned */
        font-size: inherit;
        font-weight: 800;
        line-height: inherit;
        vertical-align: baseline;
        padding: 0 4px;
        /* keep overflow visible so descenders are not clipped */
        overflow: visible;
        white-space: nowrap;
        -webkit-font-smoothing: antialiased;
        backface-visibility: hidden;
        transform: translateZ(0);
    }
    /* Inverted color scheme for Random Quiz (colors reversed) */
    .daily-title .rainbow.inverse{
        display: inline;
        color: transparent;
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        /* Inverted rainbow palette and animation (mirror of .rainbow) */
        background-image: linear-gradient(90deg,
            rgb(144,210,255) 0%, /* light blue start */
            rgb(91,170,255) 20%,  /* sky */
            rgb(255,205,86) 45%,  /* gold */
            rgb(255,165,64) 70%,  /* orange */
            rgb(255,99,71) 90%,   /* warm red */
            rgb(144,210,255) 100% /* repeat light blue */
        );
        background-size: 300% 100%;
        background-repeat: repeat-x;
        animation: rainbowMoveReverse 16s linear infinite;
        will-change: background-position, transform;
        font-size: inherit;
        font-weight: 800;
        line-height: inherit;
        vertical-align: baseline;
        padding: 0 4px;
        overflow: visible;
        white-space: nowrap;
        -webkit-font-smoothing: antialiased;
        backface-visibility: hidden;
        transform: translateZ(0);
    }
    /* Ensure links inside the daily/random quiz title are not underlined (keep styling narrow and scoped) */
    .daily-title a { text-decoration: none; }
    .daily-title a:hover { text-decoration: none; }
    /* ASCII face idle animation in AI explanation panel */
    .ascii-face{ display:block; text-align:center; margin-top:12px }
    .ascii-face .face{ display:inline-block; font-family: inherit; font-size:18px; line-height:1; transform-origin:center; animation: faceIdle 3.6s ease-in-out infinite; }
    .ascii-face .mouth{ display:inline-block; min-width:1.1em; display:inline-block; animation: mouthIdle 3.6s ease-in-out infinite; }
    @keyframes faceIdle{ 0%{ transform: translateY(0) } 50%{ transform: translateY(-3px) } 100%{ transform: translateY(0) } }
    @keyframes mouthIdle{ 0%,100%{ transform: scaleX(1) } 45%{ transform: scaleX(1.02) } 50%{ transform: scaleX(0.56) } 55%{ transform: scaleX(1.02) } }
    /* Eye movement controlled by JS: use CSS variables so JS can set translations while blink uses scaleY
       This gives smooth transitions and lets us keep blink + translate composed together. */
    .ascii-face .eye{
        display:inline-flex; align-items:center; justify-content:center; width:0.9em; text-align:center;
        --ex: 0px; --ey: 0px;
        transform-origin:center;
        transition: transform 900ms cubic-bezier(.2,.8,.2,1);
        transform: translate(var(--ex), var(--ey)) scaleY(1);
    }
    /* Blink: compress vertically while preserving current translate values */
    .ascii-face .eye.blink{ transform: translate(var(--ex), var(--ey)) scaleY(0.12); transition: transform 120ms ease-in-out; }
    /* Lashes — two quotation marks centered right above each eye */
    .ascii-face .eye{ position: relative; }
    .ascii-face .eye .lash{
        position:absolute; top:0; left:50%; transform: translate(-50%, -0.36em);
        font-size:.7em; line-height:1; opacity:0; pointer-events:none; letter-spacing:-0.02em;
    }
    .ascii-face .face.lashed .eye .lash{ opacity:1 }
    /* Flutter when toggled — subtle brightness/spacing shimmer */
    @keyframes lashFlutter{ 0%{ filter: brightness(1); letter-spacing: 0 } 50%{ filter: brightness(1.12); letter-spacing: 0.02em } 100%{ filter: brightness(1); letter-spacing: 0 } }
    .ascii-face .face.lash-toggle .lash{ animation: lashFlutter .28s ease }
    /* Compose with blink: only soften visibility during blink when lashes are enabled */
    .ascii-face .face.lashed .eye.blink .lash{ opacity:.6 }
    /* When AI output is active, JS will pause updates; keep this CSS selector as a safeguard */
    #resultsAiOutput.ai-active .eye{ transition: none !important; }
    /* Respect user preference for reduced motion */
    @media (prefers-reduced-motion: reduce){
        .ascii-face .face, .ascii-face .mouth, .ascii-face .eye { transition: none !important; transform: none !important; }
    }
    
    /* Topic link styling: remove underline but keep rainbow text inside; show a colored dot per type */
    a.topic-link{ text-decoration: none; color: inherit; display: inline-flex; align-items: center; gap:8px }
    a.topic-link:focus{ outline: 2px solid rgba(96,165,250,.18); outline-offset:2px; border-radius:6px }
    a.topic-link .rainbow{ padding:0; }
    /* Prepend a small colored dot to indicate inferred topic type */
    a.topic-link::before{ content: ''; display:inline-block; width:10px; height:10px; border-radius:50%; flex:0 0 auto; box-shadow:0 0 6px rgba(0,0,0,0.12); }
    a.topic-link.topic-type-person::before{ background: #FFB86B; box-shadow:0 0 10px rgba(255,184,107,0.35); }
    a.topic-link.topic-type-place::before{ background: #7AD3FF; box-shadow:0 0 10px rgba(122,211,255,0.35); }
    a.topic-link.topic-type-event::before{ background: #FFD36B; box-shadow:0 0 10px rgba(255,211,107,0.28); }
    a.topic-link.topic-type-science::before{ background: #A6FFBA; box-shadow:0 0 10px rgba(166,255,186,0.28); }
    a.topic-link.topic-type-media::before{ background: #D7A3FF; box-shadow:0 0 10px rgba(215,163,255,0.28); }
    a.topic-link.topic-type-organism::before{ background: #9BE57A; box-shadow:0 0 10px rgba(155,229,122,0.28); }
    a.topic-link.topic-type-organization::before{ background: #FFD1D1; box-shadow:0 0 10px rgba(255,209,209,0.28); }
    a.topic-link.topic-type-concept::before{ background: #9FB0FF; box-shadow:0 0 10px rgba(159,176,255,0.28); }
    a.topic-link.topic-type-other::before{ background: #CCCCCC; box-shadow:0 0 8px rgba(204,204,204,0.18); }
    @keyframes rainbowMove {
        0% { background-position: 0% 50%; }
        /* move exactly one background-size length so the pattern tiles without a seam */
        100% { background-position: -300% 50%; }
    }

    /* Compact modal adjustments for the daily build dialog */
    #dailyBuildModal .modal-panel{ padding: 12px 14px; max-width:880px; }
    #dailyBuildModal .modal-body{ padding: 8px 6px 12px 6px; }
    #dailyBuildModal .modal-header h3{ margin: 0 0 6px 0; font-size: 16px; }
    .daily-title{ font-size: clamp(20px, 4.2vw, 36px); line-height: 1.2; padding:4px 0 6px 0; }
    /* Center spinner + status and make them compact */
    #dailyBuildSpinner{ display:flex; align-items:center; justify-content:center; gap:8px; padding:6px 0; }
    #dailyBuildStatus{ text-align:center; font-weight:600; color:var(--muted); }
    /* Center and tighten hint/subtext */
    #dailyBuildModal .hint{ text-align:center; margin-top:8px; font-size:13px; color:var(--muted); }
    /* Reduce close button size visual impact */
    #dailyBuildClose{ padding:6px 10px; font-size:13px }

     /* Animated capsule outline that follows the button's border-radius exactly.
         Technique: two-layer background. The top layer (padding-box) paints the
         button interior; the bottom layer (border-box) paints the gradient which
         is visible only in the transparent border region. This keeps the center
         untouched and creates a perfect pill-shaped outline. */
    /* Make Daily button match other .btn elements (same filled background and border as the News toggle) */
    /* Keep the Daily button visually identical to other .btn.pill elements; avoid overriding
       background, border, or padding so it inherits the exact same look. */
    #dailyQuizBtn{
        position: relative;
        overflow: visible;
        color: var(--ink);
        z-index: 2;
        /* keep the button visually identical to other .btn.pill elements while ensuring
           internal content (dot + label) is properly centered */
        display: inline-flex;
        align-items: center;
    gap: 6px;
        vertical-align: middle;
        /* do not set background/border/padding here so .btn and .btn.pill rules apply exactly */
    }
    /* (removed) animate the button element itself — animation is applied to ::before ring only */
    /* Visible labels are rendered via ::after; no hidden inner label spans remain */
    /* (removed) previously hid the structural label for Random Quiz; label is now rendered via ::after */
    /* Gradient text remains animated for the label */
    #dailyQuizBtn::after{
        content: attr(data-label);
        position: relative;
        display: inline; /* match regular inline text so sizing matches siblings */
        padding: 0; /* don't add extra padding that increases button size */
        margin: 0;
        color: transparent;
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        background-image: linear-gradient(90deg, rgb(255,99,71) 0%, rgb(255,165,64) 30%, rgb(255,205,86) 45%, rgb(144,210,255) 70%, rgb(91,170,255) 85%, rgb(255,99,71) 100%);
        background-size: 300% 100%;
        background-repeat: repeat-x;
    animation: rainbowMove 16s linear infinite;
    font-weight: 800;
        font-size: inherit;
        line-height: inherit;
        z-index: 2;
        pointer-events: none;
        vertical-align: middle;
    }
    /* Random Quiz: use same gradient but animate in the opposite direction for an inverted effect */
    #randomQuizBtn::after{
        content: attr(data-label);
        position: relative;
        display: inline;
        padding: 0; margin: 0;
        color: transparent;
        -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent;
        /* shifted hue palette: purples -> magenta -> warm -> lime -> teal -> repeat */
        background-image: linear-gradient(90deg,
            hsl(260,90%,60%) 0%,   /* purple */
            hsl(320,85%,62%) 20%,  /* magenta */
            hsl(28,90%,60%) 45%,   /* warm orange */
            hsl(95,60%,48%) 70%,   /* lime */
            hsl(175,65%,50%) 90%,  /* teal */
            hsl(260,90%,60%) 100%  /* back to purple */
        );
        background-size: 300% 100%; background-repeat: repeat-x;
        animation: rainbowMoveReverse 14s linear infinite; /* slightly different duration for variety */
        font-weight: 800; font-size: inherit; line-height: inherit; z-index: 2; pointer-events: none; vertical-align: middle;
    }
    @keyframes rainbowMoveReverse { 0% { background-position: 0% 50%; } 100% { background-position: 300% 50%; } }
    /* Ensure the small API key dot keeps its original appearance and is above the outline/text
       and participates in the flex layout so it vertically centers with the label */
    /* Ensure the small API key dot keeps its original appearance and is above the outline/text
       and participates in the flex layout so it vertically centers with the label */
    #dailyQuizBtn .api-key-dot {
        position: relative;
        z-index: 3;
        flex: 0 0 auto;
        align-self: center;
        display: inline-block;
        width: 12px; height: 12px;
    }

    /* Make Random button match the Daily button's internal layout so labels align exactly */
    #randomQuizBtn{
        display: inline-flex;
        align-items: center;
        gap: 6px;
        vertical-align: middle;
    }
    </style>

        <!-- Terms of Use Modal (initial popup) -->
        <div id="tosModal" class="modal hidden" role="dialog" aria-modal="true" aria-label="Terms of Use and Disclaimer">
            <div class="modal-backdrop"></div>
            <div class="modal-panel" id="tosPanel">
                <div class="modal-header">
                    <h3>Terms of Use & Disclaimer — Effective Oct 20, 2025 (v1.0)</h3>
                    <button id="tosClose" class="btn small" aria-label="Close">Close</button>
                </div>
                <div class="modal-body tos-body" id="tosContent">
                    <pre>Terms of Use & Disclaimer
Effective Date: October 20, 2025
Version: 1.0
________________________________________
1. Overview and Acceptance
This website (the “Service”) provides a hosted demonstration of the BUNKR108 open-source multiple-choice question (MCQ) generator (the “Project").
By accessing or using this Service or any downloaded copy of the Project, you agree to these Terms of Use (“Terms"). If you do not agree, you must not use the Service.
The Project is made publicly available for educational and personal use only. This Service is offered as a client-side demo with no user registration, no server-side storage, and no commercial intent.
________________________________________
2. Open-Source License (MIT)
The Project’s source code is licensed under the MIT License, granting you broad rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the software, subject to inclusion of the original license notice and attribution to the authors.
Nothing in these Terms alters or limits your rights under the MIT License. You may view the complete license text at: https://opensource.org/licenses/MIT
________________________________________
3. Nature of the Hosted Demo
The hosted instance found at TKWMO.github.io/BUNKR108/New_Comp_Test.html is a convenience demo of the open-source Project.
All data processing occurs locally in your browser.
No uploaded documents, quiz content, or API keys are transmitted to or stored by the website operator.
Use of the hosted demo is entirely voluntary. For privacy or customization, users are strongly encouraged to download the repository from GitHub and run the Project locally. Github repository URL: https://github.com/TKWMO/BUNKR108
________________________________________
4. Local Processing and API Keys
The Service runs fully in the browser using local storage (IndexedDB/localStorage).
If you choose to enable AI-powered features, you may enter an external API key (e.g., Gemini). This key is stored only in your browser and never sent to the site operator.
There are no server-side safeguards for key security. You assume all responsibility for protecting, rotating, and revoking your own API keys.
If this is a concern, use the self-hosted version of the Project.
________________________________________
5. User Responsibility and Self-Hosting Option
You are free—and encouraged—to download and adapt the Project for your own use, subject to the MIT License.
You are solely responsible for:
• How you configure and operate the code;
• Any content you input or generate; and
• Compliance with all applicable laws in your jurisdiction.
By using, modifying, or redistributing the Project, you acknowledge that you act independently and assume full responsibility for all associated outcomes.
________________________________________
6. Third-Party APIs and Services
Certain features connect directly from your browser to third-party endpoints, including but not limited to:
• Gemini (Google Generative AI) – remote text generation and parsing (the app imports the Gemini SDK via esm.run which then connects to Google’s Generative Language endpoints when you invoke AI features);
• Library CDNs and package hosts (esm.run, jsDelivr, unpkg, cdnjs) used to load third-party JavaScript libraries such as pdf.js/pdf.worker, JSZip, mammoth (DOCX), tesseract.js (OCR), pako, and related tooling;
• Content proxies and CORS intermediaries (api.allorigins.win, cors.isomorphic-git.org, r.jina.ai) used in a small number of fetch operations as fallbacks or to work around CORS restrictions;
• Public content feeds and audio streams accessed by example features (for instance RSS/news feeds such as feeds.npr.org and public audio stream endpoints such as stream.srg-ssr.ch, ice5.somafm.com, strm112.1.fm, and similar public hosts).

These services are independent of this Project and operate under their own terms and privacy policies. When you invoke an AI feature or request any content that requires an external endpoint, your browser connects directly to those third-party services. The Project does not forward, persist, or otherwise intercept your transmitted data beyond what the third-party service receives in a direct browser request.
________________________________________
7. Acceptable Use and Prohibited Conduct
You agree not to use the Service or Project for:
• Any illegal, harmful, or fraudulent purpose;
• Uploading or generating content that violates privacy, intellectual property, or export laws;
• Impersonation of real persons, officials, or entities;
• Harassment, stalking, or targeted hate speech;
• Political or election manipulation without disclosure;
• Processing regulated data (e.g., PHI under HIPAA, children’s data under COPPA, financial records);
• Creating deceptive synthetic or “deepfake” media;
• Training or redistributing AI model outputs that violate copyright or data-use agreements.
Violation of these rules may result in access being blocked from the hosted demo.
________________________________________
8. Data Privacy and Security Notice
This Service does not:
• Require accounts;
• Collect analytics or telemetry;
• Store user-generated content on a remote server;
• Share or sell any user information.
All user data (documents, API keys, MCQs) is confined to your local browser environment and can be deleted at any time via your browser settings.
Because there is no server-side persistence, the operator is not a data controller under GDPR or similar regulations.
________________________________________
9. Intellectual Property and Attribution
• You retain ownership of all content you upload and any MCQs you generate.
• The Project’s source code, name, and visual design are protected by copyright and MIT license attribution.
• You may modify and distribute the Project, provided that you preserve the original license notice and attribution in visible form.
• You may not present derivative versions as the official [Project Name] release or imply endorsement by its authors.
________________________________________
10. No Warranty / Educational Disclaimer
The Project and all related materials are provided “AS IS” without warranty of any kind, express or implied, including but not limited to:
• Accuracy, completeness, or reliability of generated MCQs;
• Suitability for educational, professional, or assessment use;
• Error-free or uninterrupted operation.
All outputs generated through AI features should be independently verified before use in any instructional or evaluative setting.
________________________________________
11. Limitation of Liability
To the maximum extent permitted by applicable law:
• The developers, contributors, and maintainers of this Project shall not be liable for any direct, indirect, incidental, consequential, or special damages arising from or in connection with your use or inability to use the Service or Project.
• This includes, without limitation, loss of data, misuse of API keys, or inaccuracies in generated content.
Your sole remedy for dissatisfaction with the Service is to stop using it.
________________________________________
12. Indemnification
You agree to defend, indemnify, and hold harmless the developers, contributors, and affiliates of this Project from and against any claims, damages, liabilities, or expenses arising out of:
• Your use, configuration, or distribution of the Project;
• Any content or data you submit; or
• Any breach of these Terms or applicable law.
________________________________________
13. Termination and Availability
The maintainers may modify, suspend, or discontinue the hosted demo at any time without notice.
This will not affect your right to continue using the open-source Project independently under the MIT License.
You may stop using the Service or delete all locally stored data at any time.
________________________________________
14. Modifications to Terms or Project
These Terms may be updated periodically.
Changes take effect when posted to this site or repository.
Your continued use after updates constitutes acceptance of the new Terms.
The Project’s source code and dependencies may evolve, and functionality may change without prior notice.
________________________________________
15. Governing Law and Jurisdiction
These Terms are governed by the laws of the State of Texas, United States, without regard to conflict-of-law principles.
Any disputes arising under or in connection with these Terms shall be resolved exclusively in the courts located in Harris County, Texas, USA.
_____________________________
17. Effective Date and Version
Effective Date: October 20, 2025
Version: 1.0
</pre>
                </div>
                <div class="flex justify-end gap-8 mt-12">
                    <button id="tosDecline" class="btn">Decline</button>
                    <button id="tosAccept" class="btn primary">Accept</button>
                </div>
            </div>
        </div>
        <script>
        (function(){
            const KEY = 'tos.accepted.v1';
            const tosModal = document.getElementById('tosModal');
            const tosPanel = document.getElementById('tosPanel');
            const tosAccept = document.getElementById('tosAccept');
            const tosDecline = document.getElementById('tosDecline');
            const tosClose = document.getElementById('tosClose');
            const viewTosBtn = document.getElementById('viewTosBtn');
            // support either the compact widget (#tosState) or the boxed module (#tosStateBox)
            let tosState = document.getElementById('tosState');
            let tosStateBox = document.getElementById('tosStateBox');
            const tosStatus = document.getElementById('tosStatus');

            function setWidgetState(accepted){
                try{
                    if(!tosState) tosState = document.getElementById('tosState');
                    if(!tosStateBox) tosStateBox = document.getElementById('tosStateBox');
                    if(tosState){ tosState.textContent = accepted ? 'Accepted' : 'Not accepted'; tosState.style.color = accepted ? '#4dd17a' : ''; }
                    if(tosStateBox){ tosStateBox.textContent = accepted ? 'Accepted' : 'Not accepted'; tosStateBox.style.color = accepted ? '#4dd17a' : ''; }
                }catch{}
            }

            // UI lock/unlock: add/remove a class on the root to blur and block interactions
            function lockUI(){ try{ 
                    document.documentElement.classList.add('tos-locked'); 
                    const ov = document.getElementById('tosOverlay'); if(ov) ov.classList.remove('hidden');
                    // Disable keyboard focus/tabbing for all interactive elements outside the TOS overlay and modal
                    try{
                        const tosOverlay = document.getElementById('tosOverlay');
                        const tosModal = document.getElementById('tosModal');
                        const all = Array.from(document.querySelectorAll('a, button, input, select, textarea, [tabindex]'));
                        all.forEach(el=>{
                            try{
                                if(!el) return;
                                // Ignore elements inside the overlay or the modal
                                if((tosOverlay && tosOverlay.contains(el)) || (tosModal && tosModal.contains(el))) return;
                                // Store previous tabindex if present
                                if(el.hasAttribute('tabindex')) el.dataset.prevTabindex = el.getAttribute('tabindex');
                                else el.dataset.prevTabindex = '__none__';
                                // mark as disabled for unlock restoration
                                el.dataset._tosDisabled = '1';
                                // Remove from tab order
                                try{ el.setAttribute('tabindex', '-1'); }catch(e){}
                                // mark as aria-disabled for screen readers
                                try{ el.setAttribute('aria-disabled', 'true'); }catch(e){}
                            }catch(e){}
                        });
                        // Save currently focused element id to restore later
                        try{ const ae = document.activeElement; if(ae && ae.id) document.documentElement.dataset._prevActive = ae.id; }catch(e){}
                        // Move focus to the unlock button for accessibility
                        try{ document.getElementById('tosUnlockBtn')?.focus(); }catch(e){}
                    }catch(e){}
                }catch{} }
            function unlockUI(){ try{ 
                    document.documentElement.classList.remove('tos-locked'); 
                    const ov = document.getElementById('tosOverlay'); if(ov) ov.classList.add('hidden');
                    // Restore tabindex / aria-disabled for elements we modified
                    try{
                        const modified = Array.from(document.querySelectorAll('[data-_tosDisabled]'));
                        modified.forEach(el=>{
                            try{
                                if(!el) return;
                                const prev = el.dataset.prevTabindex;
                                if(typeof prev !== 'undefined'){
                                    if(prev === '__none__') el.removeAttribute('tabindex'); else el.setAttribute('tabindex', prev);
                                    delete el.dataset.prevTabindex;
                                }
                                delete el.dataset._tosDisabled;
                                try{ el.removeAttribute('aria-disabled'); }catch(e){}
                            }catch(e){}
                        });
                        // Restore previous focus if possible
                        try{ const prevId = document.documentElement.dataset._prevActive; if(prevId){ const el = document.getElementById(prevId); if(el) el.focus(); delete document.documentElement.dataset._prevActive; } }catch(e){}
                    }catch(e){}
                }catch{} }

            function saveAccepted(){ try{ localStorage.setItem(KEY, '1'); }catch{} setWidgetState(true); unlockUI(); }
            function clearAccepted(){ try{ localStorage.removeItem(KEY); }catch{} setWidgetState(false); lockUI(); }

            function openModal(){
                try{
                    // Hide the centered unlock overlay so the modal's own backdrop appears above the blurred plane
                    const ov = document.getElementById('tosOverlay'); if(ov){ ov.classList.add('hidden'); ov.setAttribute('aria-hidden','true'); }
                }catch(e){}
                tosModal.classList.remove('hidden'); tosModal.setAttribute('aria-hidden','false'); document.documentElement.classList.add('modal-open'); document.body.classList.add('modal-open');
                // focus the close button for accessibility
                try{ document.getElementById('tosClose')?.focus(); }catch(e){}
            }
            function closeModal(){
                tosModal.classList.add('hidden'); tosModal.setAttribute('aria-hidden','true'); document.documentElement.classList.remove('modal-open'); document.body.classList.remove('modal-open');
                try{
                    // If the TOS has not been accepted, restore the locked overlay so the page remains inaccessible
                    const ov = document.getElementById('tosOverlay'); const has = !!localStorage.getItem(KEY);
                    if(ov){ if(!has){ ov.classList.remove('hidden'); ov.setAttribute('aria-hidden','false'); } else { ov.classList.add('hidden'); ov.setAttribute('aria-hidden','true'); } }
                }catch(e){}
            }

            // Wait until DOM is ready so boxed elements exist, then wire buttons and initialize
            function ready(cb){ if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', cb, { once:true }); else cb(); }
            ready(()=>{
                // Re-query DOM elements that may appear after this script block
                try{
                    // modal buttons
                    const _tosAccept = document.getElementById('tosAccept');
                    const _tosDecline = document.getElementById('tosDecline');
                    const _tosClose = document.getElementById('tosClose');
                    const _viewTosBtn = document.getElementById('viewTosBtn');
                    const _tosBoxView = document.getElementById('tosBoxView');
                    // Wire handlers
                    if(_tosAccept) _tosAccept.addEventListener('click', ()=>{ saveAccepted(); closeModal(); });
                    if(_tosDecline) _tosDecline.addEventListener('click', ()=>{ clearAccepted(); closeModal(); });
                    if(_tosClose) _tosClose.addEventListener('click', ()=>{ closeModal(); });
                    if(_viewTosBtn) _viewTosBtn.addEventListener('click', ()=>{ openModal(); });
                    if(_tosBoxView) _tosBoxView.addEventListener('click', ()=>{ openModal(); });
                    const _tosUnlockBtn = document.getElementById('tosUnlockBtn');
                    if(_tosUnlockBtn) _tosUnlockBtn.addEventListener('click', ()=>{ openModal(); });

                    // Initialize widget/box state now that elements exist
                    try{ const v = localStorage.getItem(KEY); const accepted = !!v; setWidgetState(accepted); if(!accepted){ lockUI(); setTimeout(openModal, 250); } else { unlockUI(); } }catch{ setWidgetState(false); lockUI(); setTimeout(openModal, 250); }
                }catch(e){ console.warn('TOS init failed', e); }
            });

            // Update header count with aggregate size (KB)
            try{ savedCount.textContent = `${arr.length} (${(totalBytes/1024).toFixed(1)} KB)`; }catch(e){}

        })();
        </script>

        <div id="quiz" class="card pad hidden"></div>

        <!-- See All Modal: lists parsed questions for review -->
        <div id="seeAllModal" class="modal hidden" role="dialog" aria-modal="true" aria-label="All parsed questions">
            <div class="modal-backdrop"></div>
            <div class="modal-panel">
                <div class="modal-header">
                    <h3>All Questions</h3>
                    <button id="seeAllClose" class="btn small" aria-label="Close">Close</button>
                </div>
                <div id="seeAllContent" class="modal-body"></div>
            </div>
        </div>

    <!-- Flashcards panel moved earlier in the document -->

        <!-- === Post-Quiz Results & AI Feedback (mirrors validate/like style) === -->
        <section id="results-card" class="card pad hidden">
            <!-- Attempts selector at the top, centered -->
            <div class="flex center gap-12">
                <label for="attemptSelect" class="muted fs-12">Attempts</label>
                <!-- Keep native select for accessibility but visually hide it; mirror with a styled dropdown -->
                <select id="attemptSelect" class="rp-select attempt-select visually-hidden" title="Select attempt to view missed questions" aria-hidden="true" tabindex="-1"></select>
                <div id="attemptDropdown" class="attempt-dd" role="combobox" aria-haspopup="listbox" aria-expanded="false" aria-label="Attempts">
                    <button id="attemptTrigger" class="attempt-trigger" type="button">
                        <span id="attemptTriggerText">Select attempt…</span>
                        <span class="chev">▾</span>
                    </button>
                    <div id="attemptMenu" class="attempt-menu" role="listbox" aria-label="Attempts"></div>
                </div>
                <button id="copyResultsBtn" class="btn small" type="button" title="Copy results to clipboard">Copy Results</button>
            </div>
            <div class="hint mt-8 text-center">
                Summary of your quiz performance. Use the analyzer below for AI feedback on missed questions and trends.
            </div>
            <div id="resultsSummary" class="mt-8"></div>
            <div id="attemptMissedList" class="mt-12"></div>
            <hr class="ai-divider" />
            <!-- Analysis section separated under results -->
            <div class="flex col center gap-8 mt-8">
                <div class="key-badge missing" id="resultsKeyBadge" title="Shows whether a Gemini API key is present"><span class="dot"></span><span class="hint">No key set</span></div>
                <div class="flex center gap-12">
                    <div style="flex:1; /* export removed from results view per request */"></div>
                    <button id="analyzeMissedBtn" type="button" class="btn primary btn-wide" disabled>Analyze Missed with AI</button>
                </div>
            </div>
            <div id="resultsAiStatus" class="hint mt-8 text-center"></div>
            <div id="resultsAiOutput" class="hint mt-12" role="status" aria-live="polite"></div>
        </section>

    <!-- Saved Quiz Results Module -->
    <section id="savedResultsPanel" class="card pad" style="margin: 12px 0; clear: both;">
        <!-- Title moved into the saved-card header for contained styling -->
        <div id="savedQuizzes" class="saved-card" role="region" aria-label="Saved Quiz Results" style="margin: 0;">
            <div class="saved-header">
                <div class="flex center gap-8 saved-header-left" style="align-items:center">
                    <h3 class="mt-0" style="margin:0">Saved Quiz Results</h3>
                    <div class="saved-badge-wrap"><span id="savedQuizCount">0</span></div>
                    <div id="savedQuizTotal" class="muted fs-12">Total: 0.0 KB</div>
                </div>
                <div class="flex gap-8">
                    <button id="compileMissedBtn" class="btn small" title="Compile all first-attempt missed questions into a new quiz">Compile Missed</button>
                    <button id="toggleSavedQuizBtn" class="btn small" aria-expanded="false" aria-controls="savedQuizMenu">Show</button>
                    <button id="clearSavedQuizBtn" class="btn small" title="Remove all saved quiz results">Clear</button>
                </div>
            </div>
            <div id="savedQuizMenu" class="saved-menu" role="listbox" aria-label="Saved Quiz Results Menu">
                <div id="savedQuizList" class="saved-list"></div>
            </div>

            <!-- Last Attempted Quiz sub-module within same card -->
            <div class="saved-header" id="lastAttemptBlock" style="margin-top:12px; border-top:1px solid rgba(255,255,255,0.04); padding-top:10px;">
                <div class="flex center gap-8 saved-header-left" style="align-items:center">
                    <h3 class="mt-0" style="margin:0">Last Attempted Quiz</h3>
                    <div id="lastAttemptLabel" class="muted fs-12">None yet</div>
                </div>
                <div class="flex gap-8">
                    <button id="lastAttemptCopyBtn" class="btn small" disabled>Copy</button>
                    <button id="lastAttemptSaveBtn" class="btn small" disabled>Save</button>
                    <button id="lastAttemptOpenBtn" class="btn small" disabled>Return</button>
                </div>
            </div>
        </div>
    </section>

        <!-- === Textbook Library (replaced with index.html app UI + script) === -->
        <section id="textbook-lib" class="card pad">
            <div class="tb-wrap">
                <style>
                    :root{ --bg:#0b1620; --panel:#0f2130; --muted:#9fb0c5; --accent:#4aa3ff; --ok:#4dd17a; --bad:#ff6b6b }
                    .tb-wrap{ max-width:100%; margin-top:0; padding-top:0; overflow:visible }
                    .tb-toc{ width: 100%; }
                    .tb-log{ width: 100%; }
                    /* Layout: compact variant for denser, minimal UI */
                    .flexRow{ display:flex; gap:10px; align-items:flex-start; }
                    /* left column fixed, right column flexes to fill remaining space */
                    .flexRow > .w420 { flex: 0 0 360px; }
                    .flexRow > .flex1 { flex: 1 1 auto; min-width:240px; }
                    /* Tighter, compact cards — use saved-card theme for consistent parent outline */
                    .tb-card{ border-radius:12px; padding:10px; margin:0 0 10px 0; box-shadow: var(--depth); border:1px solid var(--btnBorder); background: linear-gradient(180deg, rgba(16,25,40,.75), rgba(10,16,28,.75)); }
                    .tb-card.small{ padding:8px }
                    .tb-row{ display:flex; gap:8px; align-items:center }
                    .tb-inputNarrow{ width:62px; margin-left:6px; padding:6px 6px; font-size:12px }
                    .tb-pill{ background:rgba(255,255,255,.03); padding:6px 8px; border-radius:8px; font-size:13px }
                    .tb-pill.small{ padding:4px 6px; font-size:12px }
                    .tb-group-sep{ border-top:1px solid rgba(255,255,255,0.04); margin:6px 0 }
                    .tb-node{ padding:4px 6px; border-radius:4px; margin:2px 0 }

                    /* TOC + Log compact sizes */
                    .toc-wrap{ position:relative; width:100%; box-sizing:border-box }
                    /* Make Log and TOC equal fixed height and compact */
                    .tb-toc{ width:100%; box-sizing:border-box; height:120px; overflow:auto; padding:8px; border-radius:6px; background:rgba(0,0,0,.04); font-size:13px }
                    .tb-log{ height:92px; overflow:auto; background:#051018; padding:8px; border-radius:6px; font-family:monospace; font-size:12px }

                    /* saved preview clamp fallback for non-webkit browsers */
                    #savedPreviewWrap{ display:block; max-height:88px; overflow:hidden; line-height:1.2 }

                    /* Center the small headers above each column and remove extra top spacing */
                    .w420 h3.noTopMargin, .flex1 h3.noTopMargin{ text-align: center; margin: 0 0 6px 0; padding-top:0; font-size:16px; font-weight:800 }
                    /* Ensure the card and row don't add extra top padding pushing headers down */
                    .tb-card .flexRow{ margin-top:0 }
                    .flexRow > .w420 h3.noTopMargin, .flexRow > .flex1 h3.noTopMargin{ margin-top:0 }

                    /* Inline meta readout (single row) */
                    .meta-inline{ display:flex; gap:14px; align-items:center; margin-top:8px }
                    .meta-inline .meta-item{ color:var(--muted); font-size:13px }

                    /* Numeric inputs styled as small pills */
                    .num-pill{ width:64px; text-align:center; border-radius:10px; border:1px solid rgba(255,255,255,0.06); background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01)); padding:8px 10px; margin:0 6px; font-size:13px; min-height:36px; box-sizing:border-box; color:var(--ink); }
                    /* Narrow numeric inputs inside TOC controls — use num-pill visual language */
                    .tb-inputNarrow{ width:64px; margin-left:6px; padding:8px 8px; font-size:13px; border-radius:10px; border:1px solid rgba(255,255,255,0.06); background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01)); color:var(--ink); text-align:center; box-shadow: inset 0 1px 0 rgba(255,255,255,0.02) }
                    .tb-inputNarrow:focus{ outline: 2px solid rgba(96,165,250,.16); outline-offset:2px }
                    /* hide number spinners for a cleaner look */
                    input[type=number].tb-inputNarrow::-webkit-outer-spin-button,
                    input[type=number].tb-inputNarrow::-webkit-inner-spin-button{ -webkit-appearance: none; margin: 0 }
                    input[type=number].tb-inputNarrow{ -moz-appearance: textfield; appearance: textfield }
                    .tb-controls-inline{ display:flex; gap:8px; align-items:center }
                    .tb-control-group{ display:flex; align-items:center; gap:6px; padding:6px 8px }

                    /* Saved card should span full width of its parent column */
                    .w420 .card.saved-card, .flex1 .card.saved-card{ width:100%; box-sizing:border-box }
                    /* Ensure saved-card and tb-card share the same visual treatment */
                    .card.saved-card, .tb-card{ background: linear-gradient(180deg, rgba(16,25,40,.75), rgba(10,16,28,.75)); border:1px solid var(--btnBorder); border-radius:12px; box-shadow: var(--depth); }

                    /* Saved sample viewer (monospace, compact) */
                    .saved-sample{ margin-top:6px; background:#051018; padding:6px; border-radius:6px; font-family:monospace; white-space:pre-wrap; max-height:88px; overflow:hidden; color:#cfe9ff; font-size:12px; line-height:1.2 }
                    /* Tighter controls for saved textbook buttons - match .btn.small sizing so they match Saved MCQ buttons */
                    .saved-controls .btn{ padding:6px 8px; font-size:13px; border-radius:10px; font-weight:700; letter-spacing:.2px }
                    /* Map specific clear buttons to the blue clear style */
                    #clearSavedBtn, #tbClearBtn, #sdClearAll { color: #dfeeff; background: rgba(30,110,220,0.08); border: 1px solid rgba(60,120,220,0.25); }
                    .saved-controls .btn.pill{ border-radius:999px }
                    /* Saved select (dropdown) — match paste-section choose-btn / global button palette */
                    .saved-select{ margin-left:6px; margin-right:6px; background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); border: 1px solid var(--btnBorder); color: var(--ink); padding:6px 10px; border-radius:8px; font-weight:700; font-size:13px; min-height:36px; display:inline-flex; align-items:center; position:relative; -webkit-appearance:none; -moz-appearance:none; appearance:none; padding-right:38px; background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24'><path fill='%23cfe9ff' d='M7 10l5 5 5-5z'/></svg>"); background-repeat:no-repeat; background-position: right 10px center; background-size:12px }
                    .saved-select:focus{ outline: 2px solid rgba(96,165,250,.12); outline-offset:2px }
                    /* Style native option list where supported (browsers vary) */
                    .saved-select option{ background: linear-gradient(180deg, rgba(14,20,32,.9), rgba(10,16,24,.95)); color: var(--ink); padding:6px 10px }
                    /* WebKit scrollbar for the native popup in supported browsers */
                    .saved-select::-webkit-scrollbar{ width: 10px; height: 10px }
                    .saved-select::-webkit-scrollbar-thumb{ background: rgba(255,255,255,0.06); border-radius:8px }
                    /* Fallback: if the platform forces native popup, ensure selected look is themed */
                    .saved-select option:checked{ background: linear-gradient(180deg, rgba(7,20,34,.95), rgba(6,10,18,.95)); color: #cfe9ff }
                    .saved-actions{ display:flex; gap:6px }
                    .saved-list{ max-height:220px; overflow:auto; padding:6px; background:rgba(0,0,0,0.03); border-radius:8px }
                    .saved-row{ margin-bottom:4px; padding:4px }

                    /* Hide native file input, use label.tb-pill as button trigger */
                    input[type="file"]#tbFile{ display:none }
                    /* Make Choose PDF label exactly match the paste-section's choose-btn */
                    label.tb-pill[for="tbFile"]{ display:inline-block; padding:6px 10px; border-radius:8px; background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); border: 1px solid var(--btnBorder); color: var(--ink); font-weight:700; cursor:pointer; font-size:13px; line-height:1; box-shadow: inset 0 1px 0 rgba(255,255,255,.06); }
                    @media (max-width: 640px){ label.tb-pill[for="tbFile"]{ min-height:44px; display:flex; align-items:center } }
                    /* Small scan button visual — match Choose/Index buttons */
                    button#btnScan{ padding:6px 10px; font-size:13px; border-radius:8px; background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); border:1px solid var(--btnBorder); color:var(--ink); font-weight:700; box-shadow: inset 0 1px 0 rgba(255,255,255,.06); cursor:pointer }
                    button#btnScan:disabled{ opacity:0.5; cursor:not-allowed }
                    button#btnScan:hover{ transform: translateY(-1px) }

                    /* Floating save FAB inside TOC preview - restyled to match index button (glass-like) */
                    .tb-save-fab{ position:absolute; right:12px; bottom:8px; background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); border: 1px solid var(--btnBorder); padding:8px 12px; border-radius:999px; box-shadow: var(--depth); cursor:pointer; font-size:13px; z-index:9999; display:inline-flex; align-items:center; justify-content:center; min-height:36px; transition: transform .12s ease, box-shadow .12s ease }
                    .tb-save-fab[disabled]{ opacity:0.5; cursor:not-allowed }
                    .tb-save-fab:hover{ transform:translateY(-2px); box-shadow: 0 10px 28px rgba(0,0,0,.55) }

                    /* Saved list wrapper and toggle */
                    .saved-list-wrap{ border-radius:6px; padding:8px; background:rgba(0,0,0,0.02); margin-top:8px }
                    /* Saved Content title: centered and match preview header sizing */
                    /* Center the Saved Content title and match preview header sizing */
                    .saved-card .row > h4.noTopMargin.small, .saved-card h4.noTopMargin.small{ display:block; width:100%; text-align:center !important; font-size:16px; font-weight:800; margin:6px 0 10px 0; color:var(--ink) }
                    /* Keep inline title appearance unchanged while editing */
                    .si-title-text[contenteditable="true"]{ outline: none; background: transparent; }
                    .saved-toggle-wrap{ margin-left:auto }
                    /* Custom select control (dark themed) */
                    .custom-select{ background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); border:1px solid var(--btnBorder); color:var(--ink); padding:8px 12px; border-radius:8px; min-height:36px; display:flex; align-items:center; cursor:pointer }
                    .custom-select::after{ content:''; margin-left:auto; width:12px; height:12px; background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24'><path fill='%23cfe9ff' d='M7 10l5 5 5-5z'/></svg>"); background-repeat:no-repeat; background-position:center }
                    .custom-select.open{ box-shadow: 0 10px 28px rgba(0,0,0,.55); }
                    .custom-select-list{ position:absolute; left:0; top:calc(100% + 8px); width:100%; max-height:260px; overflow:auto; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background: linear-gradient(180deg, rgba(8,12,18,.95), rgba(6,10,14,.95)); box-shadow:0 14px 28px rgba(0,0,0,.6); z-index:99999 }
                    .custom-select-list .opt{ display:block; width:100%; box-sizing:border-box; padding:8px 12px; color:var(--ink); border-bottom:1px solid rgba(255,255,255,0.02); cursor:pointer; white-space:normal; overflow-wrap:anywhere; text-align:left }
                    .custom-select-list .opt *{ box-sizing:border-box; width:100% }
                /* keep the drop area visually minimal: store selected info in data-selected attribute and do not show text */
                #aiFileTbDrop[data-selected]{ color: transparent; text-shadow: none }
                    .custom-select-list .opt:hover, .custom-select-list .opt[aria-selected='true']{ background: linear-gradient(180deg, rgba(14,20,34,.95), rgba(10,16,24,.95)); color:#cfe9ff }
                    /* wrapper for custom select to replace inline styles */
                    .custom-select-wrap{ position:relative }

                    .tb-total-size{ margin-left:12px; align-self:center; color:var(--muted); font-size:0.9rem; }
                    .custom-select-hidden{ position:absolute; left:0; top:0; opacity:0; pointer-events:none; height:0; width:0; overflow:hidden }
                    /* Compact content library tweaks */
                    .tb-card{ padding:12px 12px; border-radius:10px; background: linear-gradient(180deg, rgba(8,12,18,.45), rgba(10,14,20,.45)); border:1px solid rgba(255,255,255,0.03) }
                    /* Blurb styling moved from inline to CSS to satisfy linter */
                    #contentLibBlurb{ text-align:center; color:var(--muted); font-size:13px; margin:6px 0 }
                    /* Remove extra gap when a blurb precedes the card */
                    #contentLibBlurb + .tb-card{ margin-top:0 }
                    .tb-row{ display:flex; gap:8px; align-items:center }
                    .tb-pill{ display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:8px; background: linear-gradient(180deg, rgba(16,25,40,.35), rgba(10,16,28,.35)); border:1px solid rgba(30,40,60,.25); font-size:13px }
                    .tb-controls-inline{ display:flex; gap:8px; align-items:center }
                    .tb-inputNarrow{ width:64px; padding:6px 8px; font-size:13px }
                    .num-pill{ width:56px }
                    .mt8{ margin-top:8px }
                    .meta-inline{ display:flex; gap:12px; align-items:center; font-size:13px }
                    .w420{ width:360px; display:flex; flex-direction:column }
                    .flexRow{ display:flex; gap:12px; align-items:stretch }
                    .flexRow > .flex1, .flexRow > .w420{ display:flex; flex-direction:column }
                    .toc-wrap{ position:relative; display:flex; flex-direction:column; flex:1 }
                    .tb-log{ height:120px; min-height:120px; max-height:120px; overflow:auto; background: linear-gradient(180deg, rgba(10,12,16,.35), rgba(8,10,14,.35)); border-radius:8px; padding:8px }
                    .tb-toc{ height:120px; min-height:120px; max-height:120px; overflow:auto; font-size:13px; padding:8px }

                    /* ensure the inner content region used for TOC preview respects the fixed size */
                    #tocTree{ height:100%; box-sizing:border-box; overflow:auto }
                    .tb-save-fab{ position:absolute; right:8px; bottom:8px; padding:8px 12px; border-radius:10px }
                    .compact-saved .saved-controls{ gap:8px; align-items:center }
                    .compact-saved-pad{ padding:10px }
                    .compact-saved-controls{ gap:8px; align-items:center }
                    .compact-select-wrap{ max-width:680px }
                </style>

                <h2 class="page-title">Content Library</h2>
                <div id="contentLibBlurb">Choose files to extract chapters and text into your local Content Library. Scan to preview, then use Save to store items; use the Saved Content controls to show, delete, or clear entries.</div>
                <div class="tb-card">
                    <div class="chooser-row">
                        <div class="chooser-left">
                            <div class="tb-row">
                                <label for="tbFile" class="tb-pill">Choose PDF</label>
                                <input id="tbFile" type="file" accept=".pdf,application/pdf" aria-label="PDF file input" />
                                <button id="btnScan" disabled>Scan TOC</button>
                                <div class="tb-controls-inline">
                                    <div class="tb-pill small tb-control-group">Depth
                                        <input id="depthStart" type="number" min="0" value="0" class="tb-inputNarrow num-pill" title="Minimum outline depth" />
                                        <span class="muted">-</span>
                                        <input id="depthEnd" type="number" min="0" value="0" class="tb-inputNarrow num-pill" title="Maximum outline depth" />
                                    </div>
                                    <div class="tb-pill small tb-control-group">Pages
                                        <input id="pageStart" type="number" min="1" placeholder="start" class="tb-inputNarrow num-pill" />
                                        <span class="muted">-</span>
                                        <input id="pageEnd" type="number" min="1" placeholder="end" class="tb-inputNarrow num-pill" />
                                    </div>
                                </div>
                            </div>
                            <div class="meta mt8 meta-inline">
                                <div class="meta-item">File: <span id="metaName">(none)</span></div>
                                <div class="meta-item">Pages: <span id="metaPages">0</span></div>
                                <div class="meta-item">Estimated: <span id="metaBytes">-</span></div>
                                <!-- Save/Clear buttons moved into the saved-textbook UI block below -->
                            </div>
                        </div>

                        <div class="chooser-divider" aria-hidden="true"></div>

                        <div class="chooser-right">
                            <div class="flexRow">
                                <div class="w420">
                                    <h3 class="noTopMargin">Activity / Progress</h3>
                                    <div id="log" class="tb-log"></div>
                                </div>

                                <div class="flex1">
                                    <h3 class="noTopMargin">Content Preview</h3>
                                    <div class="toc-wrap">
                                        <div id="tocTree" class="tb-toc">(no TOC scanned)</div>
                                        <!-- floating save button inside TOC preview wrapper (not inside tocTree content) -->
                                        <button id="tbSaveBtn" class="tb-save-fab" disabled title="Save scanned content">Save</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- notes removed per request -->
            </div>

            <!-- Saved Textbooks: full-width card placed below feature columns -->
            <div class="card saved-card compact-saved mt8 compact-saved-pad">
                <div class="row">
                    <h4 class="noTopMargin small">Saved Content</h4>
                </div>
                <div class="saved-controls row compact-row mt6 compact-saved-controls">
                    <!-- native select kept hidden for compatibility; custom UI shown below -->
                    <div class="flex1 custom-select-wrap compact-select-wrap">
                        <!-- Hidden native select kept for compatibility with existing JS; visible inline custom dropdown below -->
                        <select id="savedSelect" class="visually-hidden" aria-label="Saved content"></select>
                        <div class="custom-inline-dropdown" id="savedSelectInline" role="combobox" aria-haspopup="listbox" aria-expanded="false" tabindex="0" aria-controls="savedSelectList">
                            <span class="inline-selected">(none)</span>
                            <span class="inline-chevron">▾</span>
                        </div>
                        <div class="custom-inline-list hidden" id="savedSelectList" role="listbox" tabindex="-1" aria-labelledby="savedSelectInline"></div>
                    </div>
                    <div class="saved-actions compact-actions">
                        <button id="tbShowBtn" class="btn small" disabled>Show</button>
                        <button id="tbDeleteBtn" class="btn small" disabled>Delete</button>
                        <button id="tbClearBtn" class="btn small" disabled>Clear</button>
                        <div id="tbTotalSize" class="tb-total-size" aria-hidden="true">Total: 0.0 KB</div>
                    </div>
                </div>
                <div class="saved-list-wrap mt6">
                    <div class="mt6 small muted compact-details" id="savedDetails">(select saved content and click Show)</div>
                </div>
            </div>

            <script>
            (function(){
                const $ = id => document.getElementById(id);
                const fileEl = $('tbFile'); const btnScan = $('btnScan');
                const tocTree = $('tocTree'); const logEl = $('log');
                const metaName = $('metaName'); const metaPages = $('metaPages'); const metaBytes = $('metaBytes');
                const depthStartEl = $('depthStart'); const depthEndEl = $('depthEnd'); const pageStart = $('pageStart'); const pageEnd = $('pageEnd');

                let pdfDoc = null; let pdfArrayBuffer = null; let pdfNumPages = 0; let outline = null;
                let flattened = [];
                let pdfjsLoaded = false;
                // per-file TOC cache so repeated scans overwrite previous entries instead of duplicating
                window.tocByFile = window.tocByFile || {};
                window.currentFileKey = window.currentFileKey || null;

                function log(...args){ try{ const s = args.map(a=> typeof a==='string'? a : JSON.stringify(a)).join(' '); const line = new Date().toLocaleTimeString() + ' ' + s; logEl.textContent = line + '\n' + logEl.textContent; }catch(e){ console.log(...args); } }
                function humanBytes(n){ if(!n && n!==0) return '-'; const units=['B','KB','MB','GB']; let u=0; while(n>=1024 && u<units.length-1){ n/=1024; u++; } return n.toFixed(n<10?2:1)+' '+units[u]; }

                async function loadScript(url){ return new Promise((res,rej)=>{ const s=document.createElement('script'); s.src=url; s.onload=res; s.onerror=()=>rej(new Error('load failed '+url)); document.head.appendChild(s); }); }
                async function ensurePdfJs(){ if(window.pdfjsLib && pdfjsLoaded) return true; const ver='2.16.105'; const candidates=[
                    `https://cdn.jsdelivr.net/npm/pdfjs-dist@${ver}/build/pdf.min.js`,
                    `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${ver}/pdf.min.js`,
                    `https://unpkg.com/pdfjs-dist@${ver}/build/pdf.min.js`
                ];
                for(const c of candidates){ try{ await loadScript(c); log('loaded pdfjs', c); window.pdfjsLib = window.pdfjsLib || window['pdfjs-dist/build/pdf']; try{ window.pdfjsLib.GlobalWorkerOptions.workerSrc = c.replace(/pdf.min.js$/, 'pdf.worker.min.js'); }catch{} pdfjsLoaded=true; return true;}catch(e){ log('pdfjs load failed', c); } }
                log('pdfjs could not be loaded from any CDN'); return false; }

                // Remove control/unprintable characters and collapse whitespace in titles
                function sanitizeTitle(s){
                    if(!s && s !== 0) return '';
                    try{
                        // remove C0/C1 control ranges and replacement characters, strip a few filesystem-unsafe chars
                        return String(s)
                            .replace(/[\x00-\x1F\x7F-\x9F\uFFFD]/g, '')
                            .replace(/[\\/:*?"<>|]/g, '')
                            .replace(/\s+/g, ' ')
                            .trim()
                            .slice(0, 180);
                    }catch(e){ return String(s||'').trim(); }
                }

                function flattenOutline(outl){
                    const arr=[];
                    function walk(items, depth){
                        if(!items) return;
                        for(const it of items){
                            const rawTitle = it && it.title ? it.title : 'Untitled';
                            const node = {
                                title: sanitizeTitle(rawTitle),
                                dest: it.dest || it.destref || it.dest || it.title,
                                raw: it,
                                depth: depth
                            };
                            arr.push(node);
                            if(it.items && it.items.length) walk(it.items, depth+1);
                        }
                    }
                    walk(outl, 0);
                    return arr;
                }

                function detectChapterDepth(arr){ if(!arr || !arr.length) return 0; const score = {}; const reNum = /^\s*(?:Chapter\b|Ch\.|\d+[.):]|[IVXLCDM]+[.):]|\d+\s)/i; for(const it of arr){ const d = it.depth||0; if(!score[d]) score[d]=0; if(reNum.test(it.title)) score[d]++; } let bestDepth = 0; let best = -1; for(const k in score){ if(score[k] > best){ best = score[k]; bestDepth = parseInt(k,10); } } if(best <= 0) return 0; return bestDepth; }

                async function resolveDestToPageIndex(doc, dest){ try{ if(!dest) return null; let resolved = null; try{ if(typeof dest === 'string'){ resolved = await doc.getDestination(dest); } else if(Array.isArray(dest)) resolved = dest; else if(dest && dest.getArray) resolved = await dest.getArray(); }catch(e){} if(!resolved){ if(dest && dest.num) resolved = [dest]; } if(!resolved) return null; const ref = resolved[0]; if(!ref) return null; const pageIndex = await doc.getPageIndex(ref); return pageIndex; }catch(e){ log('resolveDestToPageIndex failed', e?.message||e); return null; } }

                async function extractPageText(doc, pnum){ try{ const page = await doc.getPage(pnum); const txt = await page.getTextContent({ normalizeWhitespace:true, disableCombineTextItems:false, includeMarkedContent:true }); const parts = txt.items.map(it=> String(it.str || '') ); const s = parts.join(' ').replace(/\s+/g,' ').trim(); return s; }catch(e){ log('page extract failed', pnum, e?.message||e); return ''; } }

                // Extract a range of pages, optionally performing OCR on rendered page images to capture text inside figures/scans.
                // Returns: { text: string, charCount: number }
                async function extractRangeText(doc, startPage, endPage, opts){
                    opts = Object.assign({ ocr: false, ocrLang: 'eng', ocrScale: 2, ocrIfNoText: true, perPage: false }, opts || {});
                    const results = [];
                    // local helper to ensure tesseract is available when OCR is requested
                    async function ensureTesseractLocal(){
                        if(window.Tesseract && (window.Tesseract.recognize || window.Tesseract.createWorker)) return true;
                        try{
                            await loadScript('https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js');
                            return !!(window.Tesseract && (window.Tesseract.recognize || window.Tesseract.createWorker));
                        }catch(e){ log('tesseract load failed', e?.message||e); return false; }
                    }

                    async function renderPageToBlob(page, scale){
                        try{
                            const viewport = page.getViewport({ scale: scale || 2 });
                            const canvas = document.createElement('canvas');
                            canvas.width = Math.round(viewport.width);
                            canvas.height = Math.round(viewport.height);
                            const ctx = canvas.getContext('2d');
                            const renderTask = page.render({ canvasContext: ctx, viewport });
                            if(renderTask && renderTask.promise) await renderTask.promise; else await new Promise(r=> setTimeout(r,250));
                            return await new Promise(res=> canvas.toBlob(res, 'image/png'));
                        }catch(e){ log('renderPageToBlob failed', e?.message||e); return null; }
                    }

                    // iterate pages in order and combine text + OCR text per page
                    const start = Math.max(1, Number(startPage)||1);
                    const end = Math.min(doc.numPages || endPage, Number(endPage) || start);
                    // If OCR is requested, ensure tesseract is available (but proceed without OCR if it fails)
                    let haveTess = false;
                    if(opts.ocr || opts.ocrIfNoText) haveTess = await ensureTesseractLocal();

                    for(let p = start; p <= end; p++){
                        try{
                            const page = await doc.getPage(p);
                            // page text via pdf.js
                            let pageText = '';
                            try{ const txt = await page.getTextContent({ normalizeWhitespace:true, disableCombineTextItems:false, includeMarkedContent:true }); pageText = (txt && Array.isArray(txt.items))? txt.items.map(it=> String(it.str||'')).join(' ').replace(/\s+/g,' ').trim() : ''; }catch(e){ pageText = ''; }

                            let ocrText = '';
                            const needOcr = opts.ocr || (opts.ocrIfNoText && (!pageText || pageText.length < 40));
                            if(needOcr && haveTess){
                                try{
                                    const blob = await renderPageToBlob(page, opts.ocrScale || 2);
                                    if(blob){
                                        // Tesseract v4 exposes Tesseract.recognize
                                        if(window.Tesseract && window.Tesseract.recognize){
                                            const res = await window.Tesseract.recognize(blob, opts.ocrLang || 'eng');
                                            ocrText = (res && res.data && res.data.text) ? String(res.data.text).trim() : (res && res.text? String(res.text).trim() : '');
                                        } else if(window.Tesseract && window.Tesseract.createWorker){
                                            // fallback worker API
                                            const worker = window.Tesseract.createWorker({ logger: ()=>{} });
                                            await worker.load(); await worker.loadLanguage(opts.ocrLang||'eng'); await worker.initialize(opts.ocrLang||'eng');
                                            const { data } = await worker.recognize(blob); ocrText = (data && data.text)? String(data.text).trim() : ''; await worker.terminate();
                                        }
                                    }
                                }catch(e){ log('OCR failed on page', p, e?.message||e); }
                            }

                            if(opts.perPage){
                                results.push({ page: p, text: pageText, ocr: ocrText, merged: pageText + (ocrText? '\n[OCR]\n' + ocrText : '') });
                            } else {
                                let merged = '';
                                if(pageText) merged += pageText;
                                if(ocrText) merged += (merged? '\n[OCR]\n' : '') + ocrText;
                                if(!merged) merged = '';
                                results.push(merged);
                            }
                            // cooperative yield
                            await new Promise(r=> setTimeout(r,0));
                        }catch(e){ log('extractRangeText page failed', p, e?.message||e); results.push(''); }
                    }

                    if(opts.perPage){
                        // return detailed per-page array
                        return { pages: results, charCount: results.reduce((a,r)=> a + (r && r.merged? r.merged.length : (r && r.merged===''?0:0)), 0) };
                    }
                    const joined = results.filter(Boolean).join('\n\n');
                    return { text: joined, charCount: joined.length };
                }

                function computeChapterRanges(entries, chapterDepth, numPages){ const chapters = entries.filter(e => Number.isFinite(e.page) && e.depth === chapterDepth).sort((a,b)=> a.page - b.page); for(let i=0;i<chapters.length;i++){ const start = chapters[i].page; const end = (i < chapters.length - 1) ? (chapters[i+1].page - 1) : numPages; chapters[i].startPage = Math.max(1, start); chapters[i].endPage = Math.min(numPages, end); } return chapters; }

                async function buildPageLengthCache(doc, ranges){ if(!ranges || !ranges.length) return {}; const minP = Math.min(...ranges.map(r=> r.startPage)); const maxP = Math.max(...ranges.map(r=> r.endPage)); const cache = {}; for (let p = minP; p <= maxP; p++){ try { const t = await extractPageText(doc, p); cache[p] = t.length; } catch (e){ cache[p] = 0; } await new Promise(r=> setTimeout(r,0)); } return cache; }

                function sumCharsFromCache(cache, start, end, limit){ let total = 0; for (let p = start; p <= end; p++){ const len = cache[p] || 0; if (limit && len > limit) continue; total += len; } return total; }

                async function scanTOC(){
                    if(!pdfDoc) return;
                    // clear previous log for this scan
                    try{ if(logEl) logEl.textContent = ''; }catch{}
                    log('scanning TOC...');
                    // reset working state so duplicates don't accumulate
                    outline = null;
                    flattened = [];
                    window.fullToc = [];
                    try{ tocTree.innerHTML = '(scanning...)'; }catch{};

                    outline = await pdfDoc.getOutline();
                    if(!outline || !outline.length){
                        log('no outline/bookmarks found');
                        flattened=[]; renderTOC(flattened);
                        if(window.currentFileKey) window.tocByFile[window.currentFileKey] = window.fullToc || [];
                        return;
                    }

                    const flat = flattenOutline(outline);
                    log('outline entries', flat.length);
                    if(Array.isArray(outline) && outline.some(it => it && Array.isArray(it.items) && it.items.length>0)){
                        detectedChapterDepth = 1;
                        log('detected chapters as secondary items (depth 1) because top-level entries have children');
                    } else {
                        detectedChapterDepth = detectChapterDepth(flat);
                        log('detected chapter depth (heuristic)', detectedChapterDepth);
                    }

                    for(let i=0;i<flat.length;i++){
                        const it=flat[i];
                        try{
                            const pageIndex = await resolveDestToPageIndex(pdfDoc, it.raw.dest || it.raw.destref || it.raw.destref|| it.raw.a || it.raw.dest);
                            it.page = (pageIndex!=null)? (pageIndex+1) : null;
                            log('resolved', i+1, it.title, '->', it.page);
                        }catch(e){ log('resolve failed for', it.title, e?.message||e); it.page=null; }
                    }

                    const withPage = flat.filter(x=> Number.isFinite(x.page)).sort((a,b)=> a.page - b.page);
                    const withoutPage = flat.filter(x=> !Number.isFinite(x.page));
                    const sorted = withPage.concat(withoutPage);

                    const chapterEntries = computeChapterRanges(sorted, detectedChapterDepth, pdfNumPages);
                    for (const e of sorted) {
                        if (e.depth === detectedChapterDepth) {
                            const found = chapterEntries.find(c => c === e || (c.title===e.title && c.page===e.page));
                            if (found) { e.startPage = found.startPage; e.endPage = found.endPage; }
                        } else {
                            e.startPage = e.page || 1;
                            e.endPage = e.page || e.startPage;
                        }
                    }

                    window.fullToc = sorted.map((s, idx)=> ({ uid: idx, order: idx+1, title: s.title, depth: s.depth, startPage: s.startPage, endPage: s.endPage, page: s.page, raw: s.raw }));
                    flattened = window.fullToc.map(s=> ({ uid: s.uid, order: s.order, title: s.title, depth: s.depth, startPage: s.startPage, endPage: s.endPage, page: s.page }));
                    try{ window.flattened = flattened; }catch(e){}

                    const LIMIT = null;
                    // Build page-length cache across all entries that have numeric start/end pages
                    const entriesForCount = window.fullToc.filter(s => Number.isFinite(s.startPage) && Number.isFinite(s.endPage));
                    try{
                        if(entriesForCount.length){
                            const pageLenCache = await buildPageLengthCache(pdfDoc, entriesForCount);
                            for (const s of window.fullToc){
                                if (Number.isFinite(s.startPage) && Number.isFinite(s.endPage)){
                                    s.charCount = sumCharsFromCache(pageLenCache, s.startPage, s.endPage, LIMIT);
                                } else { s.charCount = s.charCount || 0; }
                            }
                            // Attempt to extract full text for each chapter so saved payloads can include full content
                            try{
                                const FULL_SAVE_LIMIT = 500000; // cap per-chapter saved text to avoid runaway sizes
                                for (const s of window.fullToc){
                                    if (!Number.isFinite(s.startPage) || !Number.isFinite(s.endPage)) continue;
                                    try{
                                        let txt = '';
                                        if(typeof extractRangeText === 'function'){
                                            try{ const r = await extractRangeText(pdfDoc, s.startPage, s.endPage); txt = String(r && r.text ? r.text : ''); if(r && Number.isFinite(r.charCount)) s.charCount = r.charCount; }catch(e){ txt = ''; }
                                        } else if(typeof extractPageText === 'function'){
                                            let acc = '';
                                            for(let p = s.startPage; p <= s.endPage; p++){
                                                try{ const ptxt = await extractPageText(pdfDoc, p); if(ptxt) acc += ptxt + '\n\n'; }catch(e){ /* ignore */ }
                                                if(acc.length > FULL_SAVE_LIMIT) break;
                                            }
                                            txt = acc;
                                        }
                                        if(txt){ if(txt.length > FULL_SAVE_LIMIT) txt = txt.slice(0, FULL_SAVE_LIMIT); s.text = txt; s.snippet = txt.slice(0,20000); }
                                    }catch(e){ /* ignore per-chapter extract errors */ }
                                }
                            }catch(e){ log('chapter text extraction in scanTOC failed', e?.message||e); }
                        } else {
                            // nothing to count; set defaults
                            for (const s of window.fullToc) s.charCount = s.charCount || 0;
                        }
                        for (const f of flattened){ const full = window.fullToc.find(x=> x.uid === f.uid); f.charCount = full ? (full.charCount || 0) : 0; }
                    }catch(e){ log('quick count failed', e?.message||e); }

                    // persist/overwrite this file's TOC to avoid duplicates in future scans
                    if(window.currentFileKey) window.tocByFile[window.currentFileKey] = window.fullToc;

                    applyFiltersAndMeta();
                    try{ const sb = document.getElementById('tbSaveBtn'); if(sb) sb.disabled = false; }catch(e){}
                }

                let detectedChapterDepth = 0;
                function renderTOC(arr, startDepth = null){ if(!arr || !arr.length){ tocTree.innerHTML = '<div class="muted">(no TOC)</div>'; return; } const root=document.createElement('div'); let lastGroup = null; arr.forEach((it,idx)=>{ const d = it.depth; const indentBase = (startDepth!=null) ? Math.max(0, d - startDepth) : d; if(startDepth!=null && d === startDepth && lastGroup !== it.startPage){ const sep = document.createElement('div'); sep.className = 'tb-group-sep'; root.appendChild(sep); lastGroup = it.startPage; } const el = document.createElement('div'); el.className = 'tb-node'; el.style.paddingLeft=(indentBase*18)+'px'; const title=document.createElement('div'); title.textContent = `${String(idx+1).padStart(2,'0')} ${it.title}`; const meta=document.createElement('div'); meta.className='small muted'; const cc = (typeof it.charCount === 'number') ? it.charCount : (it.charCount || 0); meta.textContent = `pages ${it.startPage||'?'} - ${it.endPage||'?'} (${cc} chars)`; el.appendChild(title); el.appendChild(meta); root.appendChild(el); }); tocTree.innerHTML=''; tocTree.appendChild(root); }

                function applyFiltersAndMeta(){ const ds = parseInt(depthStartEl.value,10); const de = parseInt(depthEndEl.value,10); const minD = Number.isFinite(ds) ? ds : 0; const maxD = Number.isFinite(de) ? de : Math.max(9, minD); let filtered = flattened.filter(f => f.depth >= minD && f.depth <= maxD); const start = parseInt(pageStart.value,10) || 1; const end = parseInt(pageEnd.value,10) || pdfNumPages; filtered.forEach(f=>{ f.startPage = Math.max(start, f.startPage||1); f.endPage = Math.min(end, f.endPage||pdfNumPages); if(f.startPage>f.endPage) f.invalid=true; }); const finalList = filtered.filter(f=>!f.invalid && f.startPage<=f.endPage); finalList.forEach(f=> f.charCount = f.charCount || 0); renderTOC(finalList, minD); metaName.textContent = fileEl.files && fileEl.files[0] ? fileEl.files[0].name : '(none)'; metaPages.textContent = pdfNumPages; metaBytes.textContent = humanBytes(pdfArrayBuffer?pdfArrayBuffer.byteLength:0); flattened = finalList; try{ window.flattened = finalList; }catch(e){} }

                fileEl.addEventListener('change', async (e)=>{
                    const f = e.target.files && e.target.files[0]; if(!f) return;
                    // stable key: name::size::lastModified to identify same file across scans
                    const fileKey = `${f.name}::${f.size}::${f.lastModified||0}`;
                    window.currentFileKey = fileKey;
                    metaName.textContent = f.name; metaPages.textContent = '...'; metaBytes.textContent = humanBytes(f.size);
                    log('file selected', f.name, humanBytes(f.size), 'key=', fileKey);
                    // clear UI of previous scan results to avoid duplicate accumulation
                    try{ tocTree.innerHTML = '(no TOC scanned)'; logEl.textContent = ''; }catch{}
                    pdfArrayBuffer = await f.arrayBuffer(); await ensurePdfJs();
                    try{
                        pdfDoc = await window.pdfjsLib.getDocument({ data: pdfArrayBuffer }).promise;
                        pdfNumPages = pdfDoc.numPages; metaPages.textContent = pdfNumPages; log('loaded PDF', f.name, 'pages', pdfNumPages);
                        btnScan.disabled=false;
                        // If we have a cached TOC for this exact file, pre-populate it (overwrite semantics maintained on scan)
                        if(window.tocByFile && window.tocByFile[fileKey] && window.tocByFile[fileKey].length){
                            window.fullToc = window.tocByFile[fileKey];
                            flattened = window.fullToc.map(s=> ({ uid: s.uid, order: s.order, title: s.title, depth: s.depth, startPage: s.startPage, endPage: s.endPage, page: s.page, charCount: s.charCount }));
                            applyFiltersAndMeta();
                        }
                    }catch(err){ log('pdf open failed', err?.message||err); btnScan.disabled=true; }
                });

                btnScan.addEventListener('click', async ()=>{ if(!pdfDoc) return; // clear log when user requests a scan
                    try{ if(logEl) logEl.textContent = ''; }catch{}; btnScan.disabled=true; log('Scan TOC starting...'); try{ await scanTOC(); log('scan complete'); }catch(e){ log('scan failed', e?.message||e); } btnScan.disabled=false; });

                // Save scanned textbook into persistent library (saves current preview)
                const tbSaveBtn = document.getElementById('tbSaveBtn');
                tbSaveBtn?.addEventListener('click', async ()=>{
                    // Save what's currently visible in the preview (`flattened`), not the raw full TOC
                    if(!(Array.isArray(flattened) && flattened.length) || !pdfDoc) { alert('No scanned TOC available to save.'); return; }
                    try{
                        tbSaveBtn.disabled = true;
                        log('building save package...');
                        log('debug: window.loadTextbookLib=', !!window.loadTextbookLib, 'window.saveTextbookLib=', !!window.saveTextbookLib);
                        // Build a lightweight chapters array from the preview: title, startPage, endPage, and small text excerpt
                        const chapters = [];
                        for(const item of flattened){
                            try{
                                const start = Number.isFinite(item.startPage)? item.startPage : (Number.isFinite(item.page)? item.page : 1);
                                const end = Number.isFinite(item.endPage)? item.endPage : start;
                                // extract up to first 20k chars across these pages
                                let txt='';
                                for(let p=start; p<=end; p++){
                                    try{ const s = await extractPageText(pdfDoc, p); if(s) txt += s + '\n\n'; if(txt.length > 200000) break; }catch(e){ log('page extract part failed', e?.message||e); }
                                }
                                const snippet = (txt||'').slice(0,20000);
                                const charCount = (txt && txt.length) ? txt.length : 0;
                                chapters.push({ title: item.title || 'Chapter', uid: item.uid, startPage: start, endPage: end, charCount: charCount, snippet: snippet });
                            }catch(e){ log('chapter build failed', e?.message||e); chapters.push({ title: item.title||'Chapter', text: '' }); }
                        }
                        const bookTitle = metaName.textContent || ('Book ' + (new Date()).toLocaleString());
                        log('prepared book', bookTitle, 'chapters', chapters.length);
                        const LS_KEY = 'textbook.lib.v1';
                        let lib = [];
                        try{
                            if(window.loadTextbookLib){ log('using window.loadTextbookLib()'); lib = window.loadTextbookLib(); }
                            else { log('reading localStorage key', LS_KEY); lib = JSON.parse(localStorage.getItem(LS_KEY) || '[]'); }
                        }catch(e){ log('load failed', e?.message||e); lib = []; }
                        // Use consistent record shape with payload so saved entries include full metadata
                        // Persist full content into IndexedDB first (heavy record), then write a lightweight pointer into localStorage
                        let ok = false;
                        try{
                            // Build heavyweight chapters with full text for IDB storage (do this sequentially)
                            const heavyChapters = [];
                            for (const item of flattened){
                                try{
                                    const start = Number.isFinite(item.startPage)? item.startPage : (Number.isFinite(item.page)? item.page : 1);
                                    const end = Number.isFinite(item.endPage)? item.endPage : start;
                                    let fullText = '';
                                    // Prefer range extractor when available
                                    if(window.pdfDoc && typeof extractRangeText === 'function'){
                                        try{ const r = await extractRangeText(window.pdfDoc, start, end); fullText = String(r && r.text ? r.text : ''); }catch(e){ fullText = ''; }
                                    } else if(window.pdfDoc){
                                        // fallback to iterating pages
                                        let acc = '';
                                        for(let p = start; p <= end; p++){
                                            try{ const s = typeof extractPageText === 'function' ? await extractPageText(window.pdfDoc, p) : (typeof tbExtractPageText === 'function' ? await tbExtractPageText(window.pdfDoc, p) : ''); if(s) acc += s + '\n\n'; }catch(e){ /* ignore */ }
                                        }
                                        fullText = acc;
                                    }
                                    const snippet = (fullText||'').slice(0,20000);
                                    const charCount = fullText ? fullText.length : 0;
                                    // include `text` for compatibility with existing readers
                                    heavyChapters.push({ title: item.title||'Chapter', uid: item.uid, startPage: start, endPage: end, charCount: charCount, snippet: snippet, text: fullText, fullText: fullText });
                                }catch(e){ heavyChapters.push({ title: item.title||'Chapter', uid: item.uid, startPage: item.startPage||1, endPage: item.endPage||item.startPage||1, charCount: 0, snippet: '', fullText: '' }); }
                            }

                            const heavyRec = { title: sanitizeTitle(bookTitle), meta: { savedAt: Date.now(), pages: pdfNumPages, fileName: bookTitle }, payload: { savedAt: Date.now(), items: flattened, chapters: heavyChapters, meta: { fileName: bookTitle, pages: pdfNumPages } } };
                            // store full record in IndexedDB
                            try{
                                const storedId = await idbPutBook(heavyRec);
                                log('indexedDB stored heavy book id', storedId);
                                // write a lightweight pointer into localStorage so UI can show the saved entry quickly
                                try{
                                    if(window.loadTextbookLib){ log('using window.loadTextbookLib() to read lib'); lib = window.loadTextbookLib(); }
                                    else { log('reading localStorage key', LS_KEY); lib = JSON.parse(localStorage.getItem(LS_KEY) || '[]'); }
                                }catch(e){ lib = []; }
                                const pointer = { title: bookTitle, text: '', idbRef: storedId, meta: { pages: pdfNumPages, fileName: bookTitle, savedAt: (new Date()).toISOString() } };
                                lib.push(pointer);
                                try{ localStorage.setItem(LS_KEY, JSON.stringify(lib)); ok = true; log('wrote pointer to localStorage'); }
                                catch(localErr){ log('writing pointer to localStorage failed', localErr?.message||localErr); ok = true; /* pointer failed but heavy record is in IDB so mark ok true */ }
                            }catch(idbErr){ log('idbPutBook failed', idbErr?.message||idbErr); ok = false; }
                        }catch(e){ log('save to IDB failed', e?.message||e); ok = false; }
                        if(ok){ log('save succeeded'); try{ if(window.setTextbookStatus) window.setTextbookStatus('Saved content to library.'); else setStatus && setStatus('Saved content to library.'); try{ if(window.refreshTextbookLibrary) window.refreshTextbookLibrary(); }catch(e){ log('refresh failed', e?.message||e); } }catch(e){ log('status update failed', e?.message||e); } }
                        else {
                            log('save failed; no download fallback (removed)');
                            try{ if(window.setTextbookStatus) window.setTextbookStatus('Could not save content.', true); else setStatus && setStatus('Could not save content.', true); }catch(e){}
                        }
                    }catch(e){ log('save failed', e?.message||e); try{ if(window.setTextbookStatus) window.setTextbookStatus('Save failed', true); else setStatus && setStatus('Save failed', true); }catch(err){ log('status fallback failed', err); } }
                    finally{ try{ tbSaveBtn.disabled = false; }catch(e){} }
                });

                ['dragover','drop'].forEach(ev=> document.addEventListener(ev, (e)=>{ e.preventDefault(); }));
                document.addEventListener('drop', (e)=>{ if(e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length){ fileEl.files = e.dataTransfer.files; fileEl.dispatchEvent(new Event('change')); } });

            })();
            </script>
        </section>

    <script>
    (function(){
    // Inserted verbatim from index.html: IndexedDB-backed saved textbook UI + handlers
        // IndexedDB helpers
        async function idbOpen(){ return new Promise((res,rej)=>{ try{ const req = indexedDB.open('pdf-toc-lib', 1); req.onupgradeneeded = (evt)=>{ const db = evt.target.result; if(!db.objectStoreNames.contains('books')){ db.createObjectStore('books', { keyPath: 'id', autoIncrement: true }); } }; req.onsuccess = ()=> res(req.result); req.onerror = ()=> rej(req.error); }catch(e){ rej(e); } }); }
        async function idbPutBook(book){ const db = await idbOpen(); return new Promise((res, rej)=>{ const tx = db.transaction('books','readwrite'); const store = tx.objectStore('books'); const req = store.add(book); req.onsuccess = ()=>{ res(req.result); db.close(); }; req.onerror = ()=>{ rej(req.error); db.close(); }; }); }
        async function idbGetAllBooks(){ const db = await idbOpen(); return new Promise((res, rej)=>{ const tx = db.transaction('books','readonly'); const store = tx.objectStore('books'); const req = store.getAll(); req.onsuccess = ()=>{ res(req.result || []); db.close(); }; req.onerror = ()=>{ rej(req.error); db.close(); }; }); }
        async function idbGetBook(id){ const db = await idbOpen(); return new Promise((res, rej)=>{ const tx = db.transaction('books','readonly'); const store = tx.objectStore('books'); const req = store.get(id); req.onsuccess = ()=>{ res(req.result); db.close(); }; req.onerror = ()=>{ rej(req.error); db.close(); }; }); }
        async function idbDeleteBook(id){ const db = await idbOpen(); return new Promise((res, rej)=>{ const tx = db.transaction('books','readwrite'); const store = tx.objectStore('books'); const req = store.delete(id); req.onsuccess = ()=>{ res(true); db.close(); }; req.onerror = ()=>{ rej(req.error); db.close(); }; }); }

        // --- Export helpers: single .txt download and bulk .zip using JSZip ---
        function downloadBlob(blob, filename){ try{ const a = document.createElement('a'); const url = URL.createObjectURL(blob); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); try{ a.remove(); }catch{} }, 5000); }catch(e){ console.error('downloadBlob failed', e); }
        }

        async function ensureJSZip(){ if(window.JSZip) return window.JSZip; // try common CDN
            try{ await new Promise((res,rej)=>{ const s = document.createElement('script'); s.src = 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js'; s.onload = res; s.onerror = rej; document.head.appendChild(s); }); return window.JSZip; }catch(e){ console.warn('JSZip load failed', e); throw e; } }

        function sanitizeFilename(s){ try{ return String(s||'untitled').replace(/[\\/:*?"<>|\x00-\x1F]/g,'_').replace(/\s+/g,' ').trim().slice(0,180); }catch(e){ return 'untitled'; } }

        async function exportSingleChapter(ch, recTitle){ try{
            // prefer full text fields when available
            const txt = String(ch.text || ch.fullText || ch.snippet || ch.title || '');
            const filename = sanitizeFilename((recTitle? recTitle + ' - ' : '') + (ch.title || 'chapter')) + '.txt';
            const blob = new Blob([txt], { type: 'text/plain;charset=utf-8' });
            downloadBlob(blob, filename);
        }catch(e){ console.error('exportSingleChapter failed', e); alert('Export failed: ' + (e?.message||e)); } }

        async function exportAllSaved(){ try{
            const btn = document.getElementById('exportAllSavedBtn'); if(btn) { btn.disabled = true; const old = btn.textContent; btn.textContent = 'Preparing…'; }
            const all = await idbGetAllBooks(); if(!all || !all.length){ alert('No saved items to export.'); if(btn){ btn.disabled=false; btn.textContent = old || 'Export all (.zip)'; } return; }
            const JSZipLib = await ensureJSZip(); const zip = new window.JSZip();
            for(const rec of all){ try{
                    const title = rec.title || ('record-' + (rec.id||Date.now()));
                    const payload = rec.payload || {};
                    // If record has chapters, export each chapter as its own file, else create a single file per record
                    if(Array.isArray(payload.chapters) && payload.chapters.length){
                        for(const ch of payload.chapters){ const fname = sanitizeFilename(title + ' - ' + (ch.title||'chapter')) + '.txt'; const content = String(ch.text || ch.fullText || ch.snippet || ch.title || ''); zip.file(fname, content); }
                    } else {
                        const fname = sanitizeFilename(title) + '.txt'; const content = String(rec.text || (payload && payload.text) || ''); zip.file(fname, content);
                    }
            }catch(e){ console.warn('skipping record during zip', e); }
            }
            const blob = await zip.generateAsync({ type: 'blob' });
            const zipName = `saved-mcqs-${(new Date()).toISOString().replace(/[:.]/g,'-')}.zip`;
            downloadBlob(blob, zipName);
            if(btn) { btn.disabled=false; btn.textContent = old || 'Export all (.zip)'; }
        }catch(e){ console.error('exportAllSaved failed', e); alert('Export all failed: ' + (e?.message||e)); try{ const b = document.getElementById('exportAllSavedBtn'); if(b){ b.disabled = false; b.textContent = 'Export all (.zip)'; } }catch{} }
        }

        function log(...args){ try{ const s = args.map(a=> typeof a==='string'? a : JSON.stringify(a)).join(' '); const line = new Date().toLocaleTimeString() + ' ' + s; const logEl = document.getElementById('log') || document.getElementById('tbLog'); if(logEl) logEl.textContent = line + '\n' + logEl.textContent; }catch(e){ console.log(...args); } }

        function populateSavedSelect(items){
            const savedSelect = document.getElementById('savedSelect');
            const inlineTrigger = document.getElementById('savedSelectInline');
            const inlineList = document.getElementById('savedSelectList');
            if(!savedSelect || !inlineTrigger || !inlineList) return;
            // keep the hidden native select in sync for compatibility
            savedSelect.innerHTML = '';
            const emptyOpt = document.createElement('option');
            emptyOpt.value = '';
            emptyOpt.textContent = '(none)';
            savedSelect.appendChild(emptyOpt);
            // clear inline list
            inlineList.innerHTML = '';

            const tbClearBtn = document.getElementById('tbClearBtn');
            const tbShowBtn = document.getElementById('tbShowBtn');
            const tbDeleteBtn = document.getElementById('tbDeleteBtn');
            const tbTotalSizeEl = document.getElementById('tbTotalSize');

            if(!items || !items.length){
                if(tbClearBtn) tbClearBtn.disabled = true;
                if(tbShowBtn) tbShowBtn.disabled = true;
                if(tbDeleteBtn) tbDeleteBtn.disabled = true;
                if(tbTotalSizeEl) tbTotalSizeEl.textContent = 'Total: 0.0 KB';
                const savedDetails = document.getElementById('savedDetails'); if(savedDetails) savedDetails.textContent='(select saved content and click Show)';
                return;
            }

            if(tbClearBtn) tbClearBtn.disabled = false;
            let totalBytes = 0;
            for(const it of items){
                try{
                    const o = document.createElement('option');
                    o.value = String(it.id);
                    let rangeText = (it.meta && it.meta.pages) ? `${it.meta.pages} pages` : '? pages';
                    try{
                        const payload = it.payload || {};
                        if(Array.isArray(payload.chapters) && payload.chapters.length){
                            let s = Infinity, e = -Infinity;
                            for(const c of payload.chapters){ if(Number.isFinite(c.startPage)) s = Math.min(s, Number(c.startPage)); if(Number.isFinite(c.endPage)) e = Math.max(e, Number(c.endPage)); }
                            if(s !== Infinity && e !== -Infinity) rangeText = (s===e)? `${s} pages` : `${s}-${e} pages`;
                            else if(s !== Infinity) rangeText = `${s} pages`;
                        }
                    }catch(e){}
                    let sizeBytes = 0;
                    try{
                        const payload = it.payload || {};
                        if(Array.isArray(payload.chapters) && payload.chapters.length){
                            for(const c of payload.chapters){ const s = (c && (c.text || c.fullText || c.snippet || '')) || ''; sizeBytes += (s.length || 0); }
                        } else if(it.text && typeof it.text === 'string') sizeBytes = it.text.length || 0;
                    }catch(e){ sizeBytes = 0; }
                    totalBytes += (sizeBytes || 0);
                    const sizeText = sizeBytes ? ` • ${(sizeBytes/1024).toFixed(1)} KB` : '';
                    const labelText = `${it.title || '(untitled)'} — ${rangeText}${sizeText}`;
                    o.textContent = labelText;
                    savedSelect.appendChild(o);
                    // also populate inline list item
                    const item = document.createElement('div');
                    item.className = 'custom-inline-item';
                    item.setAttribute('role','option');
                    item.setAttribute('data-id', String(it.id));
                    item.tabIndex = -1;
                    item.textContent = labelText;
                    // click handler
                    item.addEventListener('click', (ev)=>{
                        try{ savedSelect.value = String(it.id); savedSelect.dispatchEvent(new Event('change', { bubbles:true })); }
                        catch(e){}
                        // update trigger label and close
                        try{ inlineTrigger.querySelector('.inline-selected').textContent = labelText; inlineTrigger.setAttribute('aria-expanded','false'); inlineList.classList.add('hidden'); }
                        catch(e){}
                    });
                    inlineList.appendChild(item);
                }catch(e){ /* ignore item errors */ }
            }
            if(tbTotalSizeEl) tbTotalSizeEl.textContent = `Total: ${(totalBytes/1024).toFixed(1)} KB`;
            if(tbShowBtn) tbShowBtn.disabled = false;
            if(tbDeleteBtn) tbDeleteBtn.disabled = false;
            const savedDetails = document.getElementById('savedDetails'); if(savedDetails) savedDetails.textContent='(select saved content and click Show)';
            // update inline trigger label if nothing selected
            try{ const sel = savedSelect.value || ''; const first = sel ? inlineList.querySelector(`.custom-inline-item[data-id="${sel}"]`) : null; if(!first){ inlineTrigger.querySelector('.inline-selected').textContent = '(none)'; } }
            catch(e){}
        }

        async function refreshSavedList(){
            try{
                const all = await idbGetAllBooks();
                // include payload so populateSavedSelect can compute scanned ranges
                const mapped = all.map(a=> ({ id: a.id, title: a.title, meta: a.meta||{}, payload: a.payload||{} }));
                populateSavedSelect(mapped);
            }catch(e){
                log('refresh saved list failed', e?.message||e);
                const savedSelect = document.getElementById('savedSelect');
                savedSelect.innerHTML='';
                const emptyOpt = document.createElement('option');
                emptyOpt.value='';
                emptyOpt.textContent='(error)';
                savedSelect.appendChild(emptyOpt);
            }
        }

        document.getElementById('tbClearBtn')?.addEventListener('click', async ()=>{
            if(!confirm('Delete ALL saved content from the library? This will not affect the currently loaded PDF or preview.')) return;
            try{
                // delete IDB entries (saved textbooks only)
                const all = await idbGetAllBooks();
                for(const a of all){ await idbDeleteBook(a.id); }
                // clear localStorage pointer key used for saved list
                try{ localStorage.removeItem('textbook.lib.v1'); }catch(e){}
                log('cleared all saved textbooks');
                // refresh the saved list UI
                await refreshSavedList();
                // reset saved-list controls only (leave file, toc, flattened and log intact)
                try{ const savedSelect = document.getElementById('savedSelect'); const inlineList = document.getElementById('savedSelectList'); const inlineTrigger = document.getElementById('savedSelectInline'); if(savedSelect){ savedSelect.innerHTML = ''; const emptyOpt = document.createElement('option'); emptyOpt.value=''; emptyOpt.textContent='(none)'; savedSelect.appendChild(emptyOpt); } if(inlineList){ inlineList.innerHTML=''; } if(inlineTrigger){ try{ inlineTrigger.querySelector('.inline-selected').textContent='(none)'; inlineTrigger.setAttribute('aria-expanded','false'); }catch(e){} } }catch(e){}
                try{ const savedDetails = document.getElementById('savedDetails'); if(savedDetails) savedDetails.textContent='(select saved content and click Show)'; }catch(e){}
                try{ const tbShowBtn = document.getElementById('tbShowBtn'); if(tbShowBtn){ tbShowBtn.dataset.visible = '0'; tbShowBtn.textContent = 'Show'; tbShowBtn.disabled = true; } }catch(e){}
                
                try{ const tbDeleteBtn = document.getElementById('tbDeleteBtn'); if(tbDeleteBtn) tbDeleteBtn.disabled = true; }catch(e){}
            }catch(e){ log('clear all failed', e?.message||e); }
        });

    // tbShowBtn now acts as a Hide/Show toggle for the savedDetails view
    document.getElementById('tbShowBtn')?.addEventListener('click', async ()=>{ const btn = document.getElementById('tbShowBtn'); const savedDetails = document.getElementById('savedDetails'); if(!btn || !savedDetails) return; // when toggling off, just hide the details and update label
        if(btn.dataset.visible === '1'){ btn.dataset.visible = '0'; btn.textContent = 'Show'; savedDetails.style.display = 'none'; return; }
        // otherwise, show (and populate) the selected saved record
    const id = parseInt(document.getElementById('savedSelect').value,10); if(!id) return; try{ const rec = await idbGetBook(id); if(!rec || !rec.payload) { savedDetails.textContent='(record not found)'; btn.dataset.visible = '0'; btn.textContent = 'Show'; return; } const payload = rec.payload; savedDetails.innerHTML=''; savedDetails.style.display = 'block'; btn.dataset.visible = '1'; btn.textContent = 'Hide'; const list = document.createElement('div'); list.className = 'saved-list'; const chapters = payload.chapters || []; if(!chapters.length){ savedDetails.textContent='(no chapters)'; btn.dataset.visible = '0'; btn.textContent = 'Show'; return; }
            function visualizeControlChars(s){ if(!s) return '(empty)'; return s.replace(/\t/g, '→\t').replace(/\r\n|\r|\n/g, '\n↵\n').replace(/[\x00-\x1F\x7F]/g, (c)=>{ const code = c.charCodeAt(0).toString(16).toUpperCase().padStart(2,'0'); return '\\u' + code; }); }
            // create a quick map of saved items (if present) so we can respect depth/indentation
            const itemsMap = (payload.items || []).reduce((acc,it)=>{ try{ acc[it.uid] = it; }catch(e){} return acc; }, {});
            for(const ch of chapters){
                const row = document.createElement('div'); row.className = 'saved-row pill';
                // compute display indentation from saved item's depth (fallback 0)
                const savedItem = itemsMap[ch.uid];
                const depth = (savedItem && Number.isFinite(savedItem.depth)) ? Number(savedItem.depth) : 0;
                const indent = Math.max(0, depth) * 16; // 16px per depth level

                const t = document.createElement('div'); t.style.paddingLeft = indent + 'px';
                // prefer authoritative counts from the current scan (if present) when saved payload looks small
                let displayCount = (typeof ch.charCount === 'number') ? ch.charCount : (ch.snippet ? ch.snippet.length : 0);
                try{
                    if((!displayCount || displayCount < 1000) && Array.isArray(window.fullToc) && window.fullToc.length){
                        const found = window.fullToc.find(x => Number(x.uid) === Number(ch.uid));
                        if(found && Number.isFinite(found.charCount)) displayCount = found.charCount;
                    }
                }catch(e){}
                t.textContent = `${ch.title} [${ch.startPage}-${ch.endPage}] (${displayCount} chars)`;

                // action buttons container
                const actions = document.createElement('div'); actions.className = 'si-actions';

                // Generate -> sets the selected generator source (replace semantics)
                const genBtn = document.createElement('button'); genBtn.className = 'btn small'; genBtn.textContent = 'Generate'; genBtn.title = 'Set this chapter as the source for Generate MCQs';
                genBtn.addEventListener('click', async (ev)=>{
                    try{
                        // If the saved chapter snippet is empty or appears truncated, try to extract the full range from the loaded PDF
                        // prefer stored full text when present on the chapter record
                        let useText = (ch.text && String(ch.text).trim()) ? ch.text : ((ch.fullText && String(ch.fullText).trim()) ? ch.fullText : ((ch.snippet && String(ch.snippet).trim()) ? ch.snippet : ''));
                        try{
                            const shouldTryExtract = (typeof ch.charCount === 'number' && ch.charCount > (useText.length || 0)) || (!useText);
                            if(shouldTryExtract && window.pdfDoc){
                                try{
                                    let r = null;
                                    if(typeof extractRangeText === 'function'){
                                        r = await extractRangeText(window.pdfDoc, ch.startPage, ch.endPage);
                                    } else if(window.pdfDoc && typeof window.pdfDoc.getPage === 'function'){
                                        // Inline fallback: iterate pages and extract text content
                                        let acc = '';
                                        const MAX_CHARS = 200000;
                                        for(let p = ch.startPage; p <= ch.endPage; p++){
                                            try{
                                                const page = await window.pdfDoc.getPage(p);
                                                const content = await page.getTextContent({ normalizeWhitespace:true, disableCombineTextItems:false, includeMarkedContent:true });
                                                const s = (content && Array.isArray(content.items)) ? content.items.map(it=> String(it.str||'')).join(' ').replace(/\s+/g,' ').trim() : '';
                                                if(s) acc += s + '\n\n';
                                                if(acc.length > MAX_CHARS) break;
                                            }catch(e){ break; }
                                        }
                                        r = { text: acc, charCount: acc.length };
                                    }
                                    if(r && r.text && String(r.text).trim().length){ useText = String(r.text).trim(); }
                                }catch(e){ /* extraction failed; keep fallback */ }
                            }
                        }catch(e){}
                        if(!useText) useText = `${ch.title} (pages ${ch.startPage}-${ch.endPage})`;
                        const data = { title: ch.title, text: useText, startPage: ch.startPage, endPage: ch.endPage };
                        // replace the generator context so this becomes the chosen file/source
                        window.__tbGenCtx = window.__tbGenCtx || { pieces: [] };
                        window.__tbGenCtx.pieces = [ data ];
                        // update status indicators to reflect selected source
                        const statusDz = document.getElementById('tbDropGenerate'); if(statusDz) statusDz.textContent = `Selected source: ${ch.title} [${ch.startPage}-${ch.endPage}] (1 chapter)`;
                        const aiStatus = document.getElementById('aiFileStatus'); if(aiStatus) aiStatus.textContent = `Selected source: ${ch.title} [${ch.startPage}-${ch.endPage}]`;
                        // update saved preview area with a snippet and charcount
                        try{
                            const preview = document.getElementById('savedPreviewWrap');
                            if(preview){ const s = String(useText||''); const snippet = s.length > 800 ? s.slice(0,800) + '\n\n[TRUNCATED]' : s; preview.textContent = snippet; preview.textContent += `\n\n(${(s.length||0).toLocaleString()} chars)`; }
                        }catch(e){}
                        // clear any other persisted selection and mark this row as selected
                        try{
                            const parent = row.parentElement;
                            if(parent){
                                parent.querySelectorAll('.saved-row.selected').forEach(r=>{
                                    r.classList.remove('selected');
                                    // clear aria-pressed for any Generate buttons in that row
                                    const b = r.querySelector('button'); if(b && b.textContent === 'Generate'){ b.setAttribute('aria-pressed','false'); }
                                });
                            }
                        }catch(e){}
                        row.classList.add('selected');
                        // mark this Generate button as pressed for accessibility
                        try{ genBtn.setAttribute('aria-pressed','true'); }catch(e){}
                        // mirror selection to the file drop element used by the file chooser
                        try{ const chooser = document.getElementById('aiFileTbDrop'); if(chooser) chooser.setAttribute('data-selected', `${ch.title} [${ch.startPage}-${ch.endPage}]`); }catch(e){}
                        log('Set generator source to', ch.title);
                    }catch(e){ log('apply generate failed', e?.message||e); }
                });

                // Validate -> applies to validator context
                const valBtn = document.createElement('button'); valBtn.className = 'btn small'; valBtn.textContent = 'Validate'; valBtn.title = 'Apply this chapter to the Validate Answers panel';
                valBtn.addEventListener('click', async (ev)=>{
                    try{
                        window.__tbValidateCtx = window.__tbValidateCtx || { pieces: [] };
                        const data = { title: ch.title, text: ch.snippet || '', startPage: ch.startPage, endPage: ch.endPage };
                        window.__tbValidateCtx.pieces.push(data);
                        const dz = document.getElementById('tbDropValidate'); if(dz) dz.textContent = `Attached ${window.__tbValidateCtx.pieces.length} chapter(s).`;
                        const valOut = document.getElementById('aiValidateOutput2'); if(valOut) valOut.textContent = `Applied: ${ch.title} [${ch.startPage}-${ch.endPage}]`;
                        // also reveal the global apply button so users can push corrections if needed
                        try{ const gbtn = document.getElementById('validatorApplyBtnGlobal'); if(gbtn) gbtn.classList.remove('hidden'); }catch(e){}
                        row.classList.add('applied'); setTimeout(()=> row.classList.remove('applied'), 1400);
                        log('Applied to validator context', ch.title);
                    }catch(e){ log('apply validate failed', e?.message||e); }
                });

                // support legacy dragstart (keep for compatibility) on the title element
                t.draggable = true;
                t.addEventListener('dragstart', (ev)=>{ try{ const payload = { title: ch.title, text: ch.snippet || '', startPage: ch.startPage, endPage: ch.endPage }; ev.dataTransfer.setData('application/json', JSON.stringify(payload)); ev.dataTransfer.effectAllowed = 'copy'; log('dragstart', ch.title); }catch(e){ log('dragstart failed', e?.message||e); } });

                // Export -> download this chapter as .txt
                const expBtn = document.createElement('button'); expBtn.className = 'btn small'; expBtn.textContent = 'Export'; expBtn.title = 'Export this chapter as .txt';
                expBtn.addEventListener('click', (ev)=>{ try{ ev.stopPropagation(); ev.preventDefault(); exportSingleChapter(ch, (payload && payload.meta && payload.meta.fileName) ? payload.meta.fileName : (rec && rec.title) ); }catch(e){ console.error(e); } });
                actions.appendChild(genBtn); actions.appendChild(valBtn); actions.appendChild(expBtn);
                row.appendChild(t); row.appendChild(actions); list.appendChild(row);
                // clicking the saved row should show the preview (but not auto-select as generator source)
                (function(row, ch){
                    row.addEventListener('click', (ev)=>{
                        try{
                            // ignore clicks on inline buttons
                            if(ev.target && (ev.target.tagName === 'BUTTON' || ev.target.closest('button'))) return;
                            const preview = document.getElementById('savedPreviewWrap'); if(!preview) return;
                            let useText = (ch.text && String(ch.text).trim()) ? ch.text : ((ch.snippet && String(ch.snippet).trim()) ? ch.snippet : '');
                            if(!useText && ch.title) useText = `${ch.title} (pages ${ch.startPage}-${ch.endPage})`;
                            const maxPreviewChars = 420;
                            const s = String(useText||'');
                            const snippet = s.length > maxPreviewChars ? s.slice(0,maxPreviewChars) + '\n\n[TRUNCATED]' : s || '(no excerpt available)';
                            preview.textContent = snippet;
                            preview.textContent += `\n\n(${(s.length||0).toLocaleString()} chars)`;
                            try{ const parent = row.parentElement; if(parent) parent.querySelectorAll('.saved-row.selected').forEach(r=> r.classList.remove('selected')); row.classList.add('selected'); }catch(e){}
                        }catch(e){}
                    });
                })(row, ch);
            }
            savedDetails.appendChild(list);
            // Preview container for selected saved chapter excerpts
            try{
                const previewWrap = document.createElement('div');
                previewWrap.id = 'savedPreviewWrap';
                previewWrap.className = 'saved-sample compact-sample';
                previewWrap.style.marginTop = '6px';
                // shorter preview by default (visual clamp)
                previewWrap.style.maxHeight = '160px';
                previewWrap.style.overflow = 'auto';
                previewWrap.style.position = 'relative';
                previewWrap.style.display = '-webkit-box';
                previewWrap.style.webkitLineClamp = '4';
                previewWrap.style.webkitBoxOrient = 'vertical';
                previewWrap.style.lineHeight = '1.2';
                previewWrap.textContent = '(select a chapter and click Generate to preview excerpt)';
                savedDetails.appendChild(previewWrap);

                // If the first chapter has a snippet that appears truncated and the PDF is loaded, try to extract the full range
                (async ()=>{
                    try{
                        const first = chapters && chapters.length ? chapters[0] : null;
                        if(!first) return;
                        const preview = document.getElementById('savedPreviewWrap');
                        if(!preview) return;
                        const sSnippet = String(first.snippet || '');
                        const sCount = (typeof first.charCount === 'number') ? first.charCount : sSnippet.length;
                        // if PDF loaded and snippet is much smaller than expected, attempt extraction
                        if(window.pdfDoc && (!sCount || sSnippet.length < Math.max(1000, Math.min(50000, sCount)))){
                            let useText = sSnippet || '';
                            try{
                                let r = null;
                                if(typeof extractRangeText === 'function'){
                                    r = await extractRangeText(window.pdfDoc, first.startPage, first.endPage);
                                } else if(window.pdfDoc && typeof window.pdfDoc.getPage === 'function'){
                                    let acc = '';
                                    const MAX_CHARS = 300000;
                                    for(let p = first.startPage; p <= first.endPage; p++){
                                        try{
                                            const page = await window.pdfDoc.getPage(p);
                                            const content = await page.getTextContent({ normalizeWhitespace:true, disableCombineTextItems:false, includeMarkedContent:true });
                                            const s = (content && Array.isArray(content.items)) ? content.items.map(it=> String(it.str||'')).join(' ').replace(/\s+/g,' ').trim() : '';
                                            if(s) acc += s + '\n\n';
                                            if(acc.length > MAX_CHARS) break;
                                        }catch(e){ break; }
                                    }
                                    r = { text: acc, charCount: acc.length };
                                }
                                if(r && r.text && String(r.text).trim().length) useText = String(r.text).trim();
                            }catch(e){}
                            if(!useText) useText = `${first.title} (pages ${first.startPage}-${first.endPage})`;
                            const s = String(useText||'');
                            const maxPreviewChars = 420;
                            const snippet = s.length > maxPreviewChars ? s.slice(0,maxPreviewChars) + '\n\n[TRUNCATED]' : s;
                            preview.textContent = snippet;
                            preview.textContent += `\n\n(${(s.length||0).toLocaleString()} chars)`;
                        } else {
                            // show whatever snippet is available
                            const s = sSnippet || '';
                            const maxPreviewChars = 420;
                            const snippet = s.length ? (s.length > maxPreviewChars ? s.slice(0,maxPreviewChars) + '\n\n[TRUNCATED]' : s) : '(no excerpt available)';
                            preview.textContent = snippet;
                            preview.textContent += `\n\n(${(sCount||0).toLocaleString()} chars)`;
                        }
                    }catch(e){ /* ignore preview extraction failures */ }
                })();
            }catch(e){}
        }catch(e){ log('show failed', e?.message||e); savedDetails.textContent='(error)'; } });

    document.getElementById('tbDeleteBtn')?.addEventListener('click', async ()=>{ const id = parseInt(document.getElementById('savedSelect').value,10); if(!id) return; if(!confirm('Delete selected saved content?')) return; try{ await idbDeleteBook(id); log('deleted saved', id); await refreshSavedList(); document.getElementById('savedDetails').textContent='(none)'; }catch(e){ log('delete failed', e?.message||e); } });

    

    // Migrate selected saved record to include full chapter text (when PDF is loaded)
    

        // Load into UI/generator context
    

    // Save handler (compact payload) + flash saved state
    document.getElementById('tbSaveBtn')?.addEventListener('click', async ()=>{ const tbSaveBtn = document.getElementById('tbSaveBtn'); const savedSelect = document.getElementById('savedSelect'); if(!(window.fullToc && window.fullToc.length)) return; tbSaveBtn.disabled=true; const oldText = tbSaveBtn.textContent; log('Saving scanned textbook to IndexedDB...'); try{ const meta = { savedAt: Date.now(), pages: (window.pdfNumPages||window.pdfNumPages===0)? window.pdfNumPages : (window.pdfNumPages||0), fileName: (document.getElementById('metaName')?.textContent || '') }; const chapters = []; const itemsToSave = Array.isArray(window.flattened)? window.flattened.slice() : (Array.isArray(window.fullToc)? window.fullToc.slice():[]); const fullMap = (window.fullToc||[]).reduce((acc, x)=>{ acc[x.uid] = x; return acc; }, {});
            for (const ch of itemsToSave) {
                // compute start/end pages with safe fallbacks and bounds checking
                const s = Math.max(1, Number.isFinite(ch.startPage) ? ch.startPage : (Number.isFinite(ch.page) ? ch.page : 1));
                let e = Number.isFinite(ch.endPage) ? ch.endPage : (Number.isFinite(ch.page) ? ch.page : s);
                if (Number.isFinite(window.pdfNumPages) && window.pdfNumPages > 0) e = Math.min(window.pdfNumPages, e);

                // we'll try to compute an authoritative charCount for the full range and capture the full text.
                // prefer extractRangeText if available (returns text + charCount). Otherwise fall back to per-page accumulation
                let snippet = '';
                let charCount = 0;
                let fullText = '';
                try{
                    if(window.pdfDoc){
                        if(typeof extractRangeText === 'function'){
                            // extract the full chapter range (s..e)
                            const r = await extractRangeText(window.pdfDoc, s, e);
                            fullText = String(r && r.text ? r.text : '');
                            // cap stored full text to a reasonable limit to avoid extremely large saves
                            const FULL_SAVE_LIMIT = 500000;
                            if(fullText.length > FULL_SAVE_LIMIT) fullText = fullText.slice(0, FULL_SAVE_LIMIT);
                            snippet = fullText.slice(0, 20000);
                            charCount = Number.isFinite(r && r.charCount) ? r.charCount : fullText.length;
                        } else {
                            // no range helper available: iterate pages and accumulate lengths
                            let acc = '';
                            let total = 0;
                            const ACC_LIMIT = 200000; // don't build enormous temporary buffers
                            for(let p = s; p <= e; p++){
                                try{
                                    let pageText = '';
                                    if(typeof extractPageText === 'function'){
                                        pageText = await extractPageText(window.pdfDoc, p);
                                    } else if(typeof tbExtractPageText === 'function'){
                                        pageText = await tbExtractPageText(window.pdfDoc, p);
                                    }
                                    if(pageText){
                                        total += pageText.length;
                                        if(acc.length < ACC_LIMIT) acc += pageText + '\n\n';
                                    }
                                }catch(e){ /* ignore page errors and continue */ }
                            }
                            // use accumulated text as the full text (within ACC_LIMIT)
                            fullText = acc;
                            snippet = fullText.slice(0, 20000);
                            charCount = total;
                        }
                    }
                }catch(err){ log('chapter extract failed', err?.message||err); snippet = snippet || ''; charCount = charCount || 0; }

                // prefer authoritative counts and stored text discovered during scan (fullMap) when present
                const authoritative = fullMap[ch.uid];
                let authCount = (authoritative && Number.isFinite(authoritative.charCount)) ? authoritative.charCount : (Number.isFinite(charCount) ? charCount : (snippet ? snippet.length : 0));
                // if the scan populated full text for this chapter, prefer that and avoid re-extraction
                let storedText = (authoritative && authoritative.text) ? authoritative.text : (authoritative && authoritative.fullText ? authoritative.fullText : (fullText || ''));
                if(storedText && !authCount) authCount = storedText.length;
                const finalSnippet = storedText ? (String(storedText).slice(0,20000)) : snippet;
                const finalText = storedText || fullText || '';
                chapters.push({ title: ch.title, uid: ch.uid, startPage: s, endPage: e, charCount: authCount, snippet: finalSnippet, text: finalText });
            }
            const payload = { savedAt: Date.now(), items: itemsToSave, chapters, meta }; const rec = { title: sanitizeTitle(meta.fileName || ('Saved '+new Date().toISOString())), meta: meta, payload }; const id = await idbPutBook(rec); log('saved textbook id', id); await refreshSavedList();
            // Flash saved state similar to the index MCQ button
            try{ tbSaveBtn.textContent = 'Saved'; tbSaveBtn.classList.add('saved'); setTimeout(()=>{ try{ tbSaveBtn.textContent = oldText || 'Save'; tbSaveBtn.classList.remove('saved'); }catch(e){} }, 1200); }catch(e){}
        }catch(e){ log('save failed', e?.message||e); } document.getElementById('tbSaveBtn').disabled=false; });

    // initial refresh
    refreshSavedList().catch(err=> log('initial saved list refresh failed', err?.message||err));

    // Wire bulk export button for localStorage saved MCQs
    try{ document.getElementById('exportAllSavedBtn')?.addEventListener('click', (e)=>{ e.preventDefault(); exportAllLocalSaved(); }); }catch(e){ console.warn('exportAllLocalSaved wiring failed', e); }

        // Wire savedSelect change
        document.getElementById('savedSelect')?.addEventListener('change', ()=>{ const id = document.getElementById('savedSelect').value; const has = !!id; const tbShowBtn = document.getElementById('tbShowBtn'); document.getElementById('tbShowBtn').disabled = !has; document.getElementById('tbDeleteBtn').disabled = !has; if(tbShowBtn){ tbShowBtn.dataset.visible = '0'; tbShowBtn.textContent = 'Show'; const savedDetails = document.getElementById('savedDetails'); if(savedDetails) savedDetails.style.display = 'none'; } });
        // Keep inline trigger label in sync when the hidden select value changes
        (function(){ const hidden = document.getElementById('savedSelect'); const trigger = document.getElementById('savedSelectInline'); const list = document.getElementById('savedSelectList'); if(!hidden || !trigger) return; hidden.addEventListener('change', ()=>{ try{ const v = hidden.value || ''; const opt = list ? list.querySelector(`.custom-inline-item[data-id="${v}"]`) : null; trigger.querySelector('.inline-selected').textContent = opt ? opt.textContent : '(none)'; }catch(e){} }); })();
        // Wire inline trigger: toggle list and keyboard handling
        (function(){
            const trigger = document.getElementById('savedSelectInline'); const list = document.getElementById('savedSelectList'); const hidden = document.getElementById('savedSelect'); if(!trigger || !list || !hidden) return;
            // open/close (use fixed positioning and compute coordinates to avoid ancestor clipping)
            // We'll portal the list node to document.body while open so transforms/overflow on ancestors
            // cannot clip it. Store the original parent so we can restore it on close.
            const _origParent = list.parentElement;
            const _placeholder = document.createElement('div'); _placeholder.style.display = 'none';
            // helpers for repositioning while open
            let _rafScheduled = null;
            let _boundHandlers = null;
            const applyPosition = ()=>{
                try{
                    const rect = trigger.getBoundingClientRect();
                    // Match trigger width exactly
                    const width = Math.round(rect.width);
                    list.style.boxSizing = 'border-box';
                    list.style.width = width + 'px';
                    list.style.minWidth = width + 'px';
                    list.style.maxWidth = ''; 
                    
                    // measure after width applied
                    const lr = list.getBoundingClientRect();
                    let left = Math.round(rect.left);
                    // Prefer below the trigger only (do not flip above)
                    let top = Math.round(rect.bottom + 6);
                    // If it would overflow bottom, reduce max-height rather than flipping
                    if(top + lr.height > window.innerHeight - 8){
                        const available = Math.max(80, window.innerHeight - top - 8);
                        list.style.maxHeight = available + 'px';
                    } else {
                        list.style.maxHeight = '';
                    }
                    // Keep inside viewport horizontally
                    if(left + lr.width > window.innerWidth - 8){
                        left = Math.max(8, Math.round(window.innerWidth - lr.width - 8));
                    }
                    if(left < 8) left = 8;
                    list.style.left = left + 'px';
                    list.style.top = top + 'px';
                }catch(e){}
            };

            // schedule a single rAF to coalesce many events
            const schedulePosition = ()=>{
                if(_rafScheduled) return;
                _rafScheduled = requestAnimationFrame(()=>{ _rafScheduled = null; applyPosition(); });
            };

            const startRepositionLoop = ()=>{
                if(_boundHandlers) return;
                // Use event listeners (capture) so we catch scrolls on any ancestor. Debounce with rAF.
                const h = (ev)=>{ try{ schedulePosition(); }catch(e){} };
                _boundHandlers = { resize: h, scroll: h, wheel: h, touchmove: h };
                window.addEventListener('resize', h);
                window.addEventListener('scroll', h, true);
                window.addEventListener('wheel', h, { passive: true, capture: true });
                window.addEventListener('touchmove', h, { passive: true, capture: true });
                // Observe trigger size/position changes in case layout shifts (ResizeObserver is well-supported)
                try{
                    _boundHandlers.ro = new ResizeObserver(()=> schedulePosition());
                    _boundHandlers.ro.observe(trigger);
                }catch(e){}
            };

            const stopRepositionLoop = ()=>{
                try{
                    if(_rafScheduled){ cancelAnimationFrame(_rafScheduled); _rafScheduled = null; }
                    if(_boundHandlers){
                        window.removeEventListener('resize', _boundHandlers.resize);
                        window.removeEventListener('scroll', _boundHandlers.scroll, true);
                        window.removeEventListener('wheel', _boundHandlers.wheel, { passive: true, capture: true });
                        window.removeEventListener('touchmove', _boundHandlers.touchmove, { passive: true, capture: true });
                        try{ if(_boundHandlers.ro){ _boundHandlers.ro.disconnect(); } }catch(e){}
                        _boundHandlers = null;
                    }
                }catch(e){}
            };

            const close = ()=>{
                try{ trigger.setAttribute('aria-expanded','false'); }catch(e){}
                try{
                    // hide
                    list.classList.add('hidden');
                    list.style.left = '';
                    list.style.top = '';
                    list.style.width = '';
                    list.style.visibility = '';
                    list.style.position = '';
                    list.style.zIndex = '';
                    // stop reposition loop
                    stopRepositionLoop();
                    // restore into original container if we moved it and remove the placeholder
                    try{ if(_placeholder.parentElement){ _placeholder.parentElement.removeChild(_placeholder); } }catch(e){}
                    try{
                        if(_origParent && _origParent !== list.parentElement){ _origParent.appendChild(list); }
                    }catch(e){}
                }catch(e){}
            };

            const open = ()=>{
                try{ trigger.setAttribute('aria-expanded','true'); }catch(e){}
                try{
                    // Portal the list to document.body while open so it can escape any ancestor
                    // stacking contexts or overflow clipping. Insert a placeholder so we can restore later.
                    try{
                        if(list.parentElement !== document.body){
                            try{ if(list.parentElement){ list.parentElement.insertBefore(_placeholder, list); } }catch(e){}
                            document.body.appendChild(list);
                        }
                    }catch(e){}
                    // Prepare for measurement using viewport-fixed positioning
                    list.classList.remove('hidden');
                    list.style.position = 'fixed';
                    list.style.visibility = 'hidden';
                    // Place the list just below the light-mode overlay (2147483646) so it inverts with the rest of the page
                    list.style.zIndex = '2147483645';
                    // Compute size/position in the next frame and show
                    applyPosition();
                    list.style.visibility = 'visible';
                    try{ list.focus(); }catch(e){}
                    // Begin tracking scroll/resize to keep the portal aligned
                    startRepositionLoop();
                }catch(e){ try{ list.classList.remove('hidden'); list.style.visibility='visible'; }catch(_){} }
            };
            trigger.addEventListener('click', (e)=>{ const expanded = trigger.getAttribute('aria-expanded') === 'true'; if(expanded) close(); else open(); });
            // keyboard: Enter/Space opens, Arrow keys navigate, Escape closes
            trigger.addEventListener('keydown', (e)=>{
                if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); const expanded = trigger.getAttribute('aria-expanded') === 'true'; if(expanded) close(); else open(); }
                if(e.key === 'ArrowDown'){ e.preventDefault(); open(); const first = list.querySelector('.custom-inline-item'); if(first) first.focus(); }
            });
            list.addEventListener('keydown', (e)=>{
                const items = Array.from(list.querySelectorAll('.custom-inline-item'));
                const idx = items.findIndex(n=> n === document.activeElement);
                if(e.key === 'ArrowDown'){ e.preventDefault(); const nxt = items[Math.min(items.length-1, Math.max(0, idx+1))]; if(nxt) nxt.focus(); }
                else if(e.key === 'ArrowUp'){ e.preventDefault(); const prev = items[Math.min(items.length-1, Math.max(0, idx-1))]; if(prev) prev.focus(); }
                else if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); if(document.activeElement && document.activeElement.classList.contains('custom-inline-item')) document.activeElement.click(); }
                else if(e.key === 'Escape'){ e.preventDefault(); close(); trigger.focus(); }
            });
            // click outside to close
            document.addEventListener('click', (ev)=>{ if(!trigger.contains(ev.target) && !list.contains(ev.target)){ close(); } });
        })();

        // toggleSavedList removed — Show/Hide functionality is handled by the TB Show button

        // Drag/drop receive helper (allow files to be dropped into page to trigger file inputs elsewhere)
        ['dragover','drop'].forEach(ev=> document.addEventListener(ev, (e)=>{ e.preventDefault(); }));
        document.addEventListener('drop', (e)=>{ if(e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length){ const fileEl = document.getElementById('file') || document.getElementById('tbFile'); if(fileEl){ try{ fileEl.files = e.dataTransfer.files; fileEl.dispatchEvent(new Event('change')); }catch(e){ } } } });

    // Small helper used above
    function sanitizeTitle(s){ return String(s||'').replace(/[\\/:*?"<>|\x00-\x1F]/g,'_').replace(/\s+/g,' ').trim().slice(0,180); }
    })();
    </script>

        <!-- === AI Like-Question Generator (start-only) === -->
    <section id="ai-likeq-copy" class="card pad ai-likeq" style="position:relative; z-index:0; pointer-events:auto;">
            <div class="flex col center gap-8">
                <div class="key-badge missing" id="globalKeyBadge2" title="Shows whether a Gemini API key is present"><span class="dot"></span><span class="hint">No key set</span></div>
                <div id="validatorActionRow" class="flex center gap-12">
                <button id="aiLikeBtn2" class="btn primary btn-wide" disabled>Validate Answers (AI)</button>
                <!-- Apply corrections button moved here so it appears inside the same card/action area -->
                <button id="validatorApplyBtnGlobal" class="btn primary hidden ml-8">Apply corrections to text</button>
                </div>
            </div>
            <div class="hint mt-8 text-center">
                Validates each ANSWER KEY entry against its question options. Outputs a single-line summary (CORRECT / INCORRECT counts) followed by only the incorrectly keyed questions and their correct answers into the box below.
            </div>
            <div id="aiLikeStatus2" class="hint mt-8 text-center"></div>
                        <div id="aiValidateOutput2" class="hint mt-12" role="status" aria-live="polite"></div>
                        <div id="aiValidateActions" class="mt-8 flex justify-start gap-8"></div>
                        <!-- global apply button intentionally moved into the ai-like header so it's visible inside the card (see header markup) -->
        </section>

<script>
// Textbook Library: client-side extract + chapter segmentation + drag-drop integration
(function(){
    const $ = (id)=> document.getElementById(id);
    const LS = 'textbook.lib.v1';
    const tbFiles = $('tbFiles'); const tbName = $('tbFilesName'); const tbTree = $('tbTree'); const tbStatus = $('tbStatus'); const tbClear = $('tbClearBtn'); const tbDebug = $('tbDebug'); const tbProcess = $('tbProcessBtn');
    // safe global status updater for textbook module (guard against scope issues)
    try{ window.setTextbookStatus = window.setTextbookStatus || function(t, bad){ try{ const el = document.getElementById('tbStatus'); if(el){ el.textContent = t||''; el.style.color = bad? 'var(--bad)' : ''; } else { console.log('[TB status]', t); } }catch(e){ console.log('[TB status error]', e); } }; }catch(e){}

    // --- IndexedDB helpers for fallback storage when localStorage quota is exceeded ---
    function idbOpen(){
        return new Promise((res, rej)=>{
            try{
                const req = indexedDB.open('textbook_lib_v1', 1);
                req.onupgradeneeded = ()=>{ const db = req.result; if(!db.objectStoreNames.contains('books')) db.createObjectStore('books', { keyPath: 'id', autoIncrement: true }); };
                req.onsuccess = ()=> res(req.result);
                req.onerror = ()=> rej(req.error || new Error('idb open failed'));
            }catch(e){ rej(e); }
        });
    }
    async function idbPutBook(book){ try{ const db = await idbOpen(); return await new Promise((res, rej)=>{ const tx = db.transaction('books','readwrite'); const store = tx.objectStore('books'); const r = store.add(book); r.onsuccess = ()=> res(r.result); r.onerror = ()=> rej(r.error||new Error('idb add failed')); }); }catch(e){ throw e; } }
    // Update existing book record (uses put so object with id will replace)
    async function idbUpdateBook(book){ try{ const db = await idbOpen(); return await new Promise((res, rej)=>{ const tx = db.transaction('books','readwrite'); const store = tx.objectStore('books'); const r = store.put(book); r.onsuccess = ()=> res(r.result); r.onerror = ()=> rej(r.error||new Error('idb put failed')); }); }catch(e){ throw e; } }
    async function idbGetBook(id){ try{ const db = await idbOpen(); return await new Promise((res, rej)=>{ const tx = db.transaction('books','readonly'); const store = tx.objectStore('books'); const r = store.get(Number(id)); r.onsuccess = ()=> res(r.result); r.onerror = ()=> rej(r.error||new Error('idb get failed')); }); }catch(e){ throw e; } }
    // Ensure the visible 'Add Textbook' button triggers the hidden file input (robust click wiring)
    try{ const choose = document.querySelector('label.choose-btn[for="tbFiles"]'); if(choose){ choose.addEventListener('click', (ev)=>{ ev.preventDefault(); tbFiles && tbFiles.click(); }); } }catch(e){ /* ignore */ }
    if(!tbTree) return;
    function logDbg(...args){ try{ const s = args.map(a=> typeof a==='string'? a : JSON.stringify(a)).join(' '); if(tbDebug){ tbDebug.textContent = (new Date()).toLocaleTimeString() + ' ' + s + "\n" + tbDebug.textContent; } else { console.log('[TB]', ...args); } }catch(e){ console.log('[TB]', ...args); } }
    function loadLib(){ try{ const raw = localStorage.getItem(LS); return raw? JSON.parse(raw): []; }catch{ return []; } }
    function saveLib(arr){ try{ localStorage.setItem(LS, JSON.stringify(arr||[])); return true; }catch(e){ logDbg('saveLib failed', e?.message||e); setStatus('Could not save library to this device (storage full or blocked). Data kept in memory for this session.', true); return false; } }
    // expose helpers for other modules to reuse (safe no-op if overwritten)
    try{ window.loadTextbookLib = window.loadTextbookLib || loadLib; window.saveTextbookLib = window.saveTextbookLib || saveLib; window.setTextbookStatus = window.setTextbookStatus || setStatus; }catch(e){}
    function setStatus(t, bad){ if(tbStatus){ tbStatus.textContent = t||''; tbStatus.style.color = bad? 'var(--bad)' : ''; } }

    // --- Resilient CDN/script loader helpers ---
    async function loadScriptWithFallbacks(pairs){
        // pairs: [{script, worker?, onload?}]
        for(const p of pairs){
            try{
                await new Promise((res, rej)=>{
                    const s = document.createElement('script');
                    s.src = p.script; s.async = true; s.onload = ()=> res(); s.onerror = ()=> rej(new Error('load failed'));
                    document.head.appendChild(s);
                });
                if(typeof p.onload === 'function'){ await p.onload(); }
                logDbg('cdn loaded', p.script);
                return p; // return the winning pair
            }catch(e){ logDbg('cdn failed', p.script); }
        }
        return null;
    }

    async function ensurePdfJs(){
        if(window.pdfjsLib && window.pdfjsLib.getDocument) return true;
        const VER = '4.2.67';
        const candidates = [
            { script: `https://cdn.jsdelivr.net/npm/pdfjs-dist@${VER}/build/pdf.min.js`, worker: `https://cdn.jsdelivr.net/npm/pdfjs-dist@${VER}/build/pdf.worker.min.js` },
            { script: `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${VER}/pdf.min.js`, worker: `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${VER}/pdf.worker.min.js` },
            { script: `https://unpkg.com/pdfjs-dist@${VER}/build/pdf.min.js`, worker: `https://unpkg.com/pdfjs-dist@${VER}/build/pdf.worker.min.js` },
        ];
        const picked = await loadScriptWithFallbacks(candidates.map(c=>({ script:c.script })));
        if(picked && window.pdfjsLib){ try{ window.pdfjsLib.GlobalWorkerOptions.workerSrc = candidates.find(c=> c.script===picked.script)?.worker || ''; }catch{} return true; }
        logDbg('pdf.js could not be loaded from any CDN');
        return false;
    }

    async function ensureTesseract(){
        if(window.Tesseract && window.Tesseract.recognize) return true;
        const VER = '4.1.1';
        const candidates = [
            { script: `https://cdn.jsdelivr.net/npm/tesseract.js@${VER}/dist/tesseract.min.js` },
            { script: `https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/${VER}/tesseract.min.js` },
            { script: `https://unpkg.com/tesseract.js@${VER}/dist/tesseract.min.js` },
        ];
        const picked = await loadScriptWithFallbacks(candidates);
        if(picked && window.Tesseract){ return true; }
        logDbg('tesseract.js could not be loaded from any CDN');
        return false;
    }

    async function ensurePako(){
        if(window.pako && window.pako.inflate) return true;
        const VER = '2.1.0';
        const candidates = [
            { script: `https://cdn.jsdelivr.net/npm/pako@${VER}/dist/pako.min.js` },
            { script: `https://cdnjs.cloudflare.com/ajax/libs/pako/${VER}/pako.min.js` },
            { script: `https://unpkg.com/pako@${VER}/dist/pako.min.js` },
        ];
        const picked = await loadScriptWithFallbacks(candidates);
        if(picked && window.pako){ return true; }
        logDbg('pako could not be loaded from any CDN');
        return false;
    }

    function decodeHexString(hex){
        const clean = (hex||'').replace(/[^0-9a-fA-F]/g,'');
        if(clean.length < 2) return '';
        const bytes = [];
        for(let i=0;i<clean.length;i+=2){ bytes.push(parseInt(clean.slice(i,i+2),16)); }
        // UTF-16BE BOM handling
        if(bytes.length>=2 && bytes[0]===0xFE && bytes[1]===0xFF){
            let s=''; for(let i=2;i+1<bytes.length;i+=2){ s += String.fromCharCode((bytes[i]<<8)|bytes[i+1]); }
            return s;
        }
        return String.fromCharCode(...bytes);
    }

    function extractLiteralStrings(s){
        const out=[]; let i=0; const n=s.length;
        while(i<n){
            if(s[i]==='('){
                i++; let buf=''; let depth=1; while(i<n && depth>0){
                    const ch = s[i++];
                    if(ch==='\\'){ // escape
                        const nxt = s[i++]||''; if(nxt){
                            if(/[0-7]/.test(nxt)){ // octal sequence \ddd
                                let oct=nxt; for(let k=0;k<2 && /[0-7]/.test(s[i]);k++){ oct+=s[i++]; }
                                buf += String.fromCharCode(parseInt(oct,8));
                            }else{ const map={n:'\n', r:'\r', t:'\t', b:'\b', f:'\f', '(':'(', ')':')', '\\':'\\'}; buf += (map[nxt]??nxt); }
                        }
                        continue;
                    } else if(ch==='('){ depth++; buf += ch; }
                    else if(ch===')'){ depth--; if(depth>0) buf += ch; }
                    else { buf += ch; }
                }
                if(buf) out.push(buf);
            } else { i++; }
        }
        return out;
    }

    async function pdfFallbackExtractStrings(ab){
        const limitChars = 400000; // cap like the primary path
        const u8 = new Uint8Array(ab);
        const latin1 = new TextDecoder('latin1');
        const txts = [];
        const whole = latin1.decode(u8);
        // Collect candidate streams
        let idx = 0; let streams = 0; let decompressed = 0;
        while((idx = whole.indexOf('stream', idx)) !== -1){
            // Find endstream and slice raw bytes; account for CRLF after 'stream'
            let start = idx + 6; if(whole[start]==='\r' && whole[start+1]==='\n') start+=2; else if(whole[start]==='\n') start+=1;
            const end = whole.indexOf('endstream', start);
            if(end === -1) break;
            const raw = u8.subarray(start, end);
            let contents='';
            // Try inflate; if fails, fall back to latin1 plain
            try{ if(await ensurePako()){ const infl = window.pako.inflate(raw); contents = latin1.decode(infl); decompressed++; } }catch{ contents = latin1.decode(raw); }
            streams++;
            // Extract literal strings and hex strings
            const lits = extractLiteralStrings(contents);
            lits.forEach(s=> { if(s) txts.push(s); });
            const hexRe = /<([0-9A-Fa-f\s]+)>\s*(?:T[Jj]|TJ|Tj)/g; let m;
            while((m = hexRe.exec(contents))){ const decoded = decodeHexString(m[1]); if(decoded) txts.push(decoded); }
            if(txts.join(' ').length > limitChars) break;
            idx = end+9;
        }
        // If nothing from streams, try the whole file for stray literal strings
        if(txts.length===0){ extractLiteralStrings(whole).forEach(s=> txts.push(s)); }
        const out = txts.join('\n').replace(/\s+/g,' ').replace(/\s*\n\s*/g,'\n').trim();
        logDbg('pdf fallback streams', streams, 'inflated', decompressed, 'chars', out.length);
        return out;
    }

    // Simple segmentation heuristics: detect Chapter/Section headings and build nested structure
    function segmentChapters(text){
        const lines = (text||'').split(/\r?\n/);
        const chapters = [];
        let cur = null;
        let sub = null;
        function pushSub(){ if(cur && sub){ cur.sub.push(sub); sub = null; } }
        function pushCur(){ if(cur){ pushSub(); chapters.push(cur); cur = null; } }
        for(const raw of lines){
            const line = raw.trim(); if(!line) continue;
            const chap = line.match(/^(Chapter\s+\d+\b\.?|^\d+\.)\s*(.+)$/i);
            const sect = line.match(/^(Section\s+\d+(?:\.\d+)*\b\.?|^\d+\.\d+)\s*(.+)$/i);
            if(chap){
                pushCur();
                cur = { title: chap[0].replace(/\.$/, ''), text: '', sub: [] };
                continue;
            }
            if(sect){
                if(!cur){ cur = { title: 'Chapter', text:'', sub: [] }; }
                pushSub();
                sub = { title: sect[0].replace(/\.$/, ''), text: '' };
                continue;
            }
            if(sub){ sub.text += (sub.text? '\n':'') + raw; }
            else if(cur){ cur.text += (cur.text? '\n':'') + raw; }
        }
        pushCur();
        // Fallback if nothing detected: chunk into ~8-12k char pieces to keep drag manageable
        if(chapters.length===0){
            const CHUNK = 10000; // ~10k chars per chunk
            if(!text || !text.trim()) return [{ title:'Document (empty)', text:'', sub:[] }];
            for(let i=0;i<text.length;i+=CHUNK){
                const slice = text.slice(i, i+CHUNK);
                chapters.push({ title: `Segment ${Math.floor(i/CHUNK)+1}`, text: slice, sub:[] });
            }
        }
        return chapters;
    }

    async function ensureExtractors(){
        // Reuse existing extractors loaded by AI file gen block
        return true;
    }

    async function extractTextFromFile(file){
        // Reuse the AI file gen extractors to avoid code duplication
        await ensureExtractors();
        // Minimal inline extraction using the same libraries loaded on demand there
        const name = file?.name||'file'; const lower = name.toLowerCase();
        logDbg('extract start', name);
        if(/\.txt$/i.test(lower)) { const t = await file.text(); logDbg('txt bytes', t.length); return t; }
        if(/\.docx$/i.test(lower)){
            const ab = await file.arrayBuffer();
            try{
                if(!(window.mammoth && window.mammoth.convertToHtml)){
                    await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src='https://unpkg.com/mammoth@1.6.0/mammoth.browser.min.js'; s.onload=res; s.onerror=()=>rej(new Error('mammoth load failed')); document.head.appendChild(s); });
                }
                const res = await window.mammoth.convertToHtml({ arrayBuffer: ab });
                const html = (res && res.value) || '';
                const out = html.replace(/<[^>]+>/g,' ').replace(/\s+/g,' ').replace(/\s*\n\s*/g,'\n').trim();
                logDbg('docx mammoth chars', out.length);
                return out;
            }catch{
                if(!window.JSZip){ await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js'; s.onload=res; s.onerror=()=>rej(new Error('jszip load failed')); document.head.appendChild(s); }); }
                const zip = await window.JSZip.loadAsync(ab);
                const entry = zip.file('word/document.xml');
                const xml = await entry.async('string');
                const out = xml.replace(/<w:p[^>]*>/g, '\n').replace(/<w:tab\b[^>]*\/>/g,' ').replace(/<w:t[^>]*>(.*?)<\/w:t>/g,'$1').replace(/<[^>]+>/g,' ').replace(/\s+/g,' ').trim();
                logDbg('docx xml chars', out.length);
                return out;
            }
        }
        if(/\.pdf$/i.test(lower)){
            const ab = await file.arrayBuffer();
            let havePdfJs = await ensurePdfJs();
            if(havePdfJs && window.pdfjsLib && window.pdfjsLib.getDocument){
                try{
                    const pdf = await window.pdfjsLib.getDocument({ data: ab, disableFontFace:true, useSystemFonts:true }).promise; const parts=[]; logDbg('pdf pages', pdf.numPages);
                    let extractedChars = 0; const SOFT_LIMIT = 400000; // ~400k chars cap for memory/perf
                    for(let p=1;p<=pdf.numPages;p++){
                        const page = await pdf.getPage(p);
                        let pageText = '';
                        try{
                            const c = await page.getTextContent({ normalizeWhitespace:true, disableCombineTextItems:false });
                            pageText = c.items.map(it=> it.str).join(' ').replace(/\s+/g,' ').trim();
                        }catch(e){ logDbg('pdf textContent failed page', p, e?.message||e); }
                        if(pageText) { parts.push(pageText); extractedChars += pageText.length; }
                        if(extractedChars > SOFT_LIMIT) { logDbg('pdf soft limit reached'); break; }
                        if(p % 10 === 0) await new Promise(r=> setTimeout(r, 0));
                    }
                    let out = parts.join('\n');
                    logDbg('pdf chars (text extraction)', out.length);
                    const wantOcr = !!document.getElementById('tbOcrToggle')?.checked;
                    const ocrMax = parseInt(document.getElementById('tbOcrMax')?.value||'8',10) || 8;
                    if(out.length < 800 && wantOcr){
                        logDbg('pdf appears image-only, starting OCR up to', ocrMax, 'pages');
                        const ok = await ensureTesseract();
                        if(ok){
                            const ocrParts=[]; const dpi = 160;
                            for(let p=1; p<=Math.min(pdf.numPages, ocrMax); p++){
                                try{
                                    const page = await pdf.getPage(p);
                                    const viewport = page.getViewport({ scale: 1.5 });
                                    const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d', { willReadFrequently:true });
                                    canvas.width = Math.floor(viewport.width * (dpi/96));
                                    canvas.height = Math.floor(viewport.height * (dpi/96));
                                    await page.render({ canvasContext: ctx, viewport }).promise;
                                    const dataUrl = canvas.toDataURL('image/png');
                                    const res = await window.Tesseract.recognize(dataUrl, 'eng');
                                    const txt = (res && res.data && res.data.text) ? res.data.text : '';
                                    if(txt && txt.trim()) ocrParts.push(txt.trim());
                                    canvas.width = canvas.height = 0;
                                }catch(e){ logDbg('ocr page failed', p, e?.message||e); }
                                await new Promise(r=> setTimeout(r, 0));
                            }
                            const ocrText = ocrParts.join('\n');
                            logDbg('ocr chars', ocrText.length);
                            if(ocrText.length > out.length) out = ocrText;
                        } else {
                            logDbg('OCR skipped: tesseract unavailable');
                        }
                    }
                    return out;
                }catch(e){ logDbg('pdf.js extract failed, falling back', e?.message||e); }
            }
            // Fallback path: parse strings directly from PDF content streams
            const fallbackText = await pdfFallbackExtractStrings(ab);
            if(fallbackText && fallbackText.length){ return fallbackText; }
            logDbg('pdf fallback got no text');
            return '';
        }
        if(/\.pptx$/i.test(lower)){
            if(!window.JSZip){ await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js'; s.onload=res; s.onerror=()=>rej(new Error('jszip load failed')); document.head.appendChild(s); }); }
            const ab = await file.arrayBuffer(); const zip = await window.JSZip.loadAsync(ab);
            const names = Object.keys(zip.files).filter(n=>/^ppt\/slides\/slide\d+\.xml$/i.test(n)).sort((a,b)=>parseInt(a.match(/slide(\d+)/i)[1])-parseInt(b.match(/slide(\d+)/i)[1])); logDbg('pptx slides', names.length);
            const chunks=[]; for(const n of names){ const xml = await zip.file(n).async('string'); const t = xml.replace(/<a:br\s*\/>/gi,'\n').replace(/<a:p[^>]*>/gi,'\n').replace(/<a:t[^>]*>([\s\S]*?)<\/a:t>/gi,'$1').replace(/<[^>]+>/g,' ').replace(/\s+/g,' ').trim(); if(t) chunks.push(t); if(chunks.join(' ').length>200000) break; }
            const out = chunks.join('\n\n'); logDbg('pptx chars', out.length); return out;
        }
        const t = await file.text(); logDbg('fallback text chars', t.length); return t;
    }

    // --- Lightweight TOC scanner (uses pdf.js if available) ---
    const tbScanBtn = $('tbScanBtn'); const tbTocTree = $('tbTocTree'); const tbLog = $('tbLog'); const tbMetaName = $('tbMetaName'); const tbMetaPages = $('tbMetaPages'); const tbMetaBytes = $('tbMetaBytes');

    function tbLogLine(...a){ try{ if(tbLog) tbLog.textContent = (new Date()).toLocaleTimeString() + ' ' + a.join(' ') + '\n' + tbLog.textContent; else console.log(...a); }catch(e){ console.log(...a); } }

    // sanitize title text for display (remove control/unprintable chars)
    function tbSanitizeTitle(s){ if(!s && s !== 0) return ''; try{ return String(s).replace(/[\x00-\x1F\x7F-\x9F\uFFFD]/g,'').replace(/[\\/:*?"<>|]/g,'').replace(/\s+/g,' ').trim().slice(0,180); }catch(e){ return String(s||'').trim(); } }

    function tbFlattenOutline(outl){
        const arr = [];
        function walk(items, depth){
            if(!items) return;
            for(const it of items){
                const rawTitle = it && it.title ? it.title : 'Untitled';
                const node = { title: tbSanitizeTitle(rawTitle), raw: it, depth };
                arr.push(node);
                if(it.items && it.items.length) walk(it.items, depth+1);
            }
        }
        walk(outl, 0);
        return arr;
    }

    function tbDetectChapterDepth(arr){ if(!arr || !arr.length) return 0; const score={}; const reNum=/^\s*(?:Chapter\b|Ch\.|\d+[.):]|[IVXLCDM]+[.):]|\d+\s)/i; for(const it of arr){ const d=it.depth||0; score[d]=(score[d]||0)+(reNum.test(it.title)?1:0); } let best=-1,bd=0; for(const k in score){ if(score[k]>best){ best=score[k]; bd=parseInt(k,10); } } return best>0?bd:0; }

    async function tbResolveDestToPageIndex(pdf, dest){ try{ if(!dest) return null; let resolved=null; try{ if(typeof dest === 'string') resolved = await pdf.getDestination(dest); else if(Array.isArray(dest)) resolved = dest; else if(dest && dest.getArray) resolved = await dest.getArray(); }catch{} if(!resolved && dest && dest.num) resolved=[dest]; if(!resolved) return null; const ref = resolved[0]; if(!ref) return null; const idx = await pdf.getPageIndex(ref); return idx; }catch(e){ tbLogLine('resolve fail', e?.message||e); return null; } }

    async function tbExtractPageText(pdf, pnum){ try{ const page = await pdf.getPage(pnum); const txt = await page.getTextContent({ normalizeWhitespace:true, disableCombineTextItems:false, includeMarkedContent:true }); const s = txt.items.map(it=> it.str||'').join(' ').replace(/\s+/g,' ').trim(); return s; }catch(e){ tbLogLine('page extract failed', pnum, e?.message||e); return ''; } }

    function tbComputeChapterRanges(entries, chapterDepth, numPages){ const chapters = entries.filter(e=> Number.isFinite(e.page) && e.depth===chapterDepth).sort((a,b)=>a.page-b.page); for(let i=0;i<chapters.length;i++){ const start=chapters[i].page; const end=(i<chapters.length-1)? chapters[i+1].page-1 : numPages; chapters[i].startPage=Math.max(1,start); chapters[i].endPage=Math.min(numPages,end); } return chapters; }

    async function tbBuildPageLengthCache(pdf, ranges){ if(!ranges || !ranges.length) return {}; const minP = Math.min(...ranges.map(r=>r.startPage)); const maxP = Math.max(...ranges.map(r=>r.endPage)); const cache={}; for(let p=minP;p<=maxP;p++){ try{ const t = await tbExtractPageText(pdf,p); cache[p]=t.length; }catch{ cache[p]=0; } await new Promise(r=>setTimeout(r,0)); } return cache; }

    function tbSumCharsFromCache(cache,start,end,limit){ let total=0; for(let p=start;p<=end;p++){ const len=cache[p]||0; if(limit && len>limit) continue; total+=len; } return total; }

    function tbRenderToc(arr, startDepth){ if(!tbTocTree) return; if(!arr||!arr.length){ tbTocTree.innerHTML='<div class="hint">(no TOC)</div>'; return; } const root=document.createElement('div'); root.setAttribute('role','tree'); let lastGroup=null; let groupEl = null; arr.forEach((it,idx)=>{ const d=it.depth; const indentBase = (startDepth!=null) ? Math.max(0, d-startDepth) : d; if(startDepth!=null && d===startDepth && lastGroup !== it.startPage){ // start a new group
            groupEl = document.createElement('div'); groupEl.setAttribute('role','group'); groupEl.className='group-wrapper'; const sep=document.createElement('div'); sep.className='group-sep'; groupEl.appendChild(sep); root.appendChild(groupEl); lastGroup = it.startPage; }
        const el=document.createElement('div'); el.className='tb-chapter'; el.style.paddingLeft=(indentBase*18)+'px'; el.setAttribute('role','treeitem'); const left=document.createElement('div'); left.textContent = `${String(idx+1).padStart(2,'0')} ${it.title}`; const meta=document.createElement('div'); meta.className='tb-meta'; meta.textContent = `pages ${it.startPage||'?'}-${it.endPage||'?'} • ${it.charCount||0} chars`; el.appendChild(left); el.appendChild(meta); if(groupEl) groupEl.appendChild(el); else root.appendChild(el); }); tbTocTree.innerHTML=''; tbTocTree.appendChild(root); }

    // Scan TOC for selected file (first selected file used)
    tbScanBtn?.addEventListener('click', async ()=>{
        const f = (tbFiles && tbFiles.files && tbFiles.files[0]) || null; if(!f){ setStatus('No file selected to scan.', true); return; }
        try{
            tbScanBtn.disabled = true; tbLogLine('Loading file', f.name);
            const ab = await f.arrayBuffer(); tbMetaName.textContent = f.name; tbMetaBytes.textContent = (f.size/1024/1024).toFixed(2)+' MB';
            const ok = await ensurePdfJs(); if(!ok){ tbLogLine('pdf.js not available'); tbScanBtn.disabled=false; return; }
            const pdf = await window.pdfjsLib.getDocument({ data: ab }).promise; tbMetaPages.textContent = pdf.numPages; tbLogLine('PDF loaded pages', pdf.numPages);
            const outline = await pdf.getOutline(); if(!outline || !outline.length){ tbLogLine('No outline/bookmarks found'); tbRenderToc([], null); tbScanBtn.disabled=false; return; }
            const flat = tbFlattenOutline(outline); tbLogLine('outline entries', flat.length);
            const detected = (Array.isArray(outline) && outline.some(it=> Array.isArray(it.items) && it.items.length>0)) ? 1 : tbDetectChapterDepth(flat);
            tbLogLine('detected chapter depth', detected);
            // resolve dests
            for(let i=0;i<flat.length;i++){ const it=flat[i]; try{ const pageIndex = await tbResolveDestToPageIndex(pdf, it.raw.dest || it.raw.destref || it.raw.a || it.raw.dest); it.page = pageIndex!=null ? pageIndex+1 : null; tbLogLine('resolved', it.title, '->', it.page); }catch(e){ it.page = null; } }
            const withPage = flat.filter(x=>Number.isFinite(x.page)).sort((a,b)=>a.page-b.page); const withoutPage = flat.filter(x=>!Number.isFinite(x.page)); const sorted = withPage.concat(withoutPage);
            const chapterEntries = tbComputeChapterRanges(sorted, detected, pdf.numPages);
            for(const e of sorted){ if(e.depth===detected){ const found = chapterEntries.find(c=> c===e || (c.title===e.title && c.page===e.page)); if(found){ e.startPage=found.startPage; e.endPage=found.endPage; } } else { e.startPage = e.page || 1; e.endPage = e.page || e.startPage; } }
            window.tbFullToc = sorted.map((s,idx)=> ({ uid: idx, order: idx+1, title: s.title, depth: s.depth, startPage: s.startPage, endPage: s.endPage, page: s.page }));
            // quick count
            const chaptersForCount = window.tbFullToc.filter(s=> s.depth===detected && Number.isFinite(s.startPage) && Number.isFinite(s.endPage));
            const cache = await tbBuildPageLengthCache(pdf, chaptersForCount);
            for(const s of window.tbFullToc){ if(s.depth===detected && s.startPage && s.endPage){ s.charCount = tbSumCharsFromCache(cache, s.startPage, s.endPage, null); } else { s.charCount = s.charCount||0; } }
            const flattened = window.tbFullToc.map(s=> ({ uid: s.uid, order: s.order, title: s.title, depth: s.depth, startPage: s.startPage, endPage: s.endPage, page: s.page, charCount: s.charCount }));
            const ds = parseInt($('depthStart')?.value||'0',10); tbRenderToc(flattened, Number.isFinite(ds)?ds:0);
            tbLogLine('scan complete');
        }catch(e){ tbLogLine('scan failed', e?.message||e); }
        tbScanBtn.disabled = false;
    });


    function renderTree(){
        const lib = loadLib();
    if(!lib.length){ tbTree.innerHTML = '<div class="hint">No saved content added yet.</div>'; return; }
        function nodeHtml(id, label, kind){ return `<span class="tb-chip" draggable="true" data-id="${id}" data-kind="${kind}">${label}</span>`; }
        tbTree.innerHTML = lib.map((book, bi)=>{
            const chHtml = (book.chapters||[]).map((ch, ci)=>{
                const subHtml = (ch.sub||[]).map((s, si)=> '<div class="tb-sub" data-path="'+bi+':'+ci+':'+si+'"><div>'+nodeHtml(bi+':'+ci+':'+si, s.title||('Section '+(ci+1)+'.'+(si+1)), 'sub')+'</div><div class="tb-meta">'+((s.text||'').length)+' chars</div></div>').join('');
                return '<div class="tb-chapter" data-path="'+bi+':'+ci+'"><div>'+nodeHtml(bi+':'+ci, ch.title||('Chapter '+(ci+1)), 'chapter')+'</div><div class="tb-meta">'+((ch.text||'').length)+' chars '+(subHtml? (' • '+((ch.sub||[]).length)+' sub') : '')+'</div>'+(subHtml? ('<div class="tb-chapters ml-12 mt-6">'+subHtml+'</div>') : '')+'</div>';
            }).join('');

            // Update header with aggregate size (show total KB next to the count)
            try{ savedCount.textContent = `${arr.length} (${(totalBytes/1024).toFixed(1)} KB)`; }catch(e){}
            // if this entry is a pointer to IndexedDB, show a placeholder and resolve asynchronously
            const bookTitleSafe = book.idbRef ? (book.title || ('Book '+(bi+1)+' (saved)')) : (book.title||('Book '+(bi+1)));
            // estimate size in bytes for display
            let estBytes = null;
            try{
                if(book.idbRef && book.chapters && book.chapters.length){
                    estBytes = book.chapters.reduce((acc,c)=> acc + ((c && (c.text||c.fullText||c.snippet)||'').length || 0), 0);
                } else if(book.text){ estBytes = (book.text||'').length; }
            }catch(e){ estBytes = null; }
            const sizeBadge = estBytes==null ? '' : (' • '+(estBytes/1024).toFixed(1)+' KB');
            const metaText = book.idbRef ? ('Stored (indexedDB id '+book.idbRef+') • '+((book.chapters||[]).length)+' chapters'+sizeBadge) : (((book.text||'').length)+' chars • '+((book.chapters||[]).length)+' chapters'+sizeBadge);
            const html = '<div class="tb-book" data-book="'+bi+'"><div class="tb-head"><div class="tb-title" data-book-idx="'+bi+'">'+bookTitleSafe+'</div><div class="tb-actions"><span class="tb-meta">'+metaText+'</span></div></div>' + (chHtml ? ('<div class="tb-chapters mt-6">'+chHtml+'</div>') : '') + '</div>';
            return html;
        }).join('');

        // Drag payload wiring
        tbTree.querySelectorAll('.tb-chip').forEach(ch=>{
            ch.addEventListener('dragstart', (e)=>{
                const id = ch.getAttribute('data-id'); const [bi, ci, si] = id.split(':').map(n=>parseInt(n,10));
                const lib2 = loadLib(); const book = lib2[bi]; if(!book) return;
                let title='', text='';
                if(si!=null && isFinite(si)) { const s = book?.chapters?.[ci]?.sub?.[si]; title = s?.title||'Section'; text = s?.text||''; }
                else if(ci!=null && isFinite(ci)) { const c = book?.chapters?.[ci]; title = c?.title||'Chapter'; text = [c?.text||'', ...(c?.sub||[]).map(x=>x.text||'')].filter(Boolean).join('\n\n'); }
                else {
                    // top-level book: if it's an idbRef pointer, try to fetch the full record synchronously via idbGetBook
                    if(book.idbRef){ title = book.title || 'Book'; text = ''; try{ idbGetBook(book.idbRef).then(full=>{ const payload = JSON.stringify({ title: full.title||book.title, text: (full.payload && full.payload.chapters ? (full.payload.chapters||[]).map(ch=> ch.text || ch.fullText || ch.snippet || '').join('\n\n') : ((full.chapters||[]).map(ch=> ch.text || ch.fullText || ch.snippet || '').join('\n\n'))) }); e.dataTransfer.setData('application/json', payload); }); }catch(e){ log('idbGetBook for drag failed', e?.message||e); } }
                    title = book.title||'Book';
                }
                const payload = JSON.stringify({ title, text });
                e.dataTransfer.setData('application/json', payload);
                e.dataTransfer.effectAllowed = 'copy';
            }); // end addEventListener('dragstart')
        }); // end forEach('.tb-chip')

        // Resolve idbRef titles asynchronously so UI shows friendly names
        (async ()=>{
            const nodes = tbTree.querySelectorAll('[data-book-idx]');
            for(const n of nodes){
                const idx = parseInt(n.getAttribute('data-book-idx'), 10);
                const lib2 = loadLib(); const book = lib2[idx];
                if(book && book.idbRef){ try{ const full = await idbGetBook(book.idbRef); if(full && full.title) n.textContent = full.title + ' (saved)'; }catch(e){ /* ignore */ } }
            }
        })();
    }
    // allow other parts of the page to refresh the saved textbook UI
    try{ window.refreshTextbookLibrary = window.refreshTextbookLibrary || renderTree; }catch(e){}

    // Upload handling: only record selection; processing happens on button click
    tbFiles?.addEventListener('change', ()=>{
        const files = Array.from(tbFiles.files||[]);
        tbName && (tbName.textContent = files.length? `${files.length} file(s)` : 'No files selected');
        if(!files.length){ setStatus(''); return; }
        logDbg('selected', files.map(f=>f.name));
        setStatus('Ready. Click “Process selected” to begin.');
    });

    // Process selected files on demand
    tbProcess?.addEventListener('click', async ()=>{
        const files = Array.from(tbFiles?.files||[]);
        if(!files.length){ setStatus('No files selected.', true); return; }
        tbProcess.disabled = true; const origLabel = tbProcess.textContent; tbProcess.textContent = 'Processing…';
        setStatus('Extracting…'); logDbg('process begin', files.map(f=>f.name));
        const lib = loadLib(); let added = 0;
        for(let i=0;i<files.length;i++){
            const f = files[i];
            try{
                setStatus(`(${i+1}/${files.length}) ${f.name}…`); logDbg('processing', f.name, f.type||'');
                const text = await extractTextFromFile(f);
                const chapters = segmentChapters(text);
                lib.push({ title: f.name.replace(/\.[^.]+$/, ''), text, chapters });
                added++;
            }catch(e){ console.warn('extract failed', f?.name, e); logDbg('extract failed', f?.name, e?.message||e); }
        }
        const saved = saveLib(lib);
        renderTree();
        setStatus(added? 'Done.' : 'No content extracted. Try another file.', !added);
        tbProcess.textContent = origLabel; tbProcess.disabled = false;
    });

    tbClear?.addEventListener('click', ()=>{ if(confirm('Clear content library?')){ saveLib([]); renderTree(); setStatus('Cleared.'); } });

    // Drop integration: Validate Answers and Generate MCQ
    function makeDropzone(el, onDrop){ if(!el) return; ['dragenter','dragover'].forEach(ev=> el.addEventListener(ev, (e)=>{ e.preventDefault(); el.classList.add('hover'); e.dataTransfer.dropEffect='copy'; })); ['dragleave','dragend','drop'].forEach(ev=> el.addEventListener(ev, ()=> el.classList.remove('hover'))); el.addEventListener('drop', (e)=>{ e.preventDefault(); try{ const json = e.dataTransfer.getData('application/json'); if(!json) return; const data = JSON.parse(json); onDrop && onDrop(data); }catch{} }); }

    // Validate Answers dropzone (under output/actions area)
    (function(){
        const actions = document.getElementById('aiValidateActions');
        if(!actions || actions.dataset.tbDropWired==='1') return; actions.dataset.tbDropWired='1';
    const dz = document.createElement('div'); dz.id='tbDropValidate'; dz.className='dropzone'; dz.textContent='Drop content chapters here to supplement Validate Answers'; actions.appendChild(dz);
        const ctx = { pieces: [] };
        makeDropzone(dz, (data)=>{
            if(!data || !data.text) return; ctx.pieces.push(data); dz.textContent = `Attached ${ctx.pieces.length} chapter(s).`;
        });
        // Hook the Validate button to include context
        const vBtn = document.getElementById('aiLikeBtn2');
        if(vBtn && !vBtn.dataset.tbAug){
            vBtn.dataset.tbAug='1';
            const origHandler = vBtn.onclick; // not used in current wiring (addEventListener used)
            // Monkey-patch the generator to read extra context in prompt build
            const originalFetch = window.GoogleGenerativeAI;
            // Instead of patching SDK, patch the click handler path by intercepting prompt creation via a global flag
            window.__tbValidateCtx = ctx;
        }
        // Patch prompt usage inside validate block by wrapping model.generateContent
        const wrapGen = async (key, promptBuilder)=>{
            const AI = window.GoogleGenerativeAI; const client = new AI(key); const model = client.getGenerativeModel({ model: 'gemini-2.5-flash' });
            const extra = (window.__tbValidateCtx?.pieces||[]).map(p=> p.text).join('\n\n');
            const prompt = promptBuilder(extra);
            const resp = await model.generateContent({ contents: [{ role:'user', parts:[{ text: prompt }] }] });
            return (await resp?.response?.text?.())?.trim();
        };
        // Expose for validate module to call
        window.__tbWrapGen = wrapGen;
    })();

    // Generate MCQ drop target: attach to the AI file panel status area
    (function(){
        const status = document.getElementById('aiFileStatus'); if(!status || status.dataset.tbDropWired==='1') return; status.dataset.tbDropWired='1';
    const dz = document.createElement('div'); dz.id='tbDropGenerate'; dz.className='dropzone mt-8'; dz.textContent='Drop content chapters here to generate MCQs'; status.parentElement?.appendChild(dz);
        const ctx = { pieces: [] };
        makeDropzone(dz, (data)=>{ if(!data || !data.text) return; ctx.pieces.push(data); dz.textContent = `Attached ${ctx.pieces.length} chapter(s).`; });
        window.__tbGenCtx = ctx;
    })();

    // Wire the AI file chooser's drop element (created in the choose-file parent) to the same generator context
    (function(){
        try{
            const dropEl = document.getElementById('aiFileTbDrop');
            if(!dropEl) return;
            // Ensure global gen context exists
            window.__tbGenCtx = window.__tbGenCtx || { pieces: [] };
            makeDropzone(dropEl, (data)=>{
                if(!data || !data.text) return;
                window.__tbGenCtx.pieces.push(data);
                dropEl.textContent = `Attached ${window.__tbGenCtx.pieces.length} chapter(s)`;
                // mirror to existing status dropzone if present
                const statusDz = document.getElementById('tbDropGenerate'); if(statusDz) statusDz.textContent = dropEl.textContent;
            });
        }catch(e){ console.log('aiFileTbDrop wiring failed', e); }
    })();

    // Initial render
    renderTree();
})();
</script>
<script>
// Flashcards + simple SRS (client-side) implementation
(function(){
    const $ = id => document.getElementById(id);
    const SRS_KEY = 'srs.v1';
    let fcDeck = null; // array of cards { id, q, a, choices, ix }
    let fcSession = null; // { queue: [], pos: 0 }

    // Global Flashcard Timer (cumulative, persisted)
    const FCTIMER_KEY = 'fc.timer.v1';
    function readFcTimer(){ try{ return JSON.parse(localStorage.getItem(FCTIMER_KEY) || '{}'); }catch(e){ return {}; } }
    function writeFcTimer(obj){ try{ localStorage.setItem(FCTIMER_KEY, JSON.stringify(obj||{})); }catch(e){} }

    let fcTimerAccumMs = 0;                 // per-session total (resets at session start)
    let fcTimerMode = 'always';             // 'always' | 'hover' (default to visible)
    let fcTimerInterval = null;             // interval id
    let fcTimerRunningSince = null;         // timestamp when started

    function loadFcTimerState(){ const st = readFcTimer(); if(st && (st.mode === 'hover' || st.mode === 'always')) fcTimerMode = st.mode; }
    function saveFcTimerState(){ writeFcTimer({ mode: fcTimerMode }); }
    function formatHMS(ms){ try{ const t = Math.max(0, Math.floor(ms/1000)); const h = Math.floor(t/3600); const m = Math.floor((t%3600)/60); const s = t%60; return (h>0? (h+':'+String(m).padStart(2,'0')+':'+String(s).padStart(2,'0')) : (m+':'+String(s).padStart(2,'0'))); }catch(e){ return '00:00'; } }
    function updateFcTimerUI(){ try{
        const nowPart = fcTimerRunningSince ? (Date.now() - fcTimerRunningSince) : 0; const txt = formatHMS(fcTimerAccumMs + nowPart);
        const el1 = $('fcTimer'); if(el1){ el1.textContent = txt; el1.classList.toggle('hover-only', fcTimerMode === 'hover'); el1.classList.toggle('always', fcTimerMode !== 'hover'); }
        const el2 = document.getElementById('fcOverlayTimer'); if(el2){ el2.textContent = txt; el2.classList.toggle('hover-only', fcTimerMode === 'hover'); el2.classList.toggle('always', fcTimerMode !== 'hover'); }
    }catch(e){} }
    function tickFcTimer(){ try{ updateFcTimerUI(); }catch(e){} }
    function startFcTimer(){ try{ fcTimerAccumMs = 0; if(fcTimerRunningSince) return; fcTimerRunningSince = Date.now(); if(!fcTimerInterval) fcTimerInterval = setInterval(tickFcTimer, 1000); updateFcTimerUI(); }catch(e){} }
    function stopFcTimer(){ try{ if(fcTimerRunningSince){ fcTimerAccumMs += (Date.now() - fcTimerRunningSince); fcTimerRunningSince = null; } if(fcTimerInterval){ clearInterval(fcTimerInterval); fcTimerInterval = null; } updateFcTimerUI(); saveFcTimerState(); }catch(e){} }
    function toggleFcTimerMode(){ try{ fcTimerMode = (fcTimerMode === 'hover') ? 'always' : 'hover'; const el = $('fcTimer'); const el2 = document.getElementById('fcOverlayTimer'); if(el){ try{ el.classList.add('pulse'); }catch(e){} } if(el2){ try{ el2.classList.add('pulse'); }catch(e){} } setTimeout(()=>{ try{ if(el) el.classList.remove('pulse'); if(el2) el2.classList.remove('pulse'); }catch(e){} }, 360); updateFcTimerUI(); saveFcTimerState(); }catch(e){} }
    function initFcTimer(){ try{ loadFcTimerState(); updateFcTimerUI(); const el = $('fcTimer'); if(el){ el.addEventListener('click', toggleFcTimerMode); }
        // Observe for overlay removal to stop timer when session ends/escapes
        try{ const obs = new MutationObserver((muts)=>{ try{
                for(const m of muts){
                    // If the session overlay is removed, stop timer
                    if(m && m.removedNodes && m.removedNodes.length){
                        for(const n of m.removedNodes){ try{ if(n && n.id === 'fcSessionOverlay'){ stopFcTimer(); } }catch(e){} }
                    }
                    // If the pre-session countdown overlay is removed and fcSessionOverlay exists, start timer now
                    if(m && m.removedNodes && m.removedNodes.length){
                        for(const n of m.removedNodes){ try{ if(n && n.id === 'fcPreSessionOverlay' && document.getElementById('fcSessionOverlay')){ try{ startFcTimer(); }catch(e){} } }catch(e){} }
                    }
                }
            }catch(e){} }); obs.observe(document.body, { childList: true, subtree: true }); }catch(e){}
    }catch(e){} }

    function readSrs(){ try{ return JSON.parse(localStorage.getItem(SRS_KEY) || '{}'); }catch(e){ return {}; } }
    function writeSrs(obj){ try{ localStorage.setItem(SRS_KEY, JSON.stringify(obj||{})); }catch(e){} }

    function downloadBlob(filename, blob){ try{ const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); setTimeout(()=>{ try{ a.remove(); URL.revokeObjectURL(url); }catch{} }, 500); }catch(e){ alert('Download failed: '+(e?.message||e)); } }

    function shuffleInplace(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); const t=arr[i]; arr[i]=arr[j]; arr[j]=t; } return arr; }

    function renderDeckInfo(){ const info = $('fcDeckInfo'); if(!info) return; if(!fcDeck) return info.textContent = 'No deck loaded.'; info.textContent = `Deck loaded — ${fcDeck.length} cards.`; }

    function enableStart(enable){ const s = $('fcStartSession'); if(s) s.disabled = !enable; }

    // Expose a safe global setter so other modules (e.g., parser) can overwrite the deck reliably
    try{ window.fcSetDeckFromItems = function(items){ try{
        const hasItems = Array.isArray(items) && items.length > 0;
        fcDeck = hasItems ? items.map((it, ix)=>({ id: it.num || (ix+1), q: it.q || it.text || '', a: (Array.isArray(it.choices) && typeof it.correctIdx === 'number') ? (it.choices[it.correctIdx] || '') : '', choices: Array.isArray(it.choices)? it.choices.slice() : [], ix })) : null;
        // Reset any in-progress session and refresh UI
        fcSession = null;
        renderDeckInfo();
        enableStart(!!hasItems);
        try{ const prog = $('fcProgressText'); if(prog) prog.textContent = `0 / ${hasItems ? (items.length||0) : 0}`; }catch(e){}
        // Hide card area if deck cleared
        if(!hasItems){ try{ const area = $('fcCardArea'); const info = $('fcDeckInfo'); if(area) area.style.display='none'; if(info) info.style.display=''; }catch(e){} }
    }catch(e){ console.warn('fcSetDeckFromItems failed', e); } } }catch(e){}

    // Load from parsed items (state.items)
    $('fcFromParsed')?.addEventListener('click', (e)=>{
        try{
            const items = (window.__quizState && window.__quizState.items) ? window.__quizState.items : (window.state && state.items) ? state.items : [];
            if(!items || !items.length){ alert('No parsed items found to build a deck. Parse or load a quiz first.'); return; }
            fcDeck = items.map((it, ix)=>({ id: it.num || (ix+1), q: it.q || it.text || '', a: (Array.isArray(it.choices) && typeof it.correctIdx === 'number') ? (it.choices[it.correctIdx] || '') : '', choices: Array.isArray(it.choices)? it.choices.slice() : [], ix }));
            renderDeckInfo(); enableStart(true);
        }catch(err){ console.error('fcFromParsed failed', err); alert('Could not load deck from parsed items.'); }
    });

    // Start session — open a distraction-free in-page overlay (black UI) with countdown.
    // Uses the same countdown dialog (but with white outline) and keyboard controls:
    // Space = flip, 1=Again, 2=Hard, 3=Good, 4=Easy, Enter/Right = next, Esc = close
    $('fcStartSession')?.addEventListener('click', (e)=>{
        try{
            if(!fcDeck || !fcDeck.length){ alert('No deck loaded. Click "Load from parsed" first.'); return; }
            const deckCopy = fcDeck.map(c => ({ id: c.id, q: c.q, a: c.a, choices: Array.isArray(c.choices) ? c.choices.slice() : [], ix: c.ix }));
            // Timer will start after the countdown finishes (see MutationObserver in initFcTimer)

            // show a focused white-outlined countdown overlay tailored for flashcards
            function showFcPreSessionOverlay(deck, cb){
                try{
                    if(window.__preQuizOverlayActive){ try{ cb(); }catch(e){} return; }
                    window.__preQuizOverlayActive = true;
                    const overlay = document.createElement('div'); overlay.id = 'fcPreSessionOverlay';
                    overlay.style.position = 'fixed'; overlay.style.left = '0'; overlay.style.top = '0'; overlay.style.right = '0'; overlay.style.bottom = '0';
                    overlay.style.display = 'flex'; overlay.style.alignItems = 'center'; overlay.style.justifyContent = 'center';
                    overlay.style.zIndex = '999999';
                    // less dark during setup so user can still see background; will cross-fade into session UI
                    overlay.style.background = 'rgba(0,0,0,0.55)'; overlay.style.backdropFilter = 'blur(4px)'; overlay.style.color = '#fff'; overlay.style.fontSize = '16px'; overlay.style.padding = '24px'; overlay.style.boxSizing = 'border-box';
                    overlay.style.transition = 'background 320ms ease, opacity 320ms ease, backdrop-filter 320ms ease';
                    overlay.style.opacity = '1';
                    overlay.style.textAlign = 'center'; overlay.style.pointerEvents = 'auto';

                    const card = document.createElement('div'); card.style.maxWidth = '820px'; card.style.width = '92%'; card.style.background = 'linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01))'; card.style.borderRadius = '10px'; card.style.padding = '18px'; card.style.pointerEvents = 'none';
                    // White outline per user request
                    card.style.outline = '2px solid rgba(255,255,255,0.95)'; card.style.outlineOffset = '6px';
                    card.style.boxShadow = '0 12px 36px rgba(0,0,0,0.6)';

                    const title = document.createElement('div'); title.style.fontSize = '18px'; title.style.fontWeight = '700'; title.style.marginBottom = '8px'; title.textContent = 'Study Session — ready in:';
                    // countdown
                    const countdown = document.createElement('div'); countdown.style.marginTop = '8px'; countdown.style.fontSize = '28px'; countdown.style.fontWeight = '700'; countdown.textContent = '3';
                    // show key shortcuts so users see controls before session starts
                    const hintText = document.createElement('div'); hintText.style.marginTop = '12px'; hintText.style.fontSize = '13px'; hintText.style.color = 'rgba(255,255,255,0.9)'; hintText.style.opacity = '0.95'; hintText.textContent = 'Controls: Space or F = flip · 1=Again 2=Hard 3=Good 4=Easy · Enter/Right = next · Esc = exit';
                    card.appendChild(title); card.appendChild(countdown); card.appendChild(hintText);
                    overlay.appendChild(card); document.body.appendChild(overlay);

                    // Immediately open the session overlay beneath this pre-overlay so it can fade in during the countdown
                    // Also disable background interaction (keyboard + pointer) while countdown is active by capturing events.
                    let __preOverlayKeyBlocker = function(ev){ try{
                        // Allow the results "Restart" shortcut (r) to pass through when the
                        // Restart button is visible and enabled. This prevents the countdown
                        // capture from permanently blocking the user's ability to restart
                        // from the results screen while overlays are active.
                        try{
                            const k = (ev && ev.key) ? ev.key : '';
                            if(k && k.toLowerCase && k.toLowerCase() === 'r'){
                                const restartBtn = document.getElementById('restart');
                                if(restartBtn && restartBtn.offsetParent !== null && !restartBtn.disabled){
                                    // allow event to propagate so global handlers can pick it up
                                    return;
                                }
                            }
                        }catch(_){ }
                        ev.stopImmediatePropagation(); ev.preventDefault();
                    }catch(e){} };
                    // Capture keydown events at the document level during countdown to prevent underlying handlers from firing.
                    document.addEventListener('keydown', __preOverlayKeyBlocker, true);
                    // Prevent pointer interactions from reaching the page by ensuring the overlay is the topmost element
                    // and by stopping propagation on pointer events targeting the overlay.
                    overlay.addEventListener('pointerdown', function(ev){ try{ ev.stopPropagation(); ev.preventDefault(); }catch(e){} }, true);

                    // Temporarily de-initialize the last-focused element (commonly the Start button) so an Enter key
                    // won't re-trigger it while the countdown/session is starting. We'll restore it after the session overlay
                    // is created and the countdown finishes.
                    let __prevActiveEl = null; let __prevWasDisabled = false;
                    try{
                        const pa = document.activeElement;
                        if(pa && pa instanceof HTMLElement){ __prevActiveEl = pa; try{ __prevWasDisabled = !!pa.disabled; }catch{} try{ pa.blur && pa.blur(); }catch{}
                            // If it's a button or input that could receive Enter, disable it temporarily
                            try{ if((pa.tagName === 'BUTTON' || pa.tagName === 'INPUT' || pa.getAttribute && pa.getAttribute('role') === 'button')){ pa.disabled = true; pa.setAttribute('data-fc-temp-disabled','1'); } }catch(e){}
                        }
                    }catch(e){}

                    try{ cb(); }catch(e){}
                    // If the session overlay was created, lengthen its fade to match the countdown
                    try{
                        const sess = document.getElementById('fcSessionOverlay');
                        if(sess){
                            const fadeMs = (3 * 1000) + 160; // countdown seconds + small buffer
                            sess.style.transition = `opacity ${fadeMs}ms ease`;
                            // trigger fade-in (openFlashcardsSessionOverlay also tries to fade in; overriding here ensures duration)
                            requestAnimationFrame(()=>{ try{ sess.style.opacity = '1'; }catch(e){} });
                        }
                    }catch(e){}

                    let t = 3; const iv = setInterval(()=>{
                        try{
                            t--;
                            if(t <= 0){
                                clearInterval(iv);
                                // cross-fade the pre-overlay out to reveal the session UI
                                overlay.style.background = 'rgba(0,0,0,0.95)'; overlay.style.backdropFilter = 'blur(8px)';
                                requestAnimationFrame(()=>{ overlay.style.opacity = '0'; });
                                // remove after transition completes and restore normal event flow
                                setTimeout(()=>{ try{ if(document.body.contains(overlay)) document.body.removeChild(overlay); }catch(_ ){}
                                    try{ document.removeEventListener('keydown', __preOverlayKeyBlocker, true); }catch(_){}
                                    // restore any temporarily-disabled element
                                    try{ if(__prevActiveEl && __prevActiveEl.getAttribute && __prevActiveEl.getAttribute('data-fc-temp-disabled')){ try{ __prevActiveEl.disabled = __prevWasDisabled ? true : false; __prevActiveEl.removeAttribute('data-fc-temp-disabled'); }catch(e){} } }catch(e){}
                                    window.__preQuizOverlayActive = false; }, 420);
                            } else { countdown.textContent = String(t); }
                        }catch(e){ clearInterval(iv); try{ document.body.removeChild(overlay); }catch{} window.__preQuizOverlayActive = false; }
                    }, 1000);
                }catch(e){ console.warn('showFcPreSessionOverlay failed', e); try{ cb(); }catch(e){} }
            }

            // Open the in-page full-screen overlay session
            function openFlashcardsSessionOverlay(deck){
                try{
                    // create overlay container
                    const ol = document.createElement('div'); ol.id = 'fcSessionOverlay';
                    ol.style.position = 'fixed'; ol.style.left = '0'; ol.style.top = '0'; ol.style.right = '0'; ol.style.bottom = '0';
                    ol.style.zIndex = '999998'; ol.style.background = '#000'; ol.style.color = '#fff'; ol.style.display = 'flex'; ol.style.alignItems = 'center'; ol.style.justifyContent = 'center'; ol.style.padding = '18px'; ol.style.boxSizing = 'border-box';
                    // start invisible and fade in so the pre-overlay can cross-fade to it
                    ol.style.opacity = '0'; ol.style.transition = 'opacity 360ms ease';
                    ol.innerHTML = `
                        <style>
                        .fc-bg-decor{ position:absolute; inset:0; pointer-events:none; overflow:hidden; z-index:1 }
                        .fc-bg-decor .dot{ position:absolute; border-radius:50%; filter:blur(64px); opacity:0.10; transform:translateZ(0); }
                        .fc-bg-decor .one{ width:520px; height:520px; left:-120px; top:-90px; background: radial-gradient(circle at 30% 30%, rgba(106,169,255,0.95), rgba(106,169,255,0.35) 30%, transparent 60%); }
                        .fc-bg-decor .two{ width:420px; height:420px; right:-140px; bottom:-100px; background: radial-gradient(circle at 70% 70%, rgba(130,100,255,0.95), rgba(130,100,255,0.32) 30%, transparent 60%); }
                        /* Overlay timer: positioned above the question number but centered over the flashcard text */
                        .fc-otimer-wrap{ position:absolute; left:50%; transform:translateX(-50%); top:5%; z-index:5; display:flex; justify-content:center; }
                        .fc-otimer{ font:700 18px ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; color:#e6edf3; background: transparent; border: none; padding:0 2px; border-radius:0; box-shadow:none; cursor:pointer; -webkit-user-select:none; user-select:none; transition: transform .12s ease, opacity .12s ease; }
                        .fc-otimer:hover{ transform: translateY(-2px); }
                        .fc-otimer.hover-only{ opacity:0; pointer-events:none }
                        .fc-card:hover .fc-otimer.hover-only{ opacity:1; pointer-events:auto }
                        .fc-otimer.pulse{ animation: fcTimerPulse 300ms ease; }
                        .fc-card{ position:relative; z-index:2; padding:48px 22px; box-sizing:border-box; max-width:1100px; margin:0 auto }
                        /* Flip container */
                        .fc-flip-wrap{ perspective: 1400px; display:flex; justify-content:center }
                        .fc-flip{ width:100%; max-width:980px; transform-style: preserve-3d; transition: transform 520ms cubic-bezier(.2,.9,.3,1); cursor:pointer }
                        .fc-flip.flipped{ transform: rotateY(180deg); }
                        .fc-face{ backface-visibility: hidden; -webkit-backface-visibility: hidden; position:relative; display:block; min-height:120px; padding-bottom:6px }
                        .fc-face.front{ transform: rotateY(0deg) }
                        .fc-face.back{ transform: rotateY(180deg); position:absolute; left:0; top:0; width:100% }
                        .fc-question{ font-size:34px; font-weight:700; text-align:center; line-height:1.3; color:#fff; max-height:8.6em; overflow:hidden; padding:4px 0 6px }
                        /* Make both faces share identical text styling for consistency */
                        .fc-answer, .fc-question{ font-size:34px; font-weight:700; text-align:center; line-height:1.3; color:#fff; padding-bottom:6px }
                        .fc-controls{ display:flex; gap:14px; justify-content:center; margin-top:16px; transition: opacity .18s ease, transform .18s ease; opacity:0; transform: translateY(6px); }
                        /* Reveal all rating buttons when the control group is hovered or when any child has focus */
                        .fc-controls:hover, .fc-controls:focus-within{ opacity:1; transform: translateY(0); }
                        .fc-controls button{ background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02)); border: 1px solid rgba(255,255,255,0.10); color:#fff; padding:12px 20px; border-radius:999px; box-shadow: 0 8px 24px rgba(0,0,0,0.55); cursor:pointer; font-weight:600; transition: transform .12s ease, box-shadow .12s ease, opacity .12s ease; }
                        .fc-controls button:hover{ transform: translateY(-2px); box-shadow: 0 12px 36px rgba(0,0,0,0.6) }
                        .fc-controls button:active{ transform: translateY(0) }
                        /* Individual button colors */
                        #fcOAgain{ background: linear-gradient(180deg, rgba(239,68,68,0.92), rgba(220,38,38,0.92)); border-color: rgba(190,18,60,0.9); }
                        #fcOHard{ background: linear-gradient(180deg, rgba(249,115,22,0.95), rgba(234,88,12,0.95)); border-color: rgba(200,80,10,0.9); }
                        #fcOGood{ background: linear-gradient(180deg, rgba(34,197,94,0.92), rgba(16,185,129,0.92)); border-color: rgba(4,120,87,0.9); }
                        #fcOEasy{ background: linear-gradient(180deg, rgba(96,165,250,0.9), rgba(59,130,246,0.9)); border-color: rgba(30,90,200,0.9); }
                        .fc-close{ position:absolute; left:14px; bottom:12px; z-index:3; opacity:0; transform: translateY(6px); transition: opacity .18s ease, transform .18s ease; }
                        /* Only reveal the close control when it itself is hovered */
                        .fc-close:hover{ opacity:1; transform: translateY(0); }
                        .fc-prog{ position:absolute; left:14px; top:14px; color:#c9d6e6; font-size:13px; z-index:3 }
                        </style>
                        <div class="fc-bg-decor" aria-hidden="true"><div class="dot one"></div><div class="dot two"></div></div>
                        <div class="fc-card">
                            <div id="fcOverlayProg" class="fc-prog">0 / 0</div>
                            <div class="fc-otimer-wrap"><div id="fcOverlayTimer" class="fc-otimer" title="Click to toggle: Always visible ↔ Show on hover">00:00</div></div>
                            <div class="fc-flip-wrap"><div id="fcFlipContainer" class="fc-flip" role="button" tabindex="0">
                                <div class="fc-face front"><div id="fcOverlayQ" class="fc-question"></div></div>
                                <div class="fc-face back"><div id="fcOverlayA" class="fc-answer"></div></div>
                            </div></div>
                            <div class="fc-controls">
                                <button id="fcOAgain">Again</button>
                                <button id="fcOHard">Hard</button>
                                <button id="fcOGood">Good</button>
                                <button id="fcOEasy">Easy</button>
                            </div>
                            <div class="fc-close"><button id="fcOExit" class="btn small">Close</button></div>
                        </div>
                    `;
                    document.body.appendChild(ol);
                    // trigger fade-in
                    requestAnimationFrame(()=>{ try{ ol.style.opacity = '1'; }catch(e){} });

                    // create session queue
                    const queue = deck.map(c=> ({ ...c })); shuffleInplace(queue);
                    fcSession = { queue, pos: 0 };

                    const SRS_KEY = 'srs.v1';
                    function readSrsLocal(){ try{ return JSON.parse(localStorage.getItem(SRS_KEY) || '{}'); }catch(e){ return {}; } }
                    function writeSrsLocal(obj){ try{ localStorage.setItem(SRS_KEY, JSON.stringify(obj||{})); }catch(e){} }

                    function renderOverlayCard(){
                        const card = (fcSession && fcSession.queue && fcSession.queue.length) ? fcSession.queue[fcSession.pos] : null;
                        const qEl = document.getElementById('fcOverlayQ');
                        const aEl = document.getElementById('fcOverlayA');
                        const prog = document.getElementById('fcOverlayProg');
                        const flipEl = document.getElementById('fcFlipContainer');
                        if(!card){
                            if(qEl) qEl.textContent = 'No cards.';
                            if(aEl) aEl.textContent = '';
                            if(flipEl) flipEl.classList.remove('flipped');
                            if(prog) prog.textContent = '0 / 0';
                            return;
                        }
                        if(qEl) qEl.textContent = String(card.q||'');
                        if(aEl) aEl.textContent = String(card.a||'');
                        // ensure front is shown
                        if(flipEl) flipEl.classList.remove('flipped');
                        if(prog) prog.textContent = `${(fcSession.pos+1)} / ${fcSession.queue.length}`;
                    }

                    function saveRatingAndAdvance(level){ try{
                        const card = fcSession.queue[fcSession.pos]; if(!card) return;
                        const srs = readSrsLocal(); const key = String(card.id); const now = Date.now(); const rec = srs[key] || { box: 0, last: null, streak: 0 };
                        // map level: 0=Again,1=Hard,2=Good,3=Easy
                        if(level === 0){ rec.box = 0; rec.streak = 0; rec.last = now; }
                        else if(level === 1){ rec.box = Math.max(0, (rec.box||0) - 1); rec.streak = 0; rec.last = now; }
                        else if(level === 2){ rec.box = Math.min(5,(rec.box||0)+1); rec.streak = (rec.streak||0)+1; rec.last = now; }
                        else if(level === 3){ rec.box = Math.min(6,(rec.box||0)+2); rec.streak = (rec.streak||0)+1; rec.last = now; }
                        srs[key] = rec; writeSrsLocal(srs);
                        // move or remove from queue depending on level (Again/Hard -> move to end; Good/Easy -> remove)
                        if(level === 0 || level === 1){ const item = fcSession.queue.splice(fcSession.pos,1)[0]; fcSession.queue.push(item); }
                        else { fcSession.queue.splice(fcSession.pos,1); }
                        // sync: storage event will fire for other windows
                        // if session finished
                        if(fcSession.queue.length === 0){
                            // Show an in-overlay completion sequence: message -> "Returning to Main Menu" -> fade out
                            try{
                                const overlayEl = document.getElementById('fcSessionOverlay');
                                if(overlayEl){
                                    // create centered message container
                                    try{ const prev = document.getElementById('fcCompleteContainer'); if(prev) prev.remove(); }catch(e){}
                                    const cont = document.createElement('div'); cont.id = 'fcCompleteContainer';
                                    // Mount on body so it persists while the overlay fades — use fixed to cover viewport
                                    cont.style.position = 'fixed'; cont.style.inset = '0'; cont.style.display = 'flex'; cont.style.alignItems = 'center'; cont.style.justifyContent = 'center'; cont.style.zIndex = '9999999'; cont.style.pointerEvents = 'none';
                                    // blur what's behind the pop-up (like the countdown overlay)
                                    cont.style.backdropFilter = 'blur(6px)'; cont.style.background = 'rgba(0,0,0,0.28)';
                                    const box = document.createElement('div');
                                    box.style.background = 'linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.5))';
                                    box.style.border = '1px solid rgba(255,255,255,0.06)';
                                    box.style.padding = '18px 22px'; box.style.borderRadius = '12px'; box.style.textAlign = 'center'; box.style.color = '#fff'; box.style.maxWidth = '820px'; box.style.boxSizing = 'border-box'; box.style.opacity = '0'; box.style.transition = 'opacity .28s ease';
                                    /* match flashcard face text size and strong outline like the countdown card */
                                    box.style.outline = '2px solid rgba(255,255,255,0.95)'; box.style.outlineOffset = '6px';
                                    const main = document.createElement('div'); main.textContent = 'Completed all Flashcards'; main.style.fontSize = '34px'; main.style.fontWeight = '700'; main.style.lineHeight = '1.2'; main.style.marginBottom = '8px';
                                    const sub = document.createElement('div'); sub.id = 'fcCompleteSub'; sub.textContent = 'Returning to Main Menu'; sub.style.fontSize = '20px'; sub.style.fontWeight = '700'; sub.style.opacity = '0'; sub.style.transition = 'opacity .36s ease';
                                    box.appendChild(main); box.appendChild(sub); cont.appendChild(box); document.body.appendChild(cont);
                                    // fade in main then sub, then start returning to main menu
                                    requestAnimationFrame(()=>{ try{ box.style.opacity = '1'; }catch(e){} });
                                    setTimeout(()=>{ try{ sub.style.opacity = '1'; }catch(e){} }, 900);
                                    // Start the overlay-close sequence after a short delay so the popup remains visible
                                    // while the overlay fades; actual de-blur+fade of the popup is handled by closeOverlay().
                                    setTimeout(()=>{ try{ closeOverlay(); }catch(e){} }, 1540);
                                    return;
                                }
                            }catch(e){}
                            // Fallback: close overlay then show a simple alert
                            try{ closeOverlay(); }catch(e){}
                            setTimeout(()=>{ try{ alert('Session complete.'); }catch(e){} }, 420);
                            return;
                        }
                        if(fcSession.pos >= fcSession.queue.length) fcSession.pos = 0;
                        renderOverlayCard();
                    }catch(e){ console.error('saveRatingAndAdvance', e); } }

                    function flipOverlay(){ const flipEl = document.getElementById('fcFlipContainer'); if(!flipEl) return; flipEl.classList.toggle('flipped'); }
                    function nextOverlay(){ if(!fcSession) return; fcSession.pos = (fcSession.pos + 1) % fcSession.queue.length; renderOverlayCard(); }
                    function closeOverlay(){ try{
                        const el = document.getElementById('fcSessionOverlay');
                        // Robust fade-out: prefer transitionend event, fall back to timeout.
                        function _cleanup(){ try{ document.removeEventListener('keydown', overlayKeyHandler); }catch(e){} try{ fcSession = null; }catch(e){}
                            try{ const startBtn = document.getElementById('fcStartSession'); if(startBtn) { try{ startBtn.focus(); }catch(e){} } }catch(e){}
                        }
                        if(el){
                            try{
                                // Detect completion popup either inside overlay or portaled on body
                                const compInside = (el.querySelector && el.querySelector('#fcCompleteContainer')) || null;
                                const compOnBody = document.getElementById('fcCompleteContainer');
                                // Helper to remove a portaled completion container with de-blur + fade sequence
                                const removePortaledCompletion = function(cont){
                                    try{
                                        if(!cont) return;
                                        const box = cont.firstElementChild || cont.querySelector('div');
                                        // Animate backdrop -> transparent so the page de-blurs before the box fades
                                        try{
                                            cont.style.transition = cont.style.transition || 'background .28s ease, backdrop-filter .28s ease, -webkit-backdrop-filter .28s ease';
                                            // Trigger reflow then de-blur
                                            void cont.offsetWidth;
                                            requestAnimationFrame(()=>{
                                                try{ cont.style.background = 'transparent'; cont.style.backdropFilter = 'none'; cont.style.WebkitBackdropFilter = 'none'; }catch(e){}
                                            });
                                        }catch(e){}
                                        // After backdrop transition, fade the inner box then remove
                                        setTimeout(()=>{
                                            try{
                                                if(box){ box.style.transition = box.style.transition || 'opacity .22s ease'; box.style.opacity = '0'; }
                                            }catch(e){}
                                            // remove cont after box fade
                                            setTimeout(()=>{ try{ if(document.body.contains(cont)) document.body.removeChild(cont); }catch(e){} }, 320);
                                        }, 260);
                                    }catch(e){ try{ if(cont && document.body.contains(cont)) document.body.removeChild(cont); }catch(e){} }
                                };

                                const startOverlayFade = function(afterOverlayRemoved){
                                    try{
                                        // ensure we have a transition; force a reflow then start fade
                                        el.style.transition = el.style.transition || 'opacity 320ms ease, transform 220ms ease';
                                        void el.offsetWidth;
                                        const onEnd = function(ev){ try{ if(ev && ev.target !== el) return; el.removeEventListener('transitionend', onEnd); try{ if(document.body.contains(el)) document.body.removeChild(el); }catch(e){} if(typeof afterOverlayRemoved === 'function') afterOverlayRemoved(); _cleanup(); }catch(e){} };
                                        el.addEventListener('transitionend', onEnd);
                                        requestAnimationFrame(()=>{ try{ el.style.opacity = '0'; el.style.transform = 'scale(0.995)'; }catch(e){} });
                                        // Fallback in case transitionend doesn't fire
                                        setTimeout(()=>{ try{ if(document.body.contains(el)) { try{ document.body.removeChild(el); }catch(e){} } if(typeof afterOverlayRemoved === 'function') afterOverlayRemoved(); _cleanup(); }catch(e){} }, 640);
                                    }catch(e){ try{ if(document.body.contains(el)) document.body.removeChild(el); }catch(e){} if(typeof afterOverlayRemoved === 'function') afterOverlayRemoved(); _cleanup(); }
                                };

                                // If completion popup exists and is portaled to body (not nested in overlay), keep it
                                // visible while the overlay fades, then de-blur it, fade it, and remove it.
                                if(compOnBody && compOnBody.parentNode === document.body && !compInside){
                                    // Start overlay fade but tell it to run removePortaledCompletion after overlay removed
                                    startOverlayFade(()=> removePortaledCompletion(compOnBody));
                                } else {
                                    // If a completion box is nested inside the overlay, fade the inner box first, then fade overlay
                                    try{
                                        const comp = compInside || compOnBody;
                                        if(comp){
                                            const box = comp.firstElementChild || comp.querySelector('div');
                                            if(box){ box.style.transition = box.style.transition || 'opacity .22s ease'; requestAnimationFrame(()=>{ try{ box.style.opacity = '0'; }catch(e){} }); }
                                            setTimeout(()=> startOverlayFade(), 220);
                                        } else {
                                            startOverlayFade();
                                        }
                                    }catch(e){ startOverlayFade(); }
                                }
                            }catch(e){ try{ if(document.body.contains(el)) document.body.removeChild(el); }catch(e){} _cleanup(); }
                        } else { _cleanup(); }
                    }catch(e){} }

                    document.getElementById('fcOAgain').addEventListener('click', ()=> saveRatingAndAdvance(0));
                    document.getElementById('fcOHard').addEventListener('click', ()=> saveRatingAndAdvance(1));
                    document.getElementById('fcOGood').addEventListener('click', ()=> saveRatingAndAdvance(2));
                    document.getElementById('fcOEasy').addEventListener('click', ()=> saveRatingAndAdvance(3));
                    // Show the same 'Returning to Main Menu' popup when user clicks Close
                    function showReturningPopup(){
                        try{
                            try{ const prev = document.getElementById('fcCompleteContainer'); if(prev) prev.remove(); }catch(e){}
                            const cont = document.createElement('div'); cont.id = 'fcCompleteContainer';
                            cont.style.position = 'fixed'; cont.style.inset = '0'; cont.style.display = 'flex'; cont.style.alignItems = 'center'; cont.style.justifyContent = 'center'; cont.style.zIndex = '9999999'; cont.style.pointerEvents = 'none';
                            cont.style.backdropFilter = 'blur(6px)'; cont.style.background = 'rgba(0,0,0,0.28)';
                            const box = document.createElement('div');
                            box.style.background = 'linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.5))';
                            box.style.border = '1px solid rgba(255,255,255,0.06)';
                            box.style.padding = '18px 22px'; box.style.borderRadius = '12px'; box.style.textAlign = 'center'; box.style.color = '#fff'; box.style.maxWidth = '820px'; box.style.boxSizing = 'border-box'; box.style.opacity = '0'; box.style.transition = 'opacity .28s ease';
                            box.style.outline = '2px solid rgba(255,255,255,0.95)'; box.style.outlineOffset = '6px';
                            const main = document.createElement('div'); main.textContent = 'Returning to Main Menu'; main.style.fontSize = '34px'; main.style.fontWeight = '700'; main.style.lineHeight = '1.2'; main.style.marginBottom = '8px';
                            const sub = document.createElement('div'); sub.id = 'fcCompleteSub'; sub.textContent = ''; sub.style.fontSize = '20px'; sub.style.fontWeight = '700'; sub.style.opacity = '0'; sub.style.transition = 'opacity .36s ease';
                            box.appendChild(main); box.appendChild(sub); cont.appendChild(box); document.body.appendChild(cont);
                            requestAnimationFrame(()=>{ try{ box.style.opacity = '1'; }catch(e){} });
                            setTimeout(()=>{ try{ sub.style.opacity = '1'; }catch(e){} }, 600);
                            // Keep the popup visible while overlay fades; let closeOverlay() handle de-blur and popup fade/removal after overlay removal.
                            setTimeout(()=>{ try{ closeOverlay(); }catch(e){} }, 1400);
                        }catch(e){}
                    }
                    document.getElementById('fcOExit').addEventListener('click', ()=> showReturningPopup());
                    // Bind overlay timer toggle and sync UI
                    try{ document.getElementById('fcOverlayTimer')?.addEventListener('click', ()=> toggleFcTimerMode()); }catch(e){}
                    try{ updateFcTimerUI(); }catch(e){}

                    // enable click/keyboard flip on the card
                    const _bindFlip = ()=>{
                        const fcFlip = document.getElementById('fcFlipContainer');
                        if(!fcFlip) return;
                        // click to flip
                        fcFlip.addEventListener('click', (ev)=>{ ev.stopPropagation(); flipOverlay(); });
                        // keyboard: Space / F when focused on the flip container
                        // Note: do NOT treat Enter as a flip/advance here — Enter was causing an unexpected reset in some environments.
                        fcFlip.addEventListener('keydown', (ev)=>{ try{ const k = (ev && ev.key) ? ev.key : ''; if(k === ' ' || k === 'Spacebar' || (k && k.toLowerCase && k.toLowerCase() === 'f')){ ev.preventDefault(); flipOverlay(); } }catch(e){} });
                    };
                    _bindFlip();

                    function overlayKeyHandler(e){ try{
                        const ek = (e && e.key) ? e.key : '';
                        if(ek === ' ' || (ek && ek.toLowerCase && ek.toLowerCase() === 'f')){ e.preventDefault(); flipOverlay(); }
                        else if(e.key === '1'){ saveRatingAndAdvance(0); }
                        else if(e.key === '2'){ saveRatingAndAdvance(1); }
                        else if(e.key === '3'){ saveRatingAndAdvance(2); }
                        else if(e.key === '4'){ saveRatingAndAdvance(3); }
                        else if(e.key === 'ArrowRight'){ nextOverlay(); }
                        /* NOTE: intentionally ignore Enter here — Enter triggered unexpected resets/blank state in flashcard view.
                           If you'd like Enter to advance, we can enable it conditionally (for example only when the card is flipped),
                           but for now we keep it disabled to avoid the reported issue. */
                        else if(e.key === 'Escape'){ 
                            try{ showReturningPopup(); }catch(e){}
                        }
                    }catch(e){} }
                    document.addEventListener('keydown', overlayKeyHandler);

                    // initial render
                    renderOverlayCard();
                }catch(e){ console.error('openFlashcardsSessionOverlay failed', e); }
            }

            // Show countdown then open overlay
            showFcPreSessionOverlay(deckCopy, ()=> openFlashcardsSessionOverlay(deckCopy));

        }catch(err){ console.error('fcStartSession', err); }
    });

    function currentCard(){ if(!fcSession || !fcSession.queue || fcSession.queue.length===0) return null; return fcSession.queue[fcSession.pos] || null; }

    function renderFcCard(){ const card = currentCard(); if(!card){ $('fcCardArea').style.display='none'; $('fcDeckInfo').style.display=''; renderDeckInfo(); return; }
        const front = $('fcFront'), back = $('fcBack'); if(front) front.textContent = String(card.q||''); if(back) back.textContent = String(card.a||''); if(back) back.style.display = 'none'; }

    function updateFcProgress(){ try{ const total = fcSession ? fcSession.queue.length : 0; const pos = fcSession ? (fcSession.pos+1) : 0; $('fcProgressText').textContent = `${pos > total ? total : (fcSession && total? pos : 0)} / ${total}`; }catch(e){} }

    // Flip
    $('fcFlip')?.addEventListener('click', ()=>{ try{ const back = $('fcBack'); if(!back) return; back.style.display = (back.style.display==='none') ? '' : 'none'; }catch(e){} });

    // Rating handlers — simple scheduler: Again -> push to end, mark box 0; Hard -> box1; Good -> remove; Easy -> remove and optionally mark mastered
    function handleRating(level){ try{
        const card = currentCard(); if(!card) return;
        const srs = readSrs(); const key = String(card.id);
        const now = Date.now(); const rec = srs[key] || { box: 0, last: null, streak: 0 };
        // map level to action
        // 0: Again, 1: Hard, 2: Good, 3: Easy
        if(level === 0){ rec.box = 0; rec.streak = 0; rec.last = now; srs[key]=rec; // move to end
            const item = fcSession.queue.splice(fcSession.pos,1)[0]; fcSession.queue.push(item);
        } else if(level === 1){ rec.box = Math.max(0, rec.box-1); rec.streak = 0; rec.last = now; srs[key]=rec; // move to end
            const item = fcSession.queue.splice(fcSession.pos,1)[0]; fcSession.queue.push(item);
        } else if(level === 2){ rec.box = Math.min(5, rec.box+1); rec.streak = (rec.streak||0)+1; rec.last = now; srs[key]=rec; // remove from queue as learned for session
            fcSession.queue.splice(fcSession.pos,1);
        } else if(level === 3){ rec.box = Math.min(6, rec.box+2); rec.streak = (rec.streak||0)+1; rec.last = now; srs[key]=rec; fcSession.queue.splice(fcSession.pos,1);
        }
        writeSrs(srs);
        // do not advance pos when we removed current — keep same index (next item shifts into pos)
        if(fcSession && fcSession.queue.length===0){ // session finished
            try{
                // Show a centered completion message (non-modal) then return to main view
                const existing = document.getElementById('fcCompleteContainerMain'); if(existing) existing.remove();
                const cont = document.createElement('div'); cont.id = 'fcCompleteContainerMain';
                cont.style.position = 'fixed'; cont.style.inset = '0'; cont.style.display = 'flex'; cont.style.alignItems = 'center'; cont.style.justifyContent = 'center'; cont.style.zIndex = '100010'; cont.style.pointerEvents = 'none';
                // blur the background behind the completion card (like the countdown popup)
                cont.style.backdropFilter = 'blur(6px)'; cont.style.background = 'rgba(0,0,0,0.28)';
                const box = document.createElement('div');
                box.style.background = 'linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.5))';
                box.style.border = '1px solid rgba(255,255,255,0.06)'; box.style.padding = '16px 20px'; box.style.borderRadius = '10px'; box.style.textAlign = 'center'; box.style.color = '#fff'; box.style.maxWidth = '760px'; box.style.boxSizing = 'border-box'; box.style.opacity = '0'; box.style.transition = 'opacity .28s ease';
                /* match flashcard face text size and countdown outline */
                box.style.outline = '2px solid rgba(255,255,255,0.95)'; box.style.outlineOffset = '6px';
                const main = document.createElement('div'); main.textContent = 'Completed all Flashcards'; main.style.fontSize = '34px'; main.style.fontWeight = '700'; main.style.lineHeight = '1.2'; main.style.marginBottom = '6px';
                const sub = document.createElement('div'); sub.id = 'fcCompleteSubMain'; sub.textContent = 'Returning to Main Menu'; sub.style.fontSize = '20px'; sub.style.fontWeight = '700'; sub.style.opacity = '0'; sub.style.transition = 'opacity .36s ease';
                box.appendChild(main); box.appendChild(sub); cont.appendChild(box); document.body.appendChild(cont);
                requestAnimationFrame(()=>{ try{ box.style.opacity = '1'; }catch(e){} });
                setTimeout(()=>{ try{ sub.style.opacity = '1'; }catch(e){} }, 900);
                // fade box out then remove and show main UI so the transition is continuous
                setTimeout(()=>{ try{ box.style.opacity = '0'; sub.style.opacity = '0'; }catch(e){} }, 1400);
                setTimeout(()=>{
                    try{ if(document.body.contains(cont)) document.body.removeChild(cont); }catch(e){}
                    try{ $('fcCardArea').style.display='none'; $('fcDeckInfo').style.display=''; renderDeckInfo(); updateFcProgress(); }catch(e){}
                }, 1700);
            }catch(e){
                try{ alert('Session complete.'); $('fcCardArea').style.display='none'; $('fcDeckInfo').style.display=''; renderDeckInfo(); updateFcProgress(); }catch(e){}
            }
            return; }
        if(fcSession.pos >= fcSession.queue.length) fcSession.pos = 0;
        renderFcCard(); updateFcProgress();
    }catch(e){ console.error('handleRating', e); } }

    $('fcAgain')?.addEventListener('click', ()=> handleRating(0));
    $('fcHard')?.addEventListener('click', ()=> handleRating(1));
    $('fcGood')?.addEventListener('click', ()=> handleRating(2));
    $('fcEasy')?.addEventListener('click', ()=> handleRating(3));

    // Export CSV
    $('fcExportCsv')?.addEventListener('click', (e)=>{
        try{
            if(!fcDeck || !fcDeck.length){ alert('No deck loaded.'); return; }
            const srs = readSrs();
            const rows = [['id','question','answer','choices','srsBox','lastReview','streak']];
            fcDeck.forEach(c=>{ const rec = srs[String(c.id)]|| {}; rows.push([String(c.id), c.q.replace(/\n/g,' '), c.a.replace(/\n/g,' '), (c.choices||[]).join(' || ').replace(/\n/g,' '), String(rec.box||''), rec.last? new Date(rec.last).toISOString() : '', String(rec.streak||0)]); });
            const csv = rows.map(r=> r.map(v=> '"'+String(v||'').replace(/"/g,'""')+'"').join(',')).join('\n');
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
            downloadBlob('flashcards.csv', blob);
        }catch(err){ console.error('fcExportCsv', err); alert('CSV export failed: '+(err?.message||err)); }
    });

    // APKG shim: create a ZIP with notes.csv + media/ + README explaining it's a shim
    $('fcExportApkg')?.addEventListener('click', async (e)=>{
        try{
            if(!fcDeck || !fcDeck.length){ alert('No deck loaded.'); return; }
            // Ensure JSZip
            if(!window.JSZip) await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js'; s.onload=res; s.onerror=rej; document.head.appendChild(s); });
            if(!window.JSZip){ alert('Failed to load JSZip for APKG shim.'); return; }
            const zip = new JSZip();
            const srs = readSrs();
            const rows = [['id','question','answer','choices','srsBox','lastReview','streak']];
            fcDeck.forEach(c=>{ const rec = srs[String(c.id)]|| {}; rows.push([String(c.id), c.q.replace(/\n/g,' '), c.a.replace(/\n/g,' '), (c.choices||[]).join(' || ').replace(/\n/g,' '), String(rec.box||''), rec.last? new Date(rec.last).toISOString() : '', String(rec.streak||0)]); });
            const csv = rows.map(r=> r.map(v=> '"'+String(v||'').replace(/"/g,'""')+'"').join(',')).join('\n');
            zip.file('notes.csv', csv);
            zip.folder('media');
            zip.file('README.txt', 'APKG SHIM: This ZIP is a lightweight export containing flashcard notes (notes.csv) and an empty media/ folder.\n\nA true Anki .apkg file requires a SQLite database and is not produced here. Use this CSV to import into Anki (File → Import) or use a conversion tool to build a proper .apkg.');
            const content = await zip.generateAsync({ type: 'blob' });
            downloadBlob('deck-apkg-shim.zip', content);
        }catch(err){ console.error('fcExportApkg', err); alert('APKG shim export failed: ' + (err?.message||err)); }
    });

    // small helpers: auto-load deck from parsed items when available (auto-invoke previous 'Load from parsed')
    (function autoLoadFcFromParsed(){
        try{
            function tryLoad(){
                try{
                    const items = (window.__quizState && window.__quizState.items) ? window.__quizState.items : (window.state && state.items) ? state.items : [];
                    if(items && items.length){
                        fcDeck = items.map((it, ix)=>({ id: it.num || (ix+1), q: it.q || it.text || '', a: (Array.isArray(it.choices) && typeof it.correctIdx === 'number') ? (it.choices[it.correctIdx] || '') : '', choices: Array.isArray(it.choices)? it.choices.slice() : [], ix }));
                        renderDeckInfo(); enableStart(true);
                        return true;
                    }
                }catch(e){ console.warn('tryLoad flashcards failed', e); }
                return false;
            }

            if(tryLoad()) return;
            // Poll briefly in case parsing completes shortly after this script runs
            let attempts = 0; const maxAttempts = 12; const intervalMs = 500; const iv = setInterval(()=>{
                attempts++;
                if(tryLoad() || attempts >= maxAttempts){ try{ clearInterval(iv); }catch(e){} }
            }, intervalMs);
        }catch(e){ console.warn('autoLoadFcFromParsed failed', e); }
    })();

    // Listen for SRS updates from other windows (popup) and storage events so the main UI stays in sync.
    try{
        window.addEventListener('storage', function(e){ try{ if(e && e.key === 'srs.v1'){ renderDeckInfo(); } }catch(e){}});
        window.addEventListener('message', function(ev){ try{ if(ev && ev.data && ev.data.type === 'srs.updated'){ /* srs updated in popup */ renderDeckInfo(); } }catch(e){} });
    }catch(e){ /* ignore if not allowed */ }

    // Initialize timer UI and state on load
    try{ initFcTimer(); }catch(e){}

})();
</script>

        <!-- === AI Like-Question Generator (start-only) === -->
        <section id="ai-likeq" class="card pad ai-likeq">
            <div class="flex col center gap-8">
                <div class="key-badge missing" id="globalKeyBadge" title="Shows whether a Gemini API key is present"><span class="dot"></span><span class="hint">No key set</span></div>
                <div class="flex center gap-12">
                    <button id="aiLikeBtn" class="btn primary btn-wide" disabled>Generate Like-Questions (AI)</button>
                </div>
            </div>
            <div class="hint mt-8 text-center">
                Carefully replaces your pasted set with new, <em>format-identical</em> items. Uses conservative
                rewriting; keeps same count, structure, and single correct answer per question.
            </div>
            <div id="aiLikeStatus" class="hint mt-8 text-center"></div>
        </section>

        <!-- === AI Caveat + Credit (paste near the end of your main container) === -->
        <section id="ai-disclaimer" class="card pad ai-legal">
            <h3 class="mt-0 mb-8">About AI Elements (Gemini 2.5 Flash)</h3>
            <p class="muted">
                The rationale shown in the panel is generated by Google’s Gemini model. While useful for learning,
                it may occasionally misidentify the correct option or provide incomplete justification. Reasons include:
            </p>
            <ul class="muted">
                <li><strong>Non-determinism & sampling:</strong> temperature/top-p sampling can yield different
                    rationales across runs, including confident but incorrect claims.</li>
                <li><strong>Prompt/format drift:</strong> if the question/options aren’t parsed exactly as intended,
                    the model may reason over the wrong input.</li>
                <li><strong>Hallucinations & shortcut bias:</strong> large models sometimes invent facts or over-rely
                    on surface cues rather than domain-accurate reasoning.</li>
                <li><strong>Answer-key disagreement:</strong> if your key or parsing is off, the model could be “right”
                    while disagreeing with the displayed key (or vice-versa).</li>
            </ul>

            <p class="muted mt-10">
                For guidance on safety, evaluation, and reliability, see:
                <a href="https://ai.google.dev/gemini-api/docs" target="_blank" rel="noopener">API Docs</a>
            </p>

            <!-- Gemini status indicator: shows remote/ local API status (green/yellow/red) -->
            <div id="geminiStatus" class="muted mt-8" style="display:flex;align-items:center;gap:10px">
                <span id="geminiStatusDot" class="status-dot status-unknown" aria-hidden="true"></span>
                <div id="geminiStatusLabel">Gemini status: <strong id="geminiStatusText">unknown</strong></div>
                <a id="geminiStatusLink" href="https://aistudio.google.com/status" target="_blank" rel="noopener" class="muted" style="margin-left:6px; text-decoration:underline;">status</a>
            </div>

            <div class="ai-credit">
                <!-- credit moved to page header and boot overlay -->
            </div>
        </section>

    <!-- === Terms of Use Box (placed under 'About AI Elements') === -->
    <section id="tos-box" class="card pad tos-box">
        <h3 class="mt-0 mb-8">Terms of Use & Disclaimer</h3>
        <div class="muted">
            <p>Effective Date: October 20, 2025 — Version: 1.0</p>
            <p>This hosted demo runs entirely in your browser. Acceptance of the full Terms of Use is required to use AI features. Click "View TOS" to read the full Terms.</p>
        </div>
        <div class="flex gap-8 mt-8">
            <span id="tosBoxState" class="muted">Signed: <strong id="tosStateBox">Unknown</strong></span>
            <div class="right">
                <button id="tosBoxView" class="btn small">View TOS</button>
            </div>
        </div>
    </section>
    <script>
    (function(){
        const dot = document.getElementById('geminiStatusDot');
        const label = document.getElementById('geminiStatusText');
        const link = document.getElementById('geminiStatusLink');

        function setStatus(kind, text){
            try{
                dot.className = 'status-dot';
                if(kind === 'operational') dot.classList.add('status-operational');
                else if(kind === 'degraded') dot.classList.add('status-degraded');
                else if(kind === 'down') dot.classList.add('status-down');
                else dot.classList.add('status-unknown');
                label.textContent = text || kind || 'unknown';
            }catch(e){}
        }

        async function probeRemoteStatus(){
            // Try to fetch the Google AI status page (public endpoint)
            // The provided site is https://aistudio.google.com/status — try a JSON endpoint fallback if available
            try{
                const url = 'https://aistudio.google.com/status';
                const r = await fetch(url, { cache: 'no-store', mode: 'cors' });
                if(!r.ok) return { kind: 'unknown', text: 'remote unreachable' };
                const txt = await r.text();
                // Heuristic: look for 'operational' or 'degraded' keywords in the page text
                const lower = txt.toLowerCase();
                if(lower.includes('operational') || lower.includes('all systems operational')) return { kind: 'operational', text: 'remote: operational' };
                if(lower.includes('degraded') || lower.includes('partial outage') || lower.includes('degradation')) return { kind: 'degraded', text: 'remote: degraded' };
                if(lower.includes('outage') || lower.includes('down') || lower.includes('major outage')) return { kind: 'down', text: 'remote: outage' };
                return { kind: 'unknown', text: 'remote: status unknown' };
            }catch(e){ return { kind: 'unknown', text: 'remote: fetch failed' }; }
        }

        function checkLocalStatus(){
            try{
                const key = (document.getElementById('globalGemKey') && document.getElementById('globalGemKey').value) || localStorage.getItem('gemini.key');
                const enabled = !!(document.getElementById('globalGemEnable') && document.getElementById('globalGemEnable').checked);
                // Presence of a key + enabled checkbox counts as local operational; presence only of key is degraded
                if(enabled && key) return { kind: 'operational', text: 'local: enabled' };
                if(key) return { kind: 'degraded', text: 'local: key present' };
                return { kind: 'unknown', text: 'local: no key' };
            }catch(e){ return { kind: 'unknown', text: 'local: unknown' }; }
        }

        async function updateGeminiStatus(){
            try{
                setStatus('unknown','checking...');
                const [remote, local] = await Promise.allSettled([probeRemoteStatus(), Promise.resolve(checkLocalStatus())]);
                let remoteRes = { kind: 'unknown', text: '' };
                if(remote.status === 'fulfilled' && remote.value) remoteRes = remote.value;
                let localRes = { kind: 'unknown', text: '' };
                if(local.status === 'fulfilled' && local.value) localRes = local.value;

                // Prioritize remote outage signals (down => red). If remote degraded, show degraded unless local is down.
                if(remoteRes.kind === 'down') { setStatus('down', remoteRes.text + (localRes.text ? ' • ' + localRes.text : '')); return; }
                if(remoteRes.kind === 'degraded') { setStatus('degraded', remoteRes.text + (localRes.text ? ' • ' + localRes.text : '')); return; }
                // If remote looks fine or unknown, use local signal
                if(localRes.kind === 'operational') { setStatus('operational', localRes.text + (remoteRes.text ? ' • ' + remoteRes.text : '')); return; }
                if(localRes.kind === 'degraded') { setStatus('degraded', localRes.text + (remoteRes.text ? ' • ' + remoteRes.text : '')); return; }
                // default
                setStatus(remoteRes.kind || localRes.kind || 'unknown', (remoteRes.text || '') + (localRes.text ? ' • ' + localRes.text : '') || 'unknown');
            }catch(e){ setStatus('unknown','error'); }
        }

        // Run on load and periodically
        try{ updateGeminiStatus(); setInterval(updateGeminiStatus, 60 * 1000); }catch(e){}

        // Also update when key/enable inputs change
        try{ document.getElementById('globalGemKey')?.addEventListener('input', updateGeminiStatus); document.getElementById('globalGemEnable')?.addEventListener('change', updateGeminiStatus); }catch(e){}
    })();
    </script>

    <!-- Overlay used when TOS not accepted to block/blur the UI; contains centered unlock panel -->
    <div id="tosOverlay" class="tos-overlay hidden" aria-hidden="true">
        <div class="tos-unlock-panel" role="dialog" aria-label="Accept Terms to access site">
            <p class="tos-unlock-text">This site is restricted until you accept the Terms of Use. You can view and accept the Terms to unlock access.</p>
            <div class="tos-unlock-actions">
                <button id="tosUnlockBtn" class="btn primary">View & Sign TOS</button>
            </div>
        </div>
    </div>

        <!-- === style touch-ups (can live in your existing <style> block) === -->
        <style>

            .ai-legal {
                margin-top: 12px;
            }

            .ai-legal .muted {
                color: var(--muted, #9fb0c5);
                font-size: 12px;
            }

            .ai-legal a {
                color: var(--brand, #6aa9ff);
                text-decoration: underline;
            }

            .ai-legal a:focus-visible {
                outline: none;
                box-shadow: 0 0 0 2px rgba(106, 169, 255, .35);
                border-radius: 4px;
            }

            .ai-divider {
                border: 0;
                height: 1px;
                margin: 6px 0; /* reduced vertical gap */
                background: rgba(160, 180, 220, .18);
            }

            .ai-credit {
                font-size: 13px;
                color: var(--ink, #e9f0f7);
                opacity: .85;
            }

            .ai-likeq {
                margin-top: 12px;
            }

            .ai-likeq {
                margin-bottom: 12px;
            }

            .ai-likeq .hint {
                color: var(--muted, #9fb0c5);
            }
        </style>

        <style>
            /* Gemini status dot: green (operational), yellow (degraded), red (outage), gray unknown */
            .status-dot{ display:inline-block; width:12px; height:12px; border-radius:50%; border:1px solid rgba(0,0,0,0.08); box-shadow: 0 0 6px rgba(0,0,0,0.12); }
            .status-operational{ background: #4dd17a; box-shadow: 0 0 10px rgba(77,209,122,0.18); }
            .status-degraded{ background: #ffd166; box-shadow: 0 0 10px rgba(255,209,102,0.12); }
            .status-down{ background: #ff6b6b; box-shadow: 0 0 10px rgba(255,107,107,0.18); }
            .status-unknown{ background: #9fb0c5; box-shadow: none; }
            #geminiStatusLabel{ font-size:13px; color:var(--muted,#9fb0c5); }
            #geminiStatusText{ color:var(--ink,#e9f0f7); }
            /* AI explanation persistent key dot driven by root classes so it survives re-renders */
            #aiExplanationKeyDot{ background: var(--ai-key-missing-color, #ef4444); box-shadow:none; }
            .ai-key-ok #aiExplanationKeyDot{ background: var(--ai-key-ok-color, #16a34a) !important; box-shadow: 0 0 8px rgba(22,163,74,0.14); }
            .ai-key-missing #aiExplanationKeyDot{ background: var(--ai-key-missing-color, #ef4444) !important; box-shadow: none; }
        </style>

        <style>
        /* Compact TOS box: reduced vertical footprint while preserving content and controls */
        .tos-box{
            max-width: none;
            width: 100%;
            box-sizing: border-box;
            margin-top: 8px;
            padding: 8px 12px; /* tighter padding */
            border-radius: 12px;
        }
        /* Tighter text sizing and spacing for the compact card */
        .tos-box .muted, .tos-box p, .tos-box span { font-size: 11px; color: var(--muted, #9fb0c5); line-height:1.3; margin:0 }
        .tos-box h3{ font-size: 14px; margin: 0 0 6px 0; font-weight:700 }
        /* Reduce gap between state and actions and align vertically */
        .tos-box .flex { gap: 6px }
        .tos-box .right { margin-left: auto }
        .tos-box #tosBoxState { font-size: 11px }
        /* Make the View TOS button slightly smaller and tighter */
        .tos-box .btn.small{ padding: 6px 8px; font-size: 12px; border-radius: 8px }
        /* Responsive adjustments: keep compact spacing on narrow screens */
        @media (max-width: 960px){ .tos-box{ width: calc(100% - 24px); margin-left:12px; margin-right:12px; } }
        
        /* Compact overlay unlock panel */
        .tos-unlock-panel{ padding: 10px 12px; max-width: 520px; border-radius: 10px }
        .tos-unlock-text{ font-size:13px; margin:0 0 8px }
        .tos-unlock-actions .btn.primary{ padding: 8px 10px; font-size:13px }
        </style>

    </div>

    <!-- Reset to Main Menu (shown only during quiz) -->
    <div id="resetBar" class="mt-12 hidden text-center" style="margin-bottom:18px;">
        <button id="resetToMenuBtn" class="btn">Return to Main Menu</button>
    </div>

    

        <!-- Layout reinforcement for AI explanation sizing -->
        <style>
            /* Make the AI explanation fill the right panel on desktop */
            @media (min-width: 981px){
                #quiz .side{ display:flex; flex-direction:column; min-height:0; }
                #quiz #gemOut{ height:auto !important; max-height:none !important; flex:1 1 auto; min-height:420px; }
            }
        </style>

    <!-- Official Gemini JS SDK -->
    <script
        type="module">import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai"; window.GoogleGenerativeAI = GoogleGenerativeAI;</script>

    <script>
        // --- GLOBAL HELPERS: normalizeGreek and friends ---
        const GREEK_MAP = {
            '&alpha;':'α','&beta;':'β','&gamma;':'γ','&delta;':'δ','&epsilon;':'ε','&zeta;':'ζ','&eta;':'η','&theta;':'θ','&iota;':'ι','&kappa;':'κ','&lambda;':'λ','&mu;':'μ','&nu;':'ν','&xi;':'ξ','&omicron;':'ο','&pi;':'π','&rho;':'ρ','&sigma;':'σ','&tau;':'τ','&upsilon;':'υ','&phi;':'φ','&chi;':'χ','&psi;':'ψ','&omega;':'ω',
            '&Alpha;':'Α','&Beta;':'Β','&Gamma;':'Γ','&Delta;':'Δ','&Epsilon;':'Ε','&Zeta;':'Ζ','&Eta;':'Η','&Theta;':'Θ','&Iota;':'Ι','&Kappa;':'Κ','&Lambda;':'Λ','&Mu;':'Μ','&Nu;':'Ν','&Xi;':'Ξ','&Omicron;':'Ο','&Pi;':'Π','&Rho;':'Ρ','&Sigma;':'Σ','&Tau;':'Τ','&Upsilon;':'Υ','&Phi;':'Φ','&Chi;':'Χ','&Psi;':'Ψ','&Omega;':'Ω',
            '&sigmaf;':'ς','&thetasym;':'ϑ','&upsih;':'ϒ','&varphi;':'ϕ'
        };
        const decodeNumericEntities = (s)=> String(s||'').replace(/&#(x?)([0-9A-Fa-f]+);/g, (m, x, code) => {
            try{ const cp = x ? parseInt(code,16) : parseInt(code,10); if(!isFinite(cp) || cp<0 || cp>0x10FFFF) return m; return String.fromCodePoint(cp); }catch{ return m; }
        });
        const decodeGreekNamed = (s)=> String(s||'').replace(/&(alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Alpha|Beta|Gamma|Delta|Epsilon|Zeta|Eta|Theta|Iota|Kappa|Lambda|Mu|Nu|Xi|Omicron|Pi|Rho|Sigma|Tau|Upsilon|Phi|Chi|Psi|Omega|sigmaf|thetasym|upsih|varphi);/g, (m)=> GREEK_MAP[m]||m);
        const normalizeGreek = (s)=>{
            try{
                if(s==null) return s;
                let t = String(s);
                // Decode HTML numeric/named entities first so we normalize the real code points
                t = decodeNumericEntities(t);
                t = decodeGreekNamed(t);
                t = t.replace(/[\u200B-\u200D\u2060\uFEFF]/g, '');
                t = t.replace(/Âµ/g, 'µ');
                t = t.replace(/\u00B5/g, '\u03BC');
                // Map common Latin/IPA/Cyrillic lookalikes and math alphas to true Greek
                const VARIANT = {
                    'ϑ':'θ','ϵ':'ε','ϕ':'φ','ϱ':'ρ','ϖ':'π','ϰ':'κ','ϴ':'Θ','ϐ':'β','ϒ':'Υ',
                    'ɣ':'γ','Ɣ':'Γ','Ʃ':'Σ','∑':'Σ','∏':'Π','ɑ':'α','ᵅ':'α','⍺':'α','ɸ':'φ','ı':'ι','ĸ':'κ'
                };
                t = t.replace(/[ϑϵϕϱϖϰϴϐϒɣƔƩ∑∏ɑᵅ⍺ɸıĸ]/g, ch => VARIANT[ch] || ch);
                // Use NFKC to fold mathematical bold/italic Greek (e.g., 𝛼, 𝛾) to plain Greek
                if(t.normalize){ t = t.normalize('NFKC'); }
                return t;
            }catch{ return s; }
        };
        try{ window.normalizeGreek = normalizeGreek; }catch(e){}

        (function () {
            const $ = id => document.getElementById(id);
            const setup = $('setup'), preview = $('preview'), quiz = $('quiz');
            const resetBar = $('resetBar');
            const letters = ['A', 'B', 'C', 'D', 'E', 'F'];
            const state = { items: [], order: [], idx: 0, score: 0, answered: {}, skipped: new Set(), started: false, mode: 'quiz', reviewPool: [], returnIdx: null, returnMode: null, quizStartTime: null, quizEndTime: null, timerInterval: null, attempts: [], currentAttempt: null, tags: new Set(), showSourceHints: false };
            // Expose quiz state for modules outside this closure (e.g., results analyzer)
            try{ window.__quizState = state; }catch{}

            // Theme switching: updates CSS vars to recolor bg lighting and button gradients
            (function initThemes(){
                const root = document.documentElement;
                const orbSel = document.querySelectorAll('.theme-capsule .theme-orb');
                const themes = {
                    ocean:  { glow1:'rgba(74,144,255,.20)', glow2:'rgba(112,220,255,.14)', glow3:'rgba(130,100,255,.16)', btnTop:'rgba(96,165,250,.35)', btnBottom:'rgba(24,60,120,.65)', btnBorder:'#1f3a64', brand:'#6aa9ff' },
                    sunset: { glow1:'rgba(255,122,122,.22)', glow2:'rgba(255,184,77,.16)', glow3:'rgba(255,216,107,.18)', btnTop:'rgba(255,184,122,.30)', btnBottom:'rgba(120,60,24,.65)', btnBorder:'#7a3e1f', brand:'#f59e0b' },
                    forest: { glow1:'rgba(43,212,122,.20)', glow2:'rgba(117,230,140,.15)', glow3:'rgba(63,178,160,.17)', btnTop:'rgba(45,160,110,.30)', btnBottom:'rgba(18,64,44,.65)', btnBorder:'#1a3f2c', brand:'#22c55e' },
                    violet: { glow1:'rgba(139,92,246,.22)', glow2:'rgba(96,165,250,.16)', glow3:'rgba(34,211,238,.18)', btnTop:'rgba(124,58,237,.32)', btnBottom:'rgba(49,46,129,.65)', btnBorder:'#3b2f6d', brand:'#8b5cf6' },
                    ember:  { glow1:'rgba(255,107,107,.22)', glow2:'rgba(245,158,11,.16)', glow3:'rgba(251,146,60,.18)', btnTop:'rgba(239,68,68,.32)', btnBottom:'rgba(80,30,24,.65)', btnBorder:'#4a1f1f', brand:'#ef4444' },
                                        greyscale: { 
                                            glow1:'rgba(180, 180, 180, .20)', 
                                            glow2:'rgba(120, 120, 120, .16)', 
                                            glow3:'rgba(70, 70, 70, .18)', 
                                            btnTop:'rgba(200, 200, 200, .30)', 
                                            btnBottom:'rgba(40, 40, 40, .70)', 
                                            btnBorder:'#4b5563', 
                                            brand:'#c0c0c0' 
                                        },
                };
                function hexToRgbaLocal(h, a){ try{ if(!h) return 'rgba(128,128,128,'+a+')'; h = h.replace('#',''); if(h.length===3) h = h.split('').map(ch=>ch+ch).join(''); const r = parseInt(h.substring(0,2),16); const g = parseInt(h.substring(2,4),16); const b = parseInt(h.substring(4,6),16); return 'rgba('+r+','+g+','+b+','+a+')'; }catch(e){ return 'rgba(128,128,128,'+a+')'; } }

                function applyTheme(name){
                    // Normalize theme key to lowercase to handle variants like 'Custom' or 'greyscale'
                    const lname = (name || '').toString().toLowerCase();
                    // If the user has a custom greyscale palette saved, prefer it when 'greyscale' or 'custom' is chosen
                    if(lname === 'greyscale' || lname === 'custom'){
                        try{
                            const raw = localStorage.getItem('__custom_orb_greyscale_v1');
                            if(raw){
                                const parsed = JSON.parse(raw);
                                if(parsed && parsed.colors && parsed.colors.c1){
                                    const c1 = parsed.colors.c1; const c2 = parsed.colors.c2; const c3 = parsed.colors.c3;
                                    root.style.setProperty('--glow1', hexToRgbaLocal(c1, 0.20));
                                    root.style.setProperty('--glow2', hexToRgbaLocal(c2, 0.14));
                                    root.style.setProperty('--glow3', hexToRgbaLocal(c3, 0.16));
                                    root.style.setProperty('--btnTop', hexToRgbaLocal(c1, 0.30));
                                    root.style.setProperty('--btnBottom', hexToRgbaLocal(c2, 0.28));
                                    /* Dye borders to match the custom palette (use a stronger c3 tint for outlines) */
                                    try{ root.style.setProperty('--btnBorder', hexToRgbaLocal(c3, 0.9)); }catch(e){ root.style.setProperty('--btnBorder', themes.greyscale.btnBorder); }
                                    root.style.setProperty('--brand', c1);
                                    // ensure the greyscale/custom orb reflects the inline colors as well
                                    try{ const gre = document.querySelector('.theme-orb[data-theme="greyscale"]') || document.querySelector('.theme-orb[data-theme="custom"]') || document.querySelector('.orb-greyscale') || document.querySelector('.orb-custom'); if(gre){ gre.style.setProperty('--c1', c1); gre.style.setProperty('--c2', c2); gre.style.setProperty('--c3', c3); } }catch(e){}
                                    // mark active
                                    orbSel.forEach(o=>o.classList.toggle('active', (o.dataset.theme||'').toString().toLowerCase()===lname));
                                    try{ localStorage.setItem('__theme', lname); }catch(e){}
                                    try{ document.dispatchEvent(new CustomEvent('theme-changed', { detail: { name: lname } })); }catch(e){}
                                    return;
                                }
                            }
                        }catch(e){ /* fallback to built-in greyscale below */ }
                    }
                    // default theme handling
                    const t = themes[lname] || themes.ocean;
                    root.style.setProperty('--glow1', t.glow1);
                    root.style.setProperty('--glow2', t.glow2);
                    root.style.setProperty('--glow3', t.glow3);
                    root.style.setProperty('--btnTop', t.btnTop);
                    root.style.setProperty('--btnBottom', t.btnBottom);
                    root.style.setProperty('--btnBorder', t.btnBorder);
                    root.style.setProperty('--brand', t.brand);
                    orbSel.forEach(o=>o.classList.toggle('active', (o.dataset.theme||'').toString().toLowerCase()===lname));
                    // persist selection and notify listeners
                    try{ localStorage.setItem('__theme', lname); }catch(e){}
                    try{ document.dispatchEvent(new CustomEvent('theme-changed', { detail: { name: lname } })); }catch(e){}
                }
                orbSel.forEach(o=> o.addEventListener('click', ()=> applyTheme(o.dataset.theme)));
                // Restore last theme or default to ocean (handle previously saved 'Custom' or other-cased values)
                let initial = 'ocean';
                try{ const saved = localStorage.getItem('__theme'); if(saved){ const s = saved.toString().toLowerCase(); if(s === 'custom') initial = 'greyscale'; else if(themes[s]) initial = s; } }catch(e){}
                applyTheme(initial);
            })();

            /* ---------- Skipped modal (lazy) ---------- */
            function ensureSkippedModal() {
                if (document.getElementById('skippedModal')) return;
                const wrap = document.createElement('div'); wrap.id = 'skippedModal'; wrap.className = 'hidden';
                wrap.innerHTML = `<div class="overlay"><div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center"><h3>Skipped Questions</h3><button class="btn" id="closeSkipped">Close</button></div>
      <div class="hint">Click a question to jump. Use <span class="tag">Return</span> to go back to your current spot.</div>
      <div id="skippedList" class="list" style="margin-top:10px"></div>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-end"><button class="btn" id="returnToCurrent">Return</button></div>
    </div></div>`;
                document.body.appendChild(wrap);
                $('closeSkipped').onclick = () => wrap.classList.add('hidden');
                $('returnToCurrent').onclick = () => { if (state.returnIdx != null) { state.idx = state.returnIdx; state.mode = state.returnMode || 'quiz'; } wrap.classList.add('hidden'); renderCurrent(); };
            }
            const showSkipped = () => $('skippedModal')?.classList.remove('hidden');
            const hideSkipped = () => $('skippedModal')?.classList.add('hidden');

            /* ---------- Parse ---------- */
            function parseDoc(text) {
                const lines = normalizeGreek(text || '').replace(/\r\n?/g, '\n').split('\n');
                const items = []; const qre = /^Q\s*(\d+)\.\s*(.+)$/i; const keyMap = {};
                const keyIdx = lines.findIndex(l => /^\s*ANSWER\s+KEY\s*$/i.test(l));
                if (keyIdx !== -1) {
                    for (let k = keyIdx + 1; k < lines.length; k++) {
                        const m = lines[k].match(/^(\d+)\s*\.?\s*([A-D])/i);
                        if (m) keyMap[m[1]] = m[2].toUpperCase();
                    }
                }
                for (let i = 0; i < lines.length; i++) {
                    const q = lines[i].match(qre);
                    if (!q) continue;
                    const qnum = q[1]; const qtext = q[2].trim(); const choices = [];
                    for (let j = i + 1; j < lines.length; j++) {
                        const s = lines[j].trim();
                        if (/^Q\s*\d+\./i.test(s) || /^ANSWER\s+KEY/i.test(s)) { i = j - 1; break; }
                        if (/^[\-\u2013\u2014]\s+/.test(s)) choices.push(normalizeGreek(s.replace(/^[\-\u2013\u2014]\s+/, ''))); // - option
                        if (j === lines.length - 1) i = j;
                    }
                    if (choices.length >= 2) {
                        const letter = (keyMap[qnum] || 'A').toUpperCase();
                        const correctIdx = Math.max(0, Math.min(choices.length - 1, letter.charCodeAt(0) - 65));
                        items.push({ num: qnum, q: qtext, choices, correctIdx });
                    }
                }

                // Attach any AI-generated source hints captured during generation
                try {
                    if (window.__aiMcqSourceHints && items.length) {
                        for (const it of items) {
                            const k = String(it.num);
                            if (Object.prototype.hasOwnProperty.call(window.__aiMcqSourceHints, k)) {
                                it.sourceHint = window.__aiMcqSourceHints[k];
                            }
                        }
                    }
                } catch (e) {}

                return items;
            }
            // Expose parser globally for validator/apply-corrections helpers
            try{ window.parseDoc = parseDoc; }catch{}

            /* ---------- Helpers ---------- */
            const shuffle = a => { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[a[i], a[j]] = [a[j], a[i]]; } return a; };
            // Reshuffle choices for an item, ensuring the correct answer changes position if possible
            function shuffleChoicesEnsureMove(it){
                try{
                    if(!it || !Array.isArray(it.choices) || it.choices.length < 2) return;
                    const prev = typeof it.correctIdx === 'number' ? it.correctIdx|0 : 0;
                    const base = it.choices.map((c,i)=>({ c, i }));
                    let z = base.slice();
                    let tries = 0;
                    do{ z = base.slice(); shuffle(z); tries++; } while(z.findIndex(t=>t.i===prev) === prev && tries < 8);
                    it.choices = z.map(t=>t.c);
                    it.correctIdx = z.findIndex(t=>t.i===prev);
                }catch(e){ console.warn('shuffleChoicesEnsureMove failed', e); }
            }
            const esc = s => (s + '').replace(/[&<>"']/g, c => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#39;" }[c]));
            // Safely decode only numeric entities and common Greek named entities, then escape for HTML
            const decodeNumericEntities = (s)=> String(s||'').replace(/&#(x?)([0-9A-Fa-f]+);/g, (m, x, code) => {
                try{ const cp = x ? parseInt(code,16) : parseInt(code,10); if(!isFinite(cp) || cp<0 || cp>0x10FFFF) return m; return String.fromCodePoint(cp); }catch{ return m; }
            });
            const GREEK_MAP = {
                '&alpha;':'α','&beta;':'β','&gamma;':'γ','&delta;':'δ','&epsilon;':'ε','&zeta;':'ζ','&eta;':'η','&theta;':'θ','&iota;':'ι','&kappa;':'κ','&lambda;':'λ','&mu;':'μ','&nu;':'ν','&xi;':'ξ','&omicron;':'ο','&pi;':'π','&rho;':'ρ','&sigma;':'σ','&tau;':'τ','&upsilon;':'υ','&phi;':'φ','&chi;':'χ','&psi;':'ψ','&omega;':'ω',
                '&Alpha;':'Α','&Beta;':'Β','&Gamma;':'Γ','&Delta;':'Δ','&Epsilon;':'Ε','&Zeta;':'Ζ','&Eta;':'Η','&Theta;':'Θ','&Iota;':'Ι','&Kappa;':'Κ','&Lambda;':'Λ','&Mu;':'Μ','&Nu;':'Ν','&Xi;':'Ξ','&Omicron;':'Ο','&Pi;':'Π','&Rho;':'Ρ','&Sigma;':'Σ','&Tau;':'Τ','&Upsilon;':'Υ','&Phi;':'Φ','&Chi;':'Χ','&Psi;':'Ψ','&Omega;':'Ω',
                '&sigmaf;':'ς','&thetasym;':'ϑ','&upsih;':'ϒ','&varphi;':'ϕ'
            };
            const decodeGreekNamed = (s)=> String(s||'').replace(/&(alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Alpha|Beta|Gamma|Delta|Epsilon|Zeta|Eta|Theta|Iota|Kappa|Lambda|Mu|Nu|Xi|Omicron|Pi|Rho|Sigma|Tau|Upsilon|Phi|Chi|Psi|Omega|sigmaf|thetasym|upsih|varphi);/g, (m)=> GREEK_MAP[m]||m);
            // Normalize Greek letters: unify variant glyphs, fix micro sign, strip zero-width; prefer NFKC for math alphas
            const normalizeGreek = (s)=>{
                try{
                    if(s==null) return s;
                    let t = String(s);
                    // Decode HTML entities first
                    t = decodeNumericEntities(t);
                    t = decodeGreekNamed(t);
                    // strip zero-width spaces/marks and BOMs
                    t = t.replace(/[\u200B-\u200D\u2060\uFEFF]/g, '');
                    // common UTF-8 mis-decode for micro sign
                    t = t.replace(/Âµ/g, 'µ');
                    // unify micro sign to Greek mu
                    t = t.replace(/\u00B5/g, '\u03BC');
                    // map variant Greek symbols + Latin/IPA lookalikes to canonical letters
                    const VARIANT = { 'ϑ':'θ','ϵ':'ε','ϕ':'φ','ϱ':'ρ','ϖ':'π','ϰ':'κ','ϴ':'Θ','ϐ':'β','ϒ':'Υ',
                                       'ɣ':'γ','Ɣ':'Γ','Ʃ':'Σ','∑':'Σ','∏':'Π','ɑ':'α','ᵅ':'α','⍺':'α','ɸ':'φ','ı':'ι','ĸ':'κ' };
                    t = t.replace(/[ϑϵϕϱϖϰϴϐϒɣƔƩ∑∏ɑᵅ⍺ɸıĸ]/g, ch => VARIANT[ch] || ch);
                    // NFKC to fold mathematical Greek (𝛼, 𝛾, …) to plain Greek
                    if(t.normalize){ t = t.normalize('NFKC'); }
                    return t;
                }catch{ return s; }
            };
                try{ window.normalizeGreek = normalizeGreek; }catch(e){}
            const safeText = (s)=> esc(normalizeGreek(decodeGreekNamed(decodeNumericEntities(s))));
            const activeList = () => state.mode === 'quiz' ? state.order : state.reviewPool;
            const activeLength = () => activeList().length;
            const activeIndex = () => activeList()[state.idx];

            /* ---------- Preview ---------- */
            function renderPreview(items) {
                preview.classList.remove('hidden');
                const list = $('previewList'); list.innerHTML = '';
                const n = Math.min(items.length, 5); // Limit to 5 items for preview
                for (let k = 0; k < n; k++) {
                    const it = items[k];
                    const div = document.createElement('div'); div.className = 'qcard';
                    div.innerHTML =
                        `<div><strong>Q${esc(it.num)}.</strong> ${safeText(it.q)}</div>` +
                        `<div style="margin-top:6px">${it.choices.map((c, i) => `<span class="tag">${letters[i] || '?'}.</span> ${safeText(c)}`).join('<br>')}</div>` +
                        `<div class="hint" style="margin-top:6px">Key: <span class="tag">${letters[it.correctIdx] || 'A'}</span></div>`;
                    list.appendChild(div);
                }
                $('previewCount').textContent = items.length;
                try{
                    // Scroll so the preview module starts ~100px below the top of the viewport
                    const rect = preview.getBoundingClientRect();
                    const target = Math.max(0, (rect.top + (window.scrollY||window.pageYOffset||0)) - 100);
                    window.scrollTo({ top: target, behavior: 'smooth' });
                }catch(e){ window.scrollTo({ top: Math.max(0, (preview.offsetTop||0) - 100), behavior: 'smooth' }); }
                try{ setTimeout(()=>{ try{ window.renderMathIn && window.renderMathIn(list); }catch(e){} }, 80); }catch(e){}
            }

            /* Helpers: save/restore Gemini enabled state around quizzes */
            function saveGeminiStateForQuiz(){
                try{
                    const cb = document.getElementById('globalGemEnable');
                    if(!cb) return;
                    // Save the previous checked state so it can be restored after the quiz if needed.
                    window.__prevGemEnabled = !!cb.checked;
                    // Immediately turn OFF the global Gemini enable when a quiz starts so accidental
                    // per-question requests won't fire. Do NOT permanently disable the control;
                    // leave it enabled so the user may re-enable it at any time during the quiz.
                    try{ cb.checked = false; cb.dispatchEvent(new Event('change')); }catch(e){}
                }catch(e){}
            }
            function restoreGeminiStateAfterQuiz(){
                try{
                    const cb = document.getElementById('globalGemEnable');
                    if(!cb) return;
                    // Do NOT automatically re-enable the global Gemini toggle after a quiz.
                    // Keep it disabled by default so users must explicitly opt-in again.
                    try{ cb.checked = false; }catch(e){}
                    cb.disabled = false;
                    cb.dispatchEvent(new Event('change'));
                    try{ delete window.__prevGemEnabled }catch(e){}
                }catch(e){}
            }

            /* ---------- Start Quiz + Pre-quiz overlay ---------- */
            // Show a short, non-interactive instructional overlay with a countdown and sample question.
            function showPreQuizOverlay(items, cb){
                try{
                    // If overlay already active, just callback immediately
                    if(window.__preQuizOverlayActive) { try{ cb(); }catch(e){} return; }
                    window.__preQuizOverlayActive = true;
                    const overlay = document.createElement('div'); overlay.id = 'preQuizOverlay';
                    overlay.style.position = 'fixed'; overlay.style.left = '0'; overlay.style.top = '0'; overlay.style.right = '0'; overlay.style.bottom = '0';
                    overlay.style.display = 'flex'; overlay.style.alignItems = 'center'; overlay.style.justifyContent = 'center';
                    // ensure overlay sits above focus-mode quiz (quiz uses z-index:100000 when focus-mode active)
                    overlay.style.zIndex = '100010';
                    // darker translucent backdrop plus blur for focus
                    overlay.style.background = 'rgba(0,0,0,0.78)';
                    overlay.style.backdropFilter = 'blur(6px)'; overlay.style.WebkitBackdropFilter = 'blur(6px)';
                    overlay.style.color = '#fff'; overlay.style.fontSize = '16px'; overlay.style.padding = '24px'; overlay.style.boxSizing = 'border-box';
                    overlay.style.textAlign = 'center'; overlay.style.pointerEvents = 'auto';
                    // Inner card (visual only) - no interactive controls
                    const card = document.createElement('div'); card.style.maxWidth = '820px'; card.style.width = '92%';
                    // subtle translucent card that contrasts with the blurred backdrop
                    card.style.background = 'linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02))';
                    card.style.borderRadius = '10px'; card.style.padding = '18px';
                    // outline uses the currently selected palette color (try --brand, then --accent, then --btnTop)
                    try{
                        const rootEl = document.documentElement;
                        const cs = window.getComputedStyle ? window.getComputedStyle(rootEl) : null;
                        let accent = null;
                        if(cs){ accent = cs.getPropertyValue('--brand') || cs.getPropertyValue('--accent') || cs.getPropertyValue('--btnTop'); }
                        accent = (accent || '').trim() || '#6aa9ff';
                        card.style.outline = `2px solid ${accent}`; card.style.outlineOffset = '6px';
                        // add a faint colored glow using the resolved accent color
                        card.style.boxShadow = `0 12px 36px rgba(0,0,0,0.6), 0 0 20px rgba(0,0,0,0.0), 0 0 18px ${accent}`;
                    }catch(e){ card.style.outline = '2px solid rgba(80,140,255,0.9)'; card.style.outlineOffset = '6px'; card.style.boxShadow = '0 12px 36px rgba(0,0,0,0.6)'; }
                    card.style.pointerEvents = 'none'; // ensure non-interactible
                    const title = document.createElement('div'); title.style.fontSize = '18px'; title.style.fontWeight = '700'; title.style.marginBottom = '8px'; title.textContent = 'Quick shortcuts — ready in:';
                    const hint = document.createElement('div'); hint.style.marginBottom = '12px'; hint.innerHTML = 'Press 1-9 or A-F to choose an answer. Enter to submit / next. N = Next, S = Skip.';
                    // Only show the title, shortcuts hint, and countdown — remove sample question for a cleaner pre-quiz overlay
                    const countdown = document.createElement('div'); countdown.style.marginTop = '8px'; countdown.style.fontSize = '28px'; countdown.style.fontWeight = '700'; countdown.textContent = '3';
                    card.appendChild(title); card.appendChild(hint); card.appendChild(countdown);
                    overlay.appendChild(card); document.body.appendChild(overlay);

                    // Prevent global keyboard shortcuts from acting while overlay is present
                    const prevOverlayFlag = !!window.__preQuizOverlayActive;
                    // Countdown then remove overlay and call callback
                    let t = 3; const iv = setInterval(()=>{
                        try{ t--; if(t <= 0){ clearInterval(iv); document.body.removeChild(overlay); window.__preQuizOverlayActive = false; try{ cb(); }catch(e){} } else { countdown.textContent = String(t); } }catch(e){ clearInterval(iv); try{ document.body.removeChild(overlay); }catch{} window.__preQuizOverlayActive = false; try{ cb(); }catch(e){} }
                    }, 1000);
                }catch(e){ console.warn('showPreQuizOverlay failed', e); try{ if(cb) cb(); }catch(e){} }
            }

            function startQuiz() {
                if (!state.items.length) { alert('Parse & Preview first.'); return; }
                const items = state.items.map(it => ({ ...it, choices: [...it.choices] }));
                state.order = items.map((_, i) => i);
                if ($('shuffleQ').checked) shuffle(state.order);
                if ($('shuffleA').checked) items.forEach(it => { // Shuffle answer choices if enabled
                    const z = it.choices.map((c, i) => ({ c, i })); shuffle(z);
                    it.choices = z.map(t => t.c); it.correctIdx = z.findIndex(t => t.i === it.correctIdx);
                });
                // show non-interactive overlay with shortcuts and a 3s countdown, then actually start the quiz
                showPreQuizOverlay(items, function(){
                    state.items = items; state.idx = 0; state.score = 0; state.mode = 'quiz'; state.started = true;
                    // track whether we've shown the one-time AI placeholder message for this quiz
                    try{ state._aiPlaceholderShown = false; }catch(e){}
                    try{ document.body.classList.add('quiz-running'); }catch{}
                    try{ saveGeminiStateForQuiz(); }catch{}
                    state.answered = {}; state.skipped.clear(); state.reviewPool = []; state.returnIdx = null; state.returnMode = null;
                    // Reset attempts and start initial attempt slice
                    state.attempts = []; state.currentAttempt = null;
                    startAttempt('initial', state.order.slice());
                    setup.classList.add('hidden'); preview.classList.add('hidden'); quiz.classList.remove('hidden');
                    // hide the Content Library during quiz
                    try{ document.getElementById('textbook-lib')?.classList.add('hidden'); }catch{}
                    if(resetBar) resetBar.style.display = 'block';
                    // Hide Validate/Like-Questions sections during the entire quiz session
                    try{ document.getElementById('ai-likeq')?.classList.add('hidden'); }catch{}
                    try{ document.getElementById('ai-likeq-copy')?.classList.add('hidden'); }catch{}
                    // Always hide results/attempts card when entering quiz
                    try{ document.getElementById('results-card')?.classList.add('hidden'); }catch{}
                    // Clear suppression when actively entering a fresh review flow (non-saved flow uses _loadedFromSaved=false)
                    try{ if(!state._loadedFromSaved) window.__suppressFocus = false; }catch(e){}
                    // start timer
                    state.quizStartTime = Date.now(); state.quizEndTime = null; if(state.timerInterval){ clearInterval(state.timerInterval); state.timerInterval = null; }
                    state.timerInterval = setInterval(()=>{ try{ const el = document.getElementById('quizTimer'); if(!el) return; const timerStart = (state.quizStartTime || (state.currentAttempt && state.currentAttempt.startedAt) || null); if(!timerStart) return; const ms = Math.max(0, Date.now() - timerStart); el.textContent = formatDuration(ms); }catch{} }, 500);
                    // Ensure focus mode is only enabled at quiz start when the user explicitly chose "Always enable focus".
                    // Some older flows or manual toggles could leave focus-mode active; prefer honoring the persisted Always setting.
                    try{
                        const ALWAYS_KEY = '__ui_always_focus_v1';
                        const alwaysOn = (function(){ try{ return localStorage.getItem(ALWAYS_KEY) === '1'; }catch(e){ return false; } })();
                        if(!alwaysOn){ try{ if(typeof window.__setFocusMode === 'function') window.__setFocusMode(false); else document.body.classList.remove('focus-mode-active'); }catch(e){} }
                        else if(!window.__suppressFocus){ try{ if(typeof window.__setFocusMode === 'function') window.__setFocusMode(true); else document.body.classList.add('focus-mode-active'); }catch(e){} }
                    }catch(e){}
                    hideSkipped(); renderCurrent();
                });
            }

            // Ensure Content Library is restored whenever the UI returns to setup
            document.addEventListener('click', function(e){
                try{
                    const btn = e.target.closest && e.target.closest('#backSetup');
                    if(btn){ 
                        document.getElementById('textbook-lib')?.classList.remove('hidden');
                        try{ if(window.refreshTextbookLibrary) window.refreshTextbookLibrary(); }catch{}
                    }
                }catch(e){}
            });

            // Keep Daily/Random quiz buttons visible ONLY when the main setup (main menu) is shown
            (function mainMenuButtonsVisibility(){
                function updateMainMenuButtonsVisibility(){
                    try{
                        const daily = document.getElementById('dailyQuizBtn');
                        const random = document.getElementById('randomQuizBtn');
                        const gear = document.getElementById('randomGearWrap');
                        const setupEl = document.getElementById('setup');
                        const savedPanel = document.getElementById('savedResultsPanel');
                        const isMain = !!setupEl && !setupEl.classList.contains('hidden') && !document.body.classList.contains('quiz-running');
                        [daily, random, gear].forEach(el=>{ if(!el) return; try{ el.style.display = isMain ? '' : 'none'; }catch(e){} });
                        // Only show saved results module on the main menu
                        if(savedPanel){ try{ savedPanel.style.display = isMain ? '' : 'none'; }catch(e){} }
                    }catch(e){ }
                }

                // Observe body class changes (quiz-running toggled) and setup visibility
                const bodyObserver = new MutationObserver(()=> updateMainMenuButtonsVisibility());
                try{ bodyObserver.observe(document.body, { attributes: true, attributeFilter: ['class'] }); }catch(e){}

                const setupEl = document.getElementById('setup');
                if(setupEl){
                    try{ const setupObserver = new MutationObserver(()=> updateMainMenuButtonsVisibility()); setupObserver.observe(setupEl, { attributes: true, attributeFilter: ['class', 'style'] }); }catch(e){}
                }

                // Initial run and ensure runs after DOM ready
                if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', updateMainMenuButtonsVisibility, { once:true }); else updateMainMenuButtonsVisibility();
                // Also run on window focus to catch external state changes
                window.addEventListener('focus', updateMainMenuButtonsVisibility);
            })();

            function startAttempt(mode, poolIndices){
                try{
                    state.currentAttempt = { id: (state.attempts.length + 1), mode: mode||'initial', pool: (poolIndices||[]).slice(), startedAt: Date.now(), endedAt: null, durationMs: 0, missed: [] };
                }catch(e){ console.warn('startAttempt failed', e); }
            }

            function finalizeCurrentAttempt(){
                try{
                    if(!state.currentAttempt) return;
                    const att = state.currentAttempt; att.endedAt = Date.now(); att.durationMs = Math.max(0, (att.endedAt - (att.startedAt||att.endedAt)));
                    const missed = [];
                    for(const ix of (att.pool||[])){
                        const it = state.items[ix]; const rec = state.answered[ix];
                        const wasWrong = !rec || !rec.submitted || !rec.correct;
                        if(wasWrong){
                            missed.push({
                                index: ix,
                                num: it?.num,
                                q: it?.q,
                                choices: (it?.choices||[]).slice(),
                                correctIdx: it?.correctIdx,
                                user: (rec && rec.selected!=null ? rec.selected : null),
                                durationMs: (rec && typeof rec._lastDurationMs === 'number') ? rec._lastDurationMs : null,
                                attemptId: att.id,
                                mode: att.mode
                            });
                        }
                    }
                            att.missed = missed;
                            // Save per-question timing snapshot for this attempt so results UI can show timings for all items
                            try{
                                att.qTimes = (att.pool||[]).map(ix => {
                                    const it = state.items[ix]; const rec = state.answered[ix];
                                    return {
                                        index: ix,
                                        num: it?.num,
                                        durationMs: (rec && typeof rec._lastDurationMs === 'number') ? rec._lastDurationMs : null,
                                        correct: !!(rec && rec.correct),
                                        submitted: !!(rec && rec.submitted),
                                        user: (rec && rec.selected!=null) ? rec.selected : null
                                    };
                                });
                            }catch(e){}
                    state.attempts.push(att);
                    state.currentAttempt = null;
                }catch(e){ console.warn('finalizeCurrentAttempt failed', e); }
            }

            /* ---------- Render current ---------- */
            function renderCurrent() {
                // Ensure any in-progress AI output (text/audio) is stopped and cleared immediately
                try{
                    if(typeof window.stopAiOutput === 'function') window.stopAiOutput();
                }catch{}
                try{ const w = document.getElementById('resultsAiOutput'); if(w){ try{ if(w._page) w._page.textContent = ''; else w.textContent = ''; }catch{} } }catch{}
                const list = activeList();
                if (!list.length) { if (state.mode === 'review') return showReviewDone(); alert('Nothing to show.'); return; }
                // Ensure results/attempts card is hidden while viewing questions
                try{ document.getElementById('results-card')?.classList.add('hidden'); }catch{}
                const itemIndex = activeIndex(); const it = state.items[itemIndex]; const total = activeLength();
                if (!state.answered[itemIndex]) state.answered[itemIndex] = { selected: null, submitted: false, correct: false, skipped: false };
                const rec = state.answered[itemIndex];
                // mark when this question was shown so we can compute per-question durations
                try{ rec._lastShownAt = Date.now(); }catch(e){}
                const prog = Math.round((state.idx) / Math.max(1, total) * 100);

                                // Compute current elapsed time so the timer doesn't flash to 00:00
                                const timerStart = (state.quizStartTime || (state.currentAttempt && state.currentAttempt.startedAt) || null);
                                const elapsedMsForRender = timerStart ? Math.max(0, Date.now() - timerStart) : 0;

                                const grid = document.createElement('div'); grid.className = 'quizgrid';
                // ensure the grid stretches so the sidebar can fill vertical space
                grid.style.alignItems = 'stretch'; grid.style.minHeight = '420px';
                const left = document.createElement('div');
                                left.innerHTML = `
            <div class="footer" style="margin-bottom:6px">
                <div class="row" style="gap:8px;align-items:center">
          <span class="tag">${state.mode === 'quiz' ? 'Quiz' : 'Review'}</span>
          <span class="tag">#${state.idx + 1} / ${total}</span>
          <span class="tag">Score: ${state.score}</span>
          <span class="tag">Skipped: <span id="skippedCount">${state.skipped.size}</span></span>
                                        <span class="tag" title="Elapsed time"><span id="quizTimer">${formatDuration(elapsedMsForRender)}</span></span>
                    <button id="sourceHintToggle" class="btn small" type="button" title="Toggle source search hint" style="min-height:0;height:26px;padding:2px 8px;font-size:11px;line-height:1;border-radius:999px">ⓘ</button>
          <span class="link" id="openSkipped" style="cursor:pointer;color:var(--brand);text-decoration:underline">Open Skipped</span>
        </div>
        <div class="progress" style="flex:1 1 auto; max-width:420px"><div style="width:${prog}%"></div></div>
      </div>
            <div class="qcard">
        <div class="q-head" style="display:grid;grid-template-columns:1fr auto;align-items:end;margin-bottom:4px">
            <div style="font-weight:700">Q${esc(it.num)}. ${safeText(it.q)}</div>
            <button type="button" class="tts-btn" title="Read question aloud" aria-pressed="false" style="border:none;background:transparent;font-size:18px;padding:4px;cursor:pointer;line-height:1">🔊</button>
        </div>
        <div id="sourceHint" class="hint" style="margin-bottom:8px;${state.showSourceHints && it && it.sourceHint ? '' : 'display:none;'}">${it && it.sourceHint ? safeText(it.sourceHint) : ''}</div>
                <div id="choices"></div>
        <div id="status" class="hint" style="margin-top:6px"></div>
      </div>
                <div class="footer">
                <div class="toolbar">
                    <button class="btn warn" id="skipBtn">Skip</button>
                    <button class="btn" id="backBtn" ${state.idx === 0 ? 'disabled' : ''}>Back</button>
                </div>
                <div class="toolbar">
                    <button class="btn" id="revealBtn">Reveal</button>
                    <button class="btn" id="tagBtn" title="Tag this question for later review">Tag</button>
                    <button class="btn primary" id="nextBtn">${state.idx === total - 1 ? 'Finish' : 'Next'}</button>
                </div>
            </div>`;
                const ch = left.querySelector('#choices');
                    it.choices.forEach((c, idx) => {
                    const lab = document.createElement('label'); lab.className = 'choice';
                    lab.innerHTML = `<input type="radio" name="c"> <strong>${letters[idx]}.</strong> <span class="choice-body">${safeText(c)}</span>`;
                    const input = lab.querySelector('input'); input.checked = rec.selected === idx;
                    // immediately submit on selection and lock choices so they cannot be changed
                    input.addEventListener('change', () => {
                        if (!rec.submitted) { rec.selected = idx; doSubmit(it, itemIndex); }
                    });
                    if (rec.submitted) lab.classList.add('disabled');
                    ch.appendChild(lab);
                });
                const statusEl = left.querySelector('#status'); if (rec.submitted) { statusEl.textContent = rec.correct ? 'Already submitted: Correct.' : 'Already submitted: Incorrect.'; }
                // Wire source-hint toggle button per render
                try{
                    const srcToggle = left.querySelector('#sourceHintToggle');
                    if(srcToggle){
                        const applyHintVisibility = ()=>{
                            const h = left.querySelector('#sourceHint');
                            if(!h) return;
                            if(state.showSourceHints && it && it.sourceHint){ h.style.display=''; h.textContent = safeText(it.sourceHint); }
                            else { h.style.display='none'; }
                        };
                        applyHintVisibility();
                        srcToggle.onclick = ()=>{
                            state.showSourceHints = !state.showSourceHints;
                            applyHintVisibility();
                        };
                    }
                }catch(e){}
                // Initialize Tag button state for this question
                try{
                    const tagBtn = left.querySelector('#tagBtn');
                    if(tagBtn){
                        const isTagged = state.tags && state.tags.has(itemIndex);
                        tagBtn.classList.toggle('primary', isTagged);
                        tagBtn.textContent = isTagged ? 'Untag' : 'Tag';
                        tagBtn.addEventListener('click', ()=>{
                            try{
                                if(!state.tags) state.tags = new Set();
                                if(state.tags.has(itemIndex)) state.tags.delete(itemIndex); else state.tags.add(itemIndex);
                                const nowTagged = state.tags.has(itemIndex);
                                tagBtn.classList.toggle('primary', nowTagged);
                                tagBtn.textContent = nowTagged ? 'Untag' : 'Tag';
                            }catch(e){}
                        });
                    }
                }catch(e){}

                                                                const right = document.createElement('aside'); right.className = 'side';
                                                                // make the sidebar a column flexbox so gemOut can flex-grow
                                                                right.style.display = 'flex'; right.style.flexDirection = 'column'; right.style.gap = '8px'; right.style.minHeight = '0'; right.style.alignSelf = 'stretch'; right.style.height = '100%'; right.style.flex = '0 0 320px';
                                                                // Ensure the sidebar visually occludes anything behind it (avoid buffering effect)
                                                                try{ right.style.background = 'linear-gradient(180deg, rgba(14,21,34,1), rgba(9,15,26,1))'; right.style.border = '1px solid var(--stroke)'; right.style.boxSizing = 'border-box'; right.style.zIndex = '3'; right.style.position = 'relative'; }catch(e){}
                                                                right.innerHTML = `
                                            <h3 style="margin:0 0 6px 0; display:inline-flex; align-items:center;"> <span id="aiExplanationKeyDot" class="key-dot missing" aria-hidden="true" title="API key status" style="display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:8px;vertical-align:middle;"></span>AI Explanation</h3>
                                            <div style="flex:1 1 0; min-height:0; display:flex; flex-direction:column;">
                                                <div id="resultsAiOutput" class="hint mt-12" role="status" aria-live="polite"></div>
                                            </div>
                                        `;
                grid.appendChild(left); grid.appendChild(right); quiz.innerHTML = ''; quiz.appendChild(grid);

                // Stop any in-progress per-question TTS when re-rendering
                try{ if(typeof window.stopTtsOutput === 'function') window.stopTtsOutput(); }catch{}
                // Wire up per-question TTS button (SpeechSynthesis) and render LaTeX in the newly inserted quiz content (questions, choices, AI output)
                try{ setTimeout(()=>{ try{ const qarea = quiz; window.renderMathIn && window.renderMathIn(qarea); const aiOut = document.getElementById('resultsAiOutput'); if(aiOut) window.renderMathIn && window.renderMathIn(aiOut); }catch(e){ console.warn('renderMathIn quiz failed', e); } }, 60); }catch(e){}

                // TTS: build a small controller for this page so other code can stop speech when needed
                try{
                    // helper to strip HTML tags for spoken text
                    const _stripTags = s => String(s||'').replace(/<[^>]*>/g, '').replace(/&nbsp;/g,' ').trim();
                    const tbtn = left.querySelector('.tts-btn');
                    if(tbtn){
                        // ensure previous attribute state
                        tbtn.setAttribute('aria-pressed','false');
                        tbtn.onclick = function(ev){
                            try{
                                // toggle: if speaking, stop; otherwise start
                                if(window.__ttsSpeaking){
                                    try{ window.stopTtsOutput && window.stopTtsOutput(); }catch{};
                                    return;
                                }
                                // Build spoken text: question then choices
                                const qtxt = (it.q || '').toString();
                                const choicesTxt = (it.choices || []).map((c, i) => `${letters[i] || String(i+1)}. ${_stripTags(c)}`).join('. ');
                                const speak = `${qtxt}. Choices: ${choicesTxt}.`;

                                // Cancel any lingering speech and speak
                                try{ speechSynthesis.cancel(); }catch(e){}
                                const u = new SpeechSynthesisUtterance(speak);
                                // Lower spoken voice volume to avoid being too loud by default (0.0 - 1.0)
                                try{ u.volume = 0.5; }catch(e){}
                                try{ u.lang = document.documentElement.lang || 'en-US'; }catch(e){}
                                // Save globals so other code can stop playback
                                window.__ttsUtterance = u;
                                window.__ttsSpeaking = true;
                                tbtn.setAttribute('aria-pressed','true');
                                speechSynthesis.speak(u);
                                u.onend = u.onerror = function(){ try{ window.__ttsSpeaking = false; window.__ttsUtterance = null; tbtn.setAttribute('aria-pressed','false'); }catch(e){} };
                            }catch(e){ console.warn('TTS start failed', e); }
                        };
                    }
                    // Expose a stop function so other modules can halt TTS
                    window.stopTtsOutput = function(){ try{ if(window.__ttsUtterance){ try{ speechSynthesis.cancel(); }catch(e){} window.__ttsUtterance = null; } window.__ttsSpeaking = false; const b = document.querySelector('.tts-btn'); if(b) b.setAttribute('aria-pressed','false'); }catch(e){} };
                }catch(e){ console.warn('TTS wiring failed', e); }

                // Ensure the AI Explanation wrapper (text + ASCII face) is initialized.
                // Show the one-time placeholder only once per quiz; after that, ensure the wrapper exists
                // but do not repeat the spoken/typed placeholder.
                try{
                    setTimeout(()=>{
                        try{
                            const showOnce = !(state && state._aiPlaceholderShown);
                            // Preferred: use the animated wrapper initializer if available
                            if(typeof window.showAiOutput === 'function'){
                                if(showOnce){
                                    try{ window.showAiOutput('AI explanation panel ready. Enable the API Key and select an answer to see a short AI analysis.'); }catch(e){}
                                    try{ state._aiPlaceholderShown = true; }catch(e){}
                                } else {
                                    // Ensure wrapper exists without speaking the placeholder
                                    try{ if(typeof ensureWrapper === 'function') ensureWrapper(); else if(typeof window.showAiOutput === 'function') window.showAiOutput(''); }catch(e){}
                                }
                            } else {
                                // Fallback: augment the resultsAiOutput element so it shows a page box and face
                                const out = document.getElementById('resultsAiOutput');
                                if(out){
                                    if(out.innerHTML.trim() === ''){
                                        out.classList.add('aiTextbookOutput');
                                        if(showOnce){
                                            // Make the output container opaque to prevent the underlying panel from showing through
                                            try{ out.style.background = 'linear-gradient(180deg, rgba(14,21,34,1), rgba(9,15,26,1))'; out.style.border = '1px solid var(--stroke)'; out.style.boxSizing = 'border-box'; out.style.zIndex = '4'; }catch(e){}
                                            out.innerHTML = '<div class="page" role="status" aria-live="polite">AI explanation panel ready. Select an answer to see a short AI analysis.</div>' +
                                                            '<div class="ascii-face"><div class="face" role="button" tabindex="0">(<span class="eye left"><span class="lash">&quot;&quot;</span><span class="dot">•</span></span><span class="mouth">___</span><span class="eye right"><span class="lash">&quot;&quot;</span><span class="dot">•</span></span>)</div></div>';
                                            try{ state._aiPlaceholderShown = true; }catch(e){}
                                        } else {
                                            out.innerHTML = '<div class="page" role="status" aria-live="polite"></div>' +
                                                            '<div class="ascii-face"><div class="face" role="button" tabindex="0">(<span class="eye left"><span class="lash">&quot;&quot;</span><span class="dot">•</span></span><span class="mouth">___</span><span class="eye right"><span class="lash">&quot;&quot;</span><span class="dot">•</span></span>)</div></div>';
                                        }
                                        // Apply persisted lashes state and wire toggle for fallback markup
                                        try{
                                            const face = out.querySelector('.ascii-face .face');
                                            const LASH_KEY = 'ai.face.lashed';
                                            if(face){
                                                const saved = localStorage.getItem(LASH_KEY) === '1';
                                                if(saved) face.classList.add('lashed');
                                                function setLash(on){ try{ face.classList.toggle('lashed', !!on); localStorage.setItem(LASH_KEY, on?'1':'0'); face.classList.add('lash-toggle'); setTimeout(()=>{ try{ face.classList.remove('lash-toggle'); }catch(e){} }, 380); }catch(e){} }
                                                face.addEventListener('click', ()=> setLash(!face.classList.contains('lashed')));
                                                face.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); setLash(!face.classList.contains('lashed')); }});
                                            }
                                        }catch(e){}
                                    } else {
                                        // If content exists but we haven't marked placeholder as shown, mark it so we don't repeat
                                        if(showOnce){ try{ state._aiPlaceholderShown = true; }catch(e){} }
                                    }
                                }
                            }
                        }catch(e){}
                    }, 90);
                }catch(e){}

                // AI explanation uses the global key in #globalGemKey; no per-quiz key input required here.

                left.querySelector('#revealBtn').onclick = () => reveal(it, rec);
                left.querySelector('#nextBtn').onclick = next;
                left.querySelector('#backBtn').onclick = back;
                left.querySelector('#skipBtn').onclick = skipCurrent;
                // Disable the Open Skipped control when there are no skipped questions
                try{
                    const os = left.querySelector('#openSkipped');
                    if(os){
                        const has = !!(state && state.skipped && state.skipped.size);
                        if(!has){ os.style.pointerEvents = 'none'; os.style.opacity = '0.55'; }
                        else { os.style.pointerEvents = 'auto'; os.style.opacity = '1'; os.onclick = openSkippedPanel; }
                    }
                }catch(e){}
            }

            // Reset to main menu: clear quiz state and return to setup screen
            (function bindReset(){
                const btn = $('resetToMenuBtn');
                if(!btn) return;
                // Prevent keyboard activation; only allow pointer/tap/click
                try{ btn.addEventListener('keydown', (ev)=>{ const k = ev.key; if(k === 'Enter' || k === ' ' || k === 'Spacebar'){ ev.preventDefault(); ev.stopPropagation(); } }); }catch(e){}
                btn.addEventListener('pointerup', (ev)=>{
                    try{
                        state.items = []; state.order = []; state.idx = 0; state.score = 0; state.answered = {}; state.skipped.clear(); state.reviewPool = []; state.started = false; state.mode = 'quiz';
                        // stop and clear timer
                        if(state.timerInterval){ clearInterval(state.timerInterval); state.timerInterval = null; }
                        state.quizStartTime = null; state.quizEndTime = null;
                        // Hide quiz, show setup
                        quiz.classList.add('hidden');
                        preview.classList.add('hidden');
                        setup.classList.remove('hidden');
                        try{ document.body.classList.remove('quiz-running'); }catch{}
                        try{ restoreGeminiStateAfterQuiz(); }catch{}
                        // Ensure textbook library UI is visible and refreshed
                        try{ document.getElementById('textbook-lib')?.classList.remove('hidden'); }catch{}
                        try{ if(window.refreshTextbookLibrary) window.refreshTextbookLibrary(); }catch{}
                        if(resetBar) resetBar.style.display = 'none';
                        // Unhide AI panels that were hidden after parsing/starting
                        try{ document.getElementById('ai-likeq')?.classList.remove('hidden'); }catch{}
                        try{ document.getElementById('ai-likeq-copy')?.classList.remove('hidden'); }catch{}
                        try{ document.querySelector('.ai-file-panel')?.classList.remove('hidden'); }catch{}
                        // Re-run light UI sync for key badges/buttons
                        try{
                            const evt = new Event('change');
                            document.getElementById('globalGemKey')?.dispatchEvent(new Event('input'));
                            document.getElementById('globalGemEnable')?.dispatchEvent(evt);
                        }catch{}
                        // Clear AI explanation panel and any transient UI
                        try{ if(typeof window.stopAiOutput === 'function'){ window.stopAiOutput(); } else { const gemOut = document.getElementById('gemOut'); if(gemOut) gemOut.value = ''; } }catch{}
                        const skipped = document.getElementById('skippedModal'); if(skipped) skipped.classList.add('hidden');
                        // hide results card
                        try{ document.getElementById('results-card')?.classList.add('hidden'); document.getElementById('resultsSummary').innerHTML=''; document.getElementById('resultsAiStatus').textContent=''; try{ if(typeof window.stopAiOutput === 'function'){ window.stopAiOutput(); } else { document.getElementById('resultsAiOutput').textContent=''; } }catch{} }catch{}
                        // Mark as not parsed so initializers won't hide AI panels until next parse
                        try{ window.__parsed = false; }catch{}
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                    }catch(e){ console.error('resetToMenu failed', e); }
                });
            })();

            const lockChoices = () => {
                // visually mark and prevent further interaction with choices
                quiz.querySelectorAll('.choice').forEach(n => {
                    n.classList.add('disabled');
                    // disable contained input and make label inert
                    const inp = n.querySelector('input'); if(inp){ inp.disabled = true; inp.checked = inp.checked; }
                    n.style.pointerEvents = 'none';
                    n.style.opacity = '0.95';
                });
            };

            function doSubmit(it, itemIndex) {
                const rec = state.answered[itemIndex] || (state.answered[itemIndex] = { selected: null, submitted: false, correct: false, skipped: false });
                if (rec.submitted) return;
                if (rec.selected == null) { alert('Choose an option first.'); return; }
                const nodes = quiz.querySelectorAll('.choice');
                nodes.forEach((n, idx) => { n.classList.remove('correct', 'wrong'); if (idx === it.correctIdx) n.classList.add('correct'); if (idx === rec.selected && rec.selected !== it.correctIdx) n.classList.add('wrong'); });
                rec.submitted = true; rec.correct = (rec.selected === it.correctIdx); rec.skipped = false; if (rec.correct) state.score++;
                // capture per-question answered timestamp and duration
                try{
                    const now = Date.now();
                    rec._lastAnsweredAt = now;
                    const start = rec._lastShownAt || (state.currentAttempt && state.currentAttempt.startedAt) || now;
                    rec._lastDurationMs = Math.max(0, now - start);
                }catch(e){ console.warn('timing capture failed', e); }
                const el = $('status'); if (el) el.textContent = rec.correct ? 'Correct!' : 'Not quite.';
                lockChoices();
                requestGeminiRationale(it, rec.selected);
            }

            function reveal(it, rec) {
                const nodes = quiz.querySelectorAll('.choice');
                nodes.forEach((n, idx) => { n.classList.toggle('correct', idx === it.correctIdx); });
                if (rec && rec.submitted) lockChoices();
            }

            function skipCurrent() {
                try{ if(typeof window.stopAiOutput === 'function') window.stopAiOutput(); }catch{}
                try{ const w = ensureWrapper(); if(w && w._page) w._page.textContent = ''; }catch{}
                // capture elapsed time for this question if missing before skipping
                try{ captureCurrentDurationIfMissing(); }catch(e){}
                const idx = activeIndex();
                const rec = state.answered[idx] || (state.answered[idx] = { selected: null, submitted: false, correct: false, skipped: false });
                // if no explicit duration recorded (no submit), capture now
                if(typeof rec._lastDurationMs !== 'number') try{ rec._lastDurationMs = Math.max(0, Date.now() - (rec._lastShownAt || (state.currentAttempt && state.currentAttempt.startedAt) || Date.now())); }catch(e){}
                rec.skipped = true; state.skipped.add(idx);
                if (state.idx < activeLength() - 1) { state.idx++; renderCurrent(); } else next();
            }

            function openSkippedPanel() {
                if (!state.started) return;
                ensureSkippedModal();
                state.returnIdx = state.idx; state.returnMode = state.mode;
                const listEl = $('skippedList'); listEl.innerHTML = '';
                if (!state.skipped.size) {
                    listEl.innerHTML = '<div class="hint">No skipped questions.</div>';
                } else {
                    [...state.skipped].forEach(ix => {
                        const chip = document.createElement('div'); chip.className = 'chip';
                        const n = state.items[ix]?.num || '?'; chip.textContent = `Q${n}`;
                        chip.onclick = () => { state.mode = 'quiz'; const pos = activeList().indexOf(ix); if (pos >= 0) { state.idx = pos; } else { state.order.unshift(ix); state.idx = 0; } hideSkipped(); renderCurrent(); };
                        listEl.appendChild(chip);
                    });
                }
                showSkipped();
            }

            function next() { try{ if(typeof window.stopAiOutput === 'function') window.stopAiOutput(); }catch{} try{ const w = ensureWrapper(); if(w && w._page) w._page.textContent = ''; }catch{} try{ captureCurrentDurationIfMissing(); }catch(e){} if (state.idx < activeLength() - 1) { state.idx++; renderCurrent(); } else { if (state.mode === 'quiz') return showSummary(); return showReviewDone(); } }
            function back() { try{ if(typeof window.stopAiOutput === 'function') window.stopAiOutput(); }catch{} try{ const w = ensureWrapper(); if(w && w._page) w._page.textContent = ''; }catch{} try{ captureCurrentDurationIfMissing(); }catch(e){} if (state.idx > 0) { state.idx--; renderCurrent(); } }

            // Format ms -> HH:MM:SS (or MM:SS if under 1 hour)
            function formatDuration(ms){
                ms = Math.max(0, ms|0);
                const s = Math.floor(ms/1000);
                const hh = Math.floor(s/3600);
                const mm = Math.floor((s%3600)/60);
                const ss = s%60;
                const pad = n=> String(n).padStart(2,'0');
                return hh>0 ? `${pad(hh)}:${pad(mm)}:${pad(ss)}` : `${pad(mm)}:${pad(ss)}`;
            }

            // Render a compact timing summary given an array of {index,num,durationMs,correct}
            function renderTimingSummary(qTimes){
                try{
                    if(!Array.isArray(qTimes) || qTimes.length===0) return 'No timing data available.';
                    const times = qTimes.map(q=> (typeof q.durationMs === 'number' ? q.durationMs : null)).filter(t=>t!=null);
                    if(times.length===0) return 'No per-question times recorded.';
                    const total = times.reduce((a,b)=>a+b,0);
                    const avg = Math.round(total / times.length);
                    const min = Math.min(...times);
                    const max = Math.max(...times);
                    // Build small per-question list (num: time)
                    const items = (qTimes||[]).map(q => {
                        const t = (typeof q.durationMs === 'number') ? formatDuration(q.durationMs) : 'N/A';
                        const mark = q.correct ? '' : ' • ⨯';
                        return `Q${q.num||'?'}: ${t}${mark}`;
                    });
                    // Show top-level metrics and first 8 items
                    const sample = items.slice(0,8).join('<br>');
                    return `Average: ${formatDuration(avg)} • Fastest: ${formatDuration(min)} • Slowest: ${formatDuration(max)}<br>${sample}${items.length>8 ? '<br>…' : ''}`;
                }catch(e){ return 'Timing summary unavailable.'; }
            }

            // Ensure current question has a duration recorded if it was shown but not yet answered
            function captureCurrentDurationIfMissing(){
                try{
                    const idx = activeIndex();
                    const rec = state.answered[idx];
                    if(!rec) return;
                    if(typeof rec._lastDurationMs === 'number') return; // already captured
                    const start = rec._lastShownAt || (state.currentAttempt && state.currentAttempt.startedAt) || null;
                    if(!start) return;
                    rec._lastDurationMs = Math.max(0, Date.now() - start);
                }catch(e){ /* ignore */ }
            }

            window.showSummary = function showSummary() {
                // stop timer
                if(state.timerInterval){ clearInterval(state.timerInterval); state.timerInterval = null; }
                state.quizEndTime = Date.now();
                // finalize the just-completed attempt so its duration is recorded
                finalizeCurrentAttempt();
                // Compute total time as the combined durations of all finalized attempts
                const totalAttemptMs = Array.isArray(state.attempts) ? state.attempts.reduce((s,a)=>s + (a.durationMs||0), 0) : 0;
                // Fallback: if no attempts recorded, fall back to quizStart/End delta
                const elapsedMs = totalAttemptMs || ((state.quizStartTime && state.quizEndTime) ? (state.quizEndTime - state.quizStartTime) : 0);
                // Ensure Validate/Like-Questions sections remain hidden on the summary screen
                try{ document.getElementById('ai-likeq')?.classList.add('hidden'); }catch{}
                try{ document.getElementById('ai-likeq-copy')?.classList.add('hidden'); }catch{}
                try{ document.body.classList.remove('quiz-running'); }catch{ }
                try{ restoreGeminiStateAfterQuiz(); }catch{}
                // Record whether focus mode was active before we show the summary,
                // so we can restore it when starting a Review Missed session.
                try{ state._wasFocusOn = !!document.body.classList.contains('focus-mode-active'); }catch(e){}
                // Ensure focus mode is disabled while the summary/results view is visible without changing user preference
                try{ document.body.classList.remove('focus-mode-active'); }catch(e){}
                const missed = [];
                state.items.forEach((_, ix) => { const r = state.answered[ix]; if (!r || !r.submitted || !r.correct) missed.push(ix); });
                const taggedCount = (state.tags && state.tags.size) ? state.tags.size : 0;
                const skippedCount = state.skipped ? state.skipped.size : 0;
                const pct = state.items.length ? (state.score / state.items.length * 100) : 0;
                // Wrap finished readout in a low z-index layer so overlays/popups appear above
                quiz.innerHTML =
                    `<div class="finished-summary-layer"><div class="qcard"><h2 style="margin:0 0 8px">Finished</h2>
                        <div>Score: ${state.score} / ${state.items.length} (${pct.toFixed(1)}%)</div>
                        <div>Time: ${formatDuration(elapsedMs)}</div>
                        <div class="hint" style="margin-top:8px">${missed.length ? 'You have questions to (re)try.' : 'All questions correct! 🎉'}</div>
                        <div class="mt-8" style="font-size:12px;color:var(--muted)">
                            Tagged this run: <strong>${taggedCount}</strong>
                        </div>
                    </div>` +
                    `<div class="footer finished-summary-layer"><div><div>
                        ${skippedCount ? `<button class="btn" id="openSkipped2">Open Skipped (${skippedCount})</button>` : ''}
                        ${taggedCount ? ' <button class="btn xs" id="copyTaggedBtn" type="button">Copy tagged</button>' : ''}
                        ${taggedCount ? ' <button class="btn xs" id="exportTaggedBtn" type="button">Save tagged to MCQs</button>' : ''}
                    </div></div><div><button class="btn" id="saveResultBtn">Save Result</button> ${missed.length ? '<button class="btn primary" id="reviewMissed">Review Missed</button>' : ''} <button class="btn" id="restart">Restart</button> <button class="btn" id="backSetup">Back to Setup</button></div></div>`;
                // Also render a results card below mirroring the validate/like style
                try{
                    const results = document.getElementById('results-card');
                    const sum = document.getElementById('resultsSummary');
                    if(results && sum){
                        if(missed.length === 0){
                            const pct = state.items.length? (state.score/state.items.length*100):0;
                            sum.innerHTML = `<div class="qcard">
                                <div><strong>Results</strong></div>
                                <div class="mt-6">Score: ${state.score} / ${state.items.length}</div>
                                <div>Percent Correct: ${pct.toFixed(1)}%</div>
                                <div>Time: ${formatDuration(elapsedMs)}</div>
                                <div>Missed (this pass): ${missed.length}</div>
                            </div>`;
                            // Build attempts UI and reveal only when fully complete
                            renderAttemptsUI();
                            results.classList.remove('hidden');
                            // Re-sync analyze button enabled state and key badge when results are shown
                            try{
                                const keyVal = (document.getElementById('globalGemKey')?.value||'').trim();
                                const enabled = !!document.getElementById('globalGemEnable')?.checked;
                                const ok = !!keyVal && enabled;
                                const analyze = document.getElementById('analyzeMissedBtn'); if(analyze) analyze.disabled = !ok;
                                const rBadge = document.getElementById('resultsKeyBadge'); if(rBadge){ rBadge.classList.toggle('ok', ok); rBadge.classList.toggle('missing', !ok); const h=rBadge.querySelector('.hint'); if(h) h.textContent = ok ? 'Key set' : 'No key set'; }
                            }catch{}
                        } else {
                            // Hide the results/attempts card until all questions have been completed correctly
                                results.classList.add('hidden');
                                sum.innerHTML = '';
                                const sel = document.getElementById('attemptSelect'); if(sel) sel.innerHTML = '';
                                const missList = document.getElementById('attemptMissedList'); if(missList) missList.innerHTML = '';
                                const stat = document.getElementById('resultsAiStatus'); if(stat) stat.textContent = '';
                                // Prefer aborting any animated AI output; fall back to clearing text if not available
                                try{ if(typeof window.stopAiOutput === 'function'){ window.stopAiOutput(); } else { const out = document.getElementById('resultsAiOutput'); if(out) out.textContent = ''; } }catch{}
                        }
                    }
                }catch{}
                const saveBtnEl = $('saveResultBtn');
                if(saveBtnEl) saveBtnEl.onclick = () => {
                    // User explicitly chose to save; this also updates last-attempt snapshot
                    try{ window.__setLastAttemptFromState && window.__setLastAttemptFromState('Saved result'); }catch(e){}
                    saveQuizResult();
                };
                // Tagged questions export actions (Finished/results view)
                try{
                    const exportTagBtn = document.getElementById('exportTaggedBtn');
                    const copyTagBtn = document.getElementById('copyTaggedBtn');
                    if(exportTagBtn) exportTagBtn.onclick = ()=>{ try{ window.__exportTaggedToSavedMcqs && window.__exportTaggedToSavedMcqs(); }catch(e){} };
                    if(copyTagBtn) copyTagBtn.onclick = ()=>{ try{ window.__copyTaggedToClipboard && window.__copyTaggedToClipboard(); }catch(e){} };
                }catch(e){}
                const restartEl = $('restart'); if(restartEl) restartEl.onclick = () => { try{ window.__suppressFocus = false; }catch(e){} state.idx = 0; state.score = 0; startQuiz(); };
                (function wireBackSetupOnlyPointer(){
                    const b = $('backSetup');
                    if(!b) return;
                    // Block Enter/Space so keyboard cannot trigger it
                    try{ b.addEventListener('keydown', (ev)=>{ const k = ev.key; if(k === 'Enter' || k === ' ' || k === 'Spacebar'){ ev.preventDefault(); ev.stopPropagation(); } }); }catch(e){}
                    const handler = ()=>{
                        // On leaving the summary, record this as the last attempted quiz
                        try{ window.__setLastAttemptFromState && window.__setLastAttemptFromState(); }catch(e){}
                        setup.classList.remove('hidden');
                        quiz.classList.add('hidden');
                        try{ document.getElementById('textbook-lib')?.classList.remove('hidden'); }catch{}
                        // Ensure the results card and any transient result UI are fully hidden/cleared
                        try{
                            const rc = document.getElementById('results-card'); if(rc) rc.classList.add('hidden');
                            const rs = document.getElementById('resultsSummary'); if(rs) rs.innerHTML = '';
                            const ra = document.getElementById('resultsAiStatus'); if(ra) ra.textContent = '';
                            const roa = document.getElementById('resultsAiOutput'); if(roa) roa.textContent = '';
                        }catch(e){}
                        // Hide the reset bar if visible
                        try{ if(resetBar) resetBar.style.display = 'none'; }catch(e){}
                        // Leaving summary — allow focus behavior to resume
                        try{ window.__suppressFocus = false; }catch(e){}
                    };
                    // Ensure legacy onclick does nothing
                    try{ b.onclick = null; }catch(e){}
                    b.addEventListener('pointerup', handler);
                })();
                try{ const os2 = $('openSkipped2'); if(os2) os2.onclick = openSkippedPanel; }catch(e){}
                // Wire Review Missed only if the button exists (we may omit it when there are no missed questions)
                try{
                    const _revBtn = $('reviewMissed');
                    if(_revBtn){
                        _revBtn.onclick = () => {
                            if (!missed.length) return;
                            state.mode = 'review';
                            state.reviewPool = missed.slice();
                            // Re-enable focus mode when re-entering quiz-view if Always-enable is ON.
                            // Clear suppression so overlay can engage during reattempts.
                            try{
                                window.__suppressFocus = false;
                                const ALWAYS_KEY = '__ui_always_focus_v1';
                                const alwaysOn = (function(){ try{ return localStorage.getItem(ALWAYS_KEY) === '1'; }catch(e){ return false; } })();
                                if(alwaysOn){ if(typeof window.__setFocusMode === 'function') window.__setFocusMode(true); else document.body.classList.add('focus-mode-active'); }
                            }catch(e){}
                            // Hide results card and attempts UI during review
                            try{ document.getElementById('results-card')?.classList.add('hidden'); }catch{}

                            // ⬅️ unlock items for re-answering
                            state.reviewPool.forEach(ix => {
                                const r = state.answered[ix] || (state.answered[ix] = {});
                                r.submitted = false;   // allow resubmit
                                r.selected = null;    // optional: clear old choice
                                r.skipped = false;
                                // reshuffle choices ensuring the correct answer moves to a new slot
                                shuffleChoicesEnsureMove(state.items[ix]);
                            });

                            state.idx = 0;
                            // start a new attempt covering the review pool
                            startAttempt('review', state.reviewPool.slice());
                            // start quiz timer for the review session (match startQuiz behavior)
                            try{ state.quizStartTime = Date.now(); state.quizEndTime = null; if(state.timerInterval){ clearInterval(state.timerInterval); state.timerInterval = null; } state.timerInterval = setInterval(()=>{ try{ const el = document.getElementById('quizTimer'); if(!el) return; const timerStart = (state.quizStartTime || (state.currentAttempt && state.currentAttempt.startedAt) || null); if(!timerStart) return; const ms = Math.max(0, Date.now() - timerStart); el.textContent = formatDuration(ms); }catch{} }, 500); }catch(e){}
                            // Re-enable focus mode if user had it on, or if Always-enable is set (but NOT for saved-result flows)
                            try{
                                const ALWAYS_KEY = '__ui_always_focus_v1';
                                let alwaysOn = false;
                                try{ alwaysOn = (localStorage.getItem(ALWAYS_KEY) === '1'); }catch(e){}
                                const suppress = !!state._loadedFromSaved;
                                const shouldEnable = !suppress && !!(alwaysOn || state._wasFocusOn);
                                if(shouldEnable){ if(typeof window.__setFocusMode === 'function') window.__setFocusMode(true); else document.body.classList.add('focus-mode-active'); }
                            }catch(e){}
                            renderCurrent();
                        };
                    }
                }catch(e){}
            }
            try{ window.showSummary = showSummary; }catch(e){}

            // Copy Results button handler: builds a compact summary string and copies to clipboard
            (function wireCopyResults(){
                function formatTime(ms){
                    if(!ms && ms !== 0) return '';
                    const s = Math.floor(ms/1000);
                    const mm = Math.floor(s/60); const ss = s%60;
                    return `${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
                }

                function getLectureName(){
                    try{
                        const el = document.getElementById('aiFileName');
                        if(el && el.textContent && el.textContent.trim() && el.textContent.trim() !== 'No file chosen') return el.textContent.trim();
                        // fallback: page title
                        if(document.title){
                            const t = document.title.replace(/\s*-\s*BUNKR.*$/,'').trim();
                            // If the default site title is present, use a neutral placeholder per request
                            if(/BUNKR\s*108|AI-powered Study Interface/i.test(document.title)) return '[QUIZ NAME]';
                            return t;
                        }
                    }catch(e){}
                    return 'Lecture';
                }

                async function copyResults(){
                    try{
                        const btn = document.getElementById('copyResultsBtn');
                        const lecture = getLectureName();
                        const atts = Array.isArray(state.attempts) ? state.attempts.slice() : [];
                        if(atts.length === 0 && state.currentAttempt){ atts.push(state.currentAttempt); }
                        // Build exact-format output. Example:
                        // [1] Lecture 21 [OCR; RESCAN] -- 16/29
                        // [2] 24/29; [3] 28/29; [4] 29/29
                        const lines = [];
                        // Use finalized attempts if present, otherwise include currentAttempt
                        const attemptsList = atts;
                        if(attemptsList.length){
                            // Determine total questions: prefer first attempt pool length, else union of all pools
                            let totalQuestions = 0;
                            if(Array.isArray(attemptsList[0].pool)) totalQuestions = attemptsList[0].pool.length;
                            else {
                                const allPools = new Set();
                                attemptsList.forEach(a=>{ if(Array.isArray(a.pool)) a.pool.forEach(ix=> allPools.add(ix)); });
                                totalQuestions = allPools.size;
                            }

                            // Maintain cumulative set of correctly answered indices across attempts
                            const cumulativeCorrect = new Set();

                            // First attempt line includes lecture name and cumulative after attempt 1
                            const a0 = attemptsList[0];
                            const pool0 = Array.isArray(a0.pool) ? a0.pool.slice() : [];
                            const missedSet0 = new Set((Array.isArray(a0.missed) ? a0.missed.map(m => (typeof m === 'number' ? m : (m && m.index != null ? m.index : null))).filter(x=>x!=null) : []));
                            pool0.forEach(ix => { if(!missedSet0.has(ix)) cumulativeCorrect.add(ix); });
                            const score0 = cumulativeCorrect.size;
                            lines.push(`[1] ${lecture} -- ${score0}/${totalQuestions}`);

                            // Subsequent attempts on second line, semicolon-separated, show cumulative after each attempt
                            if(attemptsList.length > 1){
                                const others = [];
                                for(let i=1;i<attemptsList.length;i++){
                                    const ai = attemptsList[i];
                                    const pool = Array.isArray(ai.pool) ? ai.pool.slice() : [];
                                    const missedSet = new Set((Array.isArray(ai.missed) ? ai.missed.map(m => (typeof m === 'number' ? m : (m && m.index != null ? m.index : null))).filter(x=>x!=null) : []));
                                    pool.forEach(ix => { if(!missedSet.has(ix)) cumulativeCorrect.add(ix); });
                                    const cumScore = cumulativeCorrect.size;
                                    const num = (typeof ai.id === 'number' || typeof ai.id === 'string') ? ai.id : (i+1);
                                    others.push(`[${num}] ${cumScore}/${totalQuestions}`);
                                }
                                lines.push(others.join('; '));
                            }
                        } else {
                            // No attempts at all: fallback to a simple single-line summary
                            lines.push(`[1] ${lecture} -- 0/0`);
                        }
                        const out = lines.join('\n');
                        if(navigator.clipboard && navigator.clipboard.writeText){
                            await navigator.clipboard.writeText(out);
                        } else {
                            // fallback: use execCommand
                            const ta = document.createElement('textarea'); ta.value = out; ta.style.position='fixed'; ta.style.left='-9999px'; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove();
                        }
                        if(btn){ const old = btn.textContent; btn.textContent = 'Copied!'; setTimeout(()=>{ try{ btn.textContent = old; }catch{} }, 1600); }
                    }catch(e){ console.error('copyResults failed', e); alert('Copy failed: ' + (e && e.message ? e.message : e)); }
                }

                document.addEventListener('click', function(ev){ try{ const t = ev.target; if(!t) return; if(t.closest && t.closest('#copyResultsBtn')){ ev.preventDefault(); copyResults(); } }catch(e){} }, true);
            })();

            function renderAttemptsUI(){
                try{
                    const sel = document.getElementById('attemptSelect');
                    const list = document.getElementById('attemptMissedList');
                    const sum = document.getElementById('resultsSummary');
                    const status = document.getElementById('resultsAiStatus');
                    const dd = document.getElementById('attemptDropdown');
                    const trigger = document.getElementById('attemptTrigger');
                    const trigText = document.getElementById('attemptTriggerText');
                    const menu = document.getElementById('attemptMenu');
                    if(!sel || !list) return;
                    // Ensure we have at least the finalized attempts
                    const attempts = state.attempts.slice();
                    // Aggregate totals (across all attempts)
                    const allMissed = attempts.flatMap(a => a.missed || []);
                    // Build labels once
                    const labels = attempts.map(a=>({ id:String(a.id), text:`${a.id}. ${a.mode} — missed ${a.missed?.length||0}, time ${formatDuration(a.durationMs||0)}` }));
                    // Fill native select (kept hidden)
                    sel.innerHTML = '';
                    labels.forEach(l=>{ const opt=document.createElement('option'); opt.value=l.id; opt.textContent=l.text; sel.appendChild(opt); });
                    // Fill custom menu
                    if(menu){ menu.innerHTML = labels.map(l=>`<div class="attempt-option" role="option" data-id="${l.id}"><span class="tag">${l.id}.</span> <span>${l.text.replace(/^\d+\.\s+/, '')}</span></div>`).join(''); }
                    // Default selection: most recent with misses, else last
                    if(attempts.length){ let def=null; for(let i=attempts.length-1;i>=0;i--){ if(attempts[i]?.missed && attempts[i].missed.length){ def=String(attempts[i].id); break; } } if(!def) def=String(attempts[attempts.length-1].id); sel.value=def; if(trigText) trigText.textContent = labels.find(x=>x.id===def)?.text || 'Select attempt…'; }
                    // Open/close behavior
                    function syncMenuWidth(){ try{ if(!dd||!menu||!trigger) return; const w = Math.ceil(trigger.getBoundingClientRect().width); menu.style.width = w + 'px'; }catch{} }
                    // Use only the in-flow menu; elevate via z-index in CSS
                    function setOpen(open){ if(!dd) return; dd.classList.toggle('open', !!open); dd.setAttribute('aria-expanded', open?'true':'false'); if(open){ syncMenuWidth(); } }
                    // Direct wiring removed to prevent double-toggle conflicts; delegated handler below handles trigger clicks robustly
                    // Robust delegated wiring (survives DOM refreshes)
                    if(!window.__attemptDdWired){
                        window.__attemptDdWired = true;
                        document.addEventListener('click', function(evt){
                            const dropdown = document.getElementById('attemptDropdown');
                            if(!dropdown) return;
                            const t = evt.target.closest ? evt.target.closest('#attemptTrigger') : null;
                            const opt = evt.target.closest ? evt.target.closest('.attempt-option') : null;
                            const menuEl = document.getElementById('attemptMenu');
                            const trigEl = document.getElementById('attemptTrigger');
                            // Toggle open when trigger clicked
                            if(t){ evt.preventDefault(); const willOpen = !dropdown.classList.contains('open');
                                // use setOpen so portal is managed too
                                const s = document.getElementById('attemptSelect'); if(!s || !s.options.length){ return; }
                                setOpen(willOpen);
                                return; }
                            // Select an option
                            if(opt){ const id = opt.getAttribute('data-id'); const selEl = document.getElementById('attemptSelect'); if(id && selEl){ selEl.value = id; try{ selEl.dispatchEvent(new Event('change', { bubbles:true })); }catch{} } setOpen(false); return; }
                            // Clicked outside -> close
                            if(!dropdown.contains(evt.target)){ setOpen(false); }
                        });
                        document.addEventListener('keydown', (e)=>{ if(e.key==='Escape'){ setOpen(false); } });
                        window.addEventListener('resize', ()=>{ const d=document.getElementById('attemptDropdown'); const trig=document.getElementById('attemptTrigger'); const m=document.getElementById('attemptMenu'); if(d && d.classList.contains('open') && trig && m){ try{ m.style.width = Math.ceil(trig.getBoundingClientRect().width) + 'px'; }catch{} }
                        });
                    }
                    // Renderer for a selected attempt
                    function renderAttempt(id){
                        const a = attempts.find(z => String(z.id) === String(id));
                        if(!a){ list.innerHTML = '<div class="hint">No attempt selected.</div>'; if(sum) sum.innerHTML=''; return; }
                        // Keep analyze button in sync with current selection (for robust reads)
                        try{ const ab = document.getElementById('analyzeMissedBtn'); if(ab){ ab.dataset.selAttemptId = String(a.id); } }catch{}
                        // Sync the custom trigger text
                        try{ if(trigText){ const l = labels.find(x=>x.id===String(a.id)); if(l) trigText.textContent = l.text; } }catch{}
                        // Update summary block for the selected attempt (isolated score/time)
                        try{
                            const pool = Array.isArray(a.pool) ? a.pool.length : 0;
                            const missedN = Array.isArray(a.missed) ? a.missed.length : 0;
                            const correct = Math.max(0, pool - missedN);
                            const pct = pool ? (correct/pool*100) : 0;
                            if(sum){
                                sum.innerHTML = `<div class="qcard">
                                    <div><strong>Results</strong></div>
                                    <div class="mt-6">Score: ${correct} / ${pool}</div>
                                    <div>Percent Correct: ${pct.toFixed(1)}%</div>
                                    <div>Time: ${formatDuration(a.durationMs||0)}</div>
                                    <div>Missed (this attempt): ${missedN}</div>
                                    <div class="mt-4 flex gap-8" style="display:flex; gap:8px; margin-top:12px">
                                        <button class="btn small" id="redoMissedBtn" ${missedN?'':'disabled'}>Redo Missed</button>
                                        <button class="btn small" id="redoCorrectBtn" ${correct?'':'disabled'}>Redo Correct</button>
                                    </div>
                                    <div class="mt-6"><strong>Per-question timing</strong></div>
                                    <div class="hint" style="margin-top:6px">${renderTimingSummary(a.qTimes||[])}</div>
                                </div>`;
                                // Wire up the redo buttons
                                setTimeout(()=>{
                                    const rm = document.getElementById('redoMissedBtn');
                                    const rc = document.getElementById('redoCorrectBtn');
                                    if(rm) rm.onclick = () => openMiniRedo(a.id, 'missed');
                                    if(rc) rc.onclick = () => openMiniRedo(a.id, 'correct');
                                }, 0);
                            }
                        }catch(e){ /* ignore summary update errors */ }
                        if(!a.missed || a.missed.length===0){
                            list.innerHTML = '<div class="hint text-center">No missed questions in this attempt.</div>';
                            if(status) status.textContent = 'No missed questions in the selected attempt to analyze.';
                            return;
                        }
                        // Similar to preview, show missed questions with A/B/C labels and key
                        // CRITICAL: Always render from the attempt snapshot (m.choices, m.correctIdx)
                        // to avoid mismatches when choices were reshuffled in later attempts.
                        const letters = ['A','B','C','D','E','F'];
                        const html = a.missed.map(m=>{
                            const it = state.items[m.index];
                            const q = (m.q ?? it?.q ?? '');
                            const num = (m.num ?? it?.num ?? '?');
                            const choicesArr = Array.isArray(m.choices) && m.choices.length ? m.choices : (it?.choices || []);
                            const choices = choicesArr.map((c,i)=>`<span class="tag">${letters[i]||'?'}.</span> ${safeText(c)}`).join('<br>');
                            const keyIdx = (typeof m.correctIdx === 'number') ? m.correctIdx : (it?.correctIdx ?? 0);
                            const keyLetter = letters[keyIdx] || 'A';
                            const userLetter = (m.user==null? '—' : (letters[m.user]||'?'));
                            // Build missed card using same structure as preview (compact, no inline flex)
                            return `<div class="qcard">
                                <div><strong>Q${esc(String(num))}.</strong> ${safeText(q)}</div>
                                <div style="margin-top:6px">${choices}</div>
                                <div class="hint" style="margin-top:6px">Key: <span class="tag">${keyLetter}</span></div>
                                <div class="hint" style="margin-top:6px">Answered: <span class="tag">${userLetter}</span> • Time: ${formatDuration(m.durationMs||0)}</div>
                            </div>`;
                        }).join('');
                        list.innerHTML = html;
                        if(status) status.textContent = `Selected attempt ${a.id}: ${a.missed.length} missed will be analyzed.`;
                        // Tagging UI removed for Phase 1 — tags and tag-based generation are deferred
                    }
                    sel.onchange = ()=> { renderAttempt(sel.value); try{ const ab = document.getElementById('analyzeMissedBtn'); if(ab){ ab.dataset.selAttemptId = String(sel.value||''); } }catch{} };
                    // Menu selection wiring
                    if(menu && menu.children.length){
                        Array.from(menu.children).forEach(el=>{
                            el.addEventListener('click', ()=>{ const id = el.getAttribute('data-id'); if(id){ sel.value = id; renderAttempt(id); } setOpen(false); syncMenuWidth(); });
                        });
                    }
                    if(attempts.length){ renderAttempt(sel.value); }
                }catch(e){ console.warn('renderAttemptsUI failed', e); }
            }

            function showReviewDone() {
                const remaining = state.reviewPool.filter(ix => { const r = state.answered[ix]; return !r || !r.correct; });
                if (remaining.length) {
                    // Ensure results card remains hidden on Keep Going screens
                    try{ document.getElementById('results-card')?.classList.add('hidden'); }catch{}
                    // Temporarily disable focus mode while the Keep Going screen is visible,
                    // mirroring the behavior of the main Results/Summary view without
                    // changing the user's Always-enable preference.
                    try{ document.body.classList.remove('focus-mode-active'); }catch(e){}
                    // Ensure the just-completed slice is recorded so attempts UI can show it now
                    finalizeCurrentAttempt();
                    quiz.innerHTML =
                        `<div class="qcard"><h2 style="margin:0 0 8px">Keep Going</h2><div class="hint">Attempt ${(state.currentAttempt && state.currentAttempt.id) ? state.currentAttempt.id : (state.attempts[state.attempts.length-1]?.id || '?')} (${(state.currentAttempt && state.currentAttempt.mode) ? state.currentAttempt.mode : (state.attempts[state.attempts.length-1]?.mode || 'review')}): Some questions are still incorrect or unsubmitted. Continue until all are correct.</div></div>` +
                        `<div class="footer"><button class="btn" id="continueReview">Continue</button><button class="btn" id="summary">Summary</button></div>`;
                    $('continueReview').onclick = () => {
                        // start a new attempt for the remaining items
                        try{ document.getElementById('results-card')?.classList.add('hidden'); }catch{}
                        state.reviewPool = remaining;

                        // ⬅️ unlock remaining items again
                        state.reviewPool.forEach(ix => {
                            const r = state.answered[ix] || (state.answered[ix] = {});
                            r.submitted = false;
                            r.selected = null;
                            r.skipped = false;
                            // reshuffle again so position can't be memorized
                            shuffleChoicesEnsureMove(state.items[ix]);
                        });

                        state.idx = 0;
                        startAttempt('review', state.reviewPool.slice());
                        // start quiz timer for this review continuation (match startQuiz behavior)
                        try{ state.quizStartTime = Date.now(); state.quizEndTime = null; if(state.timerInterval){ clearInterval(state.timerInterval); state.timerInterval = null; } state.timerInterval = setInterval(()=>{ try{ const el = document.getElementById('quizTimer'); if(!el) return; const timerStart = (state.quizStartTime || (state.currentAttempt && state.currentAttempt.startedAt) || null); if(!timerStart) return; const ms = Math.max(0, Date.now() - timerStart); el.textContent = formatDuration(ms); }catch{} }, 500); }catch(e){}
                        renderCurrent();
                    };
                    $('summary').onclick = showSummary;
                } else {
                    // finalize the last review attempt slice and auto-redirect to Summary
                    finalizeCurrentAttempt();
                    try{ document.body.classList.remove('quiz-running'); }catch{};
                    try{ restoreGeminiStateAfterQuiz(); }catch{};
                    showSummary();
                }
            }

            /* ---------- Mini Quiz Redo Logic ---------- */
            let miniQuizState = { items: [], idx: 0 };
            // key handler reference so we can attach/detach when modal opens/closes
            let __miniQuizKeyHandler = null;
            let __miniFocusTrapHandler = null;
            let __miniTabTrapHandler = null;
            let __miniIsolated = false;
            function __activateMiniIsolation(on){
                try{
                    if(on === __miniIsolated) return; __miniIsolated = !!on;
                    const modal = document.getElementById('miniQuizModal'); if(!modal) return;
                    const body = document.body;
                    if(on){
                        // Mark body for styling hooks
                        body.classList.add('mini-quiz-active');
                        // Set inert+aria-hidden on all top-level siblings except the modal wrapper
                        Array.from(body.children).forEach(ch=>{
                            if(!ch) return;
                            if(ch.id === 'miniQuizModal' || ch.querySelector?.('#miniQuizModal')) return;
                            try{ ch.setAttribute('aria-hidden','true'); }catch{}
                            try{ ch.setAttribute('inert',''); }catch{}
                        });
                        // Focus trap: on focusin, if focus leaves modal, bring it back
                        __miniFocusTrapHandler = function(ev){ try{ if(!modal || modal.classList.contains('hidden')) return; if(modal.contains(ev.target)) return; const target = document.getElementById('miniQuizClose') || document.getElementById('miniNext') || modal; target.focus && target.focus(); ev.preventDefault(); ev.stopPropagation(); }catch{} };
                        document.addEventListener('focusin', __miniFocusTrapHandler, true);
                        // Tab trap: keep focus cycling within modal
                        __miniTabTrapHandler = function(ev){ try{ if(ev.key !== 'Tab') return; if(!modal || modal.classList.contains('hidden')) return; const focusables = modal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'); const list = Array.from(focusables).filter(el=>!el.disabled && el.offsetParent!==null); if(!list.length) return; const first = list[0], last = list[list.length-1]; if(ev.shiftKey && document.activeElement === first){ last.focus(); ev.preventDefault(); ev.stopPropagation(); } else if(!ev.shiftKey && document.activeElement === last){ first.focus(); ev.preventDefault(); ev.stopPropagation(); } }catch{} };
                        document.addEventListener('keydown', __miniTabTrapHandler, true);
                    } else {
                        body.classList.remove('mini-quiz-active');
                        Array.from(body.children).forEach(ch=>{ try{ ch.removeAttribute('aria-hidden'); ch.removeAttribute('inert'); }catch{} });
                        if(__miniFocusTrapHandler){ document.removeEventListener('focusin', __miniFocusTrapHandler, true); __miniFocusTrapHandler = null; }
                        if(__miniTabTrapHandler){ document.removeEventListener('keydown', __miniTabTrapHandler, true); __miniTabTrapHandler = null; }
                    }
                }catch(e){ console.warn('mini isolation failed', e); }
            }
            function openMiniRedo(attemptId, type) {
                const a = state.attempts.find(z => String(z.id) === String(attemptId));
                if (!a) return;
                
                // Determine items
                let items = [];
                if (type === 'missed') {
                    // Use the missed array directly, but map back to full item objects if needed
                    // a.missed contains { index, q, num, choices, correctIdx, user, ... }
                    // We need to reconstruct a mini-item object that has enough info to render
                    items = (a.missed || []).map(m => ({
                        q: m.q,
                        choices: m.choices,
                        correctIdx: m.correctIdx,
                        num: m.num,
                        // Store original index if needed, though not strictly required for mini-view
                        origIndex: m.index
                    }));
                } else {
                    // Correct items: items in pool that are NOT in missed
                    // a.pool contains indices into state.items
                    const missedIndices = new Set((a.missed || []).map(m => m.index));
                    const correctIndices = (a.pool || []).filter(ix => !missedIndices.has(ix));
                    items = correctIndices.map(ix => {
                        const it = state.items[ix];
                        return {
                            q: it.q,
                            choices: it.choices,
                            correctIdx: it.correctIdx,
                            num: it.num,
                            origIndex: ix
                        };
                    });
                }
                
                if (!items.length) { alert('No questions to redo.'); return; }
                
                miniQuizState = { items, idx: 0 };
                
                // Ensure modal exists
                let modal = document.getElementById('miniQuizModal');
                if (!modal) {
                    // Inject modal HTML and CSS if missing
                    const div = document.createElement('div');
                    div.innerHTML = `
<style>
/* Mini Quiz Modal */
#miniQuizModal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 200005; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); }
#miniQuizModal.hidden { display: none; }
#miniQuizModal .modal-panel { width: 90%; max-width: 800px; max-height: 80vh; height: auto; display: flex; flex-direction: column; background: var(--bg); border: 1px solid var(--stroke); border-radius: 20px; box-shadow: 0 20px 50px rgba(0,0,0,0.6); overflow: hidden; }
#miniQuizModal .modal-header { padding: 16px; margin: 12px; border: 1px solid var(--stroke); display: flex; justify-content: space-between; align-items: center; background: rgba(0,0,0,0.4); border-radius: 20px; }
#miniQuizModal .modal-body { flex: 1; overflow-y: auto; padding: 12px 24px; }
#miniQuizModal .modal-footer { padding: 16px; margin: 12px; border: 1px solid var(--stroke); display: flex; justify-content: space-between; align-items: center; background: rgba(0,0,0,0.4); border-radius: 20px; }
#miniQuizModal .choice { display: flex; gap: 12px; padding: 12px; border: 1px solid var(--btnBorder); border-radius: 12px; margin-bottom: 8px; cursor: pointer; transition: all 0.2s; align-items: flex-start; background: linear-gradient(180deg, rgba(14, 20, 32, .55), rgba(10, 15, 26, .55)); }
#miniQuizModal .choice:hover { background: rgba(255,255,255,0.08); }
#miniQuizModal .choice.correct { background: rgba(16, 185, 129, 0.15); border-color: rgba(16, 185, 129, 0.4); }
#miniQuizModal .choice.wrong { background: rgba(239, 68, 68, 0.15); border-color: rgba(239, 68, 68, 0.4); }
#miniQuizModal .choice.disabled { pointer-events: none; opacity: 0.8; }
</style>
<div id="miniQuizModal" class="hidden">
    <div class="modal-panel">
        <div class="modal-header">
            <h3 style="margin:0">Redo <span id="miniQuizType"></span></h3>
            <button class="btn icon-only" id="miniQuizClose">✕</button>
        </div>
        <div id="miniQuizBody" class="modal-body"></div>
        <div class="modal-footer">
            <button class="btn" id="miniPrev">Previous</button>
            <span id="miniProgress" class="hint"></span>
            <button class="btn primary" id="miniNext">Next</button>
        </div>
    </div>
</div>`;
                    document.body.appendChild(div);
                    modal = document.getElementById('miniQuizModal');
                    document.getElementById('miniQuizClose').onclick = closeMiniQuiz;
                    document.getElementById('miniPrev').onclick = () => { if(miniQuizState.idx > 0) { miniQuizState.idx--; renderMiniQuizCurrent(); } };
                    document.getElementById('miniNext').onclick = () => { if(miniQuizState.idx < miniQuizState.items.length - 1) { miniQuizState.idx++; renderMiniQuizCurrent(); } else { closeMiniQuiz(); } };

                    // Keyboard shortcuts for the mini quiz modal: 1-9 / A-F to select, Enter to progress
                    __miniQuizKeyHandler = function(e){
                        try{
                            // ignore modifier combos
                            if(e.ctrlKey || e.metaKey || e.altKey) return;
                            // ignore when typing in inputs or editable elements
                            const ae = document.activeElement;
                            if(ae){ const tag = (ae.tagName||'').toLowerCase(); if(tag==='input' || tag==='textarea' || ae.isContentEditable) return; }
                            const modalEl = document.getElementById('miniQuizModal'); if(!modalEl || modalEl.classList.contains('hidden')) return;
                            const k = (e.key||'').toLowerCase();
                            const chContainer = document.getElementById('miniChoices');
                            if(!chContainer) return;
                            // If the key is one we care about, consume it so global handlers don't act
                            const isInterest = (/^[1-9]$/.test(k) || /^[a-f]$/.test(k) || k === 'enter' || k === ' ');
                            if(isInterest){ try{ e.preventDefault(); e.stopPropagation(); }catch(_){}}

                            // map 1-9 (support main keyboard and numpad via e.key or e.code)
                            let digitIdx = null;
                            if(/^[1-9]$/.test(k)){
                                digitIdx = parseInt(k,10) - 1;
                            } else if(e.code && /^Numpad([1-9])$/.test(e.code)){
                                const m = e.code.match(/^Numpad([1-9])$/); digitIdx = parseInt(m[1],10) - 1;
                            }
                            if(digitIdx !== null){ const child = chContainer.children[digitIdx]; if(child){ child.click(); } return; }

                            // map letters a-i (case-insensitive) so choices beyond 4 can be selected
                            if(/^[a-i]$/.test(k)){
                                const idx = k.charCodeAt(0) - 'a'.charCodeAt(0);
                                const child = chContainer.children[idx]; if(child){ child.click(); }
                                return;
                            }
                            // Enter: if already answered (disabled children), go next; otherwise do nothing
                            if(k === 'enter'){
                                const anyDisabled = Array.from(chContainer.children).some(c=>c.classList.contains('disabled'));
                                if(anyDisabled){ const nextBtn = document.getElementById('miniNext'); if(nextBtn){ nextBtn.click(); } }
                                return;
                            }
                        }catch(err){ console.warn('mini quiz key handler', err); }
                    };
                    try{ document.addEventListener('keydown', __miniQuizKeyHandler, true); }catch(e){}
                }
                
                // Ensure keyboard handler is attached even when the modal was created earlier
                if(!__miniQuizKeyHandler){
                    __miniQuizKeyHandler = function(e){
                        try{
                            if(e.ctrlKey || e.metaKey || e.altKey) return;
                            const ae = document.activeElement;
                            if(ae){ const tag = (ae.tagName||'').toLowerCase(); if(tag==='input' || tag==='textarea' || ae.isContentEditable) return; }
                            const modalEl = document.getElementById('miniQuizModal'); if(!modalEl || modalEl.classList.contains('hidden')) return;
                            const k = (e.key||'').toLowerCase();
                            const chContainer = document.getElementById('miniChoices');
                            if(!chContainer) return;
                            const isInterest = (/^[1-9]$/.test(k) || /^[a-f]$/.test(k) || k === 'enter' || k === ' ');
                            if(isInterest){ try{ e.preventDefault(); e.stopPropagation(); }catch(_){} }
                            let digitIdx = null;
                            if(/^[1-9]$/.test(k)){
                                digitIdx = parseInt(k,10) - 1;
                            } else if(e.code && /^Numpad([1-9])$/.test(e.code)){
                                const m = e.code.match(/^Numpad([1-9])$/); digitIdx = parseInt(m[1],10) - 1;
                            }
                            if(digitIdx !== null){ const child = chContainer.children[digitIdx]; if(child){ child.click(); } return; }
                            if(/^[a-i]$/.test(k)){
                                const idx = k.charCodeAt(0) - 'a'.charCodeAt(0);
                                const child = chContainer.children[idx]; if(child){ child.click(); }
                                return;
                            }
                            if(k === 'enter'){
                                const anyDisabled = Array.from(chContainer.children).some(c=>c.classList.contains('disabled'));
                                if(anyDisabled){ const nextBtn = document.getElementById('miniNext'); if(nextBtn){ nextBtn.click(); } }
                                return;
                            }
                        }catch(err){ console.warn('mini quiz key handler', err); }
                    };
                    try{ document.addEventListener('keydown', __miniQuizKeyHandler, true); }catch(e){}
                }
                document.getElementById('miniQuizType').textContent = type === 'missed' ? 'Missed' : 'Correct';
                modal.classList.remove('hidden');
                try{ __activateMiniIsolation(true); }catch(e){}
                // Focus trap: move focus into the modal close button or next button
                try{
                    const firstFocus = document.getElementById('miniQuizClose') || document.getElementById('miniNext');
                    if(firstFocus && firstFocus.focus) firstFocus.focus();
                }catch(e){}
                renderMiniQuizCurrent();
            }
            
            function closeMiniQuiz() {
                const modal = document.getElementById('miniQuizModal');
                if (modal) modal.classList.add('hidden');
                try{ if(__miniQuizKeyHandler){ document.removeEventListener('keydown', __miniQuizKeyHandler, true); __miniQuizKeyHandler = null; } }catch(e){}
                try{ __activateMiniIsolation(false); }catch(e){}
            }
            
            function renderMiniQuizCurrent() {
                const it = miniQuizState.items[miniQuizState.idx];
                const total = miniQuizState.items.length;
                const body = document.getElementById('miniQuizBody');
                const prog = document.getElementById('miniProgress');
                const prev = document.getElementById('miniPrev');
                const next = document.getElementById('miniNext');
                
                prog.textContent = `${miniQuizState.idx + 1} / ${total}`;
                prev.disabled = miniQuizState.idx === 0;
                next.textContent = miniQuizState.idx === total - 1 ? 'Finish' : 'Next';
                
                const letters = ['A','B','C','D','E','F'];
                
                body.innerHTML = `
                    <div style="font-weight:700; font-size:1.1em; margin-bottom:16px">Q${it.num}. ${safeText(it.q)}</div>
                    <div id="miniChoices"></div>
                    <div id="miniFeedback" class="hint" style="margin-top:12px; min-height:20px"></div>
                `;
                
                const chContainer = body.querySelector('#miniChoices');
                const fb = body.querySelector('#miniFeedback');
                
                it.choices.forEach((c, idx) => {
                    const div = document.createElement('div');
                    div.className = 'choice';
                    div.innerHTML = `<strong>${letters[idx]}.</strong> <span>${safeText(c)}</span>`;
                    div.onclick = () => {
                        // Check answer
                        const isCorrect = idx === it.correctIdx;
                        div.classList.add(isCorrect ? 'correct' : 'wrong');
                        
                        // Show correct if wrong
                        if (!isCorrect) {
                            const correctDiv = chContainer.children[it.correctIdx];
                            if (correctDiv) correctDiv.classList.add('correct');
                            fb.textContent = 'Incorrect.';
                            fb.style.color = 'var(--bad)';
                        } else {
                            fb.textContent = 'Correct!';
                            fb.style.color = 'var(--good)';
                        }
                        
                        // Disable all
                        Array.from(chContainer.children).forEach(child => child.classList.add('disabled'));
                    };
                    chContainer.appendChild(div);
                });
                
                // Render LaTeX if available
                try{ if(window.renderMathIn) window.renderMathIn(body); }catch(e){}
            }

            /* ---------- Gemini 2.5 rationale (SDK) ---------- */
            async function requestGeminiRationale(it, choiceIdx) {
                const key = (document.getElementById('globalGemKey')?.value || '').trim(); const out = $('resultsAiOutput') || $('gemOut');
                const enabled = !!document.getElementById('globalGemEnable')?.checked;
                if (!key || !enabled) {
                    // Do not write a user-facing message into the AI Explanation panel when API is disabled.
                    // The UI instead shows a small red/green dot next to the AI Explanation header to indicate status.
                    try{ console.debug('AI explanations disabled or API key missing; skipping Gemini request.'); }catch(e){}
                    return;
                }
                const AI = window.GoogleGenerativeAI; if (!AI) { try{ if(typeof window.showAiOutput === 'function'){ window.showAiOutput('SDK failed to load. Check network.'); } else { if(out) out.value = 'SDK failed to load. Check network.'; } }catch{}; return; }
                const client = new AI(key);
                const model = client.getGenerativeModel({ model: 'gemini-2.5-flash' });
                const prompt = `You are a concise tutor. Provide a compact, meaningful explanation of the student’s choice and evaluate each option.
Constraints:
- Keep the whole response brief (≈80–140 words). No fluff.
- Start with a one-line verdict: "Verdict: Correct." or "Verdict: Incorrect." (if incorrect, say which letter is correct).
- Then give 1–2 short sentences explaining the core concept.
- Then list every option (A., B., C., …): one short reason each; mark the correct one with "(correct)".
- End with a one-line takeaway.

Question: ${it.q}
Options:
${it.choices.map((c, i) => `${letters[i]}. ${c}`).join('\n')}
Student selected: ${letters[choiceIdx]}. ${it.choices[choiceIdx]}
Correct answer: ${letters[it.correctIdx]}. ${it.choices[it.correctIdx]}`;
                // Show immediate UI feedback (animated preferred)
                try{ if(typeof window.stopAiOutput === 'function'){ window.stopAiOutput(); } }catch{}
                // Capture the quiz index at the time of request so we can ignore late responses
                const _requestIdx = (typeof state.idx === 'number') ? state.idx : null;
                try{ if(typeof window.showAiOutput === 'function'){ window.showAiOutput('Analyzing with Gemini 2.5...'); } else { if(out) { out.value = 'Analyzing with Gemini 2.5...'; out.disabled = true; } } }catch{}
                // Capture the controller token created by showAiOutput (if any) so we only overwrite
                // the same output area when the original request is still active. Capture AFTER calling
                // showAiOutput so we get the actual controller instance created for this request.
                const _myAiController = window.__aiOutputController || null;
                // Snapshot the results-analysis request counter so that if an Analyze flow
                // or any other code increments the counter (via stopAiOutput or starting
                // an analysis), this per-question request will not write into the results
                // area. This protects against the observed rollover where a late per-question
                // response overwrote the Analyze output.
                const _resultsReqSnapshot = (window.__resultsAnalysisRequestCounter||0);
                // spinner visual removed for AI Explanation (use animated textbook output instead)
                const spin = null;
                try {
                    const resp = await model.generateContent({ contents: [{ role: 'user', parts: [{ text: prompt }] }] });
                    const text = await resp?.response?.text?.();
                    const final = (text || '').trim() || 'No explanation returned.';
                    // Before writing, ensure the user is still on the same question and
                    // that no newer Gemini request has replaced the global controller.
                    try{
                        const stillOnQuestion = (_requestIdx === null) || (typeof state.idx === 'number' && state.idx === _requestIdx);
                        const globalCtrl = window.__aiOutputController;
                        // Allow write when still on question and either this request's controller
                        // is the global one, or there's no active global controller (null/undefined).
                        const canWriteAnimated = (globalCtrl === _myAiController) || (globalCtrl == null);
                        if(!stillOnQuestion){
                            console.log('Gemini response ignored: question changed since request');
                        } else if(window.__resultsAnalysisRequestCounter !== _resultsReqSnapshot){
                            console.log('Gemini per-question response ignored: newer results/stop occurred');
                        } else if(typeof window.showAiOutput === 'function'){
                            if(canWriteAnimated){
                                window.showAiOutput(final);
                            } else {
                                // Fallback: if animated output can't be written, try legacy textarea
                                if(out) out.value = final; else console.log('Gemini response skipped: newer request active');
                            }
                        } else if(out){ out.value = final; }
                    }catch(e){ if(out) out.value = final; }
                } catch (e) {
                    console.error('Gemini request error', e);
                    const raw = (e?.message || String(e || '')).toString();
                    // Detect invalid API key error and provide actionable guidance
                    if (/API_KEY_INVALID|API key not valid/i.test(raw)){
                        // mask key preview
                        let preview = '<no key provided>';
                        try{ if(key && key.length){ preview = key.length>8 ? (key.slice(0,4) + '…' + key.slice(-4)) : ('*'.repeat(Math.max(4,key.length))); } }catch{}
                        const msg = `Gemini request failed: API key invalid.\nKey preview: ${preview}\n\nFixes to try:\n1) Confirm the global API key at the top of the page is correct. (Open devtools and run: document.getElementById('globalGemKey').value)\n2) In Google Cloud Console, enable the Generative Language API (generativelanguage.googleapis.com) and ensure billing is enabled for your project.\n3) Check API key restrictions: if the key is restricted by HTTP referrers or IPs, either remove restrictions for testing or add this origin (for local files consider running a localhost server).\n4) If issues persist, create a new API key and try again.\n`;
                        try{
                            const stillOnQuestion = (_requestIdx === null) || (typeof state.idx === 'number' && state.idx === _requestIdx);
                            const globalCtrl = window.__aiOutputController;
                            const canWriteAnimated = (globalCtrl === _myAiController) || (globalCtrl == null);
                            if(stillOnQuestion){
                                if(window.__resultsAnalysisRequestCounter !== _resultsReqSnapshot){
                                    console.log('Gemini per-question error ignored due to newer results/stop');
                                } else if(typeof window.showAiOutput === 'function'){
                                    if(canWriteAnimated){ window.showAiOutput(msg); }
                                    else { console.log('Gemini error skipped: newer request active'); }
                                } else if(out){ out.value = msg; }
                            } else { console.log('Gemini error ignored: question changed'); }
                        }catch{}
                    } else {
                        const msg = 'Gemini request failed: ' + raw;
                        try{
                            const stillOnQuestion = (_requestIdx === null) || (window.state && state.idx === _requestIdx);
                            const globalCtrl = window.__aiOutputController;
                            const canWriteAnimated = (globalCtrl === _myAiController) || (globalCtrl == null);
                            if(stillOnQuestion){
                                if(window.__resultsAnalysisRequestCounter !== _resultsReqSnapshot){
                                    console.log('Gemini per-question error ignored due to newer results/stop');
                                } else if(typeof window.showAiOutput === 'function'){ if(canWriteAnimated){ window.showAiOutput(msg); } else { console.log('Gemini error skipped: newer request active'); } } else if(out){ out.value = msg; }
                            }
                            else { console.log('Gemini error ignored: question changed'); }
                        }catch{}
                    }
                } finally {
                    try{
                        // Only re-enable the legacy textarea if the user is still on the same question
                        // and this request is still the latest one (or there is no active global controller).
                            const stillOnQuestion = (_requestIdx === null) || (typeof state.idx === 'number' && state.idx === _requestIdx);
                            const globalCtrl = window.__aiOutputController;
                            const isLatestOrNoGlobal = (globalCtrl === _myAiController) || (globalCtrl == null);
                        if(out && stillOnQuestion && isLatestOrNoGlobal && window.__resultsAnalysisRequestCounter === _resultsReqSnapshot){ out.disabled = false; }
                    }catch{}; if(spin) try{ spin.remove(); }catch{}
                }
            }

            /* ---------- Wire up ---------- */
            function doParse() {
                const text = $('paste').value || ''; state.items = parseDoc(text); state.order = state.items.map((_, i) => i);
                state.answered = {}; state.skipped.clear(); state.reviewPool = []; state.idx = 0; state.score = 0; state.mode = 'quiz'; state.started = false;
                // mark that the document has been parsed so UI hides (AI cards) only after parse
                try{ window.__parsed = true; }catch{}
                renderPreview(state.items); hideSkipped();
                // Enable Start Quiz only when there are parsed items
                try{ const sbtn = document.getElementById('startBtn'); if(sbtn) sbtn.disabled = !(state.items && state.items.length); }catch(e){}
                // Overwrite Flashcards deck via global setter (avoids scope/timing issues)
                try{ if(typeof window.fcSetDeckFromItems === 'function'){ window.fcSetDeckFromItems(state.items || []); } }catch(e){ console.warn('fcSetDeckFromItems call failed', e); }
            }
            // Ensure Start Quiz is disabled until a successful parse
            try{ const sbtnInit = document.getElementById('startBtn'); if(sbtnInit) sbtnInit.disabled = true; }catch(e){}
            $('parseBtn').onclick = doParse;

        // Keyboard shortcuts: answer selection, submit/next, skip
        (function(){
            function isTypingInInput(){
                const el = document.activeElement;
                if(!el) return false;
                const tag = (el.tagName||'').toLowerCase();
                if(tag === 'input' || tag === 'textarea' || tag === 'select') return true;
                if(el.isContentEditable) return true;
                return false;
            }

            function handleKey(e){
                try{
                    // If the mini-quiz modal is visible, disable global shortcuts
                    try{ const mq = document.getElementById('miniQuizModal'); if(mq && !mq.classList.contains('hidden')) return; }catch{}
                    // If TOS lock is active, disable all keyboard shortcuts
                    try{ if(document.documentElement && document.documentElement.classList && document.documentElement.classList.contains('tos-locked')) return; }catch{}
                    // If a pre-quiz overlay is active, ignore shortcuts
                    if(window.__preQuizOverlayActive) return;
                    if(!state || !state.started) return; // only when quiz active
                    if(isTypingInInput()) return; // don't interfere with typing
                    // If user is holding a modifier (Ctrl/Cmd/Alt), let the browser handle
                    // the key (e.g., Ctrl+C for copy). Do not consume modifier combos here.
                    try{ if(e && (e.ctrlKey || e.metaKey || e.altKey)) return; }catch(_){}
                    const k = (e.key || '').toLowerCase();
                    // If the summary screen is showing review/restart buttons, map Enter/N -> Review Missed and R -> Restart
                    try{
                        // Back to Setup must not be triggered by shortcuts anymore; require pointer interaction only.
                        // Therefore, deliberately do not map Enter (or any key) to the Back to Setup action.

                        const reviewBtn = document.getElementById('reviewMissed');
                        const restartBtn = document.getElementById('restart');
                        // Handle review controls only when Review Missed is visible AND enabled
                        if(reviewBtn && reviewBtn.offsetParent !== null && !reviewBtn.disabled){
                            if(k === 'enter' || k === 'n'){
                                try{ reviewBtn.click(); e.preventDefault(); }catch(e){}
                                return;
                            }
                            if(k === 'r'){
                                if(restartBtn){ try{ restartBtn.click(); e.preventDefault(); }catch(e){} }
                                return;
                            }
                        }
                        // Fallback: even if Review Missed is disabled (e.g., 0 missed),
                        // honor the 'r' key when the Restart button is visible/enabled.
                        if(restartBtn && restartBtn.offsetParent !== null && !restartBtn.disabled){
                            if(k === 'r'){
                                try{ restartBtn.click(); e.preventDefault(); }catch(e){}
                                return;
                            }
                        }

                        // If the Keep Going / Continue screen is showing, pressing Enter should trigger Continue
                        const continueBtn = document.getElementById('continueReview');
                        if(continueBtn && continueBtn.offsetParent !== null){
                            if(k === 'enter'){
                                try{ continueBtn.click(); e.preventDefault(); }catch(e){}
                                return;
                            }
                        }

                        // If a Back button is present (e.g., Back navigation in quiz view), allow 'b' to activate it
                        const backBtn = document.getElementById('backBtn');
                        if(backBtn && backBtn.offsetParent !== null){
                            if(k === 'b'){
                                try{ if(!backBtn.disabled){ backBtn.click(); e.preventDefault(); } }catch(err){}
                                return;
                            }
                        }
                    }catch(e){}

                    // map 1-9 -> choice indices 0..8
                    if(/^[1-9]$/.test(k)){
                        const idx = parseInt(k,10) - 1;
                        const inputs = quiz.querySelectorAll('.choice input');
                        if(inputs && inputs[idx]){ inputs[idx].click(); e.preventDefault(); }
                        return;
                    }
                    // map letters a-f to choices
                    if(/^[a-f]$/.test(k)){
                        const idx = k.charCodeAt(0) - 'a'.charCodeAt(0);
                        const inputs = quiz.querySelectorAll('.choice input');
                        if(inputs && inputs[idx]){ inputs[idx].click(); e.preventDefault(); }
                        return;
                    }
                    // Enter: if current question already submitted -> next, else submit if selection exists
                    if(k === 'enter'){
                        const idx = activeIndex(); const rec = state.answered[idx];
                        const it = state.items[idx];
                        if(rec && rec.submitted){ e.preventDefault(); next(); return; }
                        // try to submit using recorded selection, or find checked input
                        const sel = rec && (rec.selected!=null) ? rec.selected : null;
                        if(sel!=null){ try{ doSubmit(it, idx); e.preventDefault(); }catch(e){} return; }
                        const checked = quiz.querySelector('.choice input:checked');
                        if(checked){ try{ checked.dispatchEvent(new Event('change', { bubbles:true })); e.preventDefault(); }catch(e){} return; }
                        return;
                    }
                    // Next (n)
                    if(k === 'n') { e.preventDefault(); next(); return; }
                    // Skip (s)
                    if(k === 's') { e.preventDefault(); skipCurrent(); return; }
                }catch(err){ console.warn('keyboard shortcut handler error', err); }
            }
            // Attach once
            try{ document.addEventListener('keydown', handleKey, { capture:false }); }catch(e){ document.addEventListener('keydown', handleKey); }
        })();

        // See All modal wiring
        (function(){
            const seeAllBtn = document.getElementById('seeAllBtn');
            const modal = document.getElementById('seeAllModal');
            const closeBtn = document.getElementById('seeAllClose');
            const content = document.getElementById('seeAllContent');
            function openModal(){
                try{
                    // populate content from quiz state
                    const items = (window.__quizState && window.__quizState.items) ? window.__quizState.items : (window.state && state.items) ? state.items : [];
                    if(!items || !items.length){
                        content.innerHTML = '<div class="hint">No parsed items yet. Parse your document first.</div>';
                    } else {
                        // Render concise question + lettered choices for each parsed item
                        const esc = s => String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;');
                        const letters = ['A','B','C','D','E','F','G','H'];
                        content.innerHTML = items.map((it, ix) => {
                            const num = it.num || (ix + 1);
                            const q = esc(it.q || it.text || '');
                            const choices = Array.isArray(it.choices) ? it.choices : [];
                            // determine correct index: prefer numeric correctIdx, else try to parse a key letter
                            let correctIdx = (typeof it.correctIdx === 'number' && isFinite(it.correctIdx)) ? it.correctIdx : null;
                            if(correctIdx === null && it.answer){
                                // allow 'A' or '1. A' etc.
                                const m = String(it.answer).match(/([A-F])/i);
                                if(m) correctIdx = 'ABCDEF'.indexOf(m[1].toUpperCase());
                            }
                            if(correctIdx === null && it.key){ const m = String(it.key).match(/([A-F])/i); if(m) correctIdx = 'ABCDEF'.indexOf(m[1].toUpperCase()); }
                            const choicesHtml = choices.map((c, i) => {
                                const cls = (correctIdx !== null && i === correctIdx) ? 'seeall-choice correct' : 'seeall-choice';
                                return `<div class="${cls}"><strong>${letters[i]||String(i+1)}.</strong> ${esc(c)}</div>`;
                            }).join('');
                            return `<div class="seeall-item">` +
                                `<div style="font-weight:700;margin-bottom:6px">Q${num}. ${q}</div>` +
                                `<div class="seeall-choices">${choicesHtml}</div>` +
                                `</div>`;
                        }).join('');
                    }
                    // disable page scroll while modal is open (robust across platforms)
                    try{
                        // save current scroll and inline styles so we can restore exactly
                        document.body.dataset._prevOverflow = document.body.style.overflow || '';
                        document.body.dataset._prevPosition = document.body.style.position || '';
                        document.body.dataset._prevTop = document.body.style.top || '';
                        const scrollY = window.scrollY || window.pageYOffset || 0;
                        document.body.dataset._scrollY = String(scrollY);
                        // lock by fixing body position which prevents mobile overscroll too
                        document.body.style.position = 'fixed';
                        document.body.style.top = `-${scrollY}px`;
                        document.body.style.left = '0';
                        document.body.style.right = '0';
                        document.body.style.overflow = 'hidden';
                    }catch(e){}
                    modal.classList.remove('hidden');
                }catch(e){ console.log('openModal failed', e); }
            }
            function closeModal(){ try{ modal.classList.add('hidden'); try{
                        // restore scroll and body styles
                        const prevOverflow = document.body.dataset._prevOverflow || '';
                        const prevPosition = document.body.dataset._prevPosition || '';
                        const prevTop = document.body.dataset._prevTop || '';
                        const scrollY = parseInt(document.body.dataset._scrollY || '0', 10) || 0;
                        document.body.style.overflow = prevOverflow;
                        document.body.style.position = prevPosition;
                        document.body.style.top = prevTop;
                        // remove temp dataset keys
                        delete document.body.dataset._prevOverflow; delete document.body.dataset._prevPosition; delete document.body.dataset._prevTop; delete document.body.dataset._scrollY;
                        // restore scroll position
                        window.scrollTo(0, scrollY);
                    }catch(e){} }catch(e){} }
            seeAllBtn?.addEventListener('click', openModal);
            closeBtn?.addEventListener('click', closeModal);
            // close on backdrop click (also restore scroll)
            modal?.addEventListener('click', (ev)=>{ if(ev.target === modal || ev.target.classList.contains('modal-backdrop')) closeModal(); });
        })();
            // Ensure bindings work even if the $ helper isn't in this scope
            try{ document.getElementById('beginFromPreview')?.addEventListener('click', startQuiz); }catch(e){}
            try{ document.getElementById('startBtn')?.addEventListener('click', startQuiz); }catch(e){}
            (function(){
                const btn = document.getElementById('sampleBtn');
                if(!btn) return;
                btn.addEventListener('click', function(){
                    try{
                        const paste = document.getElementById('paste');
                        if(paste) paste.value = `Q1. Why is protein purification essential in biochemistry?\n- It prevents oxidation of DNA\n- It allows isolation and study of specific proteins free from contaminants\n- It enables bacterial transformation\n- It increases cell growth rate\nQ2. Which of the following high-resolution methods requires highly purified protein samples?\n- Mass spectrometry\n- Chromatography\n- X-ray crystallography, NMR, or cryo-EM\n- Ultrafiltration\nANSWER KEY\n1. B\n2. C`;
                        // call the parsing routine if available
                        try{ if(typeof doParse === 'function') doParse(); else document.getElementById('parseBtn')?.click(); }catch(e){}
                    }catch(e){ console.warn('sampleBtn handler failed', e); }
                });
            })();
            $('file').addEventListener('change', async (e) => { const f = e.target.files[0]; if (!f) return; const txt = await f.text(); $('paste').value = normalizeGreek(txt); doParse(); });
            // show chosen filenames in styled wrappers
            $('file')?.addEventListener('change', (e)=>{ const f = e.target.files?.[0]; const name = f ? f.name : 'No file chosen'; const span = document.getElementById('fileNameTxt'); if(span) span.textContent = name; });
            $('aiFile')?.addEventListener('change', (e)=>{
                const files = Array.from(e.target.files||[]);
                const span = document.getElementById('aiFileName');
                if(!span){ return; }
                if(files.length === 0){ span.textContent = 'No file chosen'; }
                else if(files.length === 1){ span.textContent = files[0].name; }
                else { span.textContent = `${files.length} files selected`; }
            });

        })();
    </script>
    <script>
    /* === Saved MCQs: storage + UI wiring === */
    (function(){
        const LS_KEY = 'mcq.pastes.v1';
        const byId = (id)=> document.getElementById(id);
    const savedList = byId('savedList');
    const savedCount = byId('savedCount');
    const savedMenu = byId('savedMenu');
    const toggleBtn = byId('toggleSavedBtn');
        const refreshBtn = byId('refreshSavedBtn');
        const clearBtn = byId('clearSavedBtn');
        const indexBtn = byId('indexPasteBtn');
        const pasteEl = byId('paste');

        function loadAll(){ try{ return JSON.parse(localStorage.getItem(LS_KEY)||'[]'); }catch{ return []; } }
        function saveAll(arr){ try{ localStorage.setItem(LS_KEY, JSON.stringify(arr)); }catch(e){ alert('Could not save to local storage.'); } }
        function loadFolders(){ try{ return JSON.parse(localStorage.getItem(LS_KEY+':folders')||'[]'); }catch{ return []; } }
        function saveFolders(f){ try{ localStorage.setItem(LS_KEY+':folders', JSON.stringify(f)); }catch(e){ /* non-fatal */ } }
        function now(){ const d=new Date(); return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`; }
        function shortTitle(s){ s=s||''; return s.split('\n').map(l=>l.trim()).filter(Boolean)[0]||'Untitled'; }

    // helper: safe filename
    function sanitizeFilenameLocal(s){ try{ return String(s||'untitled').replace(/[\\/:*?"<>|\x00-\x1F]/g,'_').replace(/\s+/g,' ').trim().slice(0,180); }catch(e){ return 'untitled'; } }

    // helper: ensure JSZip for bulk export of local saved MCQs
    async function loadJSZip(){ if(window.JSZip) return window.JSZip; try{ await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js'; s.onload=res; s.onerror=rej; document.head.appendChild(s); }); return window.JSZip; }catch(e){ console.warn('Failed to load JSZip', e); throw e; } }

        function render(){
            if(!savedList||!savedCount) return;
            const arr = loadAll(); savedCount.textContent = String(arr.length);
            let folders = loadFolders();
            // Sort folders by lastSelected (most recent first), falling back to creation date if needed
            try{
                folders = folders.slice().sort((a,b)=>{
                    const at = a.lastSelected || a.createdAt || 0;
                    const bt = b.lastSelected || b.createdAt || 0;
                    return bt - at;
                });
            }catch(e){}
            // compute total bytes across saved items
            try{
                const totalBytes = arr.reduce((acc,it)=>{
                    try{ if(it && it.text) return acc + (it.text.length||0); }catch(e){}
                    return acc;
                },0);
                const elTotal = document.getElementById('savedTotalKb'); if(elTotal) elTotal.textContent = `Total: ${(totalBytes/1024).toFixed(1)} KB`;
            }catch(e){}
            if(!arr.length && !folders.length){ savedList.innerHTML = '<div class="hint">No saved items yet. Use "Save MCQ" to save your paste.</div>'; return; }

                // Before rendering folders, normalize their item lists against existing saved MCQs
                try{
                    const validIds = new Set(arr.map(it=>it.id));
                    let changedFolders = false;
                    folders.forEach(f=>{
                        if(Array.isArray(f.items)){
                            const filtered = f.items.filter(id=>validIds.has(id));
                            if(filtered.length !== f.items.length){
                                f.items = filtered;
                                changedFolders = true;
                            }
                        }
                    });
                    if(changedFolders) saveFolders(folders);
                }catch(e){}

                const folderHtml = folders.map((f, idx)=>{
                    const safeName = (f.name||'Folder').replace(/&/g,'&amp;').replace(/</g,'&lt;');
                    const itemCount = Array.isArray(f.items) ? f.items.length : 0;
                    const created = f.createdAt ? new Date(f.createdAt) : null;
                    const createdStr = created && !isNaN(created.getTime())
                        ? `${created.getFullYear()}-${String(created.getMonth()+1).padStart(2,'0')}-${String(created.getDate()).padStart(2,'0')}`
                        : '';
                    return `<div class="saved-item saved-folder" data-folder-id="${(f.id||'f'+idx).replace(/"/g,'')}">
                        <div class="si-main">
                            <div class="si-title"><span class="si-folder-name" contenteditable="true" spellcheck="false">${safeName}</span><span class="si-qcount" style="margin-left:8px;color:var(--muted);font-size:12px">· ${itemCount} set${itemCount===1?'':'s'}</span></div>
                            <div class="si-meta">Created: ${createdStr || 'n/a'}</div>
                        </div>
                        <div class="si-actions">
                            <button class="btn small" data-act="folder-assign">Assign</button>
                            <button class="btn small" data-act="folder-delete">Delete</button>
                        </div>
                    </div>`;
                }).join('');

                const itemsHtml = arr.map((it, i)=>{
                    // Determine number of questions in this saved MCQ text. Prefer parseDoc if available.
                    let qCount = 0;
                    try{
                        if(typeof parseDoc === 'function'){
                            const parsed = parseDoc(it.text || ''); qCount = (parsed && parsed.length) ? parsed.length : 0;
                        } else if(it.text){ const m = String(it.text).match(/^\s*Q\s*\d+\./gim); qCount = m ? m.length : 0; }
                    }catch(e){ qCount = 0; }
                    const safeTitle = (it.title||'Untitled').replace(/&/g,'&amp;').replace(/</g,'&lt;');
                    const date = it.date || '';
                    const hasRefs = !!(it.meta && it.meta.sourceHints && typeof it.meta.sourceHints === 'object' && Object.keys(it.meta.sourceHints).length);
                    const qcountHtml = `<span class="si-qcount" style="margin-left:8px;color:var(--muted);font-size:12px">· ${qCount} Q</span>`;
                    return `<div class="saved-item" data-i="${i}" data-id="${(it.id||'').replace(/"/g,'')}">
                        <div class="si-main">
                                <div class="si-title"><span class="si-title-text" contenteditable="true" spellcheck="false">${safeTitle}</span>${qcountHtml}</div>
                                <div class="si-meta">${date}${hasRefs ? ' · ✔ refs' : ' · ✖ no refs'}</div>
                            </div>
                            <div class="si-actions">
                                <button class="btn small" data-act="export">Export</button>
                                <button class="btn small" data-act="delete">Delete</button>
                            </div>
                    </div>`;
                }).join('');

                savedList.innerHTML = folderHtml + itemsHtml + `<div class="saved-item saved-folder-footer"><button class="btn small" id="addFolderBtn">+ Folder</button></div>`;

            // Wire folder rows
            const foldersNow = loadFolders();
            savedList.querySelectorAll('.saved-folder').forEach(el=>{
                const fid = el.getAttribute('data-folder-id');
                const nameEl = el.querySelector('.si-folder-name');
                function commitFolderName(newName){
                    const fs = loadFolders(); const f = fs.find(x=>String(x.id)===String(fid)); if(!f) return;
                    const t = String(newName||'').replace(/[\r\n]+/g,' ').trim() || 'Folder';
                    f.name = t; saveFolders(fs); render();
                }
                nameEl && nameEl.addEventListener('keydown', (e)=>{
                    if(e.key==='Enter') { e.preventDefault(); nameEl.blur(); }
                    else if(e.key==='Escape'){ e.preventDefault(); const fs = loadFolders(); const f = fs.find(x=>String(x.id)===String(fid)); if(f){ nameEl.textContent = f.name || 'Folder'; } nameEl.blur(); }
                    e.stopPropagation();
                });
                nameEl && nameEl.addEventListener('blur', ()=>{ commitFolderName(nameEl.textContent||''); });

                el.addEventListener('click', (e)=>{
                    const fs = loadFolders(); const f = fs.find(x=>String(x.id)===String(fid)); if(!f) return;
                    const btn = (e.target && e.target.closest) ? e.target.closest('[data-act]') : null;
                    if(btn){
                        const act = btn.getAttribute('data-act');
                        if(act==='folder-delete'){
                            if(confirm('Delete this folder (MCQ sets remain)?')){
                                const j = fs.findIndex(x=>String(x.id)===String(fid)); if(j>=0){ fs.splice(j,1); saveFolders(fs); render(); }
                            }
                        } else if(act==='folder-assign'){
                            // Build a small inline selector listing all saved sets for quick assignment
                            const list = loadAll();
                            if(!list.length){ alert('No saved MCQs to assign.'); return; }
                            const existing = new Set(Array.isArray(f.items)?f.items:[]);
                            const choices = list.map((it, idx)=>{
                                const mark = existing.has(it.id) ? '✓' : ' ';
                                return `${idx+1}. [${mark}] ${(it.title||'Untitled')}`;
                            }).join('\n');
                            const input = prompt(`Assign saved set to folder "${f.name||'Folder'}".\nEnter number to toggle membership; separate multiple with commas.\n(Current: ✓ = in folder)\n\n${choices}`);
                            if(input==null) return;
                            const partsSel = String(input).split(/[,\s]+/).map(s=>parseInt(s,10)).filter(n=>n>=1 && n<=list.length);
                            if(!partsSel.length) return;
                            f.items = Array.isArray(f.items)?f.items:[];
                            const setItems = new Set(f.items);
                            partsSel.forEach(n=>{
                                const it = list[n-1]; if(!it || !it.id) return;
                                if(setItems.has(it.id)) setItems.delete(it.id); else setItems.add(it.id);
                            });
                            f.items = Array.from(setItems);
                            saveFolders(fs); render();
                        }
                    } else {
                        // click on folder body -> toggle this folder as current filter
                        const fs2 = loadFolders();
                        const f2 = fs2.find(x=>String(x.id)===String(fid));
                        if(!f2) return;
                        const wasActive = el.classList.contains('active-folder');
                        // bump lastSelected for MRU sort and persist
                        try{ f2.lastSelected = Date.now(); saveFolders(fs2); }catch(e){}

                        // Re-render so folders are re-sorted by lastSelected
                        render();

                        // After re-render, re-find the list and apply filter state
                        const newList = document.getElementById('savedList');
                        if(!newList) return;
                        const folderNodes = newList.querySelectorAll('.saved-folder');
                        const itemNodes = newList.querySelectorAll('.saved-item[data-i]');

                        if(wasActive){
                            // second click on same folder: clear filter and show everything
                            folderNodes.forEach(n=>{
                                n.classList.remove('active-folder');
                                n.style.display = '';
                            });
                            itemNodes.forEach(node=>{ node.style.display = ''; });
                        } else {
                            // first click: activate this folder and filter to its items
                            const currentFolderEl = Array.from(folderNodes).find(n=>n.getAttribute('data-folder-id') === String(fid));
                            const idSet = new Set((f2.items||[]));

                            folderNodes.forEach(n=>{
                                if(n === currentFolderEl){
                                    n.classList.add('active-folder');
                                    n.style.display = '';
                                } else {
                                    n.classList.remove('active-folder');
                                    n.style.display = 'none';
                                }
                            });

                            itemNodes.forEach(node=>{
                                const idx2 = Number(node.getAttribute('data-i'));
                                const it2 = arr[idx2];
                                if(!it2 || !it2.id){ node.style.display = 'none'; return; }
                                node.style.display = idSet.has(it2.id) ? '' : 'none';
                            });
                        }
                    }
                    e.preventDefault(); e.stopPropagation();
                });
            });

            const addFolderBtn = document.getElementById('addFolderBtn');
            if(addFolderBtn){
                addFolderBtn.onclick = ()=>{
                    const name = prompt('Folder name:') || 'Folder';
                    const fs = loadFolders();
                    const nowTs = Date.now();
                    fs.push({ id: nowTs.toString(36)+Math.random().toString(36).slice(2,6), name, items: [], createdAt: nowTs, lastSelected: nowTs });
                    saveFolders(fs); render();
                };
            }

            // Wire saved MCQ item rows
            savedList.querySelectorAll('.saved-item[data-i]').forEach(el=>{
                // Inline title editing (editable span only)
                const titleEl = el.querySelector('.si-title-text');
                const idx = Number(el.getAttribute('data-i'));
                function commitTitle(newTitle){
                    const arr2 = loadAll(); const itm = arr2[idx]; if(!itm) return;
                    // Sanitize and default
                    const t = String(newTitle || '').replace(/[\r\n]+/g,' ').trim() || 'Untitled';
                    itm.title = t; saveAll(arr2);
                    // Re-render to ensure consistency and to escape HTML
                    render();
                }
                titleEl && titleEl.addEventListener('keydown', (e)=>{
                    if(e.key==='Enter'){
                        e.preventDefault(); titleEl.blur();
                    } else if(e.key==='Escape'){
                        e.preventDefault();
                        const arr2 = loadAll(); const itm = arr2[idx]; if(itm){ titleEl.textContent = itm.title || 'Untitled'; }
                        titleEl.blur();
                    }
                    e.stopPropagation();
                });
                titleEl && titleEl.addEventListener('blur', ()=>{ commitTitle(titleEl.textContent||''); });

                // Item click actions: clicking the main area loads/pastes the item; buttons (delete) remain functional
                el.addEventListener('click', (e)=>{
                    const i = Number(el.getAttribute('data-i'));
                    const idAttr = el.getAttribute('data-id');
                    const arr = loadAll();
                    const item = idAttr ? arr.find(x=>String(x.id)===String(idAttr)) : arr[i];
                    if(!item) return;
                    const btn = (e.target && e.target.closest) ? e.target.closest('[data-act]') : null;
                    if(btn){
                        const act = btn.getAttribute('data-act');
                        if(act==='delete'){
                            if(confirm('Delete this saved MCQ set?')){
                                let removed = null;
                                const arr2 = loadAll();
                                let deletedId = null;
                                if(idAttr){
                                    const idx2 = arr2.findIndex(x=>String(x.id)===String(idAttr));
                                    if(idx2>=0){
                                        removed = arr2.splice(idx2,1)[0];
                                        deletedId = removed && removed.id;
                                    }
                                } else {
                                    removed = arr2.splice(i,1)[0];
                                    deletedId = removed && removed.id;
                                }
                                saveAll(arr2);

                                // Also prune this MCQ id from any folders' item lists so set counts stay accurate
                                try{
                                    if(deletedId){
                                        const fs = loadFolders();
                                        let changed = false;
                                        fs.forEach(f=>{
                                            if(Array.isArray(f.items) && f.items.includes(deletedId)){
                                                f.items = f.items.filter(x=>x!==deletedId);
                                                changed = true;
                                            }
                                        });
                                        if(changed) saveFolders(fs);
                                    }
                                }catch(e){ console.warn('folder prune failed', e); }
                                // If the deleted item was the one currently providing source hints, clear them
                                try{
                                    if(removed && removed.meta && removed.meta.sourceHints && window.__aiMcqSourceHints === removed.meta.sourceHints){
                                        window.__aiMcqSourceHints = undefined;
                                    }
                                }catch(e){}
                                render();
                            }
                        } else if(act==='export'){
                            try{
                                const item = idAttr ? arr.find(x=>String(x.id)===String(idAttr)) : arr[i]; if(!item) return;
                                const text = item.text || '';
                                const filename = sanitizeFilenameLocal((item.title||shortTitle(text))) + '.txt';
                                const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
                                const a = document.createElement('a'); const url = URL.createObjectURL(blob); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); try{ a.remove(); }catch{} }, 3000);
                            }catch(e){ console.error('export failed', e); alert('Export failed: ' + (e?.message||e)); }
                        }
                    } else {
                        // if click happened inside the editable title, allow editing (do not load)
                        if(e.target && e.target.closest && e.target.closest('.si-title')){
                            // let the click focus the editable title
                            return;
                        }
                        // Move the clicked item to the front (most-recently-used)
                        try{
                            // remove the item at index i and unshift it to front
                            arr.splice(i, 1);
                            arr.unshift(item);
                            saveAll(arr);
                            // re-render on next tick to avoid re-entrancy while iterating
                            setTimeout(render, 0);
                        }catch(e){ console.warn('Could not bump saved item to front', e); }

                        // perform load/paste; restore any saved per-question source hints before parsing
                        if(pasteEl){
                            pasteEl.value = item.text||'';
                            try{
                                // Reset global hints so they are always scoped to this load
                                window.__aiMcqSourceHints = undefined;
                                if(item.meta && item.meta.sourceHints && typeof item.meta.sourceHints === 'object'){
                                    window.__aiMcqSourceHints = item.meta.sourceHints;
                                }
                            }catch(e){}
                            try{ document.getElementById('parseBtn')?.click(); }catch{}
                        }
                        try{ window.scrollTo({ top: document.getElementById('setup').offsetTop, behavior: 'smooth' }); }catch(e){}
                    }
                    e.preventDefault(); e.stopPropagation();
                });

                // Tagging removed for Phase 1
            });
        }

        // --- Expose helpers for quiz-tag exports ---
        try{
            window.__copyTaggedToClipboard = function(){
                try{
                    const st = window.__quizState;
                    if(!st || !st.items || !st.items.length || !st.tags || !st.tags.size){ alert('No tagged questions in this session.'); return; }
                    const parts = [];
                    const keyLines = [];
                    const letters = ['A','B','C','D','E','F','G'];
                    Array.from(st.tags).sort((a,b)=>a-b).forEach(idx=>{
                        const it = st.items[idx]; if(!it) return;
                        const qNum = it.num || (idx+1);
                        parts.push(`Q${qNum}. ${it.q||''}`);
                        if(Array.isArray(it.choices)){
                            it.choices.forEach((c)=>{ parts.push(`- ${c}`); });
                        }
                        if(typeof it.correctIdx === 'number' && it.correctIdx >= 0){
                            const letter = letters[it.correctIdx] || String(it.correctIdx + 1);
                            keyLines.push(`${qNum}. ${letter}`);
                        }
                        parts.push('');
                    });

                    if(keyLines.length){
                        parts.push('ANSWER KEY');
                        keyLines.forEach(l=>parts.push(l));
                    }

                    const text = parts.join('\n');
                    if(!text.trim()){ alert('Tagged questions are empty.'); return; }
                    if(navigator.clipboard && navigator.clipboard.writeText){ navigator.clipboard.writeText(text).then(()=>{ alert('Tagged questions copied to clipboard.'); }).catch(()=>{ fallbackCopy(text); }); }
                    else{ fallbackCopy(text); }

                    function fallbackCopy(t){
                        try{
                            const ta = document.createElement('textarea');
                            ta.value = t; ta.style.position='fixed'; ta.style.left='-9999px'; document.body.appendChild(ta); ta.select();
                            document.execCommand('copy');
                            document.body.removeChild(ta);
                            alert('Tagged questions copied to clipboard.');
                        }catch(e){ alert('Could not copy tagged questions.'); }
                    }
                }catch(e){ console.error('copy tagged failed', e); alert('Copy tagged failed.'); }
            };

            window.__exportTaggedToSavedMcqs = function(){
                try{
                    const st = window.__quizState;
                    if(!st || !st.items || !st.items.length || !st.tags || !st.tags.size){ alert('No tagged questions in this session.'); return; }
                    const parts = [];
                    const keyLines = [];
                    const letters = ['A','B','C','D','E','F','G'];
                    Array.from(st.tags).sort((a,b)=>a-b).forEach(idx=>{
                        const it = st.items[idx]; if(!it) return;
                        const qNum = it.num || (idx+1);
                        parts.push(`Q${qNum}. ${it.q||''}`);
                        if(Array.isArray(it.choices)){
                            it.choices.forEach((c,i)=>{
                                const isCorrect = (typeof it.correctIdx==='number' && i===it.correctIdx);
                                const mark = isCorrect ? ' *' : '';
                                parts.push(`- ${c}${mark}`);
                            });
                        }
                        if(typeof it.correctIdx === 'number' && it.correctIdx >= 0){
                            const letter = letters[it.correctIdx] || String(it.correctIdx + 1);
                            keyLines.push(`${qNum}. ${letter}`);
                        }
                        parts.push('');
                    });

                    if(keyLines.length){
                        parts.push('ANSWER KEY');
                        keyLines.forEach(l=>parts.push(l));
                    }

                    const text = parts.join('\n');
                    if(!text.trim()){ alert('Tagged questions are empty.'); return; }

                    const d = new Date();
                    const ts = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
                    const rec = { id: Date.now().toString(36), title: `Tagged Questions ${ts}`, text, date: ts };
                    const arr = loadAll();
                    arr.unshift(rec);
                    saveAll(arr);
                    try{ render(); }catch(e){}
                    alert('Tagged questions saved into Saved MCQs.');
                }catch(e){ console.error('export tagged failed', e); alert('Save tagged failed.'); }
            };
        }catch(e){}

        indexBtn && indexBtn.addEventListener('click', ()=>{
            const txt = (pasteEl && pasteEl.value)||''; if(!txt.trim()){ alert('Paste your questions first.'); return; }
            const arr = loadAll();
            arr.unshift({ id: Date.now().toString(36), date: now(), title: shortTitle(txt), text: txt });
            saveAll(arr); render();
            indexBtn.classList.add('saved'); indexBtn.textContent = 'Saved';
            setTimeout(()=>{ indexBtn.classList.remove('saved'); indexBtn.textContent = 'Save MCQ'; }, 1800);
        });

        // Positioning + portal helpers
        const savedCard = byId('savedMcqs');
        let portalPlaceholder = null;
        function ensurePortaled(){
            if(!savedMenu) return;
            if(savedMenu.parentNode === document.body) return;
            try{
                portalPlaceholder = document.createComment('saved-menu-portal');
                savedMenu.parentNode.insertBefore(portalPlaceholder, savedMenu);
                document.body.appendChild(savedMenu);
            }catch{}
        }
        function restorePortal(){
            try{
                if(portalPlaceholder && portalPlaceholder.parentNode){
                    portalPlaceholder.parentNode.insertBefore(savedMenu, portalPlaceholder);
                    portalPlaceholder.remove();
                }else if(savedCard){
                    savedCard.appendChild(savedMenu);
                }
            }catch{}
        }
        function positionSavedMenu(){
            try{
                if(!savedMenu.classList.contains('open')) return;
                // Match the width and left edge of the parent card
                const parentEl = (byId('savedMcqs') || toggleBtn);
                const parentRect = parentEl.getBoundingClientRect();
                // Use the bottom of the parent card so the dropdown clearly separates from the card
                const margin = 12; // visible separation between card and dropdown
                const menuW = Math.ceil(parentRect.width);
                // Use viewport coordinates (parentRect is relative to the viewport) and place
                // the menu using fixed positioning so it escapes ancestor clipping/stacks.
                // Do NOT add scroll offsets here because position:fixed expects viewport coords.
                const top = Math.round(parentRect.bottom + margin);
                let left = Math.round(parentRect.left);
                const maxLeft = Math.max(0, window.innerWidth - menuW - 8);
                if(left > maxLeft) left = maxLeft;
                savedMenu.style.top = top + 'px';
                savedMenu.style.left = left + 'px';
                savedMenu.style.width = menuW + 'px';
            }catch{}
        }
        let onScrollOrResize = null;
        function bindReposition(){
            if(onScrollOrResize) return;
            onScrollOrResize = ()=> positionSavedMenu();
            // On scroll/resize, recompute absolute page coordinates
            window.addEventListener('scroll', onScrollOrResize, true);
            window.addEventListener('resize', onScrollOrResize);
        }
        function unbindReposition(){
            if(!onScrollOrResize) return;
            window.removeEventListener('scroll', onScrollOrResize, true);
            window.removeEventListener('resize', onScrollOrResize);
            onScrollOrResize = null;
        }

        toggleBtn && toggleBtn.addEventListener('click', ()=>{
            const opening = !savedMenu.classList.contains('open');
            if(opening){
                ensurePortaled();
                // Refresh the dropdown contents each time it is shown so it reflects latest saves/deletes
                try{ renderResults(); }catch(e){}
            }
            const open = savedMenu.classList.toggle('open');
            toggleBtn.textContent = open ? 'Hide' : 'Show';
            toggleBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
            if(open){ positionSavedMenu(); bindReposition(); }
            else { unbindReposition(); restorePortal(); }
        });
        // Close on outside click or Escape
        document.addEventListener('mousedown', (e)=>{
            try{
                if(!savedMenu.classList.contains('open')) return;
                if(e.target.closest('#savedMenu') || e.target.closest('#toggleSavedBtn')) return;
                savedMenu.classList.remove('open');
                toggleBtn.textContent = 'Show';
                toggleBtn.setAttribute('aria-expanded', 'false');
                unbindReposition();
                restorePortal();
            }catch{}
        });
        document.addEventListener('keydown', (e)=>{
            if(e.key === 'Escape' && savedMenu.classList.contains('open')){
                savedMenu.classList.remove('open');
                toggleBtn.textContent = 'Show';
                toggleBtn.setAttribute('aria-expanded', 'false');
                unbindReposition();
                restorePortal();
            }
        });
        refreshBtn && refreshBtn.addEventListener('click', render);
        clearBtn && clearBtn.addEventListener('click', ()=>{ if(confirm('Clear all saved MCQ sets?')){ saveAll([]); render(); } });

    // initial render
    render();
    // Expose a simple refresh function for other modules (e.g., AI preview save) so
    // they can refresh the saved MCQ list without relying on a DOM button that
    // may not exist in some builds.
    try{ window.refreshLocalSaved = render; }catch(e){}

        // Bulk export for localStorage saved MCQs (zips each saved item into .txt files)
        async function exportAllLocalSaved(){ try{
            const btn = document.getElementById('exportAllSavedBtn'); if(btn){ btn.disabled = true; const old = btn.textContent; btn.textContent = 'Preparing…'; }
            const items = loadAll(); if(!items || !items.length){ alert('No saved MCQs to export.'); if(btn){ btn.disabled=false; btn.textContent = 'Export all'; } return; }
            // ensure JSZip
            await loadJSZip(); const zip = new window.JSZip();
            for(let i=0;i<items.length;i++){
                try{
                    const it = items[i]; const title = it.title || (`saved-${i+1}`);
                    const fname = sanitizeFilenameLocal(title) + '.txt';
                    const content = String(it.text || it.payload || '');
                    zip.file(fname, content);
                }catch(e){ console.warn('skipping item during zip', e); }
            }
            const blob = await zip.generateAsync({ type: 'blob' });
            const zipName = `saved-mcqs-${(new Date()).toISOString().replace(/[:.]/g,'-')}.zip`;
            const a = document.createElement('a'); const url = URL.createObjectURL(blob); a.href = url; a.download = zipName; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); try{ a.remove(); }catch{} }, 5000);
            if(btn){ btn.disabled=false; btn.textContent = 'Export all'; }
        }catch(e){ console.error('exportAllLocalSaved failed', e); alert('Export all failed: ' + (e?.message||e)); try{ const b = document.getElementById('exportAllSavedBtn'); if(b){ b.disabled=false; b.textContent='Export all'; } }catch{} }
        }
        // Expose and ensure binding: attach a delegated click handler so the button works
        try{
            window.exportAllLocalSaved = exportAllLocalSaved;
            if(!window.__exportAllSavedDelegatedBound){
                document.addEventListener('click', function(e){
                    try{
                        const t = e.target && e.target.closest ? e.target.closest('#exportAllSavedBtn') : null;
                        if(!t) return;
                        e.preventDefault(); if(t.disabled) return; window.exportAllLocalSaved && window.exportAllLocalSaved();
                    }catch(err){}
                });
                window.__exportAllSavedDelegatedBound = true;
            }
        }catch(e){}
    })();
    /* === end Saved MCQs === */
    </script>
    <script>
    /* === Saved Quiz Results: storage + UI wiring === */
    (function(){
        const LS_KEY_RESULTS = 'quiz.results.v1';
        const LS_KEY_LAST = 'quiz.lastAttempt.v1';
        const byId = (id)=> document.getElementById(id);
        const savedList = byId('savedQuizList');
        const savedCount = byId('savedQuizCount');
        const savedMenu = byId('savedQuizMenu');
        const toggleBtn = byId('toggleSavedQuizBtn');
        const clearBtn = byId('clearSavedQuizBtn');
        const compileBtn = byId('compileMissedBtn');

        function loadAllResults(){ try{ return JSON.parse(localStorage.getItem(LS_KEY_RESULTS)||'[]'); }catch{ return []; } }
        function saveAllResults(arr){ try{ localStorage.setItem(LS_KEY_RESULTS, JSON.stringify(arr)); }catch(e){ alert('Could not save results to local storage.'); } }
        function now(){ const d=new Date(); return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`; }
        
        // Helper: persist a snapshot as the "last attempted" quiz
        function setLastAttemptFromState(customTitle){
            try{
                const state = window.__quizState;
                if(!state || !state.items || !state.items.length) return;
                const d = now();
                const title = customTitle || `Last attempt`;
                const skippedArr = Array.from(state.skipped || []);
                const qCount = Array.isArray(state.items) ? state.items.length : 0;
                // attempts/time formatting mirrors saved results subtext
                let attemptsCount = 1;
                let durationMs = 0;
                if (state.attempts && Array.isArray(state.attempts) && state.attempts.length > 0) {
                    attemptsCount = state.attempts.length;
                    durationMs = state.attempts.reduce((acc, att) => acc + (att.durationMs || 0), 0);
                } else if (state.quizEndTime && state.quizStartTime) {
                    durationMs = state.quizEndTime - state.quizStartTime;
                }
                const seconds = Math.floor(durationMs / 1000);
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                const timeStr = `${m}:${s.toString().padStart(2, '0')}`;
                const meta = `${d} 