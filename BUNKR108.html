<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>AI Quizzer WebApp</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
        <!-- Best-effort CSP for a static, client-only app.
            Note: this project uses inline scripts and some CDN imports. -->
        <meta http-equiv="Content-Security-Policy" content="default-src 'self' https: data: blob:; base-uri 'self'; object-src 'none'; form-action 'self'; frame-ancestors 'none'; img-src 'self' https: data: blob:; media-src 'self' https: blob:; font-src 'self' https: data:; style-src 'self' https: 'unsafe-inline'; script-src 'self' https: 'unsafe-inline' 'unsafe-eval' blob:; connect-src 'self' https:;" />
    <script>
        // Minimal fallback so code can call normalizeGreek() early.
        // The real implementation (if defined later) can overwrite this.
        (function(){
            try{
                if(!window.normalizeGreek){
                    window.normalizeGreek = function(s){ return s; };
                }
            }catch(e){}
        })();
    </script>
    <script>
            (function(){
                // KaTeX dynamic loader + safe render wrapper. Usage: window.renderMathIn(element, opts)
                if(window.renderMathIn) return;

                window.__katexReady = false;
                window.__katexQueue = [];
                window.__katexLoading = null;

                function loadScript(url){
                    return new Promise((resolve, reject)=>{
                        try{
                            const s = document.createElement('script');
                            s.src = url; s.async = true;
                            s.onload = ()=>resolve();
                            s.onerror = ()=>reject(new Error('Failed to load ' + url));
                            document.head.appendChild(s);
                        }catch(e){ reject(e); }
                    });
                }

                function looksLikeMathBetweenDollar(s){
                    try{
                        if(!s || typeof s !== 'string') return false;
                        if(/\\[a-zA-Z]+/.test(s)) return true;
                        if(/[=+\-\^_{}<>\/]/.test(s)) return true;
                        if(/[0-9].*[a-zA-Z]|[a-zA-Z].*[0-9]/.test(s)) return true;
                        return false;
                    }catch(e){ return false; }
                }

                function renderInto(el, opts){
                    try{
                        if(!el || !window.renderMathInElement) return;
                        const baseDelims = [
                            { left: '$$', right: '$$', display: true },
                            { left: '\\[', right: '\\]', display: true },
                            { left: '\\(', right: '\\)', display: false }
                        ];
                        let delims = baseDelims.slice();
                        let useDollar = false;
                        try{
                            const text = (el.textContent || el.innerText || '');
                            const re = /\$(.+?)\$/gs;
                            let m;
                            while((m = re.exec(text)) !== null){
                                if(looksLikeMathBetweenDollar(m[1])){ useDollar = true; break; }
                            }
                        }catch(e){}
                        if(useDollar) delims = delims.concat([{ left: '$', right: '$', display: false }]);
                        const options = Object.assign({ delimiters: delims, throwOnError: false }, (opts || {}));
                        window.renderMathInElement(el, options);
                    }catch(e){ try{ console.warn('KaTeX render failed', e); }catch(_){} }
                }

                async function ensureKatex(){
                    if(window.__katexLoading) return window.__katexLoading;
                    window.__katexLoading = (async()=>{
                        try{
                            if(window.katex && window.renderMathInElement){
                                window.__katexReady = true;
                            } else {
                                await loadScript('https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js');
                                await loadScript('https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js');
                                window.__katexReady = !!window.renderMathInElement;
                            }
                        }catch(e){ try{ console.warn('KaTeX load failed', e); }catch(_){} }

                        if(window.__katexReady && window.renderMathInElement){
                            const q = Array.isArray(window.__katexQueue) ? window.__katexQueue.slice() : [];
                            window.__katexQueue = [];
                            q.forEach(job=>{ try{ renderInto(job.el, job.opts); }catch(e){} });
                        }
                    })();
                    return window.__katexLoading;
                }

                window.renderMathIn = function(el, opts){
                    try{
                        if(!el) return;
                        if(window.__katexReady && window.renderMathInElement){ renderInto(el, opts); return; }
                        window.__katexQueue.push({ el, opts });
                        ensureKatex();
                    }catch(e){}
                };

                // Minimal print-based exporters used by UI buttons
                (function initExportHandlers(){
                    function encodeHTML(s){
                        return String(s ?? '').replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[ch]));
                    }
                    function getParsedItems(){
                        try{
                            const st = window.__quizState || window.state || {};
                            const items = st.items || [];
                            return Array.isArray(items) ? items : [];
                        }catch(e){ return []; }
                    }
                    function answerKeyLines(items){
                        const letters = ['A','B','C','D','E','F','G'];
                        const out = [];
                        items.forEach((it, ix)=>{
                            const n = it?.num || (ix+1);
                            const t = String(it?.type || 'mcq').toLowerCase();
                            if(t === 'matching'){
                                const pairs = Array.isArray(it.pairs) ? it.pairs : [];
                                const mapping = pairs
                                    .map(p=>{
                                        const L = (p && p.left != null) ? String(p.left) : '';
                                        const R = (p && p.right != null) ? String(p.right) : '';
                                        return (L && R) ? `${L} → ${R}` : '';
                                    })
                                    .filter(Boolean)
                                    .join(' ; ');
                                out.push(`${n}. ${mapping || '?'}`);
                                return;
                            }
                            if(t === 'fillblank'){
                                const keys = Array.isArray(it.answers) ? it.answers : (it.answer != null ? [it.answer] : []);
                                const ans = keys.map(a=>String(a||'').trim()).filter(Boolean).join(' | ');
                                if(ans) out.push(`${n}. ${ans}`);
                                return;
                            }
                            if(t === 'truefalse'){
                                const idx = (typeof it.correctIdx === 'number') ? it.correctIdx : 0;
                                out.push(`${n}. ${idx === 0 ? 'True' : 'False'}`);
                                return;
                            }
                            const idx = (typeof it.correctIdx === 'number') ? it.correctIdx : null;
                            out.push(`${n}. ${idx!=null ? (letters[idx]||'A') : '?'}`);
                        });
                        return out;
                    }
                    function buildBody(highlightCorrect){
                        try{
                            const c = document.getElementById('seeAllContent');
                            if(c && c.textContent && c.textContent.trim()){
                                return `<pre style="white-space:pre-wrap;font-family:inherit">${encodeHTML(c.textContent || '')}</pre>`;
                            }
                        }catch(e){}

                        const items = getParsedItems();
                        if(!items.length) return '<div style="color:#666">No parsed items.</div>';
                        const letters = ['A','B','C','D','E','F','G'];
                        const blocks = items.map((it, ix)=>{
                            const n = it?.num || (ix+1);
                            const t = String(it?.type || 'mcq').toLowerCase();
                            const q = encodeHTML(it?.q || it?.text || '');

                            if(t === 'matching'){
                                const pairs = Array.isArray(it.pairs) ? it.pairs : [];
                                const pairsHtml = pairs
                                    .map(p=>`<div style="margin:6px 0"><strong>${encodeHTML(p?.left||'')}</strong> → ${encodeHTML(p?.right||'')}</div>`)
                                    .join('');
                                return `<div style="margin-bottom:12px"><div><strong>Q${encodeHTML(n)}.</strong> ${q}</div>${pairsHtml}</div>`;
                            }

                            if(t === 'fillblank'){
                                const keys = Array.isArray(it.answers) ? it.answers : (it.answer != null ? [it.answer] : []);
                                const ans = keys.map(a=>String(a||'').trim()).filter(Boolean).join(' | ');
                                const ansHtml = (highlightCorrect && ans)
                                    ? `<div style="margin:6px 0"><strong>Ans.</strong> <span style=\\"color:#167f3a;font-weight:700\\">${encodeHTML(ans)}</span></div>`
                                    : '';
                                return `<div style="margin-bottom:12px"><div><strong>Q${encodeHTML(n)}.</strong> ${q}</div>${ansHtml}</div>`;
                            }

                            const choices = Array.isArray(it.choices) ? it.choices : [];
                            const correctIdx = (typeof it.correctIdx === 'number') ? it.correctIdx : null;
                            const choicesHtml = choices.map((c,i)=>{
                                const isCorrect = (highlightCorrect && correctIdx!=null && i===correctIdx);
                                const label = letters[i] || String(i+1);
                                const txt = encodeHTML(c);
                                return `<div style="margin:6px 0"><strong>${label}.</strong> ${isCorrect ? `<span style=\\"color:#167f3a;font-weight:700\\">${txt}</span>` : txt}</div>`;
                            }).join('');
                            return `<div style="margin-bottom:12px"><div><strong>Q${encodeHTML(n)}.</strong> ${q}</div>${choicesHtml}</div>`;
                        }).join('');

                        const key = answerKeyLines(items);
                        const keyHtml = key.length
                            ? `<div style="margin-top:14px"><strong>ANSWER KEY</strong><pre style="white-space:pre-wrap;font-family:inherit;margin-top:6px">${encodeHTML(key.join('\\n'))}</pre></div>`
                            : '';
                        return blocks + keyHtml;
                    }
                    function openPrint(title, bodyHtml){
                        try{
                            const win = window.open('', '_blank');
                            if(!win){ alert('Popup blocked. Allow popups to export.'); return; }
                            const css = `<style>body{font-family:Arial,Helvetica,sans-serif;color:#111;padding:18px;max-width:920px;margin:0 auto}</style>`;
                            win.document.write('<!doctype html><html><head><meta charset="utf-8"><title>'+encodeHTML(title)+'</title>'+css+'</head><body>' + bodyHtml + '</body></html>');
                            win.document.close();
                            setTimeout(()=>{ try{ win.focus(); win.print(); }catch(e){} }, 300);
                        }catch(e){ alert('Export failed.'); }
                    }
                    function exportPreview(){
                        const highlight = !!document.getElementById('exportHighlightPreview')?.checked;
                        openPrint('Export Preview', buildBody(highlight));
                    }
                    function exportResults(){
                        const highlight = !!document.getElementById('exportHighlightResults')?.checked;
                        openPrint('Export Results', buildBody(highlight));
                    }

                    window.exportPreviewToPdf = exportPreview;
                    window.exportResultsToPdf = exportResults;

                    function bind(){
                        try{
                            document.getElementById('exportPreviewPdfBtn')?.addEventListener('click', (e)=>{ e.preventDefault(); exportPreview(); });
                            document.getElementById('exportResultsPdfBtn')?.addEventListener('click', (e)=>{ e.preventDefault(); exportResults(); });
                        }catch(e){}
                    }
                    if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', bind);
                    else bind();
                })();
            })();
        </script>



    <style>
        .export-highlight-label{ transition: color .12s ease; color: var(--muted); }
    /* When export highlight is enabled, make the label visually prominent: bold + green */
    .export-highlight-label.export-on{ color: #16a34a; font-weight: 700; text-shadow: 0 1px 0 rgba(0,0,0,0.25); }

        /* Lint panel styling (reuses existing theme primitives) */
        .lint-panel{ margin-top: 12px; padding: 12px; border-radius: 14px; border: 1px solid var(--stroke); background: linear-gradient(180deg, rgba(14, 20, 32, .45), rgba(10, 16, 28, .35)); }
        .lint-head{ display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; }
        .lint-title{ font-weight: 800; }
        .lint-list{ margin-top: 10px; display:flex; flex-direction:column; gap:8px; }
        .lint-item{ padding: 8px 10px; border-radius: 12px; border: 1px solid rgba(60,80,120,.28); background: linear-gradient(180deg, rgba(14,20,32,.40), rgba(10,16,28,.34)); }
        .lint-item .lint-msg{ color: var(--ink); font-size: 13px; }
        .lint-item .lint-meta{ color: var(--muted); font-size: 12px; margin-top: 4px; }
        .lint-item.warn{ border-color: rgba(255, 193, 7, .22); }
        .lint-item.error{ border-color: rgba(239, 68, 68, .28); }

        :root {
            --bg: #070b12;
            --ink: #e9f0f7;
            --muted: #9fb0c5;
            --panel: #0c1320aa;
            /* Global, compact spacing for inline/stacked control rows */
            --control-gap: 4px; /* scaled x1.25 per user request */
            --stroke: #1f2a44aa;
            --brand: #6aa9ff;
            --ok: #22c55e;
            --bad: #ef4444;
            --glass-blur: 14px;
            --depth: 0 12px 30px rgba(0, 0, 0, .35), inset 0 1px 0 rgba(255, 255, 255, .04);
            /* Themeable lighting + buttons */
            --glow1: rgba(74, 144, 255, .20);
            --glow2: rgba(112, 220, 255, .14);
            --glow3: rgba(130, 100, 255, .16);
            --btnTop: rgba(96, 165, 250, .35);
            --btnBottom: rgba(24, 60, 120, .65);
            --btnBorder: #1f3a64;
        }

        * {
            box-sizing: border-box
        }

        html { height: 100% }
        .flex-wrap { flex-wrap: wrap }
        /* Utility classes to replace inline styles */
        .mt-0 { margin-top: 0 !important; }
        .mt-12 { margin-top: 12px !important; }
        .mb-0 { margin-bottom: 0 !important; }
        .m-0 { margin: 0 !important; }
        .flex-center { display: flex; align-items: center; }
        .gap-8 { gap: 8px; }
        .gap-12 { gap: 12px; }
        .w-full { width: 100%; }
        
        body {
            height: 100%
        }

        body {
            margin: 0;
            color: var(--ink);
            font: 16px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Helvetica, Arial;
            overflow-x: hidden;
            background: #060a12;
            
        }

        /* End-of-scroll breathing room beneath the final module */
        body::after{ content:''; display:block; height:6px; }

        /* fixed animated gradient layer (doesn't reset on scroll) */
        .bg-anim {
            position: fixed;
            /* Use viewport-based insets to avoid percent-based shrink on tab restore */
            top: -25vh; left: -25vw; right: -25vw; bottom: -25vh;
            z-index: -1;
            pointer-events: none;
            transform: translateZ(0);
            will-change: transform;
            filter: blur(60px) saturate(130%);
            background:
                radial-gradient(1100px 700px at 12% 18%, var(--glow1), transparent 90%),
                radial-gradient(900px 600px at 88% 12%, var(--glow2), transparent 92%),
                radial-gradient(900px 650px at 45% 88%, var(--glow3), transparent 90%);
            animation: bgDrift 22s ease-in-out infinite alternate;
        }
        /* Lighter effect on small screens to save battery/GPU */
        @media (max-width: 640px){
            .bg-anim{ filter: blur(40px) saturate(120%); }
        }

        /* Custom button colors */
        .btn#skipBtn {
            background: linear-gradient(180deg, var(--btnTop), var(--btnBottom));
            border-color: var(--btnBorder);
        }

        .btn#skipBtn:hover {
            filter: brightness(1.08);
        }

        .btn#submitBtn {
            background: linear-gradient(180deg, rgba(34, 197, 94, .6), rgba(16, 83, 44, .9));
            border-color: #22c55e;
        }

        .btn#submitBtn:hover {
            background: linear-gradient(180deg, rgba(54, 217, 114, .7), rgba(26, 93, 54, .95));
        }

        @keyframes bgDrift {
            0% {
                transform: translate3d(-1%, -1%, 0) scale(1.02);
            }

            50% {
                transform: translate3d(1%, 2%, 0) scale(1.035);
            }

            100% {
                transform: translate3d(3%, -1%, 0) scale(1.02);
            }
        }

        @media (prefers-reduced-motion: reduce) {
            .bg-anim {
                animation: none;
            }
        }

        .container {
            max-width: 1100px;
            margin: 24px auto;
            padding: 0 16px
        }

        /* Mobile parity: prevent iOS focus-zoom and reduce fixed-overlay collisions */
        @media (max-width: 640px){
            input[type="text"],
            input[type="password"],
            input[type="number"],
            input[type="search"],
            input[type="email"],
            input[type="url"],
            select,
            textarea{
                font-size: 16px;
            }
        }

        /* Sticky notes UI is desktop-first; hide on small screens to avoid overlaps */
        @media (max-width: 980px){
            :root{ --stickyScale: 0; }
            .sticky-dock,
            .sticky-panel,
            .sticky-rail,
            .sticky-rail-hoverzone,
            .sticky-rail-resizer,
            #stickyRailResizer,
            #stickyDock,
            #stickyPanel,
            #stickyRail,
            #stickyRailHoverzone,
            #leftMagnet,
            #leftTabHoverzone,
            #leftTabResizer,
            #leftMagnetTab,
            .left-tab-hoverzone,
            .left-tab-resizer{
                display:none !important;
            }
        }

        /* When a quiz is running, hide the Random/Daily quiz controls to avoid accidental navigation */
        body.quiz-running #dailyQuizBtn,
        body.quiz-running #randomQuizBtn,
        body.quiz-running #randomGearWrap {
            display: none !important;
        }

            /* Ensure main column can shrink so its children (cards) can fill available width */
            .quizgrid .col:first-child { min-width: 0; }
        @media (max-width: 640px){ .container{ margin: 16px auto; padding: 0 12px; } }

        .card {
            background: var(--panel);
            border: 1px solid var(--stroke);
            border-radius: 18px;
            box-shadow: var(--depth);
            -webkit-backdrop-filter: blur(var(--glass-blur));
            backdrop-filter: blur(var(--glass-blur));
        }

        .pad {
            padding: 18px
        }

        h1 {
            margin: 0 0 6px;
            font-size: 26px;
            text-shadow: 0 1px 0 rgba(0, 0, 0, .35)
        }

        .hint {
            color: var(--muted);
            font-size: 13px
        }

        .row {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: stretch; /* ensure columns match height */
        }

        .col {
            flex: 1 1 300px;
            display: flex;
            flex-direction: column;
            min-height: 0; /* allow children to shrink */
        }

        textarea {
            width: 100%;
            height: 320px; /* base height */
            max-height: none;
            color: var(--ink);
            background: linear-gradient(180deg, rgba(14, 20, 32, .65), rgba(10, 16, 28, .55));
            border: 1px solid rgba(60, 80, 120, .35);
            border-radius: 14px;
            padding: 12px;
            resize: none; /* prevent manual extension */
            overflow: auto; /* allow scrolling */
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, .08)
        }
        @media (max-width: 640px){ textarea{ height: 220px; } }

        /* File input styling */
        .file-input{
            display:flex; align-items:center; gap:8px; width:100%;
            background: linear-gradient(180deg, rgba(14, 20, 32, .65), rgba(10, 16, 28, .55));
            border: 1px solid rgba(60, 80, 120, .35);
            border-radius: 10px; padding: 6px 8px;
        }
        .file-input input[type=file]{ display:none }
        .file-input .choose-btn{
            display:inline-flex; align-items:center; justify-content:center; padding:6px 10px; border-radius:8px;
            background: linear-gradient(180deg, var(--btnTop), var(--btnBottom));
            border: 1px solid var(--btnBorder); color: var(--ink); font-weight: 700; cursor:pointer;
            font-size: 13px; line-height: normal; box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
        }
          /* Let the Choose File button size to its text content while avoiding layout shifts
              - flex: 0 0 auto keeps it its intrinsic width
              - filename area uses flex:1 so it absorbs variable text (long filenames)
          */
          .file-input .choose-btn{ flex: 0 0 auto; width: auto; min-width: 0; padding:6px 10px; box-sizing: border-box; white-space:nowrap }
          /* Ensure filename area flexes and truncates gracefully when needed */
          .file-input .filename{ flex: 1 1 auto; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap }
          @media (max-width: 760px){ .file-input .choose-btn{ padding:8px 12px } }
        @media (max-width: 640px){ .file-input .choose-btn{ min-height: 44px; display:flex; align-items:center; } }
        .file-input .filename{ flex:1 1 auto; color: var(--muted); font-size: 12px; overflow:hidden; text-overflow: ellipsis; white-space:nowrap }

        .options-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 0px;
            margin-bottom: 10px;
            align-items: center
        }

        /* Make the top-level Options toggles look like square buttons (not pills) */
        #setup .options-container .btn.opt-cube{
            display:inline-flex;
            align-items:center;
            gap:6px;
            padding: 7px 10px;
            border-radius: 12px;
            font-size: 13px;
            line-height: 1;
            -webkit-user-select: none;
            user-select: none;
        }
        #setup .options-container .btn.opt-cube input[type="checkbox"]{
            margin: 0;
            width: 14px;
            height: 14px;
            accent-color: var(--brand);
            flex: 0 0 auto;
        }
        #setup .options-container .btn.opt-cube input[type="checkbox"]:focus-visible{
            outline: 2px solid rgba(96,165,250,.28);
            outline-offset: 2px;
            border-radius: 4px;
        }
        /* When enabled, match the primary button vibe (like Parse & Preview) */
        #setup .options-container .btn.opt-cube:has(input[type="checkbox"]:checked){
            border-color: var(--btnBorder);
            background: linear-gradient(180deg, var(--btnTop), var(--btnBottom));
        }

        /* Theme the checkboxes inside option pills */
        .pill input[type="checkbox"]{ accent-color: var(--brand); }
    .pill input[type="checkbox"]:focus-visible{ outline: 2px solid var(--brand); outline-offset: 2px; border-radius: 4px }

    /* Removed brand accent on quiz radios to avoid color bleed; radios are custom-rendered in the quiz section */
    /* .choice input[type="radio"]{ accent-color: var(--brand); } */

/* Compact choice styling so options fit narrower cards and wrap neatly */
.choice{
    display:block;
    margin:6px 0;
    padding:8px 10px;
    border:1px solid rgba(70,90,130,.28);
    border-radius:10px;
    cursor:pointer;
    background:linear-gradient(180deg, rgba(14,20,32,.45), rgba(10,15,26,.45));
    font-size:14px;
    line-height:1.25;
    word-break:break-word;
    box-sizing:border-box;
}
.choice strong{ display:inline-block; width:2.2em; vertical-align: middle; white-space: nowrap; }
.choice.match-row{ margin:4px 0; padding:6px 10px; cursor:default; }
.choice.match-row strong{ width:auto; display:inline; }
.choice.correct{ border-color:#155e37; background:linear-gradient(180deg, rgba(11,30,21,.65), rgba(6,20,14,.55)); }
.choice.wrong{ border-color:#7f1d1d; background:linear-gradient(180deg, rgba(26,15,16,.65), rgba(18,10,12,.55)); }

        .pill {
            padding: 6px 10px;
            border: 1px solid var(--btnBorder);
            background: linear-gradient(180deg, var(--btnTop), rgba(10, 16, 28, .7));
            border-radius: 999px;
            white-space: nowrap
        }

    /* Keep the right column modules stacked tightly (avoid large empty gap before Saved MCQs) */
    #setup .ai-file-panel{ margin-top: 8px; }
    #setup #savedMcqs.saved-card{ margin-top: 8px; }

        /* Paste area wrapper to host the Index button */
        .paste-head{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:6px; }
        .paste-label{ font-size:16px; font-weight:700; }
        .paste-format-btn{
            display:inline-flex;
            align-items:center;
            justify-content:center;
            padding:0 10px;
            height:28px;
            font-size:12px;
            border-radius:999px;
            background: transparent;
            border: 1px solid var(--btnBorder);
            color: var(--muted);
            line-height:1;
            box-shadow: none;
        }
        .paste-format-btn:hover{ filter: brightness(1.08); }
        .paste-wrap{ position: relative }
        .paste-wrap .index-btn{
            position:absolute; right:10px; bottom:10px; z-index:2;
            padding:8px 12px; border-radius:999px; font-weight:800; font-size:12px; cursor:pointer;
            border:1px solid var(--btnBorder);
            background: linear-gradient(180deg, var(--btnTop), var(--btnBottom));
            color: var(--ink); box-shadow: var(--depth);
        }
        .paste-wrap .index-btn.saved{ pointer-events:none; filter:brightness(1.05) }

        /* Saved MCQs module styles */
     /* Lift the saved content card and its inline dropdown above other in-flow elements
         but keep it below the light-mode overlay so inversion still applies. */
     .saved-card{ position:relative; z-index: 2147483645; margin-top:10px; padding:10px; border-radius:12px; border:1px solid var(--btnBorder); background: linear-gradient(180deg, rgba(16,25,40,.75), rgba(10,16,28,.75)); box-shadow: var(--depth) }
    .saved-header{ display:flex; align-items:center; justify-content:space-between; gap:8px }

    /* Saved-style outline for other module headers (no extreme z-index) */
    .module-outline{ position:relative; padding:10px; border-radius:12px; border:1px solid var(--btnBorder); background: linear-gradient(180deg, rgba(16,25,40,.75), rgba(10,16,28,.75)); box-shadow: var(--depth) }

    /* Utilities: compact, space-efficient layout */
    .utilities-head{ display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; }
    .utilities-title{ display:flex; align-items:center; gap:12px; flex-wrap:wrap; min-width: 240px; }
    .utilities-actions{ display:flex; align-items:center; justify-content:flex-end; gap:8px; flex-wrap:wrap; }
    .utilities-sub{ margin:0; font-weight:400; }

    .util-panel{ margin-top:10px; }
    .util-desc{ margin-top:8px; }
    /* Backup/Restore: minimal merged layout */
    .util-merged{
        margin-top: 10px;
        padding: 10px;
        border-radius: 14px;
        border: 1px solid rgba(60,80,120,.22);
        background: linear-gradient(180deg, rgba(14,20,32,.32), rgba(10,16,28,.28));
    }
    .util-panel .options-container{ margin-bottom: 0; }
    .util-panel .pill{ display:inline-flex; align-items:center; gap:8px; padding: 6px 10px; }
    .util-mini{ color: var(--muted); font-size: 12px; font-weight: 700; letter-spacing: .2px; margin: 2px 0 6px; }

    .util-controls{
        display:grid;
        grid-template-columns: auto auto;
        justify-content: start;
        gap: 10px 12px;
        align-items: start;
    }
    @media (max-width: 860px){ .util-controls{ grid-template-columns: 1fr; } }

    .util-actions{
        margin-top: 10px;
        display:grid;
        grid-template-columns: 1fr 1fr 2.2fr auto;
        gap: 10px;
        align-items: stretch;
    }
    @media (max-width: 980px){ .util-actions{ grid-template-columns: 1fr 1fr; } }
    @media (max-width: 640px){ .util-actions{ grid-template-columns: 1fr; } }

    .util-actions .btn{ width: 100%; }
    .util-actions #exportBackupBtn,
    .util-actions #exportShareBtn{
        width: auto;
        justify-self: center;
        min-width: 200px;
        max-width: 260px;
        padding-left: 14px;
        padding-right: 14px;
    }
    @media (max-width: 640px){
        .util-actions #exportBackupBtn,
        .util-actions #exportShareBtn{
            width: 100%;
            max-width: none;
            justify-self: stretch;
        }
    }
    .util-actions .file-input{ width: 100%; min-width: 0; }
    .util-actions .file-input .choose-btn{ width: auto; }

    .util-status{ margin-top: 8px; }

    .selftest-log{
        margin-top: 10px;
        max-height: 220px;
        overflow: auto;
        display: none;
        padding: 12px;
        border-radius: 14px;
        border: 1px solid var(--stroke);
        background: linear-gradient(180deg, rgba(14, 20, 32, .55), rgba(10, 16, 28, .45));
        box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
        font-size: 13px;
        white-space: pre-wrap;
    }
    /* Dropdown list container (overlay). Use fixed + very high z-index so nothing overlaps. */
    /* Use absolute so it scrolls with content, portal to body to avoid clipping; keep very high z-index */
     /* Use fixed positioning so the dropdown escapes ancestor stacking contexts and clipping
         (matches other inline dropdowns that are portaled to document.body). Position is
         computed in JS as viewport coordinates. Keep very high z-index so it appears above
         other UI modules but below global overlays when appropriate. */
    .saved-menu{ position:fixed; top: 0; left:0; z-index: 2147483645; width: auto; max-width: 96vw; box-sizing: border-box; max-height: 50vh; overflow:auto; border: 1px solid var(--btnBorder); border-radius: 12px; background: linear-gradient(180deg, rgba(16,25,40,.95), rgba(10,16,28,.95)); box-shadow: 0 10px 24px rgba(0,0,0,.45); display:none }
    .saved-menu.open{ display:block }
    .saved-list{ display:flex; flex-direction:column; gap:8px; padding:8px }
        .saved-item{ display:flex; align-items:center; justify-content:space-between; gap:8px; padding:4px 8px; border-radius:6px; border:1px solid rgba(60,80,120,.35); background: linear-gradient(180deg, rgba(14,20,32,.55), rgba(10,16,28,.55)) }
        .saved-item .si-main{ min-width:0 }
    .saved-item .si-title{ font-weight:700; color:var(--ink); cursor:text; line-height:1.2 }
    /* Inline last-revisited badge next to title: same size, grey, on one line */
    .saved-item .si-title .si-lastrev{ color: var(--muted); font-size: inherit; line-height: inherit; margin-left: 8px; white-space: nowrap }
    .saved-item .si-title[contenteditable="true"]:focus{ outline: 2px solid rgba(96,165,250,.35); outline-offset: 2px; border-radius: 4px }
        .saved-item .si-meta{ color:var(--muted); font-size:11px }
        .saved-item .si-actions{ display:flex; gap:6px; flex-shrink:0; align-items:center }

        /* Saved-row actions (Generate / Validate) and applied visual state */
    .saved-row{ display:flex; align-items:center; justify-content:space-between; padding:4px 6px; border-radius:6px }
    .saved-row .si-actions{ display:flex; gap:8px; align-items:center; flex-shrink:0 }
    .saved-row .si-actions .btn.small{ padding:4px 8px; font-size:11px; min-height:0; height:auto; line-height:1 }
        .saved-row.applied{ box-shadow: 0 6px 18px rgba(106,169,255,0.06), inset 0 1px 0 rgba(255,255,255,0.02); transform: translateY(-1px) }

    /* Persisted selection state for the chosen source used by Generate */
    .saved-row.selected{ box-shadow: 0 10px 30px rgba(106,169,255,0.10); border: 1px solid rgba(106,169,255,0.18); transform: translateY(-1px); }

        .btn {
            appearance: none;
            border: 1px solid rgba(78, 102, 146, .45);
            background: linear-gradient(180deg, rgba(24, 36, 56, .55), rgba(12, 20, 34, .65));
            color: var(--ink);
            padding: 10px 14px;
            border-radius: 14px;
            cursor: pointer;
            font-weight: 700;
            letter-spacing: .2px;
            transition: .12s
        }
        /* Circle wrapper for gear button to visually match the Random Quiz pill */
        .gear-circle{
            display:inline-flex; align-items:center; justify-content:center; overflow:hidden;
            width:36px; height:36px; border-radius:999px; padding:0; box-sizing:border-box;
            border: 1px solid rgba(78, 102, 146, .45);
            background: linear-gradient(180deg, rgba(24, 36, 56, .55), rgba(12, 20, 34, .65));
            color: var(--ink); cursor: pointer;
            box-shadow: var(--depth); transition: transform .12s ease, filter .12s ease;
        }
        .gear-circle:hover{ transform: translateY(-1px); filter:brightness(1.06) }
    .gear-circle .gear-btn{ background: transparent; border:0; padding:0; font-size:22px; line-height:0; color:inherit; width:100%; height:100%; border-radius:999px; display:inline-grid; place-items:center }
    /* ensure the inner glyph (font icon or svg) is block-level and scales to the available space */
    .gear-circle .gear-btn > *{ display:block; width:1em; height:1em }
        /* Mobile tap affordance */
    .btn, button, .theme-orb, .choose-btn { -webkit-tap-highlight-color: rgba(255,255,255,.1); }
    .btn.pill{ border-radius:999px; padding-left:14px; padding-right:14px }
    .mt-8{ margin-top:8px }
        @media (max-width: 640px){ .btn{ padding: 12px 14px; min-height: 44px; } }

        /* Compact TOC + Saved textbook styles (tight, minimal within TOC panel) */
    .tb-toc{ height:120px; overflow:auto; padding:8px; border-radius:10px; font-size:13px }
    .tb-log{ height:120px; overflow:auto; padding:10px; border-radius:10px }
        .compact-saved{ margin-top:10px; padding:8px; border-radius:10px; font-size:13px }
        .compact-row{ gap:8px; align-items:center }
    .btn.small{ padding:6px 12px; font-size:13px; border-radius:10px; min-height:36px; display:inline-flex; align-items:center; }
          .compact-select{ font-size:13px; padding:6px 8px }
          /* Tighter saved-select + action layout to avoid overlap with Show/Delete/Clear
              Keep visual theme consistent: compact padding, subtle border, and controlled max-width
              so the select won't grow past the action buttons on narrow panels. */
          .custom-select-wrap{ flex: 1; min-width: 0; }
          .custom-select-wrap{ position: relative }
          /* Ensure the saved actions sit inline and don't wrap; tighten button spacing */
          .saved-actions{ display:flex; gap:8px; align-items:center; flex: 0 0 auto }
          .saved-actions .btn.small{ padding:6px 10px; font-size:13px; border-radius:10px; min-width:56px }
          /* Make the native select visually match other controls and cap its maximum width */
                    .saved-select{ height:36px; border-radius:10px; background: #0c1526; color:var(--ink); border:1px solid var(--btnBorder); padding:6px 10px; box-shadow: inset 0 1px 0 rgba(255,255,255,.04); min-width: 160px; max-width: 100%; display: inline-block; vertical-align: middle }
                    /* Make the closed select look like other themed controls (custom chevron + no native chrome styling) */
                    .saved-select{ -webkit-appearance: none; -moz-appearance: none; appearance: none; position: relative; padding-right: 36px; background-image:
                                linear-gradient(45deg, rgba(233,240,247,.9) 50%, transparent 50%),
                                linear-gradient(-45deg, rgba(233,240,247,.9) 50%, transparent 50%),
                                linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0));
                    background-size: 8px 8px, 8px 8px, 100% 100%;
                    background-position: right 12px center, right 12px center, 0 0;
                    background-repeat: no-repeat;
                }
                /* Hide IE/Edge default arrow where supported */
                .saved-select::-ms-expand{ display: none }
                /* Options styling: browser support varies, but modern Chromium/Edge/Firefox respect these rules */
                .saved-select option, .saved-select optgroup { background: linear-gradient(180deg, rgba(16,25,40,.98), rgba(10,16,28,.98)); color: var(--ink); padding:6px 10px }
                .saved-select option:hover { background: linear-gradient(180deg, rgba(96,165,250,.06), rgba(24,60,120,.05)); color: var(--ink) }
                /* Selected/highlighted option styling (best-effort; exact behavior differs between browsers) */
                .saved-select option:checked, .saved-select option[selected] { background: linear-gradient(90deg, rgba(59,130,246,.95), rgba(37,99,235,.95)); color: #fff }
                /* Focus state to match other controls */
                .saved-select:focus{ outline: 2px solid rgba(96,165,250,.28); outline-offset: 2px }
                /* Attempt to style scrollbars inside the native dropdown on WebKit-based browsers */
                .saved-select option::-webkit-scrollbar, .saved-select::-webkit-scrollbar { width: 10px; height: 10px }
                .saved-select option::-webkit-scrollbar-track, .saved-select::-webkit-scrollbar-track { background: rgba(12,21,34,.9); border-radius:8px }
                .saved-select option::-webkit-scrollbar-thumb, .saved-select::-webkit-scrollbar-thumb { background: linear-gradient(180deg, rgba(110,150,200,.5), rgba(70,100,160,.5)); border-radius:8px; border:1px solid rgba(40,60,90,.35) }
          /* On very small screens allow select to shrink but keep actions usable */
          @media (max-width: 520px){ .custom-select-wrap{ max-width: 100%; flex: 1 1 58%; } .saved-actions{ gap:6px } .saved-actions .btn.small{ padding:6px 8px; min-width:48px } }
    /* Inline custom dropdown visuals */
    .custom-inline-dropdown{ display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:10px; border:1px solid var(--btnBorder); background: linear-gradient(180deg, rgba(14,20,32,.65), rgba(10,16,28,.65)); color:var(--ink); cursor:pointer; min-width:160px; width: 100%; box-shadow: var(--depth); }
    .custom-inline-dropdown .inline-selected{ flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis }
    .custom-inline-dropdown .inline-chevron{ opacity:.85 }
     /* Anchor the dropdown list to its parent wrapper (position:relative). Use a z-index
    slightly below the light-mode overlay so the list is affected by inversion.
    The overlay has pointer-events:none, so interactivity remains intact. This keeps
    the dropdown visually consistent with the rest of the UI when inverted display
    is enabled.
         while still appearing above other in-flow UI elements. */
     /* Use fixed positioning for the dropdown list so ancestor overflow or stacking contexts
         cannot clip it. Placement is computed by JS when opening so it remains visually
         anchored to the trigger while escaping any parent with overflow:hidden. The
         z-index keeps it below the light-mode overlay but above other page elements. */
    .custom-inline-list{ position:fixed; left:0; top:0; z-index: 2147483645; margin-top:0; min-width: 220px; box-sizing:border-box; background: linear-gradient(180deg, rgba(16,25,40,.98), rgba(10,16,28,.98)); border:1px solid var(--btnBorder); border-radius:10px; box-shadow: 0 10px 24px rgba(0,0,0,.45); padding:6px; max-height: 48vh; overflow:auto; will-change: transform, left, top; }
    .custom-inline-list .custom-inline-item{ padding:8px 10px; border-radius:8px; margin:4px 0; cursor:pointer; color:var(--ink); }
    .custom-inline-list .custom-inline-item:focus, .custom-inline-list .custom-inline-item:hover{ outline:none; background: linear-gradient(180deg, rgba(96,165,250,.06), rgba(24,60,120,.05)); }
    .custom-inline-list .custom-inline-item[aria-selected='true'], .custom-inline-list .custom-inline-item.selected{ background: linear-gradient(90deg, rgba(59,130,246,.95), rgba(37,99,235,.95)); color:#fff }
    .visually-hidden{ position:absolute !important; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0 }
        .compact-actions button{ margin-left:6px }
        .compact-details{ margin-top:6px; font-size:12px }
        .saved-sample.compact-sample{ margin-top:6px; max-height:84px; overflow:auto; padding:8px; background: linear-gradient(180deg, rgba(8,12,18,.4), rgba(6,10,14,.35)); border-radius:8px }
        .saved-row{ padding:6px; border-radius:8px }

    /* Saved header badge centering */
    .saved-header-left{ align-items:center }
    .saved-badge-wrap{ display:flex; align-items:center; justify-content:center; min-width:28px; height:28px; border-radius:8px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:2px 6px }
    #savedCount{ display:inline-block }

        /* Page-level title displayed above the content card and centered */
        .page-title{
            text-align:center;
            margin: 6px 0 0 0; /* remove bottom gap for content library title */
            font-size:20px;
            font-weight:800;
            color: var(--ink);
            letter-spacing: .4px;
            /* keep it visually separate from card */
            display:block;
        }
    /* Combined chooser + preview (stacked with horizontal divider) */
    .chooser-row{ display:flex; flex-direction:column; gap:8px }
    .chooser-left{ width:100%; }
    .chooser-right{ width:100%; }
    /* Horizontal divider between the top controls and bottom preview */
    .chooser-divider{ height:2px; background: linear-gradient(90deg, rgba(255,255,255,0.03), rgba(110,170,255,0.06), rgba(255,255,255,0.03)); border-radius:3px; margin: 6px 0; box-shadow: 0 2px 8px rgba(106,169,255,0.03), inset 0 1px 0 rgba(255,255,255,0.02); transition: box-shadow .12s ease, transform .12s ease }
    .chooser-divider:hover, .chooser-divider:focus{ box-shadow: 0 4px 18px rgba(106,169,255,0.08), inset 0 1px 0 rgba(255,255,255,0.03); transform: translateY(-1px) }
    @media (min-width: 900px){ .chooser-row{ gap:12px } }

        .btn:hover {
            transform: translateY(-1px)
        }

        .btn.primary {
            border-color: var(--btnBorder);
            background: linear-gradient(180deg, var(--btnTop), var(--btnBottom));
        }

        /* Full-screen ASCII watermark layer (behind UI, above .bg-anim) */
        .ascii-watermark{
            position: fixed; inset: 0; z-index: -2147483644; pointer-events: none;
            display:flex; align-items:center; justify-content:center; /* center base content */
            overflow: hidden; /* clip outside */
            mix-blend-mode: normal;
        }
        .ascii-watermark pre{
            margin:0; padding:0; display:none; white-space: pre; line-height: 1;
            color: rgba(255,255,255,.06);
            text-shadow: 0 1px 0 rgba(0,0,0,.22), 0 0 8px rgba(255,255,255,.025);
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace;
            font-size: 9px; /* smaller characters; cover-fit will keep full screen */
            transform-origin: center center; /* center for cover fit */
            will-change: transform;
            overflow: hidden;
        }
        .ascii-watermark pre .row{ display:block }
        .ascii-watermark .num, .ascii-watermark .fav{ color: rgba(255,255,255,.12); }
        .ascii-watermark canvas{ width:100%; height:100%; display:block }

        /* ASCII watermark removed per user request */

        /* Global top safe area (news bar height etc.) */
        :root{ --topSafeArea: 0px; }

        /* Theme capsule (left side) */
        .theme-capsule{
            position: fixed; left: calc(12px + env(safe-area-inset-left)); top: calc(12px + env(safe-area-inset-top) + var(--topSafeArea)); transform: none;
            display:flex; gap:10px; align-items:center; padding:8px 10px;
            border-radius: 9999px; border: 1px solid rgba(31,42,68,.6);
            background: linear-gradient(180deg, rgba(16,25,40,.65), rgba(10,16,28,.65));
            box-shadow: var(--depth);
            -webkit-backdrop-filter: blur(calc(var(--glass-blur)*.8));
            backdrop-filter: blur(calc(var(--glass-blur)*.8));
            z-index: 5;
        }
        /* Place the background toggle just below the theme capsule */
        #bgToggles{
            position: fixed;
            left: calc(12px + env(safe-area-inset-left));
            /* Use theme capsule height + the unified control gap for consistent spacing */
            top: calc(12px + env(safe-area-inset-top) + var(--topSafeArea) + var(--theme-capsule-h, 56px) + var(--control-gap));
            z-index: 6; /* above canvas and peers */
            display:flex; gap: var(--control-gap); align-items:flex-start; flex-direction: column; /* stack toggles vertically */
        }
        @media (max-width: 640px){ .theme-capsule{ left: calc(8px + env(safe-area-inset-left)); top: calc(8px + env(safe-area-inset-top) + var(--topSafeArea)); } }
        /* On small screens, the orbs are larger; update the capsule height variable and recompute */
        @media (max-width: 640px){ :root{ --theme-capsule-h: 60px; } }
        @media (max-width: 640px){ #bgToggles{ left: calc(8px + env(safe-area-inset-left)); top: calc(8px + env(safe-area-inset-top) + var(--topSafeArea) + var(--theme-capsule-h, 60px) + var(--control-gap)); } }
        .theme-orb{
            --c1: #5aa5ff; --c2: #46d3ff; --c3: #7a66ff; /* default fallbacks */
            --hx: 30%; --hy: 22%; /* specular highlight anchor (moves on hover) */
            width: 40px; height: 40px; border-radius: 50%; cursor: pointer; position: relative; overflow: hidden;
            /* Deeper 3D: strong inner shade + soft outer drop shadow */
            box-shadow:
                inset 0 -10px 22px rgba(0,0,0,.55), /* bottom occlusion */
                inset 0 10px 18px rgba(255,255,255,.06), /* top bounce */
                0 8px 16px rgba(0,0,0,.40); /* outer drop */
            border: 1px solid rgba(60,80,120,.6);
            transition: transform .14s ease, box-shadow .12s ease, filter .12s ease;
            /* Seamless base (no conic seam): neutral sphere core, colors are painted in ::before */
            background: radial-gradient(120% 120% at 50% 60%, #0f1726 0%, #0b1424 65%, #09111f 100%);
            background-clip: padding-box; isolation: isolate;
            filter: saturate(112%) contrast(105%);
        }
        @media (max-width: 640px){ .theme-orb{ width: 44px; height: 44px; } }
    /* Orb palette classes to avoid inline styles */
    .orb-ocean { --c1:#5aa5ff; --c2:#46d3ff; --c3:#7a66ff }
    .orb-sunset{ --c1:#ff7a7a; --c2:#ffb84d; --c3:#ffd86b }
    .orb-forest{ --c1:#2bd47a; --c2:#75e68c; --c3:#3fb2a0 }
    .orb-violet{ --c1:#8b5cf6; --c2:#60a5fa; --c3:#22d3ee }
    .orb-ember { --c1:#ff6b6b; --c2:#f59e0b; --c3:#fb923c }
    .orb-greyscale{ --c1:#d4d4d4; --c2:#9ca3af; --c3:#4b5563 }

    /* Palette editor (minimal, square, movable) */
    .palette-editor{ position:fixed; width:248px; border-radius:10px; padding:8px; z-index:2147483645; color:var(--ink);
        background: linear-gradient(180deg, rgba(16,24,38,.94), rgba(10,16,28,.90));
        border:1px solid rgba(255,255,255,0.06);
        box-shadow: 0 14px 36px rgba(2,6,12,0.55);
        -webkit-backdrop-filter: blur(8px); backdrop-filter: blur(8px);
        -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
        opacity: 1; transform: translateY(-4px) scale(.99);
    }
    /* Remove decorative overlay for a clean, minimal look */
    .palette-editor::after{ content:none }
    .palette-editor.hidden{ display:none }
    /* open/close animation hooks */
    .palette-editor.pe-anim{ transition: opacity .18s ease, transform .18s ease; will-change: opacity, transform; }
    .palette-editor.pe-show{ opacity:1; transform: translateY(0) scale(1); }

    .palette-editor .pe-header{ display:flex; align-items:center; justify-content:space-between; gap:6px; padding:6px 8px 6px 10px; cursor:default; font-weight:800; letter-spacing:.2px; min-height:34px }
    .palette-editor .pe-header:active{ cursor:default }
    .palette-editor .pe-header span{ font-size:13px; color: var(--ink) }
    .palette-editor .pe-body{ padding:6px 8px }
    /* prevent accidental double-click selection inside the editor; allow controls to remain interactive */
    .palette-editor input, .palette-editor button, .palette-editor input[type="color"]{ -webkit-user-select: auto; -moz-user-select: auto; -ms-user-select: auto; user-select: auto }
    .palette-editor .pe-row{ display:flex; gap:8px; align-items:flex-start; justify-content:space-between }
    .palette-editor label{ display:inline-flex; flex-direction:column; font-size:12px; gap:6px; align-items:flex-start; color: var(--muted); font-weight:700 }
    .palette-editor input[type=color]{ width:56px; height:34px; border-radius:8px; padding:2px; cursor:pointer;
        border:1px solid rgba(255,255,255,0.08); background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
        box-shadow: inset 0 1px 0 rgba(255,255,255,0.06), 0 8px 20px rgba(0,0,0,0.35); }
    .palette-editor input[type=color]::-webkit-color-swatch-wrapper{ padding:2px; border-radius:8px }
    .palette-editor input[type=color]::-webkit-color-swatch{ border:none; border-radius:8px }
    .palette-editor input[type=color]:focus{ outline: 2px solid rgba(96,165,250,.35); outline-offset: 2px }
    .palette-editor .pe-preview{ margin-top:8px; height:46px; border-radius:10px; border:1px solid rgba(255,255,255,0.04);
        /* reduce inset darkening and soften edges to avoid hard side lines */
        box-shadow: inset 0 2px 6px rgba(0,0,0,0.32), 0 6px 18px rgba(0,0,0,0.35);
        background: linear-gradient(90deg, #ddd, #999); position:relative; overflow:hidden }
    .palette-editor .pe-preview::before{ content:''; position:absolute; left:-20%; right:-20%; top:-60%; height: 120%;
        background: linear-gradient(180deg, rgba(255,255,255,.18), rgba(255,255,255,0)); transform: rotate(12deg); pointer-events:none }
    .palette-editor .pe-footer{ margin-top:8px; display:flex; justify-content:flex-end }
    /* Header buttons */
    #peReset.btn.small{ border-radius:999px; padding:6px 10px; font-size:12px }
    /* Circle close: ensure perfect centering regardless of font metrics */
    #peClose.btn.small{
        width:32px; height:32px; padding:0; border-radius:50%;
        font-weight:900; font-size:14px; line-height:1; display:inline-flex; align-items:center; justify-content:center; box-sizing:border-box;
        /* make it a true circular icon button that matches theme */
        border: 1px solid var(--btnBorder);
        background: linear-gradient(180deg, var(--btnTop), var(--btnBottom));
        color: var(--ink);
        cursor: pointer;
        box-shadow: 0 6px 14px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.03);
        transition: transform .08s ease, filter .12s ease, box-shadow .12s ease;
    }
    #peClose.btn.small:hover{ filter: brightness(1.06); transform: translateY(-1px); }
    #peClose.btn.small:focus{ outline: 2px solid rgba(96,165,250,.35); outline-offset: 2px }
    @media (max-width:640px){ .palette-editor{ width:92%; left:4% !important; right:auto !important } }

    /* In-DOM Custom Color Picker (invertable under light-mode) */
    #ccpPanel{ position: fixed; z-index:2147483645; width:280px; border-radius:12px; padding:10px; box-sizing:border-box;
        color: var(--ink);
        background: linear-gradient(180deg, rgba(16,24,38,.96), rgba(10,16,28,.92));
        border:1px solid rgba(255,255,255,0.06);
        box-shadow: 0 18px 42px rgba(2,6,12,0.55);
        -webkit-backdrop-filter: blur(10px); backdrop-filter: blur(10px);
    }
    #ccpPanel .row{ display:flex; align-items:center; gap:10px; margin:8px 0 }
    #ccpPanel .lbl{ width:22px; font-weight:800; font-size:11px; color:var(--muted) }
    #ccpPanel input[type=range]{ flex:1; appearance:none; height:6px; border-radius:999px; background:#0c1526; outline:none; border:1px solid rgba(255,255,255,.06) }
    #ccpPanel input[type=range]::-webkit-slider-thumb{ -webkit-appearance:none; appearance:none; width:14px; height:14px; border-radius:50%; background:var(--ink); border:1px solid rgba(0,0,0,.4) }
    #ccpPanel .preview{ height:34px; border-radius:8px; border:1px solid rgba(255,255,255,.08); box-shadow: inset 0 1px 0 rgba(255,255,255,.04) }

    /* Glassy radio / swatch styling - semi-transparent, blurred, and reflective */
    .glass-radio, input[type="radio"]{
        -webkit-appearance: none; appearance: none;
        width: 20px; height: 20px; border-radius: 50%; display:inline-block; vertical-align: middle;
        background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.08);
        box-shadow: inset 0 6px 14px rgba(255,255,255,0.03), inset 0 1px 0 rgba(255,255,255,0.06), 0 8px 26px rgba(2,6,12,0.45);
        -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px);
        cursor: pointer; transition: transform .12s ease, box-shadow .12s ease, background .12s ease;
    }
    .glass-radio:hover, input[type="radio"]:hover{ transform: translateY(-2px); box-shadow: inset 0 8px 18px rgba(255,255,255,0.04), 0 12px 32px rgba(2,6,12,0.5); }
    .glass-radio:focus, input[type="radio"]:focus{ outline: 2px solid rgba(96,165,250,0.16); outline-offset: 2px }
    .glass-radio.checked, input[type="radio"]:checked{
        background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
        border: 1px solid rgba(255,255,255,0.16);
        box-shadow: 0 10px 30px rgba(2,6,12,0.52), inset 0 1px 0 rgba(255,255,255,0.06);
    }

    /* Use circular preview swatch inside the custom picker to show selected color as glass */
    #ccpPanel .preview{ width:34px; flex:0 0 34px; border-radius:50%; display:inline-block; }
    #ccpPanel .actions{ display:flex; justify-content:flex-end; gap:8px; margin-top:10px }
    #ccpPanel .btn{ border-radius:10px; padding:8px 12px; font-weight:800; font-size:12px; border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); cursor:pointer }

    /* Utility classes to replace inline styles */
    .mt-6{ margin-top:6px }
    .mt-8{ margin-top:8px }
    .mt-10{ margin-top:10px }
    .mt-12{ margin-top:12px }
    .fs-12{ font-size:12px }
    .fs-14{ font-size:14px }
    .muted{ color: var(--muted) }
    .flex{ display:flex }
    .col{ display:flex; flex-direction:column }
    .center{ justify-content:center; align-items:center }
    .gap-8{ gap:8px }
    .gap-12{ gap:12px }
    .justify-between{ justify-content:space-between }
    .w-68{ width:68px }

    /* Prettier numeric inputs to match theme */
    .pill input[type="number"], input.themed-input[type="number"]{
        height: 30px; border-radius: 8px; background: #0c1526; color: var(--ink);
        border: 1px solid var(--btnBorder); padding: 4px 8px; font-size: 12px;
        box-shadow: inset 0 2px 6px rgba(0,0,0,.25);
    }
    @media (max-width: 640px){
        .pill input[type="number"], input.themed-input[type="number"]{ font-size: 16px; }
    }
    .pill input[type="number"]:focus, input.themed-input[type="number"]:focus{
        outline: 2px solid var(--brand); outline-offset: 2px;
    }
    /* Hide default spinners for a cleaner look */
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button{ -webkit-appearance: none; margin: 0; }
    input[type="number"]{ -moz-appearance: textfield; appearance: textfield; }
        /* News bar styles (glassy) */
        .news-bar{ position: fixed; left:0; right:0; top: 0; z-index: 240; /* below theme capsule (z 5+) */
            width: 100%; box-sizing: border-box; padding: 0 14px; height: 46px;
            border-bottom: 2px solid rgba(80,100,140,.6); border-radius: 0;
            background: linear-gradient(180deg, rgba(18,26,36,.68), rgba(6,10,14,.56));
            -webkit-backdrop-filter: blur(12px) saturate(120%); backdrop-filter: blur(12px) saturate(120%);
            box-shadow: 0 8px 32px rgba(0,0,0,.55);
            color: #e6eef8; overflow: hidden; white-space: nowrap; font-size:14px; line-height:46px }
        .news-bar::after{ content:''; position:absolute; inset:0; pointer-events:none; background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='160' height='160' viewBox='0 0 160 160'><filter id='n'><feTurbulence baseFrequency='0.9' seed='2' numOctaves='1' stitchTiles='stitch'/><feColorMatrix type='saturate' values='0'/><feComponentTransfer><feFuncA type='table' tableValues='0 0.06'/></feComponentTransfer></filter><rect width='100%' height='100%' filter='url(%23n)' opacity='0.18' /></svg>"); mix-blend-mode: overlay; opacity: .6; }
        .news-row{ position: relative; height: 100%; overflow: hidden; }
        .news-viewport{ position: relative; height: 100%; overflow: hidden; }
        .news-track{ position: absolute; left: 0; top: 0; height: 100%; white-space: nowrap; will-change: transform; }
        /* Increase headline size but keep bar height fixed: tighten gaps and date padding */
        .news-item{ display:inline-flex; gap:6px; align-items:center; color: var(--ink); text-decoration:none; font-size:15px }
        .news-item:hover{ text-decoration: underline }
        .news-date{ color: var(--muted); font-size: 11px; border: 1px solid rgba(60,80,120,.45); padding: 0 6px; border-radius: 999px; background: linear-gradient(180deg, rgba(16,25,40,.55), rgba(10,16,28,.55)); height: 22px; display: inline-flex; align-items: center; }
        .news-sep{ color: rgba(255,255,255,.25); display:inline-block; margin: 0 10px }
    /* Push all in-flow content below the top safe area + keep breathing room at bottom */
    body{ padding-top: var(--topSafeArea); padding-bottom: 16px; transition: padding-top .12s ease; }
    /* Content root: keep transform origin stable for any future effects */
    #contentRoot{ transform-origin: top center; transition: transform .15s ease; padding-bottom: 2px; }
    /* Saved MCQs card should fill its column — use full width and include padding in box sizing */
    .saved-card{ margin-left:0; margin-right:0; width:100%; box-sizing: border-box; }
        /* soft blending of tri-colors plus subtle rim glow */
        .theme-orb::before{
            content:""; position:absolute; inset:-12%; border-radius:50%; pointer-events:none;
            background:
                radial-gradient(62% 58% at 28% 30%, var(--c1), transparent 70%),
                radial-gradient(62% 60% at 72% 30%, var(--c2), transparent 72%),
                radial-gradient(80% 70% at 50% 80%, var(--c3), transparent 74%),
                radial-gradient(120% 98% at 50% 102%, rgba(0,0,0,.35), rgba(0,0,0,0) 60%), /* inner rim shade bottom */
                radial-gradient(120% 120% at 50% -8%, rgba(255,255,255,.06), rgba(255,255,255,0) 60%); /* top rim glow */
            filter: blur(12px) saturate(118%);
            opacity: .92; /* stronger so colors fully blend and cover base */
        }
        /* layered specular highlight + inner ring */
        .theme-orb::after{
            content:""; position:absolute; inset:0; border-radius:50%; pointer-events:none;
            background:
                /* bright glint */ radial-gradient(18% 16% at var(--hx) var(--hy), rgba(255,255,255,.66), rgba(255,255,255,.12) 40%, rgba(255,255,255,0) 70%),
                /* soft highlight */ radial-gradient(120% 100% at calc(var(--hx) + 10%) calc(var(--hy) + 6%), rgba(255,255,255,.18), transparent 62%),
                /* inner ring to suggest curvature */ radial-gradient(80% 80% at 50% 52%, rgba(255,255,255,.08), rgba(255,255,255,0) 62%),
                /* ambient occlusion at bottom */ radial-gradient(120% 90% at 50% 110%, rgba(0,0,0,.45), transparent 55%);
        }
        .theme-orb .orb-label{
            position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none;
            font-weight: 800; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,.5), 0 0 10px rgba(0,0,0,.45);
            font-size: 14px; letter-spacing: .2px; transform: translateZ(0); transition: transform .14s ease;
        }
        .theme-orb:hover{
            --hx: 26%; --hy: 18%;
            transform: translateY(-1px) scale(1.06);
            box-shadow:
                inset 0 -12px 24px rgba(0,0,0,.6),
                inset 0 12px 20px rgba(255,255,255,.08),
                0 12px 22px rgba(0,0,0,.46);
            filter: saturate(118%) contrast(108%);
        }
        .theme-orb:hover .orb-label{ transform: scale(1.08); }
        .theme-orb.active{ outline: 2px solid rgba(255,255,255,.18); outline-offset: 2px; }

        .tag {
            display: inline-block;
            padding: 2px 8px;
            border: 1px solid rgba(70, 90, 130, .5);
            background: linear-gradient(180deg, rgba(16, 25, 40, .7), rgba(10, 16, 28, .7));
            border-radius: 999px;
            color: var(--muted);
            font-size: 12px;
            margin-right: 6px
        }
    /* Tagging UI removed for Phase 1: reserved styles were deleted */
    /* Make saved item actions compact so tags stand out */
    .saved-item .si-actions{ gap:6px; align-items:center }
    .saved-item .si-actions .si-addtag{ width:84px; padding:6px 8px; border-radius:8px }
    .saved-item .si-main .si-meta{ margin-top:4px; font-size:12px }
    /* Compact validator choice rows used in the validation output (no extra gaps) */
    .validator-choice{ margin:0; color:var(--muted); font-size:13px }
    .validator-choice{ padding:8px; border-radius:8px; border:1px solid rgba(70,90,130,.2); background: linear-gradient(180deg, rgba(10,16,24,.45), rgba(8,12,20,.45)); }
    .validator-choice.correct{ border-color: #155e37; background: linear-gradient(180deg, rgba(17,94,55,0.12), rgba(6,30,18,0.06)); color: var(--ink); }
    .validator-choice.wrong{ border-color: #7f1d1d; background: linear-gradient(180deg, rgba(127,29,29,0.08), rgba(40,12,12,0.03)); color: var(--ink); }

        /* quiz layout */
        .quizgrid {
            display: grid;
            /* make main content take all available space and keep sidebar fixed */
            grid-template-columns: 1fr 340px;
            gap: 16px
        }

        @media (max-width: 980px) {
            .quizgrid {
                grid-template-columns: 1fr
            }
        }

        .side {
            border: 1px solid var(--stroke);
            background: linear-gradient(180deg, rgba(14, 21, 34, .65), rgba(9, 15, 26, .6));
            border-radius: 14px;
            padding: 14px;
            -webkit-backdrop-filter: blur(calc(var(--glass-blur)*.8));
            backdrop-filter: blur(calc(var(--glass-blur)*.8));
        }

        .side h3 {
            margin: 0 0 8px;
            font-size: 16px
        }

        .side label {
            display: block;
            font-size: 12px;
            color: var(--muted);
            margin: 6px 0 4px
        }

        .side input,
        .side textarea {
            width: 100%;
            background: #0b1220;
            color: var(--ink);
            border: 1px solid #22324a;
            border-radius: 10px;
            padding: 8px
        }

        .side textarea {
            height: auto; /* allow natural/flex growth */
            max-height: none;
            flex: 1 1 auto; /* fill remaining space in sidebar */
            min-height: 0; /* enable child to shrink within flex container */
            resize: none;
            overflow: auto;
        }

        /* question cards */
        .qcard {
            /* Ensure question cards expand to fill the main column and match the results width */
            display: block; width: 100%; max-width: 100%; box-sizing: border-box;
            border: 1px solid rgba(70, 90, 130, .5);
            background: linear-gradient(180deg, rgba(14, 21, 34, .65), rgba(9, 15, 26, .6));
            border-radius: 16px;
            padding: 14px;
            margin: 12px 0;
            box-shadow: var(--depth)
        }

        .choice {
            display: block;
            margin: 12px 0;
            padding: 12px;
            border: 1px solid rgba(70, 90, 130, .5);
            border-radius: 10px;
            cursor: pointer;
            background: linear-gradient(180deg, rgba(14, 20, 32, .55), rgba(10, 15, 26, .55))
        }

        .choice.correct {
            border-color: #155e37;
            background: linear-gradient(180deg, rgba(11, 30, 21, .7), rgba(6, 20, 14, .65))
        }

        .choice.wrong {
            border-color: #7f1d1d;
            background: linear-gradient(180deg, rgba(26, 15, 16, .7), rgba(18, 10, 12, .65))
        }

        .choice input {
            margin-right: 8px
        }

        /* Ensure quiz choice rows have horizontally aligned radio dots and label text */
    .qcard .choice{ display:flex; align-items:center; gap:10px; }
    /* Fine-tune vertical alignment: ensure radio orb and text block center relative to total box height */
    .qcard .choice{ line-height:1.25; }
    .qcard .choice strong{ align-self:center; }
    /* Force radio to use flexbox centering instead of baseline quirks */
    .qcard .choice input[type="radio"]{ margin-top:0; }
    /* Elevate choice rows so radios sit above sticky notes / overlays without altering layout */
    .qcard .choice{ position:relative; z-index: 5000; }
        .qcard .choice input[type="radio"]{
            /* Override global glass style for clarity and alignment within choices */
            -webkit-appearance: none; appearance: none;
            accent-color: unset !important; /* kill UA accent so no stray green appears */
            width: 20px; height: 20px; flex: 0 0 20px;
            border-radius: 50%; box-sizing: border-box;
            border: 2px solid rgba(110,150,200,.65);
            background: transparent; background-color: transparent !important; position: relative; z-index: 6000;
            box-shadow: none !important; /* keep ring crisp; override global glass shadow */
            -webkit-backdrop-filter: none !important; backdrop-filter: none !important; /* prevent darkened center from glass blur */
            transform: none !important;
            vertical-align: middle;
            align-self: center; /* ensure radio centers within the full choice box */
        }
        .qcard .choice input[type="radio"]:focus{ outline: 2px solid rgba(96,165,250,.35); outline-offset: 2px }
        /* Default checked base (before correctness classes apply). Keep neutral to avoid bleed. */
        .qcard .choice input[type="radio"]:checked{
            border-color: rgba(110,150,200,.8) !important;
            background: none !important;
            box-shadow: none !important;
        }

        /* Smooth colored inner circle for correct / wrong states */
        /* Strong, explicit checked visuals: inner white dot plus colored ring. Use !important to override any earlier generic radio styling. */
        /* CORRECT: user's selected correct -> show white center + green ring */
        .qcard .choice.correct input[type="radio"]:checked{
            border-color: var(--ok) !important;
            background-image:
                radial-gradient(circle at center, #ffffff 0 46%, rgba(255,255,255,0) 48%),
                radial-gradient(circle at center, var(--ok) 60%, var(--ok) 78%, rgba(0,0,0,0) 80%) !important;
            background-repeat: no-repeat !important;
            background-position: center !important; background-size: 100% 100% !important;
            box-shadow: none !important; filter: none !important;
        }
        /* CORRECT: the revealed correct (not selected) -> green ring with transparent center */
        .qcard .choice.correct input[type="radio"]:not(:checked){
            border-color: var(--ok) !important;
            background: radial-gradient(circle at center,
                         rgba(0,0,0,0) 0%, rgba(0,0,0,0) 56%,
                         var(--ok) 60%, var(--ok) 78%,
                         rgba(0,0,0,0) 82%) !important;
            background-color: transparent !important; background-repeat: no-repeat !important; background-position: center !important; background-size: 100% 100% !important;
        }
        .qcard .choice.wrong input[type="radio"]:checked{
            border-color: var(--bad) !important;
            /* ensure no brand/green bleed; pure red ring with white center */
            background-image:
                radial-gradient(circle at center, #ffffff 0 46%, rgba(255,255,255,0) 48%),
                radial-gradient(circle at center, var(--bad) 60%, var(--bad) 78%, rgba(0,0,0,0) 80%) !important;
            background-repeat: no-repeat !important;
            background-position: center !important; background-size: 100% 100% !important;
            box-shadow: none !important;
        }
        /* Keep the option letter on a fixed column so text lines up nicely */
            .qcard .choice strong{ width: 1.8em; display:inline-block; vertical-align: middle; white-space: nowrap; }

    /* Choice body: make the text a block-level flex child so the radio vertically centers to the box, not the text baseline */
    .qcard .choice .choice-body{ display:block; flex:1 1 auto; min-width:0; align-self: center; }

        .footer {
            margin-top: 18px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px
        }

        .progress {
            height: 10px;
            background: linear-gradient(180deg, rgba(10, 16, 28, .8), rgba(8, 12, 20, .7));
            border: 1px solid rgba(70, 90, 130, .5);
            border-radius: 999px;
            overflow: hidden;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, .35)
        }

        .progress>div {
            height: 100%;
            background: linear-gradient(90deg, var(--brand), #6ee7b7);
            width: 0%
        }

        .hidden {
            display: none
        }

        /* skipped modal */
        .overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, .55);
            display: flex;
            align-items: center;
            justify-content: center;
            /* Ensure overlays appear above very high z-index UI like .saved-card */
            z-index: 2147483650;
            /* Respect notches and home indicators */
            padding: max(8px, env(safe-area-inset-top)) max(8px, env(safe-area-inset-right)) max(8px, env(safe-area-inset-bottom)) max(8px, env(safe-area-inset-left));
        }

        .panel {
            width: min(680px, 90vw);
            max-height: 80vh; /* fallback */
            overflow: auto;
            background: #0f1726;
            border: 1px solid #223048;
            border-radius: 14px;
            padding: 16px
        }
        /* Use dynamic viewport height when supported to avoid iOS address bar jumps */
        @supports (height: 100dvh){ .panel{ max-height: 80dvh; } }

        .list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            gap: 8px
        }

        .chip {
            padding: 8px;
            border-radius: 10px;
            border: 1px solid #2a3648;
            background: #0b1220;
            text-align: center;
            cursor: pointer
        }
        /* Copy Results button placed in top-right of results card */
        #results-card { position: relative; }
        /* Ensure Finished readout sits beneath overlays/popup layers */
        .finished-summary-layer{ position: relative; z-index: 1 }
        #copyResultsBtn { position: absolute; top: 16px; right: 16px; z-index: 2200000000; transform: none; }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #3b82f6;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            vertical-align: -3px;
            margin-right: 6px
        }

        @keyframes spin {
            to {
                transform: rotate(360deg)
            }
        }
    .key-badge{display:inline-flex;align-items:center;gap:8px;font-size:13px;color:var(--muted)}
    .key-badge .dot{width:10px;height:10px;border-radius:50%;background:#7c7c7c;box-shadow:0 0 0 6px rgba(0,0,0,0.06);box-sizing:border-box;line-height:0;vertical-align:middle}
        .key-badge.ok .dot{background:var(--ok)}
        .key-badge.missing .dot{background:var(--bad)}
        .btn[disabled]{opacity:.6;cursor:not-allowed;transform:none}
    </style>
        <style>
            /* Sticky Notes Dock + Windows */
            :root{ --stickyScale: 1; --stickyTopGap: 8px; --stickyRailW: 280px; }
            .sticky-dock{ position:fixed; right: calc(12px + env(safe-area-inset-right)); top: calc(12px + env(safe-area-inset-top) + 280px + var(--topSafeArea) + var(--stickyTopGap)); z-index:190; display:flex; gap:8px; align-items:center; padding:8px 10px; border-radius:999px; border:1px solid var(--btnBorder); background: linear-gradient(180deg, rgba(16,25,40,.72), rgba(10,16,28,.72)); box-shadow: var(--depth); -webkit-backdrop-filter: blur(8px); backdrop-filter: blur(8px); transform-origin: top right; transform: scaleY(var(--stickyScale)); }
            .sticky-dock .sd-btn{ appearance:none; border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); font-weight:800; font-size:12px; padding:6px 10px; border-radius:999px; cursor:pointer }
            .sticky-dock .sd-btn.small{ font-weight:700; padding:4px 8px; font-size:11px }
            .sticky-dock .sd-btn:hover{ filter:brightness(1.06) }
            /* Panel buttons should match dock buttons (calendar header uses sd-btn too) */
            .sticky-panel .sd-btn{ appearance:none; border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); font-weight:800; font-size:12px; padding:6px 10px; border-radius:999px; cursor:pointer }
            .sticky-panel .sd-btn.small{ font-weight:700; padding:4px 8px; font-size:11px }
            .sticky-panel .sd-btn:hover{ filter:brightness(1.06) }
            .sticky-panel .sd-btn:focus-visible{ outline: 2px solid rgba(96,165,250,.28); outline-offset: 2px }
            .sticky-dock .sd-count{ min-width:20px; height:20px; border-radius:999px; background: rgba(255,255,255,.08); border:1px solid rgba(60,80,120,.45); display:inline-flex; align-items:center; justify-content:center; font-size:12px; color: var(--ink) }
            .sticky-panel{ position:fixed; right: calc(12px + env(safe-area-inset-right)); top: calc(64px + env(safe-area-inset-top) + 280px + var(--topSafeArea) + var(--stickyTopGap)); z-index:191; width: min(420px, 92vw); max-height: 50vh; overflow:auto; padding:10px; border-radius:14px; border:1px solid var(--btnBorder); background: linear-gradient(180deg, rgba(16,25,40,.92), rgba(10,16,28,.92)); box-shadow: var(--depth); transform-origin: top right; transform: scaleY(var(--stickyScale)); }
            .sticky-panel.hidden{ display:none }
            .sticky-panel .row{ display:flex; gap:8px; align-items:center }
            .sticky-panel .sd-input{ flex:1 1 auto; height:32px; border-radius:10px; background:#0c1526; color:var(--ink); border:1px solid var(--btnBorder); padding:6px 10px; font-size:12px }
            #sdClose.sd-btn.small{ width:28px; height:28px; padding:0; border-radius:50%; font-size:16px; line-height:26px; text-align:center; font-weight:900 }
            /* Calendar header icon buttons (prev/next/close) */
            #calPrev.sd-btn.small, #calNext.sd-btn.small, #calClose.sd-btn.small{
                width:28px;
                height:28px;
                padding:0;
                border-radius:50%;
                font-size:18px;
                line-height:1;
                text-align:center;
                font-weight:900;
                display:flex;
                align-items:center;
                justify-content:center;
                -webkit-font-smoothing: antialiased;
            }
            .sticky-list{ margin-top:8px; display:flex; flex-direction:column; gap:8px }
            .sticky-item{ display:flex; gap:8px; align-items:center; padding:8px; border:1px solid rgba(60,80,120,.35); border-radius:10px; background: linear-gradient(180deg, rgba(14,20,32,.55), rgba(10,16,28,.55)); cursor:pointer }
            .sticky-item:hover{ filter:brightness(1.05) }
            .sticky-dot{ width:12px; height:12px; flex: 0 0 12px; aspect-ratio: 1 / 1; display:inline-block; border-radius:50%; border:1px solid rgba(255,255,255,.12) }
            .sticky-meta{ color: var(--muted); font-size:11px }
            /* Note window */
            .sticky-note{ position:fixed; z-index:195; width:260px; min-width:180px; min-height:160px; border-radius:12px; box-shadow: 0 10px 24px rgba(0,0,0,.45); border:1px solid rgba(60,80,120,.45); background: #121a2a; display:flex; flex-direction:column; overflow:hidden }
            .sticky-note.min{ height:auto }
            /* When a note is clipped into the left magnet (slot 4), lower it to the rail plane so quiz UI (>=8000) clears above */
            .sticky-note[data-sticky-slot="4"]{ z-index:188 !important; }
            .sticky-head{ display:flex; align-items:center; justify-content:space-between; gap:8px; padding:8px 10px; cursor:grab; -webkit-user-select:none; user-select:none; background: linear-gradient(180deg, var(--btnTop), rgba(12,20,34,.65)); border-bottom:1px solid var(--btnBorder) }
            .sticky-title{ flex:1 1 auto; min-width:0; font-size:12px; font-weight:800; color: var(--ink); outline:none; background: transparent; border:0 }
            .sticky-actions{ display:flex; gap:6px; align-items:center; flex-shrink:0; white-space:nowrap }
            .sticky-actions .sa{ appearance:none; border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); font-weight:800; font-size:11px; padding:4px 8px; border-radius:8px; cursor:pointer }
            /* Aesthetic close button: compact circular × */
            .sticky-actions .sa[data-act="close"]{ width:22px; height:22px; padding:0; border-radius:50%; font-size:14px; line-height:20px; text-align:center; font-weight:900; }
            .sticky-actions .sa[data-act="close"]:hover{ filter:brightness(1.1) }
            .sticky-body{ flex:1 1 auto; display:flex }
            .sticky-text{ flex:1 1 auto; padding:8px 10px; border:0; outline:none; resize:none; color: var(--ink); background: linear-gradient(180deg, rgba(16,25,40,.82), rgba(10,16,28,.82)) }
            .sticky-resize{ position:absolute; right:6px; bottom:6px; width:12px; height:12px; cursor:nwse-resize; opacity:.7 }
            .sticky-resize::after{ content:""; position:absolute; inset:0; background: linear-gradient(135deg, rgba(233,240,247,.9) 0 2px, transparent 2px), linear-gradient(135deg, rgba(233,240,247,.6) 0 1px, transparent 1px); background-size: 100% 100%, 70% 70%; background-repeat:no-repeat }
            .sticky-color{ display:flex; gap:6px; align-items:center }
            .sticky-color .dot{ width:12px; height:12px; flex:0 0 12px; aspect-ratio:1 / 1; border-radius:50%; border:1px solid rgba(255,255,255,.12); cursor:pointer }
            /* color themes */
            .c-yellow{ background: #1e1a05; border-color: #635d2a }
            .c-green{ background: #0d1f14; border-color: #25573c }
            .c-pink{ background: #261320; border-color: #6a314f }
            .c-sky{ background: #0e1e2a; border-color: #2d5876 }
            .c-lav{ background: #1a162a; border-color: #4b3a7a }

            /* Calendar panel (docked with sticky UI) */
            .calendar-panel{ width: min(480px, 92vw); max-height: 62vh; overflow:auto }
            .calendar-panel .cal-head{ display:flex; align-items:center; gap:6px }
            .calendar-panel .cal-month{ flex:1 1 auto; text-align:center; font-weight:900; letter-spacing:.2px; color: var(--ink); font-size:13px }
            .calendar-panel .cal-sub{ display:none }
            .calendar-panel .cal-grid{ margin-top:10px; display:grid; grid-template-columns: repeat(7, 1fr); gap:6px; align-items:stretch }
            .calendar-panel .cal-dow{ text-align:center; font-size:11px; color: var(--muted); padding:4px 0; border-radius:8px; background: rgba(255,255,255,.03); border:1px solid rgba(60,80,120,.22) }
            .calendar-panel .cal-empty{ aspect-ratio: 1 / 1; border-radius: 10px; background: rgba(255,255,255,.02); border:1px dashed rgba(60,80,120,.18) }
            .calendar-panel .cal-day{ appearance:none; text-align:left; aspect-ratio: 1 / 1; border-radius: 12px; padding:8px; cursor:pointer; position:relative;
                border:1px solid rgba(60,80,120,.35);
                background: linear-gradient(180deg, rgba(14,20,32,.55), rgba(10,16,28,.55));
                box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
                color: var(--ink);
                display:flex; flex-direction:column; gap:6px; justify-content:flex-start;
                transition: filter .12s ease, transform .12s ease, border-color .12s ease;
                /* Critical: allow grid items to shrink below content size so long text can never resize the grid */
                min-width: 0;
                min-height: 0;
                overflow: hidden;
            }
            .calendar-panel .cal-day:hover{ filter:brightness(1.06) }
            .calendar-panel .cal-day:active{ transform: translateY(1px) }
            .calendar-panel .cal-day .n{ font-weight:900; font-size:12px; line-height:1 }
            .calendar-panel .cal-day .cal-title{
                position:absolute;
                left:8px;
                right:8px;
                bottom:8px;
                font-size:10px;
                line-height:1.15;
                font-weight:800;
                color: var(--muted);
                overflow: hidden;
                display: -webkit-box;
                -webkit-box-orient: vertical;
                -webkit-line-clamp: 2;
                line-clamp: 2;
                white-space: normal;
                pointer-events: none;
                -webkit-user-select: none;
                user-select: none;
            }
            /* Minimal: do not show note text inside cells (prevents any layout growth) */
            .calendar-panel .cal-day .p{ display:none }
            .calendar-panel .cal-day.has-note::after{ content:''; position:absolute; right:10px; top:10px; width:7px; height:7px; border-radius:50%; background: var(--brand); box-shadow: 0 0 12px var(--brand); opacity:.95 }
            .calendar-panel .cal-day.today{ outline: 2px solid rgba(96,165,250,.28); outline-offset: 2px }
            .calendar-panel .cal-day.selected{
                border-color: rgba(60,80,120,.55);
                background: linear-gradient(180deg, rgba(14,20,32,.55), rgba(10,16,28,.55));
                box-shadow: inset 0 1px 0 rgba(255,255,255,.06), 0 0 0 1px rgba(96,165,250,.18);
            }
            .calendar-panel .cal-editor{ margin-top:10px; padding-top:10px; border-top:1px solid rgba(60,80,120,.28); display:flex; flex-direction:column; gap:8px }
            .calendar-panel .cal-editor .cal-row{ display:flex; gap:8px; align-items:center }
            .calendar-panel .cal-editor .cal-row-left{ flex:1 1 auto; min-width:0; display:flex; gap:8px; align-items:center }
            .calendar-panel .cal-selected{ flex:0 0 auto; font-weight:900; font-size:12px; color: var(--ink); min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap }
            .calendar-panel .cal-title-input{
                flex: 1 1 220px;
                min-width: 120px;
                max-width: 320px;
                height: 30px;
                border-radius: 10px;
                background:#0c1526;
                color: var(--ink);
                border:1px solid var(--btnBorder);
                padding: 6px 10px;
                font-size:12px;
                font-weight:800;
                outline:none;
                box-sizing:border-box;
            }
            .calendar-panel .cal-title-input:focus{ outline: 2px solid rgba(96,165,250,.28); outline-offset: 2px }
            .calendar-panel .cal-title-input:disabled{ opacity:.55 }
            .calendar-panel .cal-note{ width:100%; height: 110px; min-height: 110px; max-height: 110px; resize: none; overflow:auto; border-radius: 12px; background:#0c1526; color: var(--ink); border:1px solid var(--btnBorder); padding:10px 10px; font-size:12px; line-height:1.35; outline:none; box-sizing:border-box }
            .calendar-panel .cal-note:focus{ outline: 2px solid rgba(96,165,250,.28); outline-offset: 2px }
        </style>

    <style>
    /* UI lock while TOS not accepted */
    .tos-overlay{ position:fixed; inset:0; background: rgba(2,6,12,0.55); -webkit-backdrop-filter: blur(4px); backdrop-filter: blur(4px); z-index:22000; display:flex; align-items:center; justify-content:center; }
    .tos-overlay.hidden{ display:none }
    .tos-unlock-panel{ background: linear-gradient(180deg, rgba(8,12,18,.98), rgba(6,10,14,.98)); border:1px solid rgba(255,255,255,0.04); padding:18px; border-radius:12px; max-width:520px; color:var(--ink); box-shadow: 0 12px 40px rgba(0,0,0,0.6); }
    .tos-unlock-panel p{ color:var(--muted); font-size:13px; margin:0 0 12px }
    .tos-unlock-text{ color:var(--muted); font-size:13px; margin:0 0 12px }
    .tos-unlock-actions{ display:flex; gap:10px; justify-content:center }
    /* Use a root class so we can selectively keep TOS buttons active */
    .tos-locked * { pointer-events: none !important; }
    /* Keep only the TOS unlock overlay and the modal interactive while locked */
    .tos-locked #tosOverlay .tos-unlock-panel,
    .tos-locked #tosOverlay .tos-unlock-panel *,
    .tos-locked #tosModal,
    .tos-locked #tosModal * { pointer-events: auto !important; }
    .tos-locked .page, .tos-locked .card, .tos-locked .api-key-bar, .tos-locked .card.pad { filter: blur(4px) brightness(.96); }
    </style>

    <style>
    /* TOS box styles */
    .tos-box{ margin-top:12px; margin-bottom:12px; }
    .tos-box .muted{ color:var(--muted); }
    .tos-box .btn.small{ padding:6px 8px; font-size:12px }
    .tos-box .flex { align-items:center }
    .tos-box .muted strong{ color:inherit }
    .tos-box .right{ margin-left:auto }
    </style>
        <style>
            /* Sticky rail on the right with 5 clip slots */
            .sticky-rail{ position:fixed; top: calc(var(--topSafeArea) + var(--stickyTopGap)); bottom: 0; right: calc(12px + env(safe-area-inset-right)); z-index:189; display:flex; flex-direction:column; gap:10px; pointer-events:none; padding-bottom: 8px; transform-origin: top right; transform: scaleY(var(--stickyScale)); }
            .clip-slot{ width: var(--stickyRailW); min-height: 120px; flex: 1 1 0; border-radius: 12px; border:1px dashed rgba(100,130,180,.55); background: linear-gradient(180deg, rgba(16,25,40,.55), rgba(10,16,28,.55)); box-shadow: inset 0 0 0 1px rgba(255,255,255,.04); opacity:.9; transition: filter .12s ease; pointer-events:none }
            .clip-slot:hover{ filter: brightness(1.06) }
            .clip-slot.slot-hover{ outline: 2px solid var(--brand); outline-offset: 2px }
            .clip-slot.occupied{ border: none; opacity:.94 }
            /* colored outlines to match sticky note color */
            .clip-slot.c-yellow{ outline: 2px solid #635d2a; outline-offset: 2px }
            .clip-slot.c-green{ outline: 2px solid #25573c; outline-offset: 2px }
            .clip-slot.c-pink{ outline: 2px solid #6a314f; outline-offset: 2px }
            .clip-slot.c-sky{ outline: 2px solid #2d5876; outline-offset: 2px }
            .clip-slot.c-lav{ outline: 2px solid #4b3a7a; outline-offset: 2px }
            /* Left-side single magnet tab (between top controls and radio) */
            :root{ --leftTabW: 260px; }
            #leftMagnet{ position:fixed; left: calc(12px + env(safe-area-inset-left)); top: 180px; height: 240px; width: var(--leftTabW); z-index:188; pointer-events:none; border-radius: 12px; border:1px dashed rgba(100,130,180,.55); background: linear-gradient(180deg, rgba(16,25,40,.55), rgba(10,16,28,.55)); box-shadow: inset 0 0 0 1px rgba(255,255,255,.04); opacity:.9 }
            #leftMagnet.slot-hover{ outline: 2px solid var(--brand); outline-offset: 2px }
            #leftMagnet.occupied{ border:none; opacity:.94 }
            /* Hoverzone + resizer to expand the magnet width (mirror of right-rail control) */
            .left-tab-hoverzone{ position:fixed; z-index:210; pointer-events:auto; opacity:0; width:40px; height:60px; left: calc(12px + env(safe-area-inset-left) + var(--leftTabW) + 8px); top: 50%; transform: translateY(-50%); }
            .left-tab-resizer{ position:fixed; z-index:211; width:28px; height:28px; border-radius:50%; border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); cursor: ew-resize; display:flex; align-items:center; justify-content:center; left: calc(12px + env(safe-area-inset-left) + var(--leftTabW) + 8px); top: 50%; transform: translateY(-50%); box-shadow: var(--depth); opacity:0; transition: opacity .15s ease, filter .12s ease; }
            .left-tab-resizer::before{ content:'\2192'; /* right arrow */ font-weight:900; font-size:14px; line-height:1; }
            .left-tab-hoverzone:hover + .left-tab-resizer{ opacity:1 }
            .left-tab-resizer:hover, .left-tab-resizer:focus{ opacity:1; filter:brightness(1.06) }
            html.booting #leftMagnet, html.booting .left-tab-resizer{ pointer-events:none; opacity:.85 }
        </style>
        <style>
            /* Boot overlay */
                .boot-overlay{ position:fixed; inset:0; z-index:99999; display:flex; align-items:center; justify-content:center; 
                    /* Palette-aware ambient */
                    background:
                        linear-gradient(180deg, rgba(0,0,0,.55), rgba(0,0,0,.55)),
                        radial-gradient(800px 500px at 20% 25%, var(--glow1), transparent 70%),
                        radial-gradient(700px 450px at 80% 30%, var(--glow2), transparent 75%),
                        radial-gradient(650px 420px at 50% 85%, var(--glow3), transparent 75%);
                    -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px); opacity:1; transition: opacity .6s ease; }
            .boot-overlay.hidden{ opacity:0; pointer-events:none; }
                        .boot-card{ text-align:center; max-width: min(760px, 92vw); padding: 20px; border-radius: 16px; border: 1px solid var(--btnBorder); 
                            /* fallback gradient */
                            background: linear-gradient(180deg, rgba(16,25,40,.55), rgba(10,16,28,.55));
      
                            /* If supported, gently blend brand button colors */
                            background: linear-gradient(180deg, color-mix(in srgb, var(--btnTop) 70%, transparent), color-mix(in srgb, var(--btnBottom) 70%, transparent));
                            box-shadow: var(--depth); }
                .boot-ascii{ text-align:center; margin: 0 0 4px; overflow: hidden; }
                .boot-ascii pre{ display:inline-block; width:max-content; min-width:max-content; max-width:100%; margin:0; padding:0; color: var(--ink); white-space: pre; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace; font-size: clamp(10px, 1.8vw, 18px); line-height: 1.03; letter-spacing: 0; text-shadow: 0 1px 0 rgba(0,0,0,.35); overflow: hidden; transform-origin: left top; }
                /* Slightly reduce bottom spacing under the big ASCII title to make room for animation */
                .boot-ascii pre{ display:inline-block; width:max-content; min-width:max-content; max-width:100%; margin:0 0 6px 0; padding:0; color: var(--ink); white-space: pre; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace; font-size: clamp(10px, 1.8vw, 18px); line-height: 1.03; letter-spacing: 0; text-shadow: 0 1px 0 rgba(0,0,0,.35); overflow: hidden; transform-origin: left top; }
                .boot-ascii pre::-webkit-scrollbar{ width:0; height:0 }
            .boot-sub{ color: var(--muted); font-size: clamp(12px, 3.4vw, 14px); margin-top: 18px; min-height: 1.4em; }
            .boot-phrase{ color: var(--ink); font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace; font-size: clamp(12px, 3.2vw, 16px); line-height: 1.35; min-height: 2.2em; opacity: 0; transition: opacity .35s ease; margin-top: 8px; white-space: normal; }
            .boot-phrase.show{ opacity: 1; }
            .spinner.lg{ width:28px; height:28px; border-width:3px; margin: 10px auto 0; display:inline-block }
                /* Spinner matches active brand */
                .boot-overlay .spinner{ border-color: var(--brand); border-top-color: transparent; }
                /* Hide page scrollbars while booting */
                html.booting, body.booting{ overflow: hidden !important; height: 100%; }

                /* While booting we keep sticky UI visible but non-interactive so the overlay feels modal
                   This leaves notes/dock/rail/title in the visual background but prevents pointer/focus interactions */
                html.booting .sticky-dock,
                html.booting .sticky-panel,
                html.booting .sticky-rail,
                html.booting .sticky-note,
                html.booting #stickyTitleBox {
                    /* Keep visible (no opacity change) but disable pointer and selection */
                    pointer-events: none !important;
                    -webkit-user-select: none !important;
                    user-select: none !important;
                    transform: translateY(6px) scale(.995);
                    transition: transform .18s ease;
                }
            @media (max-width: 640px){ .boot-card{ padding: 16px; } }
        </style>
        <style>
            /* Sticky rail resizer handle */
            .sticky-rail-resizer{
                position:fixed; z-index:211; width:28px; height:28px; border-radius:50%;
                border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom));
                color: var(--ink); cursor: ew-resize; display:flex; align-items:center; justify-content:center;
                right: calc(12px + env(safe-area-inset-right) + var(--stickyRailW) + 8px);
                top: 50%; transform: translateY(-50%);
                box-shadow: var(--depth);
                opacity: 0; transition: opacity .15s ease, filter .12s ease;
            }
            .sticky-rail-resizer::before{ content:'\2190'; /* left arrow */ font-weight:900; font-size:14px; line-height:1; }
            .sticky-rail-resizer:hover{ filter: brightness(1.06); opacity: 1; }
            .sticky-rail-resizer:active{ filter: brightness(1.1); }
            .sticky-rail-resizer:focus{ outline: 2px solid var(--brand); outline-offset: 2px; }
            /* Hide when boot overlay sets inert visuals to avoid confusing focus layering */
            html.booting .sticky-rail-resizer{ pointer-events:none; opacity:.85; transform: translateY(calc(-50% + 6px)) scale(.995); }
            /* Hover zone to reveal resizer */
            .sticky-rail-hoverzone{ position:fixed; z-index:210; pointer-events:auto; opacity:0; width:40px; height:60px; right: calc(12px + env(safe-area-inset-right) + var(--stickyRailW) + 8px); top: 50%; transform: translateY(-50%); }
            .sticky-rail-hoverzone:hover + .sticky-rail-resizer{ opacity: 1; }
            .sticky-rail-resizer:hover, .sticky-rail-resizer:focus{ opacity: 1; }
            /* small fixed-size ASCII animation area that matches spinner footprint */
            /* Wider boot ascii anim so five characters fit comfortably */
            .boot-ascii-anim{ display:inline-block; width:140px; height:48px; margin: 10px auto 0; text-align:center; font-family: ui-monospace, 'Courier New', monospace; font-size:28px; line-height:44px; letter-spacing:-0.5px; color:var(--muted); overflow:hidden }
            /* Ancient glyph styling (red, glowing) for special sprinkle frames */
            .boot-ascii-anim .ancient{ color:#ff5a5a; text-shadow: 0 0 4px rgba(255,75,75,.9), 0 0 8px rgba(255,75,75,.6); font-weight:800 }
            /* Fixed-width slot styling so glyphs and dots align exactly */
            .boot-ascii-anim{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace; font-variant-ligatures: none; }
            .boot-ascii-anim .slot{ display:inline-block; width:1ch; min-width:1ch; text-align:center; line-height:14px; vertical-align:middle; }
            .boot-ascii-anim .empty{ color: transparent }
            /* Flip-clock digits (text-only) */
            .boot-ascii-anim .digits{ display:inline-block; }
            .boot-ascii-anim .digits{ display:flex; justify-content:space-between; align-items:center; width:100%; box-sizing:border-box }
            .boot-ascii-anim .digit{ display:inline-flex; flex:0 0 20%; max-width:20%; box-sizing:border-box; justify-content:center; align-items:center; text-align:center; line-height:44px; vertical-align:middle; transform-origin: center top; transition: transform .14s ease; font-variant-numeric: tabular-nums; white-space:nowrap }
            .boot-ascii-anim .digit.ancient{ /* use symbol-capable fonts so glyphs render consistently */
                font-family: 'Segoe UI Historic', 'Noto Sans Symbols2', 'Segoe UI Symbol', serif; 
                font-weight:900; font-size:30px; line-height:44px; justify-content:center; display:inline-flex; }
            .boot-ascii-anim .digit.flip{ transform: rotateX(-90deg); }
        </style>
                <style>
                    /* Hide only the root page scrollbar; preserve inner scrollbars */
                    html, body { -ms-overflow-style: none; }
                    html::-webkit-scrollbar, body::-webkit-scrollbar { width: 0 !important; height: 0 !important; }
                </style>
    <style>
      /* ASCII title banner */
    .ascii-title{ text-align:center; margin: 10px 0; overflow: hidden; -webkit-user-select:none; user-select:none; }
      .ascii-title pre{
          display:block; width:100%; margin:0; padding:0; border-radius:0;
          border: none; background: transparent; box-shadow: none;
          color: var(--ink);
          font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace;
          font-size: clamp(10px, 1.6vw, 20px); line-height: 1.03;
          letter-spacing: .3px;
          text-shadow: 0 1px 0 rgba(0,0,0,.35);
          white-space: pre; /* preserve exact ASCII */
          overflow: hidden; /* hide scrollbars entirely */
          overscroll-behavior: contain; /* avoid overscroll glow */
      }
      /* WebKit hide scrollbars on banner */
      #asciiBanner::-webkit-scrollbar { width: 0; height: 0; }
  /* Global API key bar above the main module */
    .api-key-bar {
        width: 100%;
        box-sizing: border-box;
    margin: 0 0 12px 0;
        padding: 10px 12px;
    border: 1px solid rgba(60,80,120,.35);
    border-radius: 12px;
    background: linear-gradient(180deg, rgba(16,25,40,.70), rgba(10,16,28,.70));
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        backdrop-filter: blur(8px);
            display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
  }
        .api-key-bar input[type="password"]{
                            flex: 1 0 520px; min-width: 320px; padding: 8px 10px; border-radius: 10px;
    border: 1px solid #22324a; background:#0b1220; color: var(--ink);
  }

            /* Paste area: center the action button under the textarea */
            .paste-wrap{ display:flex; flex-direction:column; align-items:center; gap:10px; }
            .paste-wrap .index-btn{ margin: 0 auto; padding:8px 12px; border-radius:10px; background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); border:1px solid var(--btnBorder); color:var(--ink); font-weight:700; cursor:pointer }
            .paste-wrap .index-btn.saved{ background: linear-gradient(180deg, rgba(60,160,120,0.12), rgba(30,120,80,0.12)); }
        @media (max-width: 760px){
            .api-key-bar input[type="password"]{ flex: 1 1 100%; min-width: 0; width: 100%; }
            .api-key-bar .spacer{ display:none }
        }
    .api-key-dot{width:12px;height:12px;border-radius:50%;display:inline-block;margin-right:0;background:#7c7c7c;box-shadow:0 0 0 6px rgba(0,0,0,0.06);box-sizing:border-box;line-height:0;vertical-align:middle}
    .api-key-dot.ok{background:var(--ok)}
    .api-key-dot.missing{background:var(--bad)}
  .api-key-bar label{ font-size:12px; color: var(--muted); display:flex; gap:6px; align-items:center }
    .api-key-bar .spacer{ flex:1 1 auto }
            /* Redesigned toggle switch: transform-centered knob to avoid misalignment */
            .switch{ --sw-w: 42px; --sw-h: 22px; --knob: 16px; --pad: 3px; display:inline-flex; align-items:center; gap:6px; cursor:pointer; -webkit-user-select:none; user-select:none; flex: 0 0 auto; white-space: nowrap }
            .switch input{ display:none }
            .switch .slider{
                position: relative; width: var(--sw-w); height: var(--sw-h); border-radius: 999px; box-sizing: border-box;
                background: rgba(60,80,120,.45); border: 1px solid rgba(60,80,120,.65);
                box-shadow: inset 0 1px 2px rgba(0,0,0,.25);
                transition: background .15s ease, border-color .15s ease;
            }
            .switch .slider::after{
                content:''; position:absolute; top: 50%; left: calc(var(--pad) + var(--knob)/2);
                width: var(--knob); height: var(--knob); border-radius:50%; box-sizing: border-box; transform: translate(-50%, -50%);
                background:#e9f0f7; box-shadow: 0 1px 2px rgba(0,0,0,.35);
                transition: left .15s ease, background .15s ease;
            }
            .switch input:checked + .slider{ background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); border-color: var(--btnBorder); }
            .switch input:checked + .slider::after{ left: calc(var(--sw-w) - var(--pad) - var(--knob)/2); }
            .switch:focus-within .slider{ outline: 2px solid rgba(96,165,250,.35); outline-offset: 2px; }

  /* Optional .docx/.pdf generator panel */
  .ai-file-panel{
        margin-top: 10px;
        padding: 8px 8px 4px 8px;
    border: 1px solid rgba(60,80,120,.35);
    border-radius: 12px;
    background: linear-gradient(180deg, rgba(16,25,40,.65), rgba(10,16,28,.65));
        max-width: 100%;
            overflow-x: hidden; /* never overflow parent width */
            overflow-wrap: anywhere;
            word-break: break-word;
        /* Let this panel expand to fill remaining column height so both columns align at the bottom */
        flex: 1 1 auto;
        min-height: 430px;
        max-height: none;
        /* Allow internal scrolling when content exceeds available height */
        /* Use flex layout so inner elements can size correctly and the log can stretch */
        display: flex;
        flex-direction: column;
  }
    /* Inline AI fixer panel (left column) */
    .ai-fix-panel{
        margin-top: 10px;
        padding: 12px;
        border: 1px solid var(--btnBorder);
        border-radius: 12px;
        background: linear-gradient(180deg, rgba(16,25,40,.70), rgba(10,16,28,.70));
        -webkit-backdrop-filter: blur(calc(var(--glass-blur)*.6));
        backdrop-filter: blur(calc(var(--glass-blur)*.6));
        width: 100%;
    }
    #aiFixPanel .btn-wide{ min-width: 260px; }
    .ai-file-row{ display:flex; flex-wrap:wrap; gap:12px; align-items:center }
    .ai-file-row > * { flex: 0 1 auto }
    /* Make all controls in the AI file row a consistent height and allow them to shrink/wrap
       so number-entry controls don't force overflow. Number inputs are compact and centered. */
    .ai-file-row .btn, .ai-file-row .btn.small, .ai-file-row .pill, .ai-file-row .file-input .choose-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        height: 36px;
        min-height: 36px;
        line-height: 1;
        padding-top: 0; padding-bottom: 0;
        box-sizing: border-box;
    }
    /* Make numeric entry compact and consistent with buttons */
    .ai-file-row input[type="number"], .ai-file-row input[type="number"].themed-input {
        height: 30px;
        min-height: 30px;
        line-height: 1;
        padding: 4px 8px;
        width: 52px; /* small fixed width for neat alignment */
        min-width: 44px;
        max-width: 84px;
        text-align: center;
        border-radius: 8px;
        box-sizing: border-box;
        flex: 0 0 auto;
    }
    /* Allow the large primary generate button to shrink on narrow viewports but keep height consistent */
    .ai-file-row #aiFileGenBtn, .ai-file-row #aiFileGenBtn.ai-fixed { height: 36px; min-height:36px; }
    /* On small screens let controls stack/wrap and let the main button grow to full width */
    @media (max-width: 760px){
        .ai-file-row .btn { flex: 1 1 auto; }
        .ai-file-row .ai-file-status{ flex: 1 1 100%; min-width: 140px }
    }
    /* Keep status column from changing width as messages update */
    .ai-file-status{ color: var(--muted); font-size: 13px; min-width: 240px; width: 240px; max-width: 240px; overflow:hidden; text-overflow: ellipsis; white-space: nowrap }
    /* Ensure filename truncates and does not push layout */
        .file-input{ display:flex; align-items:center; gap:8px; min-width: 0 }
        .file-input .filename{ flex:1 1 auto; overflow:hidden; white-space:nowrap; text-overflow:ellipsis; min-width: 0; max-width: 100% }
        @media (max-width: 760px){
            #aiFileGenBtn{ flex: 1 1 auto; width:auto; max-width:100% }
            .ai-file-status{ width:auto; min-width:160px; flex: 0 0 160px }
        }
    /* Clean scrollbars */
    /* Remove non-standard scrollbar props in Chrome/Safari; keep WebKit track/thumb below */
    *::-webkit-scrollbar { width: 10px; height: 10px; }
    *::-webkit-scrollbar-track { background: rgba(20,28,44,.6); border-radius: 8px; }
    *::-webkit-scrollbar-thumb {
        background: linear-gradient(180deg, rgba(110,150,200,.55), rgba(70,100,160,.55));
        border-radius: 8px;
        border: 1px solid rgba(40,60,90,.5);
    }

        /* Utility classes used to replace inline styles */
        .mt-0{ margin-top:0 }
        .mt-4{ margin-top:4px }
        .mt-6{ margin-top:6px }
        .mt-8{ margin-top:8px }
        .mt-10{ margin-top:10px }
        .mt-12{ margin-top:12px }
        .mb-6{ margin-bottom:6px }
        .mb-8{ margin-bottom:8px }
        .ml-6{ margin-left:6px }
        .ml-8{ margin-left:8px }
        .fs-12{ font-size:12px }
        .fs-14{ font-size:14px }
        .muted{ color: var(--muted) }
        .text-center{ text-align:center }
        .flex{ display:flex }
        .col{ display:flex; flex-direction:column }
        .center{ justify-content:center; align-items:center }
        .gap-8{ gap:8px }
        .gap-12{ gap:12px }
        .justify-between{ justify-content:space-between }
        .justify-start{ justify-content:flex-start }
        .justify-end{ justify-content:flex-end }
        .flex-1{ flex:1 1 auto }
        .flex-1-260{ flex:1 1 260px }
        .minh-320{ min-height:320px }
        .maxw-600{ max-width:600px }
        .maxw-420{ max-width:420px }
        .w-100{ width:100% }
        .btn-wide{ min-width:260px }

        /* Component blocks previously inline-styled */
        #aiValidateOutput2, #resultsAiOutput{
            white-space:pre-wrap;background:#071022;padding:12px;border-radius:10px;border:1px solid #22324a;min-height:36px;color:var(--ink);
            text-align:left;width:100%;box-sizing:border-box;overflow:auto
        }
        #aiPreviewContent{
            white-space:pre-wrap;background:#071022;padding:10px;border-radius:8px;border:1px solid #22324a;max-height:30vh;overflow:auto;margin-top:10px;color:var(--ink)
        }
        #aiFileDebug{
            margin:8px 0 4px 0;
            background:#071022;
            padding:8px;
            border-radius:8px;
            border:1px solid #22324a;
            /* Fixed-height log area: never grows past its bounds; scroll internally */
            height: 140px;
            min-height: 140px;
            max-height: 140px;
            flex: 0 0 140px; /* in case parent is flex */
            overflow-y: auto;
            overflow-x: hidden;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace;
            font-size:12px; color:var(--muted); width:100%; max-width:100%; box-sizing:border-box;
            white-space:pre-wrap; overflow-wrap:anywhere; word-break:break-word;
        }

        /* Tighten the gap between the log box and the upload helper text inside the AI file panel */
        .ai-file-panel .hint.mt-6{ margin-top: 4px; }
        #resultsAiOutput{
            display: flex;
            flex-direction: column;
            gap: 10px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace;
            white-space: pre-wrap;
            width: 100%;
            height: 100%;
            min-height: 220px; /* moderate baseline so columns remain balanced */
            max-height: calc(100vh - 320px);
            margin-top: 4px;
            box-sizing: border-box;
        }
    *::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(180deg, rgba(130,170,220,.65), rgba(90,120,180,.65));
    }
    /* Stabilize the AI file gen button width to prevent row reflow on label changes */
    #aiFileGenBtn.ai-fixed { width: 360px; max-width: 360px; flex: 0 0 360px; overflow:hidden }
    .ai-file-panel * { max-width: 100%; box-sizing: border-box }
</style>
    <style>
        /* Bottom-left Ambient Radio Player */
    #radioPlayer{ --rpClockGap: 18px; position:fixed; left: calc(12px + env(safe-area-inset-left)); bottom: calc(12px + env(safe-area-inset-bottom) + var(--rpRaise, 0px)); z-index:2200; width: 320px; max-width: 92vw; display:flex; flex-direction: column; gap:8px; padding:10px 12px; box-sizing:border-box;
        /* Ensure the radio player paints above sticky notes and doesn't affect layout
           by creating a local stacking context and promoting to its own layer. */
        isolation: isolate;
        will-change: transform, opacity;
        transform: translateZ(0);
        pointer-events: auto;
            background: linear-gradient(180deg, rgba(16,24,38,.9), rgba(10,16,28,.85)); border: 1px solid var(--btnBorder); border-radius: 14px; box-shadow: var(--depth); -webkit-backdrop-filter: blur(10px); backdrop-filter: blur(10px);
        }
    #radioPlayer .rp-btn{ appearance:none; border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); font-weight:700; font-size:12px; padding:6px 10px; border-radius:8px; cursor:pointer; line-height:1 }
        #radioPlayer .rp-btn:hover{ filter: brightness(1.06) }
    #radioPlayer .rp-btn.small{ font-size:11px; padding:4px 8px }
        #radioPlayer .rp-select{ height: 30px; border-radius: 8px; background: #0c1526; color: var(--ink); border:1px solid var(--btnBorder); padding:4px 8px; font-size:12px; flex: 1 1 auto; min-width: 120px }
    #radioPlayer .rp-vol{ flex: 1 1 120px; min-width: 60px; max-width: 100%; height: 6px; appearance: none; background: linear-gradient(90deg, var(--brand) 0%, var(--brand) var(--rpVolPercent, 40%), rgba(255,255,255,0.15) var(--rpVolPercent, 40%), rgba(255,255,255,0.15) 100%); border-radius: 999px; outline: none; accent-color: var(--brand) }
    /* WebKit */
    #radioPlayer .rp-vol::-webkit-slider-runnable-track{ height:6px; background: transparent; border-radius:999px }
    #radioPlayer .rp-vol::-webkit-slider-thumb{ -webkit-appearance:none; appearance:none; width:14px; height:14px; background: var(--ink); border:2px solid var(--brand); border-radius:50%; margin-top:-4px; box-shadow: 0 0 6px rgba(106,169,255,.35) }
    #radioPlayer.playing .rp-vol::-webkit-slider-thumb{ box-shadow: 0 0 8px var(--brand) }
    /* Firefox */
    #radioPlayer .rp-vol::-moz-range-track{ height:6px; background: rgba(255,255,255,0.15); border-radius:999px }
    #radioPlayer .rp-vol::-moz-range-progress{ height:6px; background: var(--brand); border-radius:999px }
    #radioPlayer .rp-vol::-moz-range-thumb{ width:14px; height:14px; background: var(--ink); border:2px solid var(--brand); border-radius:50% }
        #radioPlayer .rp-meta{ min-height: 16px }
        #radioPlayer #rpNow{ color: var(--muted); font-size: 12px; white-space: nowrap; text-overflow: ellipsis; overflow: hidden }
        /* Broadcasting subtext */
        #radioPlayer #rpCast{ color: var(--muted); font-size: 12px }
    /* Keep YouTube audio player from affecting layout */
    /* YouTube container removed */
    /* Generic attempt select styling */
    .attempt-select{ min-width: 160px; height: 34px; border-radius: 10px; padding: 6px 12px; background: linear-gradient(180deg, var(--btnTop), rgba(10,16,28,.72)); color: var(--ink); border: 1px solid var(--btnBorder); box-shadow: inset 0 1px 0 rgba(255,255,255,.06); font-weight: 600 }
    .attempt-select:focus{ outline: 2px solid rgba(96,165,250,.35); outline-offset: 2px }
    /* Subtle custom chevron (no asset) */
    select.attempt-select{ -webkit-appearance: none; -moz-appearance: none; appearance: none; background-position: right 12px center, 0 0; background-repeat: no-repeat; padding-right: 32px }
    select.attempt-select{
        background-image:
            linear-gradient(45deg, rgba(233,240,247,.9) 50%, transparent 50%),
            linear-gradient(-45deg, rgba(233,240,247,.9) 50%, transparent 50%),
            linear-gradient(180deg, rgba(255,255,255,.18), rgba(255,255,255,0));
        background-size: 8px 8px, 8px 8px, 100% 100%;
        background-position: calc(100% - 18px) 48%, calc(100% - 12px) 48%, 0 0;
    }
    /* Custom attempts dropdown (styled open list) */
    .visually-hidden{ position:absolute !important; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0 }
    .attempt-dd{ position:relative; display:inline-flex; align-items:center }
    .attempt-trigger{ appearance:none; border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); padding: 8px 12px; border-radius: 12px; cursor:pointer; font-weight:800; letter-spacing:.2px; box-shadow: inset 0 1px 0 rgba(255,255,255,.06) }
    .attempt-trigger:hover{ filter: brightness(1.06) }
    .attempt-trigger .chev{ margin-left:8px; opacity:.85 }
    .attempt-menu{ position:absolute; top: calc(100% + 6px); left:0; z-index: 2147483000; width: 100%; min-width: 100%; max-width: 92vw; box-sizing: border-box; max-height: 260px; overflow:auto; border: 1px solid var(--btnBorder); border-radius: 12px; background: linear-gradient(180deg, rgba(16,25,40,.95), rgba(10,16,28,.95)); box-shadow: 0 10px 24px rgba(0,0,0,.45); display:none }
    .attempt-dd.open .attempt-menu{ display:block }
    .attempt-option{ padding:8px 12px; cursor:pointer; display:flex; align-items:center; gap:8px; border-bottom: 1px solid rgba(60,80,120,.18) }
    .attempt-option:last-child{ border-bottom: 0 }
    .attempt-option:hover{ background: linear-gradient(180deg, rgba(96,165,250,.18), rgba(24,60,120,.12)) }
    .attempt-option .tag{ margin-right: 6px }
    /* Add a bit more space above the Results/Attempts card */
    #results-card{ margin-top: 12px; width: 100%; max-width: 100%; box-sizing: border-box; }
     /* Narrow scoped layout fixes for the missed-question list so each card
         only sizes to its visible content (matches the parsed preview). */
    #attemptMissedList{ display:flex; flex-direction:column; gap:12px }
    /* Make missed cards fill the available width of the results panel (match Results readout) */
    #attemptMissedList .qcard{ display:block; width:100%; max-width:100%; padding:12px 14px; box-sizing:border-box; margin:6px 0 }
     /* Ensure the hint row inside missed cards wraps and does not force extra height
         (this will apply once inline styles are removed from the renderer). */
    /* Match preview hint styling: keep it simple so missed cards use the same visual as preview cards */
    #attemptMissedList .qcard .hint{ display:block !important; margin-top:6px !important; color:var(--muted) }
    /* ASCII antenna */
    #radioPlayer .ascii-ant{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace; white-space: pre; line-height: 1.05; color: var(--ink); background: rgba(0,0,0,.12); border:1px solid rgba(90,110,140,.25); border-radius:10px; padding:6px 8px; text-align:center; overflow:hidden; max-width:100% }
    #radioPlayer .ascii-ant pre{ margin:0; display:inline-block; text-align:left }
    /* Prevent selection on radio ASCII */
    #radioPlayer .ascii-ant, #radioPlayer .ascii-ant pre, #rpAscii{ -webkit-user-select:none; user-select:none }
    @keyframes waves{ 0%{ opacity: 0 } 50%{ opacity: .95 } 100%{ opacity: 0 } }
    /* Pulse the ASCII block while playing */
    #radioPlayer.playing .ascii-ant pre{ animation: antPulse 1.4s ease-in-out infinite }
    @keyframes antPulse{ 0%{ opacity:.85; text-shadow: 0 0 0 rgba(106,169,255,0) } 50%{ opacity:1; text-shadow: 0 0 8px var(--brand) } 100%{ opacity:.85; text-shadow: 0 0 0 rgba(106,169,255,0) } }
    
    /* ASCII Clock (sits underneath the radio, same width) */
    /* Unboxed appearance: no border/background/shadow */
    #asciiClock{ position:fixed; left: calc(12px + env(safe-area-inset-left)); bottom: calc(12px + env(safe-area-inset-bottom)); z-index:179; box-sizing:border-box; padding:0; border-radius: 0; border:none; background: transparent; box-shadow: none; -webkit-backdrop-filter: none; backdrop-filter: none; display:inline-block }
    /* Clock text size set to 10px */
    #asciiClock pre{ margin:0; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace; white-space: pre; line-height:1; color: var(--ink); letter-spacing: -0.5px; font-size: 10px }
    /* Prevent selection on clock ASCII */
    #asciiClock, #asciiClock pre{ -webkit-user-select:none; user-select:none }
    @keyframes clockBob{ 0%{ transform: translateY(0) } 50%{ transform: translateY(-1px) } 100%{ transform: translateY(0) } }
    #asciiClock.playing pre{ animation: clockBob 3s ease-in-out infinite }
    /* Controls row */
    #radioPlayer .rp-row{ display:flex; align-items:center; gap:8px }
    #radioPlayer .rp-row>*{ flex: 0 0 auto }
    /* Let the volume slider flex within the row even when others are fixed */
    #radioPlayer .rp-row .rp-vol{ flex: 1 1 120px; min-width:60px; max-width:100% }
    /* Skip button styling: match size of main play/pause button */
    #radioPlayer #rpSkip{ flex: 0 0 auto; display:none; padding: 6px 10px; font-weight:700; font-size:12px; line-height:1; border-radius:8px; border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); cursor:pointer }
    #radioPlayer.twilight #rpSkip{ display:inline-block }
    /* Reduce select width when Twilight (Skip visible), let it grow otherwise */
    /* Twilight: let the genre select shrink to fit its visible text */
    #radioPlayer.twilight #rpGenre{ flex: 0 0 auto; width: auto; max-width: 150px; min-width: 0 }
    #radioPlayer.twilight #rpGenre.rp-select{ padding: 3px 6px; font-size: 11px }
    #radioPlayer:not(.twilight) #rpGenre{ flex: 1 1 auto }
    #radioPlayer .rp-gear{ appearance:none; border:1px solid var(--btnBorder); background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); font-weight:700; font-size:11px; padding:4px 8px; border-radius:8px; cursor:pointer; line-height:1 }
    #radioPlayer .rp-gear[hidden]{ display:none }
    #radioPlayer .rp-custom{ display:none; padding:8px; border:1px solid var(--btnBorder); border-radius:10px; background: rgba(0,0,0,.16) }
    #radioPlayer .rp-custom.show{ display:block }
    #radioPlayer .rp-custom .row{ display:flex; gap:8px; align-items:center; margin:6px 0 }
    #radioPlayer .rp-custom label{ width:64px; color: var(--muted); font-size:12px }
    #radioPlayer .rp-custom input, #radioPlayer .rp-custom textarea{ flex:1 1 auto; background:#0c1526; color:var(--ink); border:1px solid var(--btnBorder); border-radius:6px; padding:6px 8px; font-size:12px }
    #radioPlayer .rp-custom textarea{ min-height:28px; max-height:360px; resize:vertical; overflow:hidden; height:auto }
    /* Autosizing single-line start: when content grows, JS will expand height to fit without showing scrollbars */
    #radioPlayer .rp-custom textarea.autosize-textarea{ min-height:28px; overflow:hidden; resize:vertical }
    #radioPlayer .rp-custom .actions{ display:flex; gap:8px; justify-content:flex-end; margin-top:6px }
    #radioPlayer .rp-hint{ color: var(--muted); font-size:11px; margin-top:4px }
        /* Title row */
        #radioPlayer .rp-title{ display:flex; align-items:center; gap:8px; font-weight:800; color: var(--ink); letter-spacing:.3px; font-size:13px }
        #radioPlayer .rp-title .dot{ width:8px; height:8px; border-radius:50%; background: var(--brand); box-shadow: 0 0 12px var(--brand) }
    #radioPlayer.min .rp-meta, #radioPlayer.min .ascii-ant{ display:none }
    #radioPlayer.min{ padding-top:8px; padding-bottom:8px }
        @media (max-width: 640px){ #radioPlayer{ width: min(92vw, 340px); padding:6px 8px } #radioPlayer .rp-vol{ width: 80px } }
    </style>

</head>
<body>
        <!-- Ambient Radio Player (bottom-left boxed) -->
        <div id="radioPlayer" role="complementary" aria-label="HF Skywave Long-Range Radio">
            <div class="rp-title"><span class="dot"></span> HF Skywave Long-Range Radio <button id="rpToggle" class="rp-btn small" title="Hide/Show">Hide</button></div>
            <div class="rp-meta">
                <div id="rpNow">Radio ready</div>
                <div id="rpCast">Not receiving</div>
            </div>
                                                <div class="ascii-ant" aria-hidden="true"><pre id="rpAscii"></pre></div>
            <div class="rp-row">
                <select id="rpGenre" class="rp-select" title="Genre" aria-label="Genre">
                    <option value="">Select genre</option>
                    <option value="custom">Custom</option>
                </select>
                <button id="rpSkip" class="rp-btn small" title="Skip to next episode">Skip</button>
                <button id="rpGear" class="rp-gear" title="Custom station settings" hidden>⚙︎</button>
                <button id="rpPlay" class="rp-btn" title="Play/Pause" aria-label="Play">▶</button>
                <input id="rpVol" class="rp-vol" type="range" min="0" max="1" step="0.01" value="0.4" title="Volume" aria-label="Volume" />
            </div>
            <div id="rpCustom" class="rp-custom" aria-hidden="true">
                <div class="row"><label for="rpCustName">Name</label><input id="rpCustName" type="text" placeholder="My Custom Station" /></div>
                <div class="row"><label for="rpCustUrls">URLs</label><textarea id="rpCustUrls" class="autosize-textarea" rows="1" placeholder="One or more direct stream URLs (https).\nExample: https://example.com/stream.mp3\nYou can paste multiple, one per line."></textarea></div>
                <div class="rp-hint">Requirements: HTTPS direct stream (MP3/AAC), CORS-friendly, no login. Avoid web pages or shortlinks; use the actual .mp3/.aac stream URL.</div>
                <div class="actions">
                    <button id="rpCustSave" class="rp-btn small">Save</button>
                    <button id="rpCustClear" class="rp-btn small">Clear</button>
                </div>
            </div>
            <audio id="bgRadio" preload="none" crossorigin="anonymous"></audio>
            <!-- Hidden YouTube player container for Twilight Zone playlist -->
            <!-- YouTube integration removed -->
        </div>

        <!-- Random Category Modal -->
        <div id="randomCategoryModal" class="modal hidden" role="dialog" aria-modal="true" aria-label="Random quiz settings">
            <div class="modal-backdrop"></div>
            <div class="modal-panel">
                <div class="modal-header"><h3>Random Quiz — category / search</h3><button id="randomCategoryClose" class="btn">Close</button></div>
                <div class="modal-body">
                    <div class="hint">Narrow the random quiz to pages matching a Wikipedia search. Type a few words, choose from results, and click Save.</div>
                    <div class="rcm-row">
                        <input id="categorySearch" class="rcm-search" placeholder="Search Wikipedia (e.g., 'biochemistry enzymes')" />
                        <button id="categoryClear" class="btn">Clear</button>
                    </div>
                    <div id="categorySearchResults" aria-live="polite"></div>
                    <div class="rcm-actions"><button id="categorySaveBtn" class="btn primary">Save</button></div>
                </div>
            </div>
        </div>

        <!-- Blocky ASCII Digital Clock (just above the radio) -->
        <div id="asciiClock" aria-label="Local time clock" title="Local time clock"><pre id="asciiClockPre">00:00</pre></div>
        <!-- Boot overlay shown before the main interface -->
                <div id="bootOverlay" class="boot-overlay" aria-live="polite">
            <div class="boot-card">
                    <div class="boot-ascii" aria-hidden="false" role="img" aria-label="BUNKR 108 title banner">
    <pre id="bootAscii">
_______   __    __  __    __  __    __  _______           __     ______    ______  
|       \ |  \  |  \|  \  |  \|  \  /  \|       \        _/  \   /      \  /      \ 
| $$$$$$$\| $$  | $$| $$\ | $$| $$ /  $$| $$$$$$$\      |   $$  |  $$$$$$\|  $$$$$$\
| $$__/ $$| $$  | $$| $$$\| $$| $$/  $$ | $$__| $$       \$$$$  | $$$\| $$| $$__/ $$
| $$    $$| $$  | $$| $$$$\ $$| $$  $$  | $$    $$        | $$  | $$$$\ $$ >$$    $$
| $$$$$$$\| $$  | $$| $$\$$ $$| $$$$$\  | $$$$$$$\        | $$  | $$\$$\$$|  $$$$$$ 
| $$__/ $$| $$__/ $$| $$ \$$$$| $$ \$$\ | $$  | $$       _| $$_ | $$_\$$$$| $$__/ $$
| $$    $$ \$$    $$| $$  \$$$| $$  \$$\| $$  | $$      |   $$ \ \$$  \$$$ \$$    $$
 \$$$$$$$   \$$$$$$  \$$   \$$ \$$   \$$ \$$   \$$       \$$$$$$  \$$$$$$   \$$$$$$ 
    </pre>
                    </div>
                <!-- ASCII animation (replaces spinner) - keeps same footprint as .spinner.lg -->
                <pre id="bootAsciiAnim" aria-hidden="true" class="boot-ascii-anim">[   ]</pre>
                <div class="boot-sub">Initializing…</div>
                <div id="bootPhrase" class="boot-phrase" role="status"></div>
            </div>
        </div>
        <script>
            // Ensure the Daily button outline animates unless the user prefers reduced motion.
            // Defer until DOMContentLoaded so the element exists when we query it.
            (function(){
                function initOutline(){
                    try{
                        const btn = document.getElementById('dailyQuizBtn');
                        if(!btn) return;
                        const mq = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)');
                        const canAnimate = !(mq && mq.matches);
                        if(canAnimate) btn.classList.add('animate-outline');
                        // keep API key dot above any background layers
                        const dot = btn.querySelector('.api-key-dot'); if(dot) dot.style.zIndex = 4;
                        // respond to changes in preference
                        if(mq && mq.addEventListener) mq.addEventListener('change', e => { if(e.matches) btn.classList.remove('animate-outline'); else btn.classList.add('animate-outline'); });
                        // Leave the button background to CSS so it matches other .btn elements
                    }catch(e){}
                }
                if(document.readyState === 'complete' || document.readyState === 'interactive') setTimeout(initOutline, 0); else document.addEventListener('DOMContentLoaded', initOutline);
            })();

            // Also ensure the small Always-toggle and its +/− menu toggle can be elevated
            // above the focus overlay when hovered, matching the behavior of #enableFocusBtn.
            (function(){
                function attachElevate(el){
                    if(!el) return;
                    let placeholder = null;
                    function elevate(){
                        try{
                            if(!document.body.classList.contains('focus-mode-active')) return;
                            if(el.dataset.elevated) return;
                            const r = el.getBoundingClientRect();
                            placeholder = document.createElement('div');
                            placeholder.className = 'focus-btn-placeholder';
                            placeholder.style.width = r.width + 'px';
                            placeholder.style.height = r.height + 'px';
                            placeholder.style.display = getComputedStyle(el).display || 'inline-block';
                            el.parentNode.insertBefore(placeholder, el);
                            document.body.appendChild(el);
                            el.style.position = 'fixed';
                            el.style.left = Math.round(r.left) + 'px';
                            el.style.top = Math.round(r.top) + 'px';
                            el.style.zIndex = '100001';
                            el.dataset.elevated = '1';
                        }catch(e){}
                    }
                    function restore(){
                        try{
                            if(!el.dataset.elevated) return;
                            if(placeholder && placeholder.parentNode){ placeholder.parentNode.insertBefore(el, placeholder); placeholder.parentNode.removeChild(placeholder); }
                            placeholder = null;
                            el.style.position = '';
                            el.style.left = '';
                            el.style.top = '';
                            el.style.zIndex = '';
                            delete el.dataset.elevated;
                        }catch(e){}
                    }
                    el.addEventListener('mouseenter', elevate);
                    el.addEventListener('focus', elevate);
                    el.addEventListener('mouseleave', restore);
                    el.addEventListener('blur', restore);
                    window.addEventListener('resize', function(){ try{ if(el.dataset.elevated && placeholder){ const r = placeholder.getBoundingClientRect(); el.style.left = Math.round(r.left) + 'px'; el.style.top = Math.round(r.top) + 'px'; } }catch(e){} });
                    document.addEventListener('focus-mode-off', restore);
                }
                // Ensure attach even if elements are added later dynamically
                function ensureAttach(id){
                    try{
                        const el = document.getElementById(id);
                        if(el){ attachElevate(el); return; }
                        // watch for the element being added to the DOM
                        if(window.MutationObserver){
                            const mo = new MutationObserver((records, obs)=>{
                                try{ const found = document.getElementById(id); if(found){ attachElevate(found); obs.disconnect(); } }catch(e){}
                            });
                            mo.observe(document.body, { childList:true, subtree:true });
                        } else {
                            // fallback: check on DOMContentLoaded
                            document.addEventListener('DOMContentLoaded', ()=>{ try{ const f = document.getElementById(id); if(f) attachElevate(f); }catch(e){} }, { once:true });
                        }
                    }catch(e){}
                }
                ensureAttach('focusAlwaysMenuToggle');
                ensureAttach('alwaysEnableFocusBtn');
            })();

            // Keep Flashcards panel visible ONLY when the main setup (main menu) is shown
            (function flashcardsPanelVisibility(){
                function update(){
                    try{
                        const panel = document.getElementById('flashcardsPanel');
                        const setupEl = document.getElementById('setup');
                        const isMain = !!setupEl && !setupEl.classList.contains('hidden') && !document.body.classList.contains('quiz-running');
                        if(!panel) return;
                        // Use the project's hidden class convention so other code that toggles .hidden stays compatible
                        if(isMain) panel.classList.remove('hidden'); else panel.classList.add('hidden');
                    }catch(e){}
                }
                try{ const bodyObserver = new MutationObserver(update); bodyObserver.observe(document.body, { attributes: true, attributeFilter: ['class'] }); }catch(e){}
                try{ const setupEl = document.getElementById('setup'); if(setupEl){ const so = new MutationObserver(update); so.observe(setupEl, { attributes: true, attributeFilter: ['class','style'] }); } }catch(e){}
                // Also respond to explicit navigation controls that may not mutate attributes in a detectable way
                document.addEventListener('click', function(ev){ try{ const t = ev.target; if(!t) return; if(t.closest && (t.closest('#backSetup') || t.closest('#resetToMenuBtn') || t.closest('#fcStartSession') || t.closest('#fcFromParsed'))){ setTimeout(update, 30); } }catch(e){} }, true);
                if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', update, { once:true }); else update();
                window.addEventListener('focus', update);
            })();
            // On small mobile screens, set default zoom to ~50% for improved fit
            (function(){
                try{
                    var isSmall = Math.min(window.innerWidth, window.innerHeight) <= 640;
                    if(!isSmall) return;
                    var vp = document.querySelector('meta[name="viewport"]');
                    if(!vp) return;
                    var base = 'width=device-width, viewport-fit=cover';
                    vp.setAttribute('content', base + ', initial-scale=0.5, minimum-scale=0.5, maximum-scale=3, user-scalable=yes');
                }catch(e){}
            })();

            // Blocky ASCII Digital Clock
            (function(){
                const pre = document.getElementById('asciiClockPre'); const clockBox = document.getElementById('asciiClock'); if(!pre||!clockBox) return;
                const DIG = {
                    '0':[' ██ ','█  █','█  █','█  █',' ██ '],
                    '1':['  █ ',' ██ ','  █ ','  █ ',' ███'],
                    '2':[' ██ ','█  █','  █ ',' █  ','████'],
                    '3':['███ ','   █',' ██ ','   █','███ '],
                    '4':['█  █','█  █','████','   █','   █'],
                    '5':['████','█   ','███ ','   █','███ '],
                    '6':[' ██ ','█   ','███ ','█  █',' ██ '],
                    '7':['████','   █','  █ ',' █  ',' █  '],
                    '8':[' ██ ','█  █',' ██ ','█  █',' ██ '],
                    '9':[' ██ ','█  █',' ███','   █',' ██ '],
                    ':':['    ',' ██ ','    ',' ██ ','    '],
                    ' ':['    ','    ','    ','    ','    ']
                };
                let tickId=null;
                function two(n){ return (n<10?'0':'')+n; }
                // Lightweight runtime diagnostics: FPS, avg frame ms, event-loop lag, heap, uptime
                const fpsSamples = []; const maxFpsSamples = 60; let lastRaf = performance.now(); let rafRunning = true;
                let avgFrameMs = 0; let fps = 0;
                function rafTick(ts){
                    try{
                        const dt = ts - lastRaf; lastRaf = ts;
                        fpsSamples.push(dt);
                        if(fpsSamples.length>maxFpsSamples) fpsSamples.shift();
                        const sum = fpsSamples.reduce((a,b)=>a+b,0);
                        avgFrameMs = sum / fpsSamples.length;
                        fps = avgFrameMs ? Math.round(1000/avgFrameMs * 10)/10 : 0;
                    }catch(e){}
                    if(rafRunning) requestAnimationFrame(rafTick);
                }
                try{ requestAnimationFrame(rafTick); }catch(e){}

                // Event-loop lag sampler (measured via setTimeout drift)
                let lagSamples = []; const maxLag = 30; let avgLag = 0;
                function sampleLag(){
                    const want = 50; const t0 = performance.now();
                    setTimeout(()=>{
                        const drift = Math.max(0, performance.now() - t0 - want);
                        lagSamples.push(drift);
                        if(lagSamples.length>maxLag) lagSamples.shift();
                        avgLag = Math.round((lagSamples.reduce((a,b)=>a+b,0)/lagSamples.length)*10)/10;
                        // schedule next
                        setTimeout(sampleLag, 250);
                    }, want);
                }
                try{ sampleLag(); }catch(e){}

                const pageStart = performance.timing && performance.timing.navigationStart ? performance.timing.navigationStart : Date.now();

                function fmtMs(n){ return (Math.round(n*10)/10)+"ms" }

                function render(){
                    const d = new Date(); const hh = two(d.getHours()); const mm = two(d.getMinutes());
                    const chars = [hh[0],hh[1], ':', mm[0],mm[1]]; // static colon, no blink
                    // Left block (clock)
                    const left = ['', '', '', '', ''];
                    for(const ch of chars){ const glyph = DIG[ch] || DIG['0']; for(let r=0;r<5;r++){ left[r] += glyph[r] + ' '; } }
                    // Right block (filler details)
                    const rp = document.getElementById('radioPlayer');
                    const genreEl = document.getElementById('rpGenre');
                    const volEl = document.getElementById('rpVol');
                    const isPlaying = !!(rp && rp.classList.contains('playing'));
                    const mode = genreEl ? (genreEl.value === 'twilight' ? 'Twilight' : genreEl.value.charAt(0).toUpperCase()+genreEl.value.slice(1)) : '—';
                    const volPct = volEl ? Math.round((parseFloat(volEl.value||'0')||0)*100) : 0;
                    const wkd = d.toLocaleDateString(undefined, { weekday:'short' });
                    const mon = d.toLocaleDateString(undefined, { month:'short' });
                    const day = d.getDate();
                    const utc = `${two(d.getUTCHours())}:${two(d.getUTCMinutes())}:${two(d.getUTCSeconds())}`;
                    const right = [
                        `Date ${wkd} ${mon} ${two(day)}`,
                        `UTC  ${utc}`,
                        `Mode ${mode}`,
                        `Status ${isPlaying? 'Playing':'Paused'}`,
                        `Vol  ${volPct}%`
                    ];
                    // Diagnostics column (keep 5 rows to match right)
                    const usedMB = (performance && performance.memory && performance.memory.usedJSHeapSize) ? Math.round(performance.memory.usedJSHeapSize/1024/1024) : null;
                    const totalMB = (performance && performance.memory && performance.memory.jsHeapSizeLimit) ? Math.round(performance.memory.jsHeapSizeLimit/1024/1024) : null;
                    const uptimeMs = Date.now() - pageStart; const uptimeS = Math.floor(uptimeMs/1000);
                    const hhU = Math.floor(uptimeS/3600); const mmU = Math.floor((uptimeS%3600)/60); const ssU = uptimeS%60;
                    const uptime = `${hhU.toString().padStart(2,'0')}:${mmU.toString().padStart(2,'0')}:${ssU.toString().padStart(2,'0')}`;
                    // Build diagnostics with explicit label/value columns to ensure consistent alignment
                    const diagLabels = ['FPS', 'Frm', 'Lag', 'Heap', 'Uptime'];
                    const diagVals = [
                        (Math.round(fps*10)/10).toString(),
                        (Math.round(avgFrameMs*10)/10) + 'ms',
                        (avgLag !== null ? avgLag : '0') + 'ms',
                        (usedMB!==null? usedMB+'MB' : 'n/a'),
                        uptime
                    ];
                    const diag = diagLabels.map((lab,i)=> (lab.padEnd(6) + diagVals[i]));
                    // Join clock columns (left + right) and render diagnostics in a third column
                    const sep = ' │ ';
                    const sep2 = ' │ ';
                    // Build main column strings and compute padding so the diag column aligns
                    const mains = [];
                    for(let r=0;r<5;r++){ mains.push(left[r] + sep + right[r]); }
                    const colWidth = Math.max(...mains.map(m=>m.length));
                    const lines = [];
                    for(let r=0;r<5;r++){
                        const pad = Math.max(0, colWidth - mains[r].length);
                        lines.push(mains[r] + ' '.repeat(pad) + sep2 + diag[r]);
                    }
                    pre.textContent = lines.join('\n');
                    // bob while playing like radio
                    try{ if(isPlaying) clockBox.classList.add('playing'); else clockBox.classList.remove('playing'); }catch{}
                }
                function start(){ if(tickId) return; render(); tickId = setInterval(render, 500); }
                function stop(){ if(tickId){ clearInterval(tickId); tickId=null; } }
                // Keep the clock above radio if the radio size changes (toggle min)
                const rp = document.getElementById('radioPlayer');
                function positionClock(){
                    try{
                        if(rp){
                            // Raise radio by clock height so the clock sits underneath
                            const clkH = clockBox.getBoundingClientRect().height;
                            // Read gap from CSS variable --rpClockGap (px) on the radio, default to 12
                            let gap = 12;
                            try{ const cs = getComputedStyle(rp); const g = cs.getPropertyValue('--rpClockGap'); if(g) gap = parseInt(g)||gap; }catch{}
                            rp.style.setProperty('--rpRaise', (Math.round(clkH) + gap) + 'px');
                        }
                    }catch{}
                }
                start();
                positionClock();
                window.addEventListener('resize', ()=>{ positionClock(); });
                // Update position on radio toggle
                document.getElementById('rpToggle')?.addEventListener('click', ()=> setTimeout(positionClock, 200));
                // Optional: expose for debugging
                try{ window.asciiClock = { start, stop, render }; }catch{}
            })();
        </script>
        <script>
            // Ambient Radio Player logic (royalty-free stations + Twilight Zone YouTube mode)
            (function(){
                const $ = id => document.getElementById(id);
                const wrap = $('radioPlayer'); if(!wrap) return;
                const audio = $('bgRadio'); const playBtn = $('rpPlay'); const vol = $('rpVol'); const genreSel = $('rpGenre'); const now = $('rpNow'); const cast = $('rpCast'); const tog = $('rpToggle'); const skipBtn = $('rpSkip');
                const rpAscii = $('rpAscii');
                // Expose ASCII controls so Twilight (YouTube) can start/stop the animation
                let asciiStart = null, asciiStop = null;
                const gearBtn = $('rpGear');
                const custPanel = $('rpCustom');
                const custName = $('rpCustName');
                const custUrls = $('rpCustUrls');
                const custSave = $('rpCustSave');
                const custClear = $('rpCustClear');

                // Autosize helper for the custom URLs textarea: start single-line and grow vertically
                function autosizeTextarea(el){
                    try{
                        if(!el) return;
                        // reset to let the browser compute the scrollHeight
                        el.style.height = 'auto';
                        // ensure a small minimum (approx a single line)
                        const sh = Math.max(24, el.scrollHeight || 24);
                        el.style.height = sh + 'px';
                    }catch(e){}
                }
                if(custUrls){
                    // ensure the starter attributes/classes are present
                    custUrls.classList.add('autosize-textarea');
                    custUrls.setAttribute('rows','1');
                    // run once to seed initial height
                    autosizeTextarea(custUrls);
                    // grow as the user types/pastes
                    ['input','change','paste'].forEach(ev=> custUrls.addEventListener(ev, ()=> autosizeTextarea(custUrls)));
                }
                const hasMS = 'mediaSession' in navigator;

                // YouTube/Twilight integration removed. Stubs and safe placeholders kept for compatibility.
                let ytPlayer = null;
                let ytVol = 0.4;
                let ytApiLoading = false;
                let ytPendingStart = false;
                let ytContainer = null;
                let ytDiv = null;
                function isTwilight(){ return false; }
                function showYT(show) { /* noop - YouTube removed */ }
                function ensureYTApi(cb){ if(cb) cb && cb(); }
                function initYT(){ /* noop - YouTube removed */ }
                function playRandomFromPlaylist(player, ensureShuffle){ /* noop */ }
                function playOrResumeYT(){ /* noop */ }
                function formatTwilightTitle(title){ return 'Twilight Zone (Broadcast)'; }

                // Measure and fit text into the `now` element width using a canvas.
                function measureTextWidth(font, text){
                    try{
                        const c = document.createElement('canvas'); const ctx = c.getContext('2d'); ctx.font = font; return ctx.measureText(text).width;
                    }catch{ return text.length * 7; }
                }

                function getElementFont(el){
                    try{ const s = window.getComputedStyle(el); return `${s.fontWeight} ${s.fontSize} ${s.fontFamily}`; }catch{ return '700 12px system-ui'; }
                }

                function truncateToFit(el, fullText){
                    if(!el) return fullText;
                    try{
                        const ell = '…';
                        const font = getElementFont(el);
                        const maxW = el.clientWidth - 4; // small padding buffer
                        if(measureTextWidth(font, fullText) <= maxW) return fullText;
                        // binary search for maximum chars that fit
                        let lo = 0, hi = fullText.length; let best = '';
                        while(lo <= hi){
                            const mid = Math.floor((lo + hi) / 2);
                            const s = fullText.slice(0, mid).trim() + ell;
                            if(measureTextWidth(font, s) <= maxW){ best = s; lo = mid + 1; } else { hi = mid - 1; }
                        }
                        return best || fullText.slice(0, Math.max(0, Math.floor(el.clientWidth/7))).trim() + ell;
                    }catch{ return fullText; }
                }

                function setNowText(text){
                    try{
                        const full = String(text||'').trim();
                        // Hide when empty
                        if(!full){ if(now){ now.textContent=''; now.title=''; now.style.display='none'; } return; }
                        // Simply set the full text as-is (no truncation or dynamic shrinking)
                        if(now){ now.textContent = full; now.title = full; now.style.display = 'inline-block'; }
                    }catch(e){ try{ now.textContent = String(text||''); }catch{} }
                }

                // Curated public/royalty-free stations (subject to stream availability)
                // Classical: Radio Swiss Classic (public service; non-commercial; metadata via stream)
                // Jazz: Swiss Jazz (public service)
                // Blues: 1.FM Blues (free stream)
                // Bossa: SomaFM Bossa Nova
                const stations = {
                    classical: [
                        { name:'Radio Swiss Classic', urls:['https://stream.srg-ssr.ch/m/rsc_de/mp3_128'] },
                        { name:'Abacus.fm Classical', urls:['https://uk5.internet-radio.com/proxy/abacusclassics?mp=/stream','https://uk6.internet-radio.com/proxy/abacusclassics?mp=/stream'] },
                        { name:'Radio Swiss Classic (alt)', urls:['https://stream.srg-ssr.ch/m/rsc_it/mp3_128','https://stream.srg-ssr.ch/m/rsc_fr/mp3_128'] }
                    ],
                    jazz: [
                        { name:'Radio Swiss Jazz', urls:['https://stream.srg-ssr.ch/m/rsj/mp3_128'] },
                        { name:'Radio Swiss Jazz (alt)', urls:['https://stream.srg-ssr.ch/m/rsj_aacp_96'] },
                        { name:'1.FM - Adore Jazz', urls:['https://strm112.1.fm/adorejazz_mobile_mp3'] }
                    ],
                    // New: Bossa Nova
                    bossa: [
                        { name:'SomaFM: Bossa Nova', urls:['https://ice5.somafm.com/bossa-128-mp3'] }
                    ]
                };

                const KEY = {
                    genre:'rp.genre',
                    idx:'rp.idx',
                    vol:'rp.vol',
                    playing:'rp.playing',
                    customName:'rp.custom.name',
                    customUrls:'rp.custom.urls'
                };

                function parseUrls(text){
                    return (text||'')
                        .split(/\r?\n|,/)
                        .map(s=>s.trim())
                        .filter(s=>/^https:\/\//i.test(s));
                }

                function getCustomStation(){
                    try{
                        // Primary: new custom keys; Fallback: legacy yacht keys
                        const name = (localStorage.getItem(KEY.customName) || localStorage.getItem('rp.yacht.name') || '').trim();
                        const urlsText = (localStorage.getItem(KEY.customUrls) || localStorage.getItem('rp.yacht.urls') || '');
                        const urls = parseUrls(urlsText);
                        if(name && urls.length){ return [{ name, urls }]; }
                    }catch{}
                    return null;
                }

                function isTwilight(){ return genreSel.value==='twilight'; }
                function updateTwilightUI(){
                    const t = isTwilight();
                    try{ wrap.classList.toggle('twilight', t); }catch{}
                    if(skipBtn){ skipBtn.style.display = t ? '' : 'none'; }
                    // When Twilight, shrink the select to its content width to avoid extra blank space
                    try{
                        const sel = genreSel;
                        if(sel){
                            if(t){
                                // Measure selected option text width and set select width accordingly
                                const opt = sel.options[sel.selectedIndex];
                                const span = document.createElement('span'); span.style.visibility='hidden'; span.style.position='absolute'; span.style.whiteSpace='nowrap'; span.style.font = getComputedStyle(sel).font; span.textContent = opt ? opt.text : sel.value;
                                document.body.appendChild(span);
                                const w = Math.min(150, Math.max(64, Math.ceil(span.getBoundingClientRect().width) + 36));
                                sel.style.width = w + 'px';
                                document.body.removeChild(span);
                            } else {
                                sel.style.width = '';
                            }
                        }
                    }catch{}
                }
                function getList(){
                    // Return the list of stations for the currently selected genre.
                    // Important: if no genre is selected (empty string / falsy), return an empty array
                    // so the player does not silently fall back to the 'classical' list (Radio Swiss Classic).
                    const g = (genreSel && typeof genreSel.value !== 'undefined') ? String(genreSel.value).trim() : '';
                    if(!g) return []; // no selection
                    if(g === 'custom'){
                        const cust = getCustomStation();
                        return cust || [];
                    }
                    return stations[g] || [];
                }
                function getIdx(){ const list = getList(); let i=0; try{ i = parseInt(localStorage.getItem(KEY.idx)||'0',10);}catch{} return isFinite(i)? (i % list.length + list.length)%list.length : 0; }
                function setIdx(i){ try{ localStorage.setItem(KEY.idx, String(i)); }catch{} }
                function setGenre(g){ try{ localStorage.setItem(KEY.genre, g); }catch{} }
                function setVol(v){ try{ localStorage.setItem(KEY.vol, String(v)); }catch{} }
                function setPlaying(p){ try{ localStorage.setItem(KEY.playing, p?'1':'0'); }catch{} }

                // Hide/Show toggle
                if(tog){
                    tog.addEventListener('click', function(){
                        const min = wrap.classList.toggle('min');
                        tog.textContent = min ? 'Show' : 'Hide';
                        // Persist the collapsed state so user's preference survives reloads
                        try{ localStorage.setItem('rp.min', min ? '1' : '0'); }catch(e){}
                    });
                }

                // Receiving/Broadcasting animated ellipsis; message depends on mode
                let castTimer = null, castDots = 0;
                function startCastAnim(){
                    stopCastAnim();
                    // set immediately so UI updates without waiting for first interval
                    castDots = 1;
                    cast.textContent = (isTwilight() ? 'Broadcasting' : 'Receiving skywave signals') + ' .';
                    castTimer = setInterval(()=>{
                        castDots = (castDots + 1) % 4; // 0..3
                        const dots = castDots===0? '' : castDots===1? ' .' : castDots===2? ' ..' : ' ...';
                        const base = isTwilight() ? 'Broadcasting' : 'Receiving skywave signals';
                        cast.textContent = base + dots;
                    }, 600);
                }
                function stopCastAnim(){ if(castTimer){ clearInterval(castTimer); castTimer=null; } cast.textContent = idleText(); }
                function idleText(){ return isTwilight() ? 'Not broadcasting' : 'Not receiving'; }

                let curIdx = 0, curAlt = 0;
                function pick(list, i){ return list[(i % list.length + list.length) % list.length]; }
                function showYT(show){ if(ytContainer){ ytContainer.hidden = !show; ytContainer.setAttribute('aria-hidden', show? 'false':'true'); } }
                function load(i, alt){
                    const list = getList();
                    if(!list.length){
                        // No stations available for the current selection. Do not auto-select or load anything.
                        if(genreSel && genreSel.value === 'custom'){
                            setNowText('Custom station not set (click ⚙︎)');
                        } else {
                            setNowText('No station selected — add a custom station (⚙︎).');
                        }
                        return;
                    }
                    curIdx = (i % list.length + list.length) % list.length; curAlt = Math.max(0, alt|0);
                    const st = pick(list, curIdx);
                    const urls = Array.isArray(st.urls) ? st.urls : (st.url ? [st.url] : []);
                    if(!urls.length){ setNowText(st.name + ' (no source)'); return; }
                    let u = urls[Math.min(curAlt, urls.length-1)];
                    // Append timestamp to prevent caching / force live stream
                    try{ u += (u.includes('?') ? '&' : '?') + '_t=' + Date.now(); }catch(e){}
                    audio.src = u; audio.load();
                    setNowText(st.name + (urls.length>1 ? ` (alt ${curAlt+1}/${urls.length})` : ''));
                    setIdx(curIdx);
                    updateMediaSessionMeta();
                }

                function play(){
                    if(isTwilight()){
                        showYT(true); playOrResumeYT(); startCastAnim(); setPlaying(true);
                        return;
                    }
                    audio.play().then(()=>{ wrap.classList.add('playing'); playBtn.textContent = '⏸'; playBtn.setAttribute('aria-label','Pause'); startCastAnim(); setPlaying(true); if(hasMS){ try{ navigator.mediaSession.playbackState = 'playing'; }catch{} } }).catch(err=>{
                        // Autoplay might be blocked; update UI but don't error spam
                        console.warn('Radio play blocked or failed', err); wrap.classList.remove('playing'); playBtn.textContent='▶'; playBtn.setAttribute('aria-label','Play'); cast.textContent=idleText(); stopCastAnim(); setPlaying(false);
                    });
                }
                function pause(){
                    if(isTwilight()){
                        try{ ytPlayer && ytPlayer.pauseVideo && ytPlayer.pauseVideo(); }catch{}
                        wrap.classList.remove('playing'); playBtn.textContent='▶'; playBtn.setAttribute('aria-label','Play'); cast.textContent=idleText(); stopCastAnim(); setPlaying(false); if(hasMS){ try{ navigator.mediaSession.playbackState = 'paused'; }catch{} }
                        return;
                    }
                    audio.pause(); wrap.classList.remove('playing'); playBtn.textContent='▶'; playBtn.setAttribute('aria-label','Play'); cast.textContent=idleText(); stopCastAnim(); setPlaying(false); if(hasMS){ try{ navigator.mediaSession.playbackState = 'paused'; }catch{} }
                }
                function toggle(){ if(isTwilight()) { if(ytPlayer && ytPlayer.getPlayerState && ytPlayer.getPlayerState()===1) pause(); else play(); } else { if(audio.paused) play(); else pause(); } }

                // Volume
                function applyVol(v){
                    const x = Math.max(0, Math.min(1, parseFloat(v)||0));
                    if(isTwilight()){
                        ytVol = x; try{ ytPlayer && ytPlayer.setVolume && ytPlayer.setVolume(Math.round(x*100)); }catch{}
                    } else {
                        audio.volume = x;
                    }
                    vol.value = String(x); setVol(x);
                    try{ wrap.style.setProperty('--rpVolPercent', (x*100).toFixed(0) + '%'); }catch{}
                }
                vol.addEventListener('input', ()=> applyVol(vol.value));

                // Controls
                playBtn.addEventListener('click', toggle);
                if(skipBtn){
                    skipBtn.addEventListener('click', ()=>{
                        if(!isTwilight()) return;
                        ensureYTApi(()=>{ initYT(); if(ytPlayer){
                            try{
                                const st = ytPlayer.getPlayerState ? ytPlayer.getPlayerState() : -1;
                                if(st!==1){
                                    // If not already playing, start randomly in the playlist
                                    playRandomFromPlaylist(ytPlayer, true);
                                } else {
                                    // Advance to next item (shuffle ensures randomness)
                                    ytPlayer.nextVideo();
                                }
                            }catch{ try{ ytPlayer.playVideo && ytPlayer.playVideo(); }catch{} }
                        }});
                    });
                }
                genreSel.addEventListener('change', ()=>{
                    setGenre(genreSel.value);
                    updateTwilightUI();
                    // Show gear only for Custom
                    if(gearBtn){ gearBtn.hidden = genreSel.value!=='custom'; }
                    // If switching to Twilight, we do not use audio element
                    if(isTwilight()){
                        showYT(true);
                        try{ 
                            // Stop and unload any existing audio stream to avoid bleed-through
                            audio.pause();
                            audio.removeAttribute('src');
                            audio.load();
                        }catch{}
                        if(localStorage.getItem(KEY.playing)==='1') playOrResumeYT(); else { cast.textContent=idleText(); stopCastAnim(); }
                        return;
                    } else {
                        showYT(false);
                        try{ ytPlayer && ytPlayer.pauseVideo && ytPlayer.pauseVideo(); }catch{}
                    }
                    load(0,0);
                    if(localStorage.getItem(KEY.playing)==='1') play();
                });

                // Restore state
                (function init(){
                    // Fallback if stored genre removed
                    // Don't pre-select Radio Swiss (first classical entry) for users who have not explicitly chosen a genre.
                    // Prefer a saved genre when present; otherwise prefer a saved custom station, then a neutral default ('jazz').
                    try{
                        const g = localStorage.getItem(KEY.genre);
                        // If a saved, valid genre exists, restore it. Otherwise, do NOT auto-select a genre.
                        // New users should explicitly pick a station before anything is saved or loaded.
                        if(g && (stations[g] || g === 'custom' || g === 'twilight')) {
                            genreSel.value = g;
                        } else {
                            const cust = getCustomStation();
                            // If the user has a saved custom station, show Custom; otherwise leave selection empty
                            genreSel.value = cust ? 'custom' : '';
                        }
                    }catch{
                        try{ genreSel.value = getCustomStation() ? 'custom' : ''; }catch{ genreSel.value = ''; }
                    }
                    updateTwilightUI();
                    if(gearBtn){ gearBtn.hidden = genreSel.value!=='custom'; }
                    try{ const v = localStorage.getItem(KEY.vol); if(v!=null) applyVol(v); else applyVol(vol.value); }catch{ applyVol(vol.value); }
                    if(isTwilight()){
                        showYT(true); ensureYTApi(()=>{ initYT(); });
                        try{ if(localStorage.getItem(KEY.playing)==='1'){ play(); } else { cast.textContent=idleText(); stopCastAnim(); } }catch{ cast.textContent=idleText(); stopCastAnim(); }
                    }else{
                        showYT(false);
                        load(getIdx(), 0);
                        try{ if(localStorage.getItem(KEY.playing)==='1'){ play(); } else { cast.textContent=idleText(); stopCastAnim(); } }catch{ cast.textContent=idleText(); stopCastAnim(); }
                    }
                    // End of init(): fall through to allow outer logic to auto-hide if desired
                })();

                // Auto-hide the radio player on initial page load unless the user explicitly chose to show it.
                // Default behavior: hidden (collapsed). If the user toggled Show before, they can persist that by
                // clicking the toggle which writes 'rp.min' to localStorage.
                try{
                    const pref = localStorage.getItem('rp.min');
                    // If pref === '0' -> show; otherwise (null or '1') -> hide by default
                    const shouldHide = pref !== '0';
                    if(shouldHide){
                        wrap.classList.add('min');
                        if(tog) tog.textContent = 'Show';
                        // Stop any playback so the hidden radio doesn't continue audio unexpectedly
                        try{ pause(); }catch(e){}
                    } else {
                        wrap.classList.remove('min');
                        if(tog) tog.textContent = 'Hide';
                    }
                }catch(e){}

                // --- Playback stall detection and auto-recovery (audio-only genres; disabled in Twilight mode) ---
                // Track last progress to detect stalls
                let _lastProgTs = Date.now();
                audio.addEventListener('timeupdate', ()=>{ if(!isTwilight()) _lastProgTs = Date.now(); });
                audio.addEventListener('progress', ()=>{ if(!isTwilight()) _lastProgTs = Date.now(); });
                audio.addEventListener('playing', ()=>{ if(!isTwilight()) _lastProgTs = Date.now(); });

                function _shouldBePlaying(){
                    try{ return localStorage.getItem(KEY.playing) === '1'; }catch{ return false; }
                }

                let _resumeCooldownUntil = 0;
                let _resumeAttempt = 0;
                function tryResume(reason){
                    if(isTwilight()) return; // only for audio element
                    if(!_shouldBePlaying()) return;
                    const nowTs = Date.now();
                    if(nowTs < _resumeCooldownUntil) return;
                    _resumeAttempt++;
                    const backoff = Math.min(30000, 1000 * _resumeAttempt);
                    _resumeCooldownUntil = nowTs + backoff;

                    // First, attempt a simple play()
                    try{ audio.play().catch(()=>{}); }catch{}

                    // Re-check shortly; if still stalled, reload then play
                    setTimeout(()=>{
                        if(!_shouldBePlaying()) return;
                        const stalled = audio.paused || ((Date.now() - _lastProgTs) > 5000 && audio.readyState < 3);
                        if(stalled){
                            try{ load(curIdx, curAlt); }catch{}
                            setTimeout(()=>{ if(_shouldBePlaying()){ try{ audio.play().catch(()=>{}); }catch{} } }, 400);
                        } else {
                            // recovered; reset attempts
                            _resumeAttempt = 0; _resumeCooldownUntil = 0;
                        }
                    }, 1500);
                }

                // Respond to potential stall-ish events
                ['stalled','suspend','waiting','emptied'].forEach(ev => {
                    audio.addEventListener(ev, ()=>{
                        if(!isTwilight() && _shouldBePlaying()){
                            // brief delay to allow natural buffering before forcing resume
                            setTimeout(()=> tryResume(ev), 800);
                        }
                    });
                });

                // Watchdog: periodically ensure playback is advancing when it should
                setInterval(()=>{
                    if(isTwilight() || !_shouldBePlaying()) return;
                    const stalled = audio.paused || ((Date.now() - _lastProgTs) > 15000 && audio.readyState < 3);
                    if(stalled) tryResume('watchdog');
                }, 4000);

                // Update metadata when stream updates (limited cross-origin)
                audio.addEventListener('playing', ()=> { if(isTwilight()) return; wrap.classList.add('playing'); startCastAnim(); if(hasMS){ try{ navigator.mediaSession.playbackState = 'playing'; }catch{} } });
                audio.addEventListener('pause',   ()=> { 
                    if(isTwilight()) return;
                    wrap.classList.remove('playing'); 
                    if(_shouldBePlaying()){
                        cast.textContent='Reconnecting…';
                        startCastAnim();
                    } else {
                        cast.textContent='Not receiving';
                        stopCastAnim();
                    }
                    if(hasMS){ try{ navigator.mediaSession.playbackState = 'paused'; }catch{} }
                });
                audio.addEventListener('ended',   ()=> { 
                    if(isTwilight()) return;
                    if(_shouldBePlaying()){
                        // Stream ended unexpectedly; attempt to resume same source
                        tryResume('ended');
                    } else {
                        pause();
                    }
                });

                // Robust UI state sync: some external controllers may change playback
                // without invoking our handlers. Poll actual player state and update UI.
                try{
                    let uiSyncInterval = null;
                    function syncUIState(){
                        try{
                            let playing = false;
                            if(isTwilight()){
                                try{ playing = !!(ytPlayer && ytPlayer.getPlayerState && ytPlayer.getPlayerState()===1); }catch{ playing = false; }
                            } else {
                                playing = !!(audio && !audio.paused && !audio.ended);
                            }
                            if(playing){
                                if(!wrap.classList.contains('playing')){
                                    wrap.classList.add('playing'); playBtn.textContent = '⏸'; playBtn.setAttribute('aria-label','Pause'); startCastAnim();
                                }
                            } else {
                                if(wrap.classList.contains('playing')){
                                    wrap.classList.remove('playing'); playBtn.textContent = '▶'; playBtn.setAttribute('aria-label','Play'); cast.textContent = idleText(); stopCastAnim();
                                }
                            }
                        }catch(e){}
                    }
                    uiSyncInterval = setInterval(syncUIState, 800);
                    document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible') setTimeout(syncUIState, 100); });
                }catch(e){}
                audio.addEventListener('error',   ()=> {
                    if(isTwilight()) return;
                    setNowText('Stream error'); wrap.classList.remove('playing'); playBtn.textContent='▶'; cast.textContent=idleText(); stopCastAnim();
                    const list = getList(); const st = pick(list, curIdx);
                    const urls = Array.isArray(st.urls) ? st.urls : (st.url ? [st.url] : []);
                    if(curAlt < urls.length-1){
                        // try next alternate URL for the same station
                        load(curIdx, curAlt+1);
                        if(localStorage.getItem(KEY.playing)==='1') play();
                        return;
                    }
                    // try next station in the same genre
                    if(list.length > 1){
                        load(curIdx+1, 0);
                        if(localStorage.getItem(KEY.playing)==='1') play();
                        setNowText((now && now.textContent ? now.textContent : '') + ' (auto)');
                        return;
                    }
                    // try a different genre as last resort; rotate through available genres
                    const order = ['classical','jazz','bossa','custom'];
                    let gi = order.indexOf(genreSel.value); if(gi < 0) gi = 0; gi = (gi + 1) % order.length; genreSel.value = order[gi]; setGenre(order[gi]);
                    load(0, 0);
                    if(localStorage.getItem(KEY.playing)==='1') play();
                    setNowText((now && now.textContent ? now.textContent : '') + ' (auto cross-genre)');
                });
                // when a stream ends or errors, just stay idle (no skip)

                // Re-apply colors on theme change (purely cosmetic)
                document.addEventListener('theme-changed', ()=>{
                    // No-op: CSS vars already drive visuals; this is here if future sync is needed
                });

                // Custom station settings panel
                if(gearBtn && custPanel){
                    gearBtn.addEventListener('click', ()=>{
                        const show = !custPanel.classList.contains('show');
                        custPanel.classList.toggle('show', show);
                        custPanel.setAttribute('aria-hidden', show? 'false':'true');
                        if(show){
                            try{
                                custName.value = (localStorage.getItem(KEY.customName) || localStorage.getItem('rp.yacht.name') || '');
                                custUrls.value = (localStorage.getItem(KEY.customUrls) || localStorage.getItem('rp.yacht.urls') || '');
                                // Ensure the textarea height matches any loaded content
                                try{ autosizeTextarea && autosizeTextarea(custUrls); }catch(e){}
                            }catch{}
                        }
                    });
                    if(custSave){
                        custSave.addEventListener('click', ()=>{
                            const name = custName.value.trim();
                            const urls = parseUrls(custUrls.value);
                            if(!name || !urls.length){
                                alert('Please enter a Name and at least one HTTPS direct stream URL.');
                                return;
                            }
                            try{
                                localStorage.setItem(KEY.customName, name);
                                localStorage.setItem(KEY.customUrls, urls.join('\n'));
                                // remove legacy keys
                                localStorage.removeItem('rp.yacht.name');
                                localStorage.removeItem('rp.yacht.urls');
                            }catch{}
                            // If currently on custom, reload the custom station
                            if(genreSel.value==='custom'){
                                load(0,0);
                                if(localStorage.getItem(KEY.playing)==='1') play();
                            }
                            custPanel.classList.remove('show');
                            custPanel.setAttribute('aria-hidden','true');
                        });
                    }
                    if(custClear){
                        custClear.addEventListener('click', ()=>{
                            try{ localStorage.removeItem(KEY.customName); localStorage.removeItem(KEY.customUrls); localStorage.removeItem('rp.yacht.name'); localStorage.removeItem('rp.yacht.urls'); }catch{}
                            if(genreSel.value==='custom'){
                                load(0,0);
                                if(localStorage.getItem(KEY.playing)==='1') play();
                            }
                            custPanel.classList.remove('show');
                            custPanel.setAttribute('aria-hidden','true');
                        });
                    }
                }

                // Media Session API: make hardware buttons (AirPods/keyboard media keys) control our player
                function updateMediaSessionMeta(){
                    if(!hasMS) return;
                    try{
                        const list = getList();
                        const st = pick(list, curIdx|0);
                        const genreMap = { classical:'Classical', jazz:'Jazz', bossa:'Bossa Nova', custom:'Custom' };
                        const label = genreMap[genreSel.value] || 'Ambient';
                        navigator.mediaSession.metadata = new MediaMetadata({
                            title: st && st.name ? st.name : 'Ambient Radio',
                            artist: label + ' — Study Focus',
                            album: 'HF Skywave Radio'
                        });
                    }catch{}
                }
                if(hasMS){
                    try{
                        // Use the central play/pause/toggle handlers so UI updates consistently
                        navigator.mediaSession.setActionHandler('play', ()=>{ try{ play(); }catch{} });
                        navigator.mediaSession.setActionHandler('pause', ()=>{ try{ pause(); }catch{} });
                        navigator.mediaSession.setActionHandler('stop', ()=>{ try{ pause(); }catch{} });
                        // We deliberately don’t bind next/previous to avoid accidental station changes
                        navigator.mediaSession.setActionHandler('previoustrack', null);
                        navigator.mediaSession.setActionHandler('nexttrack', null);
                    }catch{}
                }

                // Optional: listen for media-key keyboard events as a fallback
                window.addEventListener('keydown', (e)=>{
                    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
                    // ignore when typing in inputs/textareas/contenteditable
                    if(tag==='input' || tag==='textarea' || (e.target && e.target.isContentEditable)) return;
                    if(e.code==='MediaPlayPause'){
                        e.preventDefault(); try{ toggle(); }catch{}
                    } else if(e.code==='MediaTrackPlay'){
                        e.preventDefault(); try{ play(); }catch{}
                    } else if(e.code==='MediaTrackPause'){
                        e.preventDefault(); try{ pause(); }catch{}
                    }
                }, { passive:false });

                // ---------- ASCII HF Skywave animation ----------
                // Small, efficient ASCII renderer that draws a vertical tower, ground and an "ionosphere" layer.
                // Modes:
                //  - Receiving (default): pulses from edge -> ionosphere -> tower.
                //  - Broadcasting (Twilight): pulses from tower -> ionosphere -> edge.
                (function(){
                    if(!rpAscii) return;

                    // Character grid size, computed to fit container width
                    let COLS = 37;   // initial guess; refined on measure
                    let ROWS = 15;   // compact height
                    let towerX = Math.floor(COLS/2);
                    let groundY = ROWS - 1;
                    let ionoY = 2; // near top
                    let towerTopY = Math.max(ionoY+1, groundY - 7);

                    // Animation state
                    let pulses = []; // { t0:number } spawn time (ms)
                    const duration = 1700; // ms for a pulse to traverse path
                    const spawnEvery = 650; // ms between pulses while playing
                    let lastSpawn = 0;
                    let rafId = null;

                    // Island + water state
                    let islandSeq = [4,8,15,16,23,42];
                    let islandText = '';
                    function updateIslandText(){ islandText = islandSeq.join(' '); }
                    updateIslandText();
                    let lastNumChange = 0; // ms
                    let waterPhase = 0;    // integer phase for horizontal wave shift

                    function clearFrame(){
                        rpAscii.textContent = buildStatic();
                    }

                    function buildStatic(){
                        // Create blank grid
                        const grid = Array.from({length: ROWS}, ()=> Array(COLS).fill(' '));
                        // Water row (bottom)
                        const wave = ['~','~','-','-','_','_'];
                        for(let x=0;x<COLS;x++) grid[groundY][x] = wave[(x + waterPhase) % wave.length];
                        // Ionosphere line
                        for(let x=0;x<COLS;x++) grid[ionoY][x] = '~';
                        // Island (numbers) just above water, centered under tower
                        let txt = islandText;
                        if(txt.length > COLS) txt = txt.slice(0, COLS);
                        const start = Math.max(0, Math.floor((COLS - txt.length)/2));
                        for(let i=0;i<txt.length;i++) grid[groundY-1][start+i] = txt[i];
                        // Tower
                        for(let y=towerTopY; y<=groundY-1; y++) grid[y][towerX] = '|';
                        grid[towerTopY][towerX] = 'A'; // antenna tip
                        // Little base feet
                        if(towerX-1>=0) grid[groundY-1][towerX-1] = '/';
                        if(towerX+1<COLS) grid[groundY-1][towerX+1] = '\\';

                        return grid.map(r => r.join('')).join('\n');
                    }

                    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

                    // Per-pulse randomized path params (receiving): from edge -> ionosphere -> tower top
                    function makePathInbound(){
                        const dir = Math.random() < 0.5 ? -1 : 1; // which edge
                        const edgeX = dir > 0 ? COLS-2 : 1;
                        const edgeY = clamp(Math.round((ionoY + towerTopY)/2) + (Math.random()<0.5?-1:1), 1, groundY-2);
                        const offset = COLS * (0.16 + Math.random()*0.16);
                        const bounceX = clamp(towerX + Math.round(dir * offset), 2, COLS-3);
                        return { dir, edgeX, edgeY, bounceX };
                    }
                    // Per-pulse path for broadcast: from tower top -> ionosphere -> edge
                    function makePathOutbound(){
                        const dir = Math.random() < 0.5 ? -1 : 1;
                        const edgeX = dir > 0 ? COLS-2 : 1;
                        const edgeY = clamp(Math.round((ionoY + towerTopY)/2) + (Math.random()<0.5?-1:1), 1, groundY-2);
                        const offset = COLS * (0.16 + Math.random()*0.16);
                        const bounceX = clamp(towerX + Math.round(dir * offset), 2, COLS-3);
                        return { dir, edgeX, edgeY, bounceX };
                    }

                    // Evaluate pulse position along piecewise path using given path (edge -> ionosphere -> tower top)
                    function pulsePointInbound(p, path){
                        const p0 = {x: path.edgeX, y: path.edgeY};
                        const p1 = {x: path.bounceX, y: ionoY};
                        const p2 = {x: towerX, y: towerTopY};
                        const d01 = Math.hypot(p1.x-p0.x, p1.y-p0.y);
                        const d12 = Math.hypot(p2.x-p1.x, p2.y-p1.y);
                        const T01 = d01/(d01+d12);
                        if(p <= T01){
                            const t = p / T01;
                            return { x: Math.round(lerp(p0.x, p1.x, t)), y: Math.round(lerp(p0.y, p1.y, t)) };
                        }else{
                            const t = (p - T01) / (1 - T01);
                            return { x: Math.round(lerp(p1.x, p2.x, t)), y: Math.round(lerp(p1.y, p2.y, t)) };
                        }
                    }
                    // Outbound path: tower -> ionosphere -> edge
                    function pulsePointOutbound(p, path){
                        const p0 = {x: towerX, y: towerTopY};
                        const p1 = {x: path.bounceX, y: ionoY};
                        const p2 = {x: path.edgeX, y: path.edgeY};
                        const d01 = Math.hypot(p1.x-p0.x, p1.y-p0.y);
                        const d12 = Math.hypot(p2.x-p1.x, p2.y-p1.y);
                        const T01 = d01/(d01+d12);
                        if(p <= T01){
                            const t = p / T01;
                            return { x: Math.round(lerp(p0.x, p1.x, t)), y: Math.round(lerp(p0.y, p1.y, t)) };
                        }else{
                            const t = (p - T01) / (1 - T01);
                            return { x: Math.round(lerp(p1.x, p2.x, t)), y: Math.round(lerp(p1.y, p2.y, t)) };
                        }
                    }

                    function lerp(a,b,t){ return a + (b-a)*t; }

                    function render(nowMs){
                        // Spawn pulses while playing; use wrapper state so Twilight works
                        const isPlaying = !!(wrap && wrap.classList && wrap.classList.contains('playing')) || (!audio.paused && !audio.ended);
                        const useOutbound = isTwilight();
                        if(isPlaying && (nowMs - lastSpawn) >= spawnEvery){
                            pulses.push({ t0: nowMs, path: useOutbound ? makePathOutbound() : makePathInbound(), outbound: useOutbound });
                            lastSpawn = nowMs;
                        }

                        // Advance water and occasionally reshuffle island numbers while playing
                        if(isPlaying){
                            waterPhase = (Math.floor(nowMs / 180)) % 1024; // gentle horizontal drift
                            if(nowMs - lastNumChange > 12000){
                                // rotate numbers for a subtle change
                                islandSeq.push(islandSeq.shift());
                                updateIslandText();
                                lastNumChange = nowMs;
                            }
                        }

                        // Build static frame then overlay dynamic artifacts
                        const baseLines = buildStatic().split('\n');
                        const grid = baseLines.map(l => l.split(''));

                        // Groundwave arcs: draw the same arc visuals for both modes;
                        // the pulse path (inbound vs outbound) determines motion, so
                        // Twilight will effectively be the normal animation reversed.
                        if(isPlaying){
                            const r = Math.floor((nowMs/220)%6)+1; // radius 1..6
                            // Use the same inward-looking marks regardless of mode
                            if(towerX-r>=0 && groundY-2>=0){ grid[groundY-2][towerX-r] = '('; }
                            if(towerX-r-1>=0 && groundY-3>=0){ grid[groundY-3][towerX-r-1] = '('; }
                            if(towerX+r<COLS && groundY-2>=0){ grid[groundY-2][towerX+r] = ')'; }
                            if(towerX+r+1<COLS && groundY-3>=0){ grid[groundY-3][towerX+r+1] = ')'; }
                        }

                        // Draw pulses and faint trails
                        const tnow = nowMs;
                        const newP = [];
                        for(const pl of pulses){
                            const age = tnow - pl.t0;
                            const p = age / duration;
                            if(p >= 1.05){ continue; } // done
                            newP.push(pl);

                            // main head
                            const pt = (pl.outbound ? pulsePointOutbound : pulsePointInbound)(Math.min(1, p), pl.path);
                            putChar(grid, pt.x, pt.y, '*');
                            // trailing points for motion feel
                            const t1 = (pl.outbound ? pulsePointOutbound : pulsePointInbound)(Math.max(0, p-0.08), pl.path); putCharFaint(grid, t1.x, t1.y, '·');
                            const t2 = (pl.outbound ? pulsePointOutbound : pulsePointInbound)(Math.max(0, p-0.16), pl.path); putCharFaint(grid, t2.x, t2.y, '·');

                            // Unified ripple: draw at the ionosphere bounce point so
                            // outbound pulses look like the normal animation reversed.
                            if(p>0.48){
                                const pr = Math.min(1, (p-0.48)/0.52);
                                const cx = (pl.path && typeof pl.path.bounceX !== 'undefined') ? pl.path.bounceX : towerX;
                                const cy = ionoY;
                                const rad = 1 + Math.floor(pr*6);
                                drawRipple(grid, cx, cy, rad, pl.path.dir);
                            }
                        }
                        pulses = newP;

                        // No extra Twilight motif; animation is just the reversed normal path

                        // Theme-colored signals only: color '*', '·', '(', ')', 'o', 'O' with var(--brand)
                        function esc(ch){
                            return ch==='&' ? '&amp;' : ch==='<' ? '&lt;' : ch==='>' ? '&gt;' : ch;
                        }
                        let html = '';
                        for(let y=0;y<grid.length;y++){
                            const row = grid[y];
                            for(let x=0;x<row.length;x++){
                                const ch = row[x];
                                if(ch==='*' || ch==='·' || ch==='(' || ch===')' || ch==='o' || ch==='O') html += `<span style="color: var(--brand)">${esc(ch)}</span>`;
                                else html += esc(ch);
                            }
                            if(y<grid.length-1) html += '\n';
                        }
                        rpAscii.innerHTML = html;

                        rafId = requestAnimationFrame(render);
                    }

                    function putChar(grid,x,y,ch){ if(y>=0&&y<grid.length&&x>=0&&x<grid[0].length) grid[y][x]=ch; }
                    function putCharFaint(grid,x,y,ch){ if(y>=0&&y<grid.length&&x>=0&&x<grid[0].length) grid[y][x]= grid[y][x]===' ' ? ch : grid[y][x]; }
                    function drawRipple(grid, cx, cy, rad, dir){
                        // Draw a small diamond-ish outline at the ionosphere bounce point.
                        // Use subtle dots instead of parentheses so the top animation doesn't show '(' or ')'.
                        const pts = [
                            [cx-rad, cy], [cx+rad, cy],
                            [cx, cy-rad], [cx, cy+rad]
                        ];
                        for(const [x,y] of pts){ putCharFaint(grid,x,y, '·'); }
                        // small diagonals (subtle)
                        putCharFaint(grid, cx+rad-1, cy-1, '·');
                        putCharFaint(grid, cx+rad-1, cy+1, '·');
                        putCharFaint(grid, cx-rad+1, cy-1, '·');
                        putCharFaint(grid, cx-rad+1, cy+1, '·');
                    }

                    function startAscii(){
                        if(rafId!=null) return;
                        lastSpawn = performance.now();
                        rafId = requestAnimationFrame(render);
                    }
                    function stopAscii(){
                        if(rafId!=null){ cancelAnimationFrame(rafId); rafId=null; }
                        pulses.length = 0; clearFrame();
                    }

                    // Wire into audio state
                    audio.addEventListener('playing', startAscii);
                    audio.addEventListener('pause', stopAscii);
                    audio.addEventListener('ended', stopAscii);
                    audio.addEventListener('error', stopAscii);

                    // Expose to outer scope so Twilight (YouTube) can control the ASCII
                    try{
                        asciiStart = function(){ try{ startAscii(); }catch{} try{ wrap.classList.add('playing'); playBtn.textContent='⏸'; playBtn.setAttribute('aria-label','Pause'); startCastAnim(); }catch{} };
                        asciiStop = function(){ try{ stopAscii(); }catch{} try{ wrap.classList.remove('playing'); playBtn.textContent='▶'; playBtn.setAttribute('aria-label','Play'); cast.textContent=idleText(); stopCastAnim(); }catch{} };
                    }catch{}

                    // Fit to container to prevent overflow and draw initial tower
                    function measureAndFit(){
                        try{
                            const box = rpAscii.parentElement; if(!box) return;
                            const maxW = Math.max(60, box.clientWidth - 12);
                            // Measure monospace char width using hidden probe
                            const probe = document.createElement('span');
                            probe.style.visibility = 'hidden';
                            probe.style.position = 'absolute';
                            probe.style.whiteSpace = 'pre';
                            probe.style.fontFamily = getComputedStyle(box).fontFamily;
                            probe.textContent = 'X'.repeat(100);
                            box.appendChild(probe);
                            const chW = Math.max(6, probe.getBoundingClientRect().width / 100);
                            box.removeChild(probe);
                            const targetCols = Math.max(24, Math.min(60, Math.floor(maxW / chW) - 2));
                            COLS = targetCols;
                            ROWS = 15;
                            towerX = Math.floor(COLS/2);
                            groundY = ROWS - 1;
                            ionoY = 2;
                            towerTopY = Math.max(ionoY+1, groundY - 7);
                        }catch(e){ /* keep defaults if measure fails */ }
                    }

                    measureAndFit();
                    clearFrame();
                    // Re-measure on resize to keep within container
                    let resizeT; window.addEventListener('resize', ()=>{ clearTimeout(resizeT); resizeT = setTimeout(()=>{ measureAndFit(); clearFrame(); }, 120); });
                    // If restored state says playing, start animation too
                    if(localStorage.getItem(KEY.playing)==='1' && !audio.paused){ startAscii(); }
                })();
            })();
        </script>
    <div class="bg-anim" aria-hidden="true"></div>

    <!-- Semi-transparent dynamic ASCII watermark background -->
    <div class="ascii-watermark" aria-hidden="true">
        <canvas id="asciiCanvas"></canvas>
        <pre id="asciiWatermark"></pre>
    </div>

    <script>
    // High-performance canvas-based ASCII background renderer
    (function(){
        var FAVORITES = ['4','8','15','16','23','42'];
        var DIGIT_BIAS = 0.6;               // denser numbers
        var FAVORITE_RARITY = 0.008;        // rare favored tokens
        var UPDATE_MS = 90;
        var COLS = 220, ROWS = 64;          // logical grid size
        var BASE = ' .,:;!iIl|?%*#@~=+^/\\_-';

    var canvas = document.getElementById('asciiCanvas');
    var ctx = canvas.getContext('2d', { alpha: true });
    var grid = new Array(ROWS);
        var cellW = 8, cellH = 10;          // pixel cell size; adjusted on resize
        // Brand color (RGB) and base numeric alphas; per-cell jitter adjusts these slightly
        var brandRGB = { r:255, g:255, b:255 };
        var baseAlphaVal = 0.06; // baseline alpha for general chars
        var numAlphaVal  = 0.12; // baseline alpha for digits/favorites
    // Global jitter seed + draw phase (randomized to avoid aligned dark patches after restore)
    var jitterSeed = 1;
    var phaseX = 0.0, phaseY = 0.0; // cell-relative offsets added to glyph draw positions

        function updateCanvasColorsFromTheme(){
            // derive colors from CSS custom properties to mesh with active theme
            var cs = getComputedStyle(document.documentElement);
            var brand = cs.getPropertyValue('--brand').trim() || '#6aa9ff';
            // parse brand as rgb/hex and create two translucent variants
            try{
                var c = brand.startsWith('#') ? hexToRgb(brand) : cssToRgb(brand);
                if(c){
                    brandRGB = { r:c.r, g:c.g, b:c.b };
                }
            }catch(e){}
        }

        function hexToRgb(hex){
            var h = hex.replace('#','');
            if(h.length===3){ h = h[0]+h[0]+h[1]+h[1]+h[2]+h[2]; }
            var num = parseInt(h,16);
            return { r:(num>>16)&255, g:(num>>8)&255, b:num&255 };
        }
        function cssToRgb(str){
            var ctx2 = document.createElement('canvas').getContext('2d');
            ctx2.fillStyle = str; // browser parses any css color
            var v = ctx2.fillStyle; // returns standardized rgb(a)
            var m = v.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
            return m ? { r:+m[1], g:+m[2], b:+m[3] } : null;
        }

        function rand(arr){ return arr[(Math.random()*arr.length)|0]; }
        function randDigit(){ return String((Math.random()*10)|0); }
        function randBase(){ return BASE[(Math.random()*BASE.length)|0]; }

        function initGrid(){
            for(var r=0;r<ROWS;r++){
                var row = new Array(COLS);
                for(var c=0;c<COLS;c++) row[c] = makeCell();
                grid[r] = row;
            }
        }

        function makeCell(){
            if(Math.random() < FAVORITE_RARITY){
                return { ch: rand(FAVORITES), isNum: true };
            }
            var useDigit = Math.random() < DIGIT_BIAS;
            var ch = useDigit ? randDigit() : randBase();
            return { ch: ch, isNum: useDigit };
        }

        function resize(){
            var dpr = window.devicePixelRatio || 1;
            // On mobile, cap DPR to reduce fill rate for better performance/battery
            var smallScreen = Math.min(window.innerWidth, window.innerHeight) <= 768;
            if(smallScreen) dpr = Math.min(dpr, 1.5);
            var w = canvas.clientWidth, h = canvas.clientHeight;
            canvas.width = Math.max(1, (w*dpr)|0);
            canvas.height = Math.max(1, (h*dpr)|0);
            ctx.setTransform(dpr,0,0,dpr,0,0);
            // compute cell size to cover with current COLS/ROWS
            cellW = w / COLS;
            cellH = h / ROWS;
            // choose a monospace-like font size from cell height
            var fontPx = Math.max(6, Math.floor(cellH*0.9));
            ctx.font = fontPx + "px 'Roboto Mono', ui-monospace, Menlo, Monaco, 'Courier New', monospace";
            ctx.textBaseline = 'middle';
        }

        // Small deterministic brightness jitter to avoid blocky patches; varies with a global seed
        function jitterFactor(r,c){
            // 32-bit integer hash (xorshift/mix), returns 0..1
            var rr = (r|0) + (jitterSeed & 0xffff);
            var cc = (c|0) ^ ((jitterSeed>>>16) & 0xffff);
            var x = rr * 374761393 ^ cc * 668265263; x = (x ^ (x>>>13)) * 1274126177; x = x ^ (x>>>16);
            var n = (x >>> 0) / 4294967295; // 0..1
            // Map to a gentle 0.85..1.15 range to keep contrast subtle
            return 0.85 + n * 0.30;
        }
        function rgbaWithAlpha(a){ return 'rgba(' + brandRGB.r + ',' + brandRGB.g + ',' + brandRGB.b + ',' + a + ')'; }

        function drawFull(){
            ctx.clearRect(0,0,canvas.width,canvas.height);
            for(var r=0;r<ROWS;r++){
                for(var c=0;c<COLS;c++){
                    var cell = grid[r][c];
                    var jf = jitterFactor(r,c);
                    var a = (cell.isNum ? numAlphaVal : baseAlphaVal) * jf; if(a > 1) a = 1; if(a < 0) a = 0;
                    ctx.fillStyle = rgbaWithAlpha(a);
                    var offX = 0.1 + phaseX; if(offX < 0) offX = 0; if(offX > 0.3) offX = 0.3;
                    var offY = 0.54 + phaseY; if(offY < 0.35) offY = 0.35; if(offY > 0.75) offY = 0.75;
                    ctx.fillText(cell.ch, c*cellW + cellW*offX, r*cellH + cellH*offY);
                }
            }
        }

        // Adaptive rAF loop
        var rafId = null, lastTs = 0, changeAccumulator = 0;
        var changesPerSecond = 4000; // starting target; will adapt
        var maxPerFrame = 700;       // cap to avoid spikes

        function frame(ts){
            if(!lastTs) lastTs = ts;
            var dt = ts - lastTs; // ms
            lastTs = ts;
            // accumulate how many cells to mutate this frame
            changeAccumulator += (changesPerSecond * dt) / 500;
            var toMutate = Math.min(maxPerFrame, changeAccumulator | 0);
            if(toMutate > 0){
                changeAccumulator -= toMutate;
                for(var i=0;i<toMutate;i++){
                    var r = (Math.random()*ROWS)|0;
                    var c = (Math.random()*COLS)|0;
                    var cell = grid[r][c] = makeCell();
                    var x = c*cellW, y = r*cellH;
                    // Clear a slightly larger rect to avoid any AA overhang causing ghosting/doubling
                    ctx.clearRect(x - 2, y - 2, cellW + 4, cellH + 4);
                    var jf = jitterFactor(r,c);
                    var a = (cell.isNum ? numAlphaVal : baseAlphaVal) * jf; if(a > 1) a = 1; if(a < 0) a = 0;
                    ctx.fillStyle = rgbaWithAlpha(a);
                    var offX = 0.1 + phaseX; if(offX < 0) offX = 0; if(offX > 0.3) offX = 0.3;
                    var offY = 0.54 + phaseY; if(offY < 0.35) offY = 0.35; if(offY > 0.75) offY = 0.75;
                    ctx.fillText(cell.ch, x + cellW*offX, y + cellH*offY);
                }
            }
            // simple adaptive tuning based on dt
            var targetMs = 16.7;
            if(dt > targetMs*1.2) { changesPerSecond = Math.max(1000, changesPerSecond * 0.9); }
            else if(dt < targetMs*0.7) { changesPerSecond = Math.min(12000, changesPerSecond * 1.05); }
            rafId = requestAnimationFrame(frame);
        }

    function reseedVisuals(){
        jitterSeed = (Math.random()*0x7fffffff)|0;
        // small phase shift per resume so the global grid doesn’t anchor to the same subpixel origin
        phaseX = (Math.random()*0.20) - 0.10; // [-0.10, +0.10] of a cell width
        phaseY = (Math.random()*0.20) - 0.10; // [-0.10, +0.10] of a cell height
    }
    function start(){ updateCanvasColorsFromTheme(); reseedVisuals(); initGrid(); resize(); drawFull(); rafId = requestAnimationFrame(frame); }
        function onResize(){ cancelAnimationFrame(rafId); rafId = null; resize(); drawFull(); lastTs = 0; changeAccumulator = 0; rafId = requestAnimationFrame(frame); }

        var reduce = false; try{ reduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches; }catch(e){}
    if(reduce){ changesPerSecond = 1500; }
        // On small screens, start with a lower mutation budget to keep frames smooth
        try{
            var smallScreenInit = Math.min(window.innerWidth, window.innerHeight) <= 768;
            if(smallScreenInit){ changesPerSecond = Math.min(changesPerSecond, 3000); maxPerFrame = Math.min(maxPerFrame, 450); }
        }catch(e){}

        // Optional external controls
        window.__asciiBg = {
            start: function(){ if(!rafId){ start(); setHidden(false); try{ localStorage.setItem('__asciiBg','on'); }catch(e){} } },
            stop: function(){ if(rafId){ cancelAnimationFrame(rafId); rafId=null; } try{ localStorage.setItem('__asciiBg','off'); }catch(e){} },
            isRunning: function(){ return !!rafId; }
        };

        function setHidden(hide){
            try{
                var layer = document.querySelector('.ascii-watermark');
                if(layer){ layer.style.display = hide ? 'none' : ''; }
            }catch(e){}
        }

        window.addEventListener('load', function(){
            var pref = 'on'; try{ pref = localStorage.getItem('__asciiBg')||'on'; }catch(e){}
            if(pref === 'off'){ setHidden(true); }
            else { start(); }
            // listen for theme changes via click on orbs to update colors
            var orbs = document.querySelectorAll('.theme-capsule .theme-orb');
            orbs.forEach(function(o){ o.addEventListener('click', function(){ updateCanvasColorsFromTheme(); }); });
            // also respond to a custom theme change event so programmatic theme sets update the canvas
            try{ document.addEventListener('theme-changed', function(){ updateCanvasColorsFromTheme(); }); }catch(e){}
        });
        window.addEventListener('resize', onResize);
        // When returning to the tab, some browsers “shrink” fixed layers until a reflow; fix both layers
        function refreshGlowLayer(){ try{
            var glow = document.querySelector('.bg-anim'); if(!glow) return;
            // restart CSS animation to force reflow
            var prev = glow.style.animationName; glow.style.animationName = 'none';
            void glow.offsetWidth; // force reflow
            glow.style.animationName = '';
            // also reapply positional CSS to ensure viewport-calculated insets take effect
            glow.style.top = '-25vh'; glow.style.left = '-25vw'; glow.style.right = '-25vw'; glow.style.bottom = '-25vh';
        }catch(e){} }
        document.addEventListener('visibilitychange', function(){
            if(document.hidden){ if(rafId) cancelAnimationFrame(rafId); rafId = null; }
            else {
                // Resume animations based on user preference (not current rAF state)
                try{
                    var pref = localStorage.getItem('__asciiBg') || 'on';
                    if(pref !== 'off'){
                        refreshGlowLayer();
                        reseedVisuals(); initGrid(); onResize();
                    }
                }catch(e){
                    // Best-effort resume
                    refreshGlowLayer(); reseedVisuals(); initGrid(); onResize();
                }
            }
        });
        window.addEventListener('pageshow', function(){ refreshGlowLayer(); reseedVisuals(); initGrid(); onResize(); });
    })();
    </script>

    <!-- Sticky Notes Dock (top-right) -->
    <div id="stickyDock" class="sticky-dock" role="toolbar" aria-label="Sticky notes">
        <button id="sdNew" class="sd-btn" title="New note">New</button>
        <button id="sdList" class="sd-btn" title="All notes">All</button>
        <button id="sdCalendar" class="sd-btn" title="Calendar (show)">Calendar</button>
        <button id="sdClearAll" class="sd-btn" title="Clear all notes">Clear all</button>
        <span id="sdCount" class="sd-count" title="Saved notes">0</span>
    </div>
    <div id="stickyPanel" class="sticky-panel hidden" role="region" aria-label="All sticky notes">
        <div class="row">
            <input id="sdSearch" class="sd-input" type="search" placeholder="Search notes (title/text)…" />
            <button id="sdClose" class="sd-btn small" title="Close" aria-label="Close">×</button>
        </div>
        <div id="sdListWrap" class="sticky-list"></div>
    </div>

    <div id="calendarPanel" class="sticky-panel calendar-panel hidden" role="region" aria-label="Calendar">
        <div class="cal-head">
            <button id="calPrev" class="sd-btn small" title="Previous month" aria-label="Previous month">‹</button>
            <div class="cal-head-grow">
                <div id="calMonthLabel" class="cal-month">Month</div>
                <div id="calHint" class="cal-sub">Click a day to add a note</div>
            </div>
            <button id="calNext" class="sd-btn small" title="Next month" aria-label="Next month">›</button>
            <button id="calToday" class="sd-btn small" title="Jump to today">Today</button>
            <button id="calClose" class="sd-btn small" title="Close" aria-label="Close">×</button>
        </div>
        <div id="calGrid" class="cal-grid" role="grid" aria-label="Calendar days"></div>
        <div class="cal-editor" aria-label="Day note editor">
            <div class="cal-row">
                <div class="cal-row-left">
                    <div id="calSelected" class="cal-selected">Select a day…</div>
                    <input id="calTitle" class="cal-title-input" type="text" placeholder="Title…" maxlength="48" aria-label="Day title" disabled />
                </div>
                <button id="calClearDay" class="sd-btn small" title="Clear title and note for selected day">Clear day</button>
            </div>
            <textarea id="calNote" class="cal-note" placeholder="Add a brief note for this day…"></textarea>
        </div>
    </div>

    <!-- Sticky rail: 4 clip points for pinning notes on the right -->
    <div id="stickyRail" class="sticky-rail" aria-label="Sticky clip rail">
        <div class="clip-slot" data-slot="0" title="Clip slot 1"></div>
        <div class="clip-slot" data-slot="1" title="Clip slot 2"></div>
        <div class="clip-slot" data-slot="2" title="Clip slot 3"></div>
        <div class="clip-slot" data-slot="3" title="Clip slot 4"></div>
    </div>
    <div id="stickyRailHoverzone" class="sticky-rail-hoverzone" aria-hidden="true"></div>
    <!-- Rail width resizer handle -->
    <button id="stickyRailResizer" class="sticky-rail-resizer" aria-label="Resize sticky tabs" title="Drag to resize sticky tabs width" aria-controls="stickyRail" data-min="220" data-max="520"></button>

    <!-- Left-side single magnet tab (shares clip-slot behavior; appears after rail so indices 0..3 stay stable) -->
    <div id="leftMagnet" class="clip-slot" data-slot="4" title="Left magnet tab (pin a note here)"></div>
    <div id="leftTabHoverzone" class="left-tab-hoverzone" aria-hidden="true"></div>
        <button id="leftTabResizer" class="left-tab-resizer" aria-label="Resize left magnet tab" title="Drag to resize left magnet width" aria-controls="leftMagnet" data-min="180" data-max="520"></button>

            <!-- Flip-clock digit card styling (boxes per digit with flip cover effect) -->
        <style id="bootFlipCardStyles">
            /* Scope to boot ASCII host so we don't affect other digits */
                #bootAsciiAnim{ display:block; overflow:visible; min-width: 260px; margin: 2px auto; }
                #bootAsciiAnim .digits{ display:flex; align-items:center; justify-content:center; gap:8px; flex-wrap:nowrap }
            #bootAsciiAnim .digit{
                position:relative;
                display:inline-flex; align-items:center; justify-content:center;
                    flex:0 0 auto;
                    width: 44px; height: 56px; /* smaller card so it never overlaps subtext */
                    font-size: 28px; line-height: 1; letter-spacing: .04em;
                    min-width: 40px; /* ensure visible box even with narrow glyphs */
                    padding:0;
                border-radius:8px;
                background: rgba(255,255,255,0.04);
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: inset 0 -1px 0 rgba(255,255,255,0.06), 0 10px 28px rgba(0,0,0,0.35);
                overflow:hidden;
                backface-visibility: hidden;
                transform-style: preserve-3d;
                -webkit-font-smoothing: antialiased;
                text-rendering: geometricPrecision;
                will-change: transform;
                transition: background 160ms ease, border-color 160ms ease;
            }
            /* Ancient glyphs appear inside the same card */
            #bootAsciiAnim .digit.ancient{ background: rgba(255,255,255,0.05); border-color: rgba(255,255,255,0.14) }

                        /* Split-flap illusion: we only show flaps during a flip (class .splitting) */
                        #bootAsciiAnim .digit::before, #bootAsciiAnim .digit::after{
                            position:absolute; left:0; right:0; display:flex; align-items:center; justify-content:center;
                            font: inherit; color: inherit; letter-spacing: inherit;
                            background: rgba(10,10,20,0.25);
                            border-top: 1px solid rgba(255,255,255,0.08);
                            border-bottom: 1px solid rgba(0,0,0,0.35);
                            pointer-events:none; backface-visibility:hidden; transform-style:preserve-3d; opacity:0;
                        }
                        /* top flap shows current value at flip start */
                        #bootAsciiAnim .digit.splitting::before{
                            content: attr(data-top);
                            top:0; height:50%;
                            transform-origin: bottom center;
                            transform: perspective(500px) rotateX(0deg);
                            overflow:hidden; opacity:1;
                        }
                        /* bottom flap initially shows current; later we swap content to next and flip it in */
                        #bootAsciiAnim .digit.splitting::after{
                            content: attr(data-bottom);
                            bottom:0; height:50%;
                            transform-origin: top center;
                            transform: perspective(500px) rotateX(90deg);
                            overflow:hidden; opacity:1;
                            box-shadow: 0 -8px 18px rgba(0,0,0,0.35);
                        }
                        /* Hide the base text while flaps are active so things don't look doubled */
                        #bootAsciiAnim .digit.splitting{ color: transparent; }
                        /* Stage 1: top flips up (old value) */
                        #bootAsciiAnim .digit.flip2::before{ animation: topFlipOut 160ms ease forwards; }
                        /* Stage 2: after we switch data-bottom to the next value, flip it in */
                        #bootAsciiAnim .digit.bottomIn::after{ animation: bottomFlipIn 220ms ease forwards; }
                @keyframes topFlipOut{
                    0%{ transform: perspective(500px) rotateX(0deg); }
                    100%{ transform: perspective(500px) rotateX(-90deg); }
                }
                @keyframes bottomFlipIn{
                    0%{ transform: perspective(500px) rotateX(90deg); }
                    100%{ transform: perspective(500px) rotateX(0deg); }
                }
        </style>


    <script>
            // Boot overlay controller: cycles phrases, then fades into the app
                            (function(){
                                // Only show boot overlay on initial page load (per-tab)
                                var overlay = document.getElementById('bootOverlay');
                                try{
                                    var skip = sessionStorage.getItem('__bootPlayed') === '1';
                                    if(skip){ if(overlay && overlay.parentNode){ overlay.parentNode.removeChild(overlay); } return; }
                                }catch(e){}
                                // Prevent page scroll while boot overlay is visible
                                try{ document.documentElement.classList.add('booting'); document.body.classList.add('booting'); }catch(e){}
                                // Make sticky UI inert (non-focusable / non-interactive) while boot overlay runs
                                try{ if(typeof setStickyInert === 'function') setStickyInert(true); }catch(e){}
                                // Mark as played for this session
                                try{ sessionStorage.setItem('__bootPlayed','1'); }catch(e){}
                // Small ASCII animation for the boot card (replaces spinner)
                // Flip-clock style: countdown from 108.00 with random decreasing steps.
                // Every ~5–6 seconds, all digits briefly switch to hieroglyphs, then return to the current value (no reset)
                // so the countdown can approach ~2.00. On overlay end, flash glyphs, then flip back to 108.00.
                // Entirely text-based and per-digit flip animation via CSS.
                var _bootAnimId = null;
                (function(){
                    // Five-character MMSSS timer (3-digit minutes + 2-digit seconds), starting at 108:00 → "10800"
                    var START_MIN = 108;
                    var START_SECS = START_MIN * 60; // 6480
                    var currentSecs = START_SECS;
                    var inGlitch = false;
                    var nextGlitchTs = Date.now() + 9500; // placeholder; start() will align with cycle end
                    var TICK = 80; // faster tick for more responsive flips
                    // Only the specified symbols
                    var GLYPH_SET = ['𓇋','𓎛','𓄿','𓏏','𓌙'];

                    function seedString(){ return '108.00'; }
                    // Render 5 characters total: 3-digit minutes + 2-digit seconds (no punctuation)
                    function fmtFiveFromSecs(total){
                        total = Math.max(0, Math.floor(total));
                        var mins = Math.floor(total / 60);
                        var secs = total % 60;
                        return String(mins).padStart(3,'0').slice(-3) + String(secs).padStart(2,'0');
                    }
                    function el(){ return document.getElementById('bootAsciiAnim'); }
                    function ensureStructure(str){
                        var host = el(); if(!host) return null;
                        // Ensure exactly 5 slots so glyphs fill full array
                        var slots = 5;
                        var chars = (str||'').toString().split('');
                        // If provided string shorter or longer, pad/truncate to slots
                        if(chars.length < slots){
                            while(chars.length < slots) chars.push(' ');
                        } else if(chars.length > slots){
                            chars = chars.slice(0, slots);
                        }
                        var html = '<span class="digits">' + chars.map(function(ch){ return '<span class="digit">'+ch+'</span>'; }).join('') + '</span>';
                        host.innerHTML = html; return host.querySelectorAll('.digit');
                    }
                    function spans(){ var host = el(); return host ? host.querySelectorAll('.digit') : null; }
                    // Per-digit staggered updates: leftmost slow, rightmost fast
                    var digitDelays = [220, 140, 80, 40, 12]; // ms delays for indices 0..4
                    function updateDigits(str, order){
                        var sp = spans(); if(!sp || sp.length !== 5){ sp = ensureStructure(str); }
                        if(!sp) return;
                        var cur = Array.prototype.map.call(sp, function(s){ return s.textContent || ' '; });
                        var target = (str||'').toString().split('');
                        // Ensure target is length 5
                        if(target.length < 5){ while(target.length<5) target.push(' '); }
                        if(target.length > 5) target = target.slice(0,5);
                        // If an order (scramble) was provided, respect it for timing positions
                        var orderMap = null;
                        if(Array.isArray(order) && order.length===5){ orderMap = order.slice(); }
                        for(let i=0;i<5;i++){
                            if(cur[i] === target[i]) continue;
                            (function(idx){
                                var d = sp[idx];
                                var baseDelay = digitDelays[idx] || 60;
                                // If orderMap provided, place earlier items slightly earlier
                                var extra = 0;
                                if(orderMap){ var pos = orderMap.indexOf(idx); if(pos>=0) extra = pos*8; }
                                // Prepare split-flap: start with current value on both halves
                                try{
                                    d.setAttribute('data-top', cur[idx]);
                                    d.setAttribute('data-bottom', cur[idx]);
                                    d.classList.add('splitting');
                                    d.classList.remove('ancient');
                                }catch(e){}
                                // Start split-flap animation; then swap bottom content to next and flip it in
                                setTimeout(function(){
                                    if(inGlitch) return; // don't fight the glyph flash
                                    try{ d.classList.add('flip2'); }catch(e){}
                                    // After top flap lifts, switch bottom to the next value and flip it in
                                    setTimeout(function(){
                                        if(inGlitch) return;
                                        try{
                                            d.setAttribute('data-bottom', target[idx]);
                                            d.classList.add('bottomIn');
                                        }catch(e){}
                                        // After bottom finishes, commit the new text and clear classes
                                        setTimeout(function(){
                                            if(inGlitch) return;
                                            try{
                                                d.textContent = target[idx];
                                                d.classList.remove('flip2','bottomIn','splitting');
                                            }catch(e){}
                                        }, 240);
                                    }, 160);
                                }, baseDelay + extra);
                            })(i);
                        }
                    }
                    function randomStepSecs(){
                        // kept for compatibility when occasional large jumps are desired
                        var r = Math.random(); var step;
                        if(currentSecs > 1800)      step = 30 + Math.floor(r*60);
                        else if(currentSecs > 600)  step = 10 + Math.floor(r*20);
                        else if(currentSecs > 120)  step = 5 + Math.floor(r*6);
                        else                        step = 1 + Math.floor(r*4);
                        return step;
                    }
                    // Time accumulator to produce approximately 1-second decrements while tick() runs faster
                    var tickAcc = 0;
                    var lastTickTs = Date.now();
                    var secondToggle = false; // for every-other-second small jump
                    // Cycle controls: base cycle (will be adapted to popup duration in start())
                    var CYCLE_MS = 10000;
                    // Global speed multiplier for the countdown (1 = real-time). Will be computed in start() based on `total` so the countdown reaches zero before popup ends.
                    var SPEED_MULT = 1;
                    var accelUntil = 0;     // timestamp until acceleration applies
                    var accelFactor = 1;    // 1 = normal, >1 = accelerated
                    var viewHoldUntil = 0;  // timestamp to hold a randomly lowered number for ~2s
                    var _cycleTimerId = null;
                    var cyclesSinceGlitch = 0; // count cycles to defer glyphs until we've advanced
                    // Strict cycle scheduling for 10s loop + glyph linger
                    var GLYPH_LINGER_MS = 2000; // show hieroglyphs ~2s near cycle end
                    try{ window.__bootGlyphLingerMs = GLYPH_LINGER_MS; }catch(e){}
                    // Timestamps
                    var overallStartTs = Date.now(); // marks beginning of the boot animation (used for adaptive speed)
                    var cycleStartTs = overallStartTs;
                    var finalGlyphTs = 0; // epoch ms when final hieroglyphs should appear
                    var shownFinalGlyph = false;
                    var nextStepTs = 0; // next jump update (stepBase-derived)
                    var glitchEndTs = 0; // when to end glyph display
                    // Only show glyphs when explicitly allowed (force=true) or when the final glyph time has arrived.
                    // This prevents accidental mid-cycle flashes caused by stray calls.
                    // Synchronized split-flap flip to the ancient glyphs and hold for lingerMs (ms).
                    // If `force` is false, only allow the glyphs when finalGlyphTs has passed.
                    function toGlyphs(force, lingerMs){
                        try{
                            var now = Date.now();
                            if(!force && finalGlyphTs && now < finalGlyphTs) return;
                        }catch(e){}
                        var sp = spans(); if(!sp || sp.length !== 5){ sp = ensureStructure(fmtFiveFromSecs(currentSecs)); }
                        if(!sp) return;
                        // Prepare top/bottom with current values and start splitting for all digits at once
                        var cur = Array.prototype.map.call(sp, function(s){ return s.textContent || ' '; });
                        for(var i=0;i<5;i++){
                            try{
                                sp[i].setAttribute('data-top', cur[i]);
                                sp[i].setAttribute('data-bottom', cur[i]);
                                sp[i].classList.add('splitting');
                                sp[i].classList.remove('ancient');
                            }catch(e){}
                        }
                        // Kick top flap out for all digits together (stage 1)
                        setTimeout(function(){
                            for(var i=0;i<5;i++){ try{ sp[i].classList.add('flip2'); }catch(e){} }
                        }, 20);
                        // After top flip completes, swap bottom content to glyphs and flip in (stage 2)
                        setTimeout(function(){
                            for(var i=0;i<5;i++){
                                try{
                                    sp[i].setAttribute('data-bottom', GLYPH_SET[i] || ' ');
                                    sp[i].classList.add('bottomIn');
                                }catch(e){}
                            }
                        }, 200); // slightly after topFlipOut (160ms)
                        // After bottom flip finishes, commit glyphs and leave them visible (ancient)
                        setTimeout(function(){
                            for(var i=0;i<5;i++){
                                try{
                                    sp[i].textContent = GLYPH_SET[i] || ' ';
                                    sp[i].classList.remove('flip2','bottomIn','splitting');
                                    sp[i].classList.add('ancient');
                                }catch(e){}
                            }
                            // Mark inGlitch and set end timestamp
                            try{ inGlitch = true; glitchEndTs = Date.now() + (typeof lingerMs === 'number' ? Math.max(200, lingerMs) : GLYPH_LINGER_MS); }catch(e){}
                        }, 460); // 200 + 260ms ~ bottomFlipIn duration
                    }
                    function resetToSeedRandom(){
                        var t = fmtFiveFromSecs(START_SECS); // "10800"
                        var order = Array.from({length:t.length}, function(_,i){ return i; });
                        for(var i=order.length-1;i>0;i--){ var j=(Math.random()*(i+1))|0; var tmp=order[i]; order[i]=order[j]; order[j]=tmp; }
                        updateDigits(t, order);
                    }
                    function tick(){
                        try{
                            var now = Date.now();
                            // If currently showing glyphs, end after linger interval, then reset cycle
                            if(inGlitch){
                                if(now >= glitchEndTs){
                                    inGlitch = false;
                                    // Recalculate currentSecs from overall elapsed so countdown continues smoothly
                                    var elapsedRealAfter = Math.floor((now - overallStartTs) / 1000);
                                    var virtualDecAfter = elapsedRealAfter * SPEED_MULT;
                                    currentSecs = Math.max(0, START_SECS - virtualDecAfter);
                                    updateDigits(fmtFiveFromSecs(currentSecs));
                                    // start a fresh cycle window for gating next glitch
                                    cycleStartTs = now;
                                    nextGlitchTs = cycleStartTs + Math.max( Math.min(CYCLE_MS - GLYPH_LINGER_MS, CYCLE_MS - 200), 200 );
                                    var stepBaseAfter = Math.max(200, Math.floor((CYCLE_MS - GLYPH_LINGER_MS) / 8));
                                    nextStepTs = now + stepBaseAfter + Math.floor(Math.random() * Math.max(1, Math.floor(stepBaseAfter / 2)));
                                    lastTickTs = now; tickAcc = 0; secondToggle = false;
                                }
                                return;
                            }
                            // Only show hieroglyphs at the final reserved time (derived from popup duration)
                            if(!shownFinalGlyph && finalGlyphTs && now >= finalGlyphTs){
                                shownFinalGlyph = true;
                                // Flip all glyphs synchronously and hold for GLYPH_LINGER_MS
                                toGlyphs(true, GLYPH_LINGER_MS);
                                // Final state: stop all further ticking so nothing flips back to numbers
                                try{ if(_bootAnimId){ clearInterval(_bootAnimId); _bootAnimId = null; } }catch(e){}
                                try{ if(_cycleTimerId){ clearInterval(_cycleTimerId); _cycleTimerId = null; } }catch(e){}
                                return;
                            }
                            // Update visible time every ~0.9–1.1s using accelerated scale (50×)
                            if(nextStepTs === 0){ var stepBase = Math.max(200, Math.floor((CYCLE_MS - GLYPH_LINGER_MS) / 8)); nextStepTs = now + stepBase + Math.floor(Math.random() * Math.max(1, Math.floor(stepBase/2))); }
                            if(now >= nextStepTs){
                                // Use overall elapsed time since the boot animation started so the virtual countdown scales to the full popup duration
                                var elapsedReal = Math.floor((now - overallStartTs) / 1000); // seconds since boot start
                                var virtualDec = elapsedReal * SPEED_MULT; // accelerated seconds to subtract
                                var newSecs = Math.max(0, START_SECS - virtualDec);
                                if(newSecs !== currentSecs){
                                    currentSecs = newSecs;
                                    updateDigits(fmtFiveFromSecs(currentSecs));
                                }
                                var stepBase2 = Math.max(200, Math.floor((CYCLE_MS - GLYPH_LINGER_MS) / 8));
                                nextStepTs = now + stepBase2 + Math.floor(Math.random() * Math.max(1, Math.floor(stepBase2/2)));
                            }
                        }catch(e){}
                    }
                    function _cycleKick(){
                        try{
                            // Count this cycle (used to defer glyph glitches until we've made progress)
                            cyclesSinceGlitch++;
                            // Start a short accelerated phase (stronger: 6-8x) for ~2.5s
                            accelFactor = 6 + Math.floor(Math.random()*3); // 6,7,8
                            accelUntil = Date.now() + 2500;
                            // Apply a larger proportional reduction to make meaningful progress each cycle
                            if(currentSecs > 10){
                                // Remove ~15%–40% of remaining time to drive it toward zero faster
                                var pct = 0.15 + Math.random()*0.25; // 0.15..0.40
                                var bigReduce = Math.max(5, Math.floor(currentSecs * pct));
                                currentSecs = Math.max(0, currentSecs - bigReduce);
                            } else {
                                currentSecs = 0;
                            }
                            updateDigits(fmtFiveFromSecs(currentSecs));
                            // Hold this view briefly so user can read it (~1.2s)
                            viewHoldUntil = Date.now() + 1200;
                            // Previously scheduled mid-cycle glitches removed: final glyphs will only be shown at finalGlyphTs
                            // (no-op here)
                        }catch(e){}
                    }

                    function start(){
                        var host = el(); if(!host) return;
                        var now = Date.now();
                        currentSecs = START_SECS; inGlitch = false;
                        // mark overall boot start
                        overallStartTs = now;
                        // Use outer `total` (ms) to calibrate running time
                        var TOTAL_LOAD_MS = (typeof total === 'number' && total > 0) ? Math.max(2000, Math.floor(total)) : 30000;
                        // Reserve final glyph linger window; compute effective run time for counting
                        var effectiveRunMs = Math.max(800, TOTAL_LOAD_MS - GLYPH_LINGER_MS);
                        // Compute SPEED_MULT so START_SECS virtual seconds elapse across effectiveRunMs
                        SPEED_MULT = Math.max(1, Math.ceil(START_SECS / (effectiveRunMs / 1000)));

                        // Fit cycle length to TOTAL_LOAD_MS aiming for ~10s cycles but always at least 2s
                        var approxCycleCount = Math.max(1, Math.round(TOTAL_LOAD_MS / 10000));
                        CYCLE_MS = Math.max(2000, Math.floor(TOTAL_LOAD_MS / approxCycleCount));

                        // Initialize cycle timestamps
                        cycleStartTs = now;
                        // Compute absolute final glyph time (show hieroglyphs only once at end)
                        finalGlyphTs = overallStartTs + Math.max(200, Math.floor(TOTAL_LOAD_MS - GLYPH_LINGER_MS));
                        shownFinalGlyph = false;
                        // Keep a legacy nextGlitchTs value for compatibility but it will not be used to trigger glyphs
                        nextGlitchTs = cycleStartTs + Math.max( Math.min(CYCLE_MS - GLYPH_LINGER_MS, CYCLE_MS - 200), 200 );
                        // Per-step interval scales with cycle length
                        var stepBase = Math.max(200, Math.floor((CYCLE_MS - GLYPH_LINGER_MS) / 8));
                        nextStepTs = now + stepBase + Math.floor(Math.random() * Math.max(1, Math.floor(stepBase / 2)));

                        glitchEndTs = 0;
                        tickAcc = 0; lastTickTs = now; secondToggle = false;
                        ensureStructure(fmtFiveFromSecs(currentSecs));
                        _bootAnimId = setInterval(tick, TICK);
                        // Disable any legacy cycle timer
                        if(_cycleTimerId) { clearInterval(_cycleTimerId); _cycleTimerId = null; }
                    }

                    // Stop the ticker and show glyphs for an optional linger (ms). If lingerMs omitted, use a short default.
                    function stop(lingerMs){
                        try{
                            if(_bootAnimId) clearInterval(_bootAnimId); _bootAnimId=null;
                            if(_cycleTimerId) clearInterval(_cycleTimerId); _cycleTimerId = null;
                            // Immediately switch to glyphs and mark inGlitch; do NOT reset here — reset will occur after overlay removal
                            var ms = (typeof lingerMs === 'number') ? Math.max(200, lingerMs) : GLYPH_LINGER_MS;
                            toGlyphs(true, ms);
                        }catch(e){}
                    }
                    startBootAnim = start; stopBootAnim = stop;
                })();
                var phrases = [
    "[BOOT] Don’t tell me what I can’t do… initializing.",
    "[FETCH] We have to go back… requesting previous state.",
    "[HANDSHAKE] See you in another life, brother… establishing session.",
    "[TASK] Everything happens for a reason… scheduling job.",
    "[CRON/108] Push the button… next run in 108 minutes.",
    "[VALIDATE] The numbers are bad… checksum failing: 4 8 15 16 23 42.",
    "[ROUTE] Destiny calls… recalculating path.",
    "[FAILSAFE] System failure imminent… engage protocol.",
    "[ORIENT] Orientation video loading… buffering truths.",
    "[PROTOCOL] Initiative guidelines applied… compliance passing.",
    "[I/O] The Hatch is opening… streaming secrets.",
    "[TIMER] 108 minutes remain… watchdog armed.",
    "[INPUT] Enter the code… awaiting six integers.",
    "[REBOOT] Station reboot complete… services restored.",
    "[VARIANTS] What if we’re the variables… enabling A/B routes.",
    "[IMMUTABLE] There is no reset… write-once mode set.",
    "[MERGE] Everything that rises must converge… resolving branches.",
    "[LOCK] The past can’t be changed… git history protected.",
    "[BOUND] You can’t escape the Island… sandbox enforced.",
    "[GUARD] The light must be protected… rate limiter engaged.",
    "[CHOICE] Fate vs. free will… prompting user decision.",
    "[POLICY] You’re not supposed to leave… egress blocked by rule.",
    "[SECRET] What lies in the shadow of the statue… decrypting payload.",
    "[RETRO] You all, everybody… broadcasting to subscribers.",
    "[WATCH] Monsters are real… anomaly detector online.",
    "[SEED] I made my own luck… seeding RNG.",
    "[CACHE] I remember… warm cache restored.",
    "[TIME] Time’s not a straight line… enabling jitter buffer.",
    "[INTENT] We were brought here for a reason… classifier confident.",
    "[HOME] There is no place like home… redirecting to root.",
    "[RELEASE] You can let go now… freeing resources.",
    "[INBOUND] They’re coming… opening inbound ports.",
    "[CYCLE] The end is the beginning… restarting event loop.",
    "[PING] 815 responding… round-trip stable.",
    "[TRIGGER] Button 42 pressed… executing failsafe.",
    "[MAP] Reconstructing flight path 815… plotting vectors.",
    "[CAST] Oceanic check-in… session tokens refreshed.",
    "[GUARDIAN] Smoke on the stack… firewall tightening.",
    "[LAMBDA] The Moth emerges… escalating privileges.",
    "[SYNC] See you in another timeline… state sync complete."
                ];
                overlay = overlay || document.getElementById('bootOverlay');
                if(!overlay) return;
                var phraseEl = document.getElementById('bootPhrase');
                var subEl = overlay.querySelector('.boot-sub');
                // Fit ASCII title to boot card width by scaling
                function fitBootAscii(){
                    try{
                        var pre = document.getElementById('bootAscii'); if(!pre) return;
                        var container = pre.parentElement; if(!container) return;
                        // prepare for measurement
                        var priorDisplay = pre.style.display;
                        pre.style.display = 'inline-block';
                        pre.style.transform = 'none';
                        pre.style.transformOrigin = '50% 0%';
                        container.style.height = 'auto';
                        // Measure natural width (max-content) while unscaled
                        // leave horizontal slack to avoid rounding overflow and shadow bleed
                        var cw = (container.clientWidth || container.offsetWidth || 0) - 10;
                        var naturalRect = pre.getBoundingClientRect();
                        var naturalWidth = naturalRect.width || (pre.scrollWidth || 1);
                        var scale = Math.min(1, cw / naturalWidth);
                        // Apply a stronger fudge factor to guarantee fit
                        scale = Math.max(0.1, Math.min(1, scale * 0.975));
                        pre.style.transform = 'scale(' + scale + ')';
                        var rect = pre.getBoundingClientRect();
                        // Reserve slightly more than measured to avoid clipping bottom row
                        container.style.height = Math.ceil(rect.height + 2) + 'px';
                        // Keep inline-block to preserve measured scrollWidth behavior
                        pre.style.display = 'inline-block';
                        // Safety pass: if rect width still exceeds container width, correct using rect-based ratio
                        var rw = pre.getBoundingClientRect().width;
                        var cw2 = (container.clientWidth || container.offsetWidth || 0) - 10;
                        if(rw > cw2){
                            var scale2 = Math.max(0.1, scale * (cw2 / rw) * 0.98);
                            pre.style.transform = 'scale(' + scale2 + ')';
                            var rect2 = pre.getBoundingClientRect();
                            container.style.height = Math.ceil(rect2.height + 2) + 'px';
                            scale = scale2; rect = rect2; // use final values
                        }
                        // Final centering: translateX so the scaled rect is centered inside container
                        var cRect = container.getBoundingClientRect();
                        var desiredLeft = (cRect.width - rect.width) / 2;
                        var currentLeft = rect.left - cRect.left;
                        var dx = desiredLeft - currentLeft;
                        pre.style.transform = 'translateX(' + dx.toFixed(2) + 'px) scale(' + scale + ')';
                    }catch(e){}
                }
                var i = 0, elapsed = 0;
                var total = 30000 + Math.random()*15000; // 30–45s

                function durationFor(text){
                    var len = (text||'').length;
                    // Base + per-char time; clamped to reasonable reading window
                    var ms = 1400 + len*55; // ~0.055s per char
                    if(ms < 2200) ms = 2200; // min 2.2s
                    if(ms > 7200) ms = 7200; // max 7.2s
                    return ms;
                }

                function showNext(){
                    if(!overlay) return;
                    var text = phrases[i % phrases.length];
                    var seg = durationFor(text);
                    if(elapsed + seg > total){ seg = Math.max(1400, total - elapsed); }
                    if(seg <= 0){ endBoot(); return; }
                    phraseEl.classList.remove('show');
                    // fade out then swap
                    setTimeout(function(){ phraseEl.textContent = text; phraseEl.classList.add('show'); }, 180);
                    elapsed += seg;
                    i++;
                    setTimeout(function(){
                        if(elapsed >= total) { endBoot(); }
                        else { showNext(); }
                    }, seg);
                }

                function endBoot(){
                    if(!overlay) return;
                    subEl.textContent = 'Ready.';
                    try{
                        // Use a safe, globally exposed linger value so we don't ReferenceError on an inner-scope var
                        var __linger = (typeof window!== 'undefined' && typeof window.__bootGlyphLingerMs === 'number') ? window.__bootGlyphLingerMs : 2000;
                        // Show hieroglyphs for the configured linger window before starting the overlay fade
                        if(typeof stopBootAnim === 'function') stopBootAnim(__linger);
                    }catch(e){}
                    // Start hiding the overlay after the glyph linger completes so users see glyphs 1-2s before disappearance
                    var __linger2 = (typeof window!== 'undefined' && typeof window.__bootGlyphLingerMs === 'number') ? window.__bootGlyphLingerMs : 2000;
                    setTimeout(function(){
                        try{ overlay.classList.add('hidden'); }catch(e){}
                        // remove from DOM after the CSS hide transition (keep previous 650ms fallback)
                        setTimeout(function(){
                            try{ if(overlay && overlay.parentNode){ overlay.parentNode.removeChild(overlay); } }catch(e){}
                            overlay = null;
                            try{ document.documentElement.classList.remove('booting'); document.body.classList.remove('booting'); }catch(e){}
                            try{ if(typeof setStickyInert === 'function') setStickyInert(false); }catch(e){}
                            // After boot ends, ensure sticky notes layout is computed and reflowed
                            try{ if(typeof layoutAllSlots === 'function') { layoutAllSlots(); } }catch(e){}
                            // Reset the numeric display back to seed once overlay is fully removed
                            try{ resetToSeedRandom(); inGlitch = false; shownFinalGlyph = false; }catch(e){}
                        }, 650);
                    }, __linger2);
                }

                // Start sequence after a brief tick so initial paint happens
                setTimeout(function(){
                    subEl.textContent = 'Loading modules…';
                    fitBootAscii();
                    try{ if(typeof startBootAnim === 'function') startBootAnim(); }catch(e){}
                    showNext();
                }, 120);
                // Keep API key dots updated: green when key present, red when missing
                function updateApiDots(){
                    try{
                        let key = null;
                        if(typeof getEffectiveGemKey === 'function'){
                            key = getEffectiveGemKey();
                        }
                        if(!key){ try{ key = localStorage.getItem('gemini.key'); }catch{} }
                        const randomDot = document.getElementById('randomKeyDot');
                        const dailyDot = document.getElementById('dailyKeyDot');
                        if(randomDot){ randomDot.classList.remove('missing','present'); randomDot.classList.add(key ? 'present' : 'missing'); }
                        if(dailyDot){ dailyDot.classList.remove('missing','present'); dailyDot.classList.add(key ? 'present' : 'missing'); }
                        // enable/disable gear button when key absent OR when API key is disabled via toggle
                        try{
                            const gear = document.getElementById('randomGearBtn');
                            const enabledToggle = document.getElementById('globalGemEnable');
                            const enabled = !!(enabledToggle && enabledToggle.checked);
                            const ok = !!key && enabled;
                            if(gear){
                                gear.disabled = !ok;
                                gear.setAttribute('aria-disabled', (!ok) ? 'true' : 'false');
                                gear.classList.toggle('disabled', !ok);
                                if(!ok){ gear.setAttribute('tabindex','-1'); } else { gear.removeAttribute('tabindex'); }
                            }
                        }catch(e){}
                    }catch(e){}
                }
                // update now and on storage events or input changes
                try{ updateApiDots(); window.addEventListener('storage', (e)=>{ if(e.key === 'gemini.key') updateApiDots(); }); const gk = document.getElementById('globalGemKey'); if(gk) gk.addEventListener('input', ()=>{ setTimeout(updateApiDots,10); }); const ge = document.getElementById('globalGemEnable'); if(ge) ge.addEventListener('change', ()=>{ setTimeout(updateApiDots,10); }); }catch(e){}
                // Re-fit after fonts are ready in case metrics shift
                try{ if(document.fonts && document.fonts.ready){ document.fonts.ready.then(function(){ fitBootAscii(); }); } }catch(e){}
                window.addEventListener('resize', function(){ if(!overlay) return; fitBootAscii(); });
            })();
        </script>


    <!-- Theme capsule: 6 tricolor orbs with numeric overlays controlling background and button colors -->
    <div class="theme-capsule" id="themeCapsule" aria-label="Theme colors">
       <div class="theme-orb orb-ocean" data-theme="ocean" title="Ocean"></div>
       <div class="theme-orb orb-sunset" data-theme="sunset" title="Sunset"></div>
        <div class="theme-orb orb-forest" data-theme="forest" title="Forest"></div>
       <div class="theme-orb orb-violet" data-theme="violet" title="Violet"></div>
       <div class="theme-orb orb-ember" data-theme="ember" title="Ember"></div>
    <div class="theme-orb orb-custom" data-theme="Custom" title="Custom (double-click to customize)"></div>
    </div>

    <script>
    // Keep the background-toggle stack positioned exactly one --control-gap below the theme capsule.
    (function(){
        try{
            const root = document.documentElement;
            const capsule = document.getElementById('themeCapsule');
            if(!capsule) return;

            let raf = 0;
            const sync = ()=>{
                raf = 0;
                const h = Math.ceil(capsule.getBoundingClientRect().height || 0);
                if(h > 0) root.style.setProperty('--theme-capsule-h', h + 'px');
            };
            const requestSync = ()=>{
                if(raf) cancelAnimationFrame(raf);
                raf = requestAnimationFrame(sync);
            };

            requestSync();
            window.addEventListener('resize', requestSync, { passive:true });
            try{ if(document.fonts && document.fonts.ready) document.fonts.ready.then(requestSync); }catch(e){}
        }catch(e){}
    })();
    </script>
    <div id="paletteEditor" class="palette-editor hidden" role="dialog" aria-label="Custom palette editor">
        <div class="pe-header" id="peHeader" tabindex="0">
            <span>Customize Interface</span>
            <div class="pe-actions">
                <button id="peReset" class="btn small" title="Reset">Reset</button>
                <button id="peClose" class="btn small" aria-label="Close">×</button>
            </div>
        </div>
        <div class="pe-body">
            <div class="pe-row">
                <label for="peC1">C1<input id="peC1" type="color" /></label>
                <label for="peC2">C2<input id="peC2" type="color" /></label>
                <label for="peC3">C3<input id="peC3" type="color" /></label>
            </div>
            <div class="pe-preview" id="pePreview" aria-hidden="true"></div>
        </div>
    </div>
    <div id="bgToggles">
    <!-- Group the inverted display controls in a single horizontal row -->
    <div id="invertControlsRow" class="inline-controls-row">
        <!-- Light Mode toggle: inverts the UI while preserving palette colors for the theme orbs -->
        <button id="enableLightModeBtn" class="btn pill" title="Enable Inverted Display" aria-pressed="false">Enable Inverted Display</button>
        <!-- Invert Timer mini side-menu (sits to the right of the inverted display button) -->
        <div id="invertTimerMenu" class="news-side-menu invert-timer-menu" aria-hidden="false">
            <button id="invertTimerToggle" class="btn pill news-menu-toggle" aria-expanded="false" aria-controls="invertTimerMenuContent" title="Set auto-flip speed">⏱</button>
            <div id="invertTimerMenuContent" class="news-side-menu-content" role="menu" aria-hidden="true">
                <div class="news-side-pill minimalist" role="presentation">
                    <label for="invertTimerValue" class="visually-hidden">Interval value</label>
                    <input id="invertTimerValue" class="invert-input" type="number" min="0" step="1" value="10" aria-label="Interval value" title="0 disables auto-flip" />
                    <label for="invertTimerUnit" class="visually-hidden">Interval unit</label>
                    <select id="invertTimerUnit" class="invert-select" aria-label="Interval unit">
                        <option value="s" selected>s</option>
                        <option value="ms">ms</option>
                    </select>
                    <button id="invertTimerApply" class="icon-btn" title="Set auto-flip" aria-label="Set auto-flip">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                            <path d="M20 6L9 17l-5-5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>
    <script>
    (function(){
        const KEY = '__custom_orb_greyscale_v1';
            function toHex(rgb){
            if(!rgb) return '#999999';
            rgb = rgb.trim();
            if(rgb[0] === '#') return rgb;
            const m = rgb.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
            if(m){ const r = parseInt(m[1]), g = parseInt(m[2]), b = parseInt(m[3]); return '#'+((1<<24)+(r<<16)|(g<<8)|b).toString(16).slice(1); }
            return rgb;
        }

        // mix two hex colors (linear RGB) by t in [0..1]
        function mixHex(a,b,t){
            try{
                if(!a||!b) return a||b||'#000000';
                const pa = a.replace('#',''); const pb = b.replace('#','');
                const na = pa.length===3 ? pa.split('').map(c=>c+c).join('') : pa;
                const nb = pb.length===3 ? pb.split('').map(c=>c+c).join('') : pb;
                const ar = parseInt(na.substring(0,2),16), ag = parseInt(na.substring(2,4),16), ab = parseInt(na.substring(4,6),16);
                const br = parseInt(nb.substring(0,2),16), bg = parseInt(nb.substring(2,4),16), bb = parseInt(nb.substring(4,6),16);
                const rr = Math.round(ar*(1-t)+br*t); const rg = Math.round(ag*(1-t)+bg*t); const rb = Math.round(ab*(1-t)+bb*t);
                const toHex2 = (n)=> (n<16? '0'+n.toString(16) : n.toString(16));
                return '#'+toHex2(rr)+toHex2(rg)+toHex2(rb);
            }catch(e){ return a; }
        }

        function makeSmoothGradient(c1,c2,c3){
            // produce many small blended stops across the strip to avoid banding/seams
            try{
                const steps = 18; // even number gives symmetric midpoint
                const stops = [];
                for(let i=0;i<=steps;i++){
                    const t = i / steps; // 0..1
                    let col;
                    if(t <= 0.5){ col = mixHex(c1, c2, t * 2); }
                    else { col = mixHex(c2, c3, (t - 0.5) * 2); }
                    const pct = (t * 100).toFixed(2).replace(/\.00$/,'') + '%';
                    stops.push(`${col} ${pct}`);
                }
                return `linear-gradient(90deg, ${stops.join(', ')})`;
            }catch(e){
                // fallback to simpler multi-stop
                const a1 = mixHex(c1,c2,0.25);
                const a2 = mixHex(c1,c2,0.55);
                const b1 = mixHex(c2,c3,0.45);
                const b2 = mixHex(c2,c3,0.75);
                return `linear-gradient(90deg, ${c1} 0%, ${a1} 20%, ${a2} 40%, ${c2} 50%, ${b1} 60%, ${b2} 80%, ${c3} 100%)`;
            }
        }

        function readStored(){ try{ const s = localStorage.getItem(KEY); return s ? JSON.parse(s) : null; }catch(e){ return null; } }
        function writeStored(obj){ try{ localStorage.setItem(KEY, JSON.stringify(obj)); }catch(e){} }

        function init(){
            // Prefer the explicit custom orb (orb-custom / data-theme="custom") so only it is bound
            // to the palette editor. Fall back to any greyscale-marked orb, and only as a last resort
            // pick the first orb to avoid accidental binding to Ocean.
            let orb = document.querySelector('.theme-orb.orb-custom') || document.querySelector('.theme-orb[data-theme="custom"]');
            if(!orb) orb = document.querySelector('.theme-orb.orb-greyscale') || document.querySelector('.theme-orb[data-theme="greyscale"]');
            if(!orb) orb = document.querySelector('.theme-orb');
            const editor = document.getElementById('paletteEditor');
            if(!orb || !editor) return;
            const header = document.getElementById('peHeader');
            const c1 = document.getElementById('peC1');
            const c2 = document.getElementById('peC2');
            const c3 = document.getElementById('peC3');
            const preview = document.getElementById('pePreview');
            const closeBtn = document.getElementById('peClose');
            const resetBtn = document.getElementById('peReset');

            // defaults
            const defaults = { c1: '#d4d4d4', c2: '#9ca3af', c3: '#4b5563' };

            // If a stored custom palette exists, always paint the custom orb itself so
            // it visually reflects the saved palette on every reload. However, only
            // apply the palette to the global UI variables (brand/glow/button colors)
            // when the user's persisted theme selection is actually 'custom'/'greyscale'.
            const stored = readStored();
            try{
                if(stored && stored.colors){
                    // Always set the orb's inline color vars so the orb preview stays persistent
                    try{
                        orb.style.setProperty('--c1', stored.colors.c1);
                        orb.style.setProperty('--c2', stored.colors.c2);
                        orb.style.setProperty('--c3', stored.colors.c3);
                    }catch(e){}
                    // Only promote to document-level UI variables when the user selected custom
                    const savedTheme = (localStorage.getItem('__theme') || '').toString().toLowerCase();
                    const shouldApplyStored = (savedTheme === 'custom' || savedTheme === 'greyscale');
                    if(shouldApplyStored){
                        try{ document.documentElement.style.setProperty('--brand', stored.colors.c1); }catch(e){}
                        try{ document.documentElement.style.setProperty('--glow1', hexToRgbaLocal(stored.colors.c1, 0.20)); }catch(e){}
                        try{ document.documentElement.style.setProperty('--glow2', hexToRgbaLocal(stored.colors.c2, 0.14)); }catch(e){}
                        try{ document.documentElement.style.setProperty('--glow3', hexToRgbaLocal(stored.colors.c3, 0.16)); }catch(e){}
                        try{ document.documentElement.style.setProperty('--btnTop', hexToRgbaLocal(stored.colors.c1, 0.30)); }catch(e){}
                        try{ document.documentElement.style.setProperty('--btnBottom', hexToRgbaLocal(stored.colors.c2, 0.28)); }catch(e){}
                        // dye outlines and button borders to match custom palette
                        try{ document.documentElement.style.setProperty('--btnBorder', mixHex(stored.colors.c2, stored.colors.c3, 0.65)); }catch(e){}
                    }
                }
            }catch(e){}

            function loadInputsFromOrb(){ const cs = getComputedStyle(orb); c1.value = toHex(cs.getPropertyValue('--c1')||defaults.c1); c2.value = toHex(cs.getPropertyValue('--c2')||defaults.c2); c3.value = toHex(cs.getPropertyValue('--c3')||defaults.c3); preview.style.background = makeSmoothGradient(c1.value, c2.value, c3.value); }

            loadInputsFromOrb();

            function hexToRgba(h, a){ try{ if(!h) return `rgba(0,0,0,${a})`; h = h.replace('#',''); if(h.length===3) h = h.split('').map(ch=>ch+ch).join(''); const r = parseInt(h.substring(0,2),16); const g = parseInt(h.substring(2,4),16); const b = parseInt(h.substring(4,6),16); return `rgba(${r}, ${g}, ${b}, ${a})`; }catch(e){ return `rgba(0,0,0,${a})`; } }

            function applyColors(){ try{
                // update orb pigments
                orb.style.setProperty('--c1', c1.value);
                orb.style.setProperty('--c2', c2.value);
                orb.style.setProperty('--c3', c3.value);
                // update some commonly-used UI accent variables so the palette affects the wider interface
                try{ document.documentElement.style.setProperty('--brand', c1.value); }catch(e){}
                try{ document.documentElement.style.setProperty('--glow1', hexToRgba(c1.value, 0.20)); document.documentElement.style.setProperty('--glow2', hexToRgba(c2.value, 0.14)); document.documentElement.style.setProperty('--glow3', hexToRgba(c3.value, 0.16)); }catch(e){}
                // attempt to set button gradient endpoints (subtle tint)
                try{ document.documentElement.style.setProperty('--btnTop', hexToRgba(c1.value, 0.36)); document.documentElement.style.setProperty('--btnBottom', hexToRgba(c2.value, 0.28)); }catch(e){}
                // set a dyed border color derived from the darker palette stops so outlines follow the custom scheme
                try{ document.documentElement.style.setProperty('--btnBorder', mixHex(c2.value, c3.value, 0.65)); }catch(e){}
                preview.style.background = makeSmoothGradient(c1.value, c2.value, c3.value);
                writeStored({ colors: { c1: c1.value, c2: c2.value, c3: c3.value }, pos: getPos() });
            }catch(e){} }

            c1.addEventListener('input', applyColors); c2.addEventListener('input', applyColors); c3.addEventListener('input', applyColors);

            // open editor near orb
            function openEditor(){ try{
                editor.classList.remove('hidden'); editor.classList.add('pe-anim');
                // run on next frame to trigger transition
                requestAnimationFrame(()=> editor.classList.add('pe-show'));
                loadInputsFromOrb();
                // Position the editor: prefer any stored position, otherwise place it to the right of the orb.
                try{
                    const rect = orb.getBoundingClientRect();
                    const left = Math.min(window.innerWidth - editor.offsetWidth - 12, Math.max(8, Math.round(rect.right + 8)));
                    const top = Math.min(window.innerHeight - editor.offsetHeight - 12, Math.max(8, Math.round(rect.top)));
                    editor.style.left = left + 'px'; editor.style.top = top + 'px';
                    // restore stored pos if present (preserve original placement across sessions)
                    const st = readStored(); if(st && st.pos){ try{ if(typeof st.pos.left === 'number') editor.style.left = st.pos.left + 'px'; if(typeof st.pos.top === 'number') editor.style.top = st.pos.top + 'px'; }catch(e){} }
                }catch(e){}
            }catch(e){} }

            function closeEditor(){ try{
                // animate out, then hide
                editor.classList.add('pe-anim'); editor.classList.remove('pe-show');
                const onEnd = function(ev){ try{ if(ev && ev.target !== editor) return; editor.removeEventListener('transitionend', onEnd); editor.classList.add('hidden'); }catch(e){} };
                editor.addEventListener('transitionend', onEnd);
                // fallback timeout
                setTimeout(()=>{ try{ if(!editor.classList.contains('pe-show')) editor.classList.add('hidden'); }catch(e){} }, 240);
            }catch(e){} }

            // allow closing via global Escape key regardless of focus
            document.addEventListener('keydown', (ev)=>{ try{ if(ev.key === 'Escape' && editor && !editor.classList.contains('hidden')){ closeEditor(); } }catch(e){} });

            // Open the palette editor only on a double-click to avoid accidental popups
            orb.addEventListener('dblclick', (e)=>{ e.preventDefault(); openEditor(); });
            closeBtn.addEventListener('click', (e)=>{ e.preventDefault(); closeEditor(); });

            resetBtn.addEventListener('click', (e)=>{ e.preventDefault(); c1.value = defaults.c1; c2.value = defaults.c2; c3.value = defaults.c3; applyColors(); });

            // Dragging of the palette editor has been disabled — the editor is fixed in place.
            function getPos(){ try{ return { left: parseFloat(editor.style.left)||0, top: parseFloat(editor.style.top)||0 }; }catch(e){ return { left:0, top:0 }; } }

            // ensure accessible keyboard close
            header.addEventListener('keydown', (ev)=>{ if(ev.key==='Escape'){ closeEditor(); } });

            // on load, if stored pos exists and editor visible (hidden by default) do nothing

            // --- Custom in-DOM color picker (invertable) ---
            (function(){
                // Convert helpers
                function hexToRgb(h){ try{ h=h.replace('#',''); if(h.length===3) h=h.split('').map(ch=>ch+ch).join(''); const r=parseInt(h.substr(0,2),16), g=parseInt(h.substr(2,2),16), b=parseInt(h.substr(4,2),16); return {r,g,b}; }catch(e){ return {r:0,g:0,b:0}; } }
                function rgbToHex(r,g,b){ const to=(n)=>{ n=Math.max(0,Math.min(255,Math.round(n))); const s=n.toString(16); return s.length===1?'0'+s:s; }; return '#'+to(r)+to(g)+to(b); }
                function rgbToHsl(r,g,b){ r/=255; g/=255; b/=255; const max=Math.max(r,g,b), min=Math.min(r,g,b); let h,s,l=(max+min)/2; if(max===min){ h=s=0; } else { const d=max-min; s=l>0.5? d/(2-max-min) : d/(max+min); switch(max){ case r: h=(g-b)/d+(g<b?6:0); break; case g: h=(b-r)/d+2; break; case b: h=(r-g)/d+4; break; } h/=6; } return { h: Math.round(h*360), s: Math.round(s*100), l: Math.round(l*100) }; }
                function hslToRgb(h,s,l){ h/=360; s/=100; l/=100; const hue2rgb=(p,q,t)=>{ if(t<0) t+=1; if(t>1) t-=1; if(t<1/6) return p+(q-p)*6*t; if(t<1/2) return q; if(t<2/3) return p+(q-p)*(2/3 - t)*6; return p; }; let r,g,b; if(s===0){ r=g=b=l; } else { const q=l<0.5? l*(1+s) : l+s-l*s; const p=2*l-q; r=hue2rgb(p,q,h+1/3); g=hue2rgb(p,q,h); b=hue2rgb(p,q,h-1/3); } return { r: Math.round(r*255), g: Math.round(g*255), b: Math.round(b*255) }; }

                let panel = null; let target = null; let hInp=null, sInp=null, lInp=null, preview=null; let apply=null, cancel=null;
                function ensurePanel(){
                    if(panel) return panel;
                    panel = document.createElement('div'); panel.id='ccpPanel'; panel.setAttribute('role','dialog'); panel.setAttribute('aria-label','Color picker');
                    panel.innerHTML = `
                        <div class="row"><div class="lbl">H</div><input id="ccpH" type="range" min="0" max="360" value="0"></div>
                        <div class="row"><div class="lbl">S</div><input id="ccpS" type="range" min="0" max="100" value="100"></div>
                        <div class="row"><div class="lbl">L</div><input id="ccpL" type="range" min="0" max="100" value="50"></div>
                        <div class="row"><div class="preview" id="ccpPrev" style="flex:1"></div></div>
                        <div class="actions"><button class="btn" id="ccpCancel">Cancel</button><button class="btn" id="ccpApply">Apply</button></div>
                    `;
                    document.body.appendChild(panel);
                    hInp = panel.querySelector('#ccpH'); sInp = panel.querySelector('#ccpS'); lInp = panel.querySelector('#ccpL');
                    preview = panel.querySelector('#ccpPrev'); apply = panel.querySelector('#ccpApply'); cancel = panel.querySelector('#ccpCancel');
                    function update(){
                        const h = parseInt(hInp.value||'0',10), s = parseInt(sInp.value||'0',10), l = parseInt(lInp.value||'0',10);
                        const {r,g,b} = hslToRgb(h,s,l); const hex = rgbToHex(r,g,b);
                        preview.style.background = hex;
                        return hex;
                    }
                    ['input','change'].forEach(ev=>{ hInp.addEventListener(ev, update); sInp.addEventListener(ev, update); lInp.addEventListener(ev, update); });
                    apply.addEventListener('click', ()=>{ if(!target) return; const hex = update(); try{ target.value = hex; target.dispatchEvent(new Event('input',{bubbles:true})); }catch(e){} close(); });
                    cancel.addEventListener('click', ()=> close());
                    function onKey(ev){ if(ev.key==='Escape'){ ev.preventDefault(); close(); } }
                    panel.addEventListener('keydown', onKey);
                    panel.__update = update;
                    return panel;
                }
                function positionNear(el){ try{ const r = el.getBoundingClientRect(); const w = panel.offsetWidth||280; const h = panel.offsetHeight||170; let left = Math.min(window.innerWidth - w - 8, Math.max(8, Math.round(r.left))); let top = Math.min(window.innerHeight - h - 8, Math.max(8, Math.round(r.bottom + 6))); panel.style.left = left+'px'; panel.style.top = top+'px'; }catch(e){} }
                function openFor(input){ try{
                    target = input; ensurePanel();
                    const rgb = hexToRgb(String(input.value||'#ffffff')); const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
                    hInp.value = String(hsl.h); sInp.value = String(hsl.s); lInp.value = String(hsl.l);
                    panel.__update && panel.__update();
                    positionNear(input);
                    panel.style.display = 'block';
                    setTimeout(()=>{ try{ panel.focus(); }catch(e){} }, 0);
                    // Close on outside click
                    const onDoc = (ev)=>{ try{ if(panel && !panel.contains(ev.target)) close(); }catch(e){} };
                    document.addEventListener('mousedown', onDoc, { once:true });
                    panel.__onDoc = onDoc;
                }catch(e){}
                }
                function close(){ try{ if(panel){ panel.style.display='none'; if(panel.__onDoc){ document.removeEventListener('mousedown', panel.__onDoc); panel.__onDoc=null; } } target=null; }catch(e){} }

                function intercept(input){
                    if(!input) return;
                    // Prevent native picker by disabling during pointer down
                    input.addEventListener('mousedown', (ev)=>{ try{ ev.preventDefault(); ev.stopPropagation(); input.disabled = true; setTimeout(()=>{ input.disabled = false; }, 0); openFor(input); }catch(e){} });
                    // Also intercept keyboard activation
                    input.addEventListener('keydown', (ev)=>{ try{ if(ev.key==='Enter' || ev.key===' '){ ev.preventDefault(); openFor(input); } }catch(e){} });
                }

                intercept(c1); intercept(c2); intercept(c3);
            })();
        }

        if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init); else init();
    })();
    </script>
    <button id="asciiBgToggle" class="btn pill" title="Toggle animated ASCII background">Turn off animated background</button>
            <div class="news-inline">
                <div class="news-controls-vertical">
                    <div class="news-toggle-row">
                        <button id="newsToggle" class="btn pill" title="Enable or disable the top news bar">Disable news</button>
                        <!-- Collapsible side pill for news sources: toggle expands into a horizontal pill containing options -->
                        <div id="newsSideMenu" class="news-side-menu" aria-hidden="false">
                                <button id="newsMenuToggle" class="btn pill news-menu-toggle" aria-expanded="false" aria-controls="newsSideMenuContent" title="Show news options">+</button>
                                <div id="newsSideMenuContent" class="news-side-menu-content" role="menu" aria-hidden="true">
                                        <div class="news-side-pill" role="presentation">
                                                <button class="btn small news-source-opt" data-source="pubmed" id="newsSourcePubMed" role="menuitem">PubMed</button>
                                                <button class="btn small news-source-opt" data-source="arxiv" id="newsSourceArxiv" role="menuitem">arXiv</button>
                                        </div>
                                </div>
                        </div>
                    </div>
                    <div id="focusInlineContainer" class="focus-inline">
                        <button id="enableFocusBtn" class="btn pill" title="Enable focus mode">Enable focus mode</button>
                        <!-- Side menu for Always Enable Focus Mode (mirrors news side-menu behavior) -->
                        <div id="focusAlwaysMenu" class="news-side-menu" aria-hidden="false">
                            <button id="focusAlwaysMenuToggle" class="btn pill news-menu-toggle" aria-expanded="false" aria-controls="focusAlwaysMenuContent" title="Always enable focus options">+</button>
                            <div id="focusAlwaysMenuContent" class="news-side-menu-content" role="menu" aria-hidden="true">
                                <div class="news-side-pill" role="presentation">
                                    <button id="alwaysEnableFocusBtn" class="btn small" role="menuitem">Always Enable Focus Mode</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
    </div>
    <style id="newsSideMenuStyles">
    /* Side-extending pill menu (left edge) */
    /* place inline next to other controls (e.g. #newsToggle) so it aligns horizontally */
    .news-side-menu{ position:relative; left:auto; top:auto; transform:none; display:inline-flex; align-items:center; gap:var(--control-gap); pointer-events:auto }
     /* Make the small plus toggle visually match the nearby Disable news button (size + vertical alignment)
         This is intentionally narrow and only updates the toggle itself so overall layout is unchanged. */
    .news-menu-toggle{ border-radius:999px; border:1px solid rgba(255,255,255,0.06); background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); color:var(--ink); font-size:14px; display:inline-flex; align-items:center; justify-content:center; cursor:pointer; padding:10px 14px; line-height:1; align-self:center; margin:0; /* ensure breathing room from neighbors so outline doesn't overlap */ margin-left: var(--control-gap); margin-right: var(--control-gap); }
    /* Keep collapsed side-menu content from affecting row height (fixes extra vertical spacing)
       while still expanding horizontally next to the + toggle. */
    .news-side-menu-content{
        position:absolute;
        left: calc(100% + var(--control-gap));
        top: 50%;
        transform-origin:left center;
        transform: translateY(-50%) scaleX(0);
        transition:transform 220ms cubic-bezier(.2,.9,.2,1), opacity 180ms ease;
        opacity:0;
        display:flex;
        align-items:center;
        pointer-events:none;
        z-index: 10;
    }
    .news-side-menu.expanded .news-side-menu-content{ transform: translateY(-50%) scaleX(1); opacity:1; pointer-events:auto }
    .news-side-pill{ display:flex; flex-direction:row; gap:var(--control-gap); align-items:center; padding:6px 10px; border-radius:999px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); box-shadow: 0 6px 18px rgba(0,0,0,0.35); }
    /* Blur and deepen shadow beneath side menus for better contrast */
    #invertTimerMenu .news-side-menu-content,
    #newsSideMenu .news-side-menu-content{ -webkit-backdrop-filter: blur(10px); backdrop-filter: blur(10px); }
    /* Minimalist capsule styling */
    #invertTimerMenu .news-side-pill.minimalist{ padding:6px 8px; gap:8px; border-radius:12px; background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02)); border:1px solid rgba(255,255,255,0.03); box-shadow: 0 8px 20px rgba(2,6,12,0.45); }
    /* Compact controls inside timer capsule (minimal aesthetics) */
    #invertTimerMenu .invert-input, #invertTimerMenu .invert-select{ height:30px; min-height:30px; padding:6px 8px; font-size:13px; border-radius:8px; background: transparent; color:var(--ink); border:1px solid rgba(255,255,255,0.06); -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px); }
    #invertTimerMenu .invert-input{ width:56px; text-align:center }
    #invertTimerMenu .invert-select{ width:54px }
    /* Icon-only apply button */
    .icon-btn{ display:inline-grid; place-items:center; width:34px; height:34px; padding:0; border-radius:10px; border:1px solid rgba(255,255,255,0.04); background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01)); color: var(--ink); cursor:pointer }
    .icon-btn svg{ color: var(--ink); opacity:.95 }
    /* Make the inner buttons capsule shaped (pills) and align horizontally */
    .news-side-pill .btn{ border-radius:999px; padding:8px 12px; white-space:nowrap; font-weight:700; box-shadow: inset 0 1px 0 rgba(255,255,255,0.02); background:transparent; }
    /* Make toggle visually change to minus when expanded via JS (no extra close button) */
    .news-menu-toggle:focus, .news-side-pill .btn:focus{ outline: 3px solid rgba(96,165,250,0.18); outline-offset:3px }
    @media (max-width:720px){ .news-side-menu{ left:6px } .news-side-pill{ padding:6px 8px } }
    /* Inline wrapper so the Disable news button and the + toggle sit side-by-side */
    .news-inline{ display:inline-flex; gap:var(--control-gap); align-items:center }
    /* Inline wrapper for the focus button + always-enable menu */
    .focus-inline{ display:inline-flex; gap:var(--control-gap); align-items:center }
    /* Stack Disable news and Enable focus controls vertically to keep focus button below the news toggle */
    .news-controls-vertical{ display:flex; flex-direction:column; gap:var(--control-gap); align-items:flex-start }
    /* Row that places the Disable news button and the small '+' toggle side-by-side */
    .news-toggle-row{ display:flex; gap:var(--control-gap); align-items:center }
    /* Keep the Inverted Display button and its timer toggle on the same line */
    .inline-controls-row{ display:inline-flex; gap:var(--control-gap); align-items:center; flex-wrap: nowrap }
    /* Normalize child margins so gap solely controls spacing */
    .news-inline > *,
    .focus-inline > *,
    .news-controls-vertical > *,
    .news-toggle-row > *,
    .inline-controls-row > *{ margin:0 !important }
    /* Ensure the global bg toggles row also uses compact spacing */
    #bgToggles{ gap: var(--control-gap) !important }
    /* Per-question TTS button: hide visually until card hover or keyboard focus */
    .qcard .tts-btn{
        opacity: 0;
        transform: translateY(-2px);
        transition: opacity .16s ease, transform .12s ease;
        /* Keep the button interactive for keyboard users even when visually hidden */
        pointer-events: auto;
        color: inherit;
    }
    .qcard:hover .tts-btn,
    .qcard:focus-within .tts-btn{
        opacity: 1;
        transform: translateY(0);
    }
    /* Always Enable Focus Mode ON state: green text + glowing outline */
    #alwaysEnableFocusBtn.always-on{ color: #16a34a; border: 1px solid rgba(22,163,74,0.28); box-shadow: 0 6px 20px rgba(22,163,74,0.18), 0 0 8px rgba(22,163,74,0.12); }
    </style>
    <script>
    (function(){
        const menu = document.getElementById('newsSideMenu');
        const toggle = document.getElementById('newsMenuToggle');
        const content = document.getElementById('newsSideMenuContent');
        if(!menu || !toggle || !content) return;
        function expand(){
            menu.classList.add('expanded');
            toggle.setAttribute('aria-expanded','true');
            content.setAttribute('aria-hidden','false');
            toggle.textContent = '−';
        }
        function collapse(){
            menu.classList.remove('expanded');
            toggle.setAttribute('aria-expanded','false');
            content.setAttribute('aria-hidden','true');
    (function(){
        // Invert Timer controller: repeatedly toggles the inverted display at a chosen interval
        const menu = document.getElementById('invertTimerMenu');
        const toggle = document.getElementById('invertTimerToggle');
        const content = document.getElementById('invertTimerMenuContent');
        if(!menu || !toggle || !content) return;

        let timerId = 0;
        const KEY = '__invertTimerMs';

        function expand(){ menu.classList.add('expanded'); toggle.setAttribute('aria-expanded','true'); content.setAttribute('aria-hidden','false'); }
        function collapse(){ menu.classList.remove('expanded'); toggle.setAttribute('aria-expanded','false'); content.setAttribute('aria-hidden','true'); }

        function setTimer(ms){
            try{ if(timerId){ clearInterval(timerId); timerId = 0; } }catch{}
            try{ localStorage.setItem(KEY, String(ms||0)); }catch{}
            // Visual feedback on the small toggle (title reflects current rate)
            try{ toggle.title = ms ? `Auto-flip every ${(ms/1000).toFixed(ms<1000?1:0)}s` : 'Set auto-flip speed'; }catch{}
            if(ms && ms > 0){
                timerId = setInterval(()=>{
                    try{
                        // Use the official button click to ensure overlay is created/removed correctly
                        const btn = document.getElementById('enableLightModeBtn');
                        if(btn){ btn.click(); }
                    }catch(e){}
                }, ms);
            }
            // Update the apply button icon/state so it toggles between Check (set) and X (disable)
            try{
                const ab = document.getElementById('invertTimerApply');
                if(ab){
                    if(ms && ms > 0){
                        ab.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
                        ab.title = 'Disable auto-flip';
                        ab.setAttribute('aria-label','Disable auto-flip');
                    } else {
                        ab.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M20 6L9 17l-5-5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
                        ab.title = 'Set auto-flip';
                        ab.setAttribute('aria-label','Set auto-flip');
                    }
                }
            }catch(e){}
        }

        // wire expand/collapse
        toggle.addEventListener('click', (e)=>{ e.preventDefault(); if(menu.classList.contains('expanded')) collapse(); else expand(); });

        // New compact input UI
        const valInput = document.getElementById('invertTimerValue');
        const unitSel = document.getElementById('invertTimerUnit');
        const applyBtn = document.getElementById('invertTimerApply');

        function applyFromInputs(){
            let n = parseFloat(valInput && valInput.value || '0');
            if(!isFinite(n) || n < 0) n = 0;
            const unit = (unitSel && unitSel.value) || 's';
            const ms = unit === 'ms' ? Math.round(n) : Math.round(n * 1000);
            setTimer(ms);
            collapse();
            try{ toggle.focus(); }catch{}
        }

        if(applyBtn) applyBtn.addEventListener('click', (e)=>{ e.preventDefault();
            try{
                // If a timer is currently set (persisted), treat this as the 'disable' action
                const cur = parseInt(localStorage.getItem(KEY)||'0',10) || 0;
                if(cur && cur > 0){
                    // turn off timer and reset input to zero
                    try{ if(valInput) valInput.value = '0'; if(unitSel) unitSel.value = 's'; }catch(_){}
                    try{ setTimer(0); }catch(_){}
                    try{ collapse(); toggle.focus(); }catch(_){}
                    return;
                }
            }catch(e){}
            applyFromInputs();
        });
        if(valInput) valInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); applyFromInputs(); } });
        if(unitSel) unitSel.addEventListener('change', ()=>{ /* no-op until Set is clicked */ });

        // init from saved preference and reflect into inputs
        try{
            const saved = parseInt(localStorage.getItem(KEY)||'0',10)||0;
            if(saved) setTimer(saved); else setTimer(0);
            // populate inputs from saved value
            if(valInput && unitSel){
                if(saved % 1000 === 0){ unitSel.value = 's'; valInput.value = String(saved/1000); }
                else { unitSel.value = 'ms'; valInput.value = String(saved); }
            }
        }catch{}
    })();
            toggle.textContent = '+';
        }
        toggle.addEventListener('click', ()=>{ menu.classList.contains('expanded') ? collapse() : expand(); });
        // Close on Escape when expanded
        document.addEventListener('keydown', (ev)=>{ if(ev.key === 'Escape' && menu.classList.contains('expanded')){ collapse(); toggle.focus(); } });
        // If a menu item is clicked, collapse after action
        document.querySelectorAll('#newsSideMenu .news-source-opt').forEach(b=> b.addEventListener('click', ()=>{ collapse(); toggle.focus(); }));
        // Initialize collapsed
        collapse();
    })();
    // Focus-always side menu wiring
    (function(){
        const menu = document.getElementById('focusAlwaysMenu');
        const toggle = document.getElementById('focusAlwaysMenuToggle');
        const content = document.getElementById('focusAlwaysMenuContent');
        const alwaysBtn = document.getElementById('alwaysEnableFocusBtn');
        if(!menu || !toggle || !content || !alwaysBtn) return;
        function expand(){ menu.classList.add('expanded'); toggle.setAttribute('aria-expanded','true'); toggle.textContent = '-'; content.setAttribute('aria-hidden','false'); }
        function collapse(){ menu.classList.remove('expanded'); toggle.setAttribute('aria-expanded','false'); toggle.textContent = '+'; content.setAttribute('aria-hidden','true'); }
        toggle.addEventListener('click', ()=>{ menu.classList.contains('expanded') ? collapse() : expand(); });
        document.addEventListener('keydown', (ev)=>{ if(ev.key === 'Escape' && menu.classList.contains('expanded')){ collapse(); toggle.focus(); } });
        // Toggle persistent preference
        const ALWAYS_KEY = '__ui_always_focus_v1';
        function setAlwaysState(on){
            try{
                if(on) alwaysBtn.classList.add('always-on'); else alwaysBtn.classList.remove('always-on');
                try{ localStorage.setItem(ALWAYS_KEY, on ? '1':'0'); }catch(e){}
                // Inform focus-mode controller in this tab and update a shared hint
                try{ window.__alwaysFocus = !!on; document.dispatchEvent(new CustomEvent('always-focus-changed', { detail:{ on: !!on } })); }catch(e){}
            }catch(e){}
        }
        try{ const s = localStorage.getItem(ALWAYS_KEY); setAlwaysState(s === '1'); }catch(e){}
        alwaysBtn.addEventListener('click', ()=>{ try{ const isOn = alwaysBtn.classList.contains('always-on'); const newState = !isOn; setAlwaysState(newState);
            // Immediately apply the runtime focus-mode change when the Always toggle is changed
            try{ if(typeof window.__setFocusMode === 'function'){ window.__setFocusMode(!!newState); } }catch(e){}
            // collapse menu and return focus to the toggle
            try{ if(menu.classList.contains('expanded')) collapse(); toggle.focus(); }catch(e){} }catch(e){} });
        // Collapse by default
        collapse();
    })();
    </script>

    <!-- Focus Mode: darken everything except quiz view -->
    <style id="focusModeStyles">
    /* Fullscreen dark overlay used for focus mode */
    #focusOverlay{ position:fixed; inset:0; z-index:99990; background:rgba(0,0,0,0.88); opacity:0; visibility:hidden; transition:opacity .32s ease, visibility .32s ease; pointer-events:none; }
    /* When active, show overlay and lift #quiz above it */
    body.focus-mode-active #focusOverlay{ opacity:1; visibility:visible }
    body.focus-mode-active #quiz{ position:relative; z-index:100000; pointer-events:auto }
    /* Make the enable button visually pressed when active */
    #enableFocusBtn[aria-pressed="true"]{ box-shadow: 0 6px 18px rgba(0,0,0,0.16); transform: translateY(-1px); }
    /* Ensure quiz-child panels maintain normal pointer events above overlay */
    body.focus-mode-active #quiz *{ pointer-events:auto }
    /* When hovering the Disable/Enable Focus button while in focus mode,
       lift the button above the overlay so it appears on the same plane
       as the quiz view (and remains clickable). This only activates on
       hover/focus to avoid exposing other controls unintentionally. */
    body.focus-mode-active #enableFocusBtn{
        transition: transform .12s ease, box-shadow .12s ease, z-index 0s;
    }
    body.focus-mode-active #enableFocusBtn:hover,
    body.focus-mode-active #enableFocusBtn:focus{
        position: relative;
        z-index: 100001; /* above #quiz (100000) */
        transform: translateY(-6px) scale(1.02);
        box-shadow: 0 18px 40px rgba(0,0,0,0.6);
        /* ensure it receives pointer events even if its container is inert */
        pointer-events: auto;
    }

    /* Ensure the small Always-toggle and its +/- menu toggle also render above the overlay
       when focus mode is active. Give the inline container a higher stacking context so
       its child buttons can appear above #quiz without needing to be moved to body. */
    body.focus-mode-active #focusInlineContainer{ position: relative; z-index: 100002; pointer-events: auto }
    body.focus-mode-active #focusInlineContainer .news-side-menu{ position: relative; z-index: 100003 }
    body.focus-mode-active #focusInlineContainer .news-menu-toggle,
    body.focus-mode-active #focusInlineContainer #alwaysEnableFocusBtn{ position: relative; z-index: 200004 }
    body.focus-mode-active #focusInlineContainer .news-menu-toggle:hover,
    body.focus-mode-active #focusInlineContainer #alwaysEnableFocusBtn:hover{ transform: translateY(-6px); box-shadow: 0 18px 40px rgba(0,0,0,0.6); }

    /* When mini-quiz is active, ensure the modal is above everything */
    body.mini-quiz-active #miniQuizModal{ z-index: 2147483000; }
    </style>

    <script>
    (function(){
        // Focus mode toggle: show a fullscreen dark overlay but keep #quiz visible above it
        const KEY = '__ui_focus_mode_v1';

        // Initialize focus-mode wiring in a safe, idempotent way.
        function initFocusMode(){
            let btn = document.getElementById('enableFocusBtn');
            // If the button isn't in the DOM yet, retry after DOMContentLoaded
            if(!btn){
                if(document.readyState === 'loading'){
                    document.addEventListener('DOMContentLoaded', initFocusMode, { once:true });
                }
                return;
            }

            function ensureOverlay(){
                let ov = document.getElementById('focusOverlay');
                if(!ov){ ov = document.createElement('div'); ov.id = 'focusOverlay'; document.body.appendChild(ov); }
                return ov;
            }

            function setState(on){
                try{
                    ensureOverlay();
                    if(on){ document.body.classList.add('focus-mode-active'); }
                    else { document.body.classList.remove('focus-mode-active'); }
                    btn.setAttribute('aria-pressed', on ? 'true' : 'false');
                    btn.textContent = on ? 'Disable focus mode' : 'Enable focus mode';
                    try{ localStorage.setItem(KEY, on ? '1' : '0'); }catch(e){}
                }catch(e){ console.warn('focus-mode toggle failed', e); }
            }

            // Expose a global setter so other modules can disable focus mode (useful when returning to setup)
            try{ window.__setFocusMode = function(on){ try{ setState(!!on); }catch(e){} }; }catch(e){}

            // Auto-disable focus mode whenever the main setup view becomes visible
            try{
                let setupEl = document.getElementById('setup');
                function disableOnSetupVisible(){
                    try{
                        const el = setupEl || document.getElementById('setup');
                        if(!el) return;
                        if(!el.classList.contains('hidden')){
                            try{ setState(false); }catch(e){}
                        }
                    }catch(e){}
                }
                // Observe class changes so we catch transitions into setup
                if(window.MutationObserver){
                    if(setupEl){
                        const mo2 = new MutationObserver(()=> disableOnSetupVisible());
                        mo2.observe(setupEl, { attributes:true, attributeFilter:['class'] });
                    } else {
                        // If setup not present yet, wait for it to be added then observe
                        const docMo = new MutationObserver((records, obs)=>{
                            setupEl = document.getElementById('setup');
                            if(setupEl){ const mo3 = new MutationObserver(()=> disableOnSetupVisible()); mo3.observe(setupEl, { attributes:true, attributeFilter:['class'] }); obs.disconnect(); disableOnSetupVisible(); }
                        });
                        docMo.observe(document.body, { childList:true, subtree:true });
                    }
                }
                // Run once now in case we're already on setup
                disableOnSetupVisible();
            }catch(e){}

            // Toggle handler
            btn.addEventListener('click', function(e){ e.preventDefault(); setState(!document.body.classList.contains('focus-mode-active')); });

            // Elevate on hover/focus: move the button to document.body while hovered so it can
            // escape ancestor stacking contexts and render above the focus overlay.
            (function(){
                let placeholder = null;
                function elevate(){
                    try{
                        if(!document.body.classList.contains('focus-mode-active')) return;
                        if(btn.dataset.elevated) return;
                        const r = btn.getBoundingClientRect();
                        // create a placeholder so layout doesn't jump
                        placeholder = document.createElement('div');
                        placeholder.className = 'focus-btn-placeholder';
                        placeholder.style.width = r.width + 'px';
                        placeholder.style.height = r.height + 'px';
                        placeholder.style.display = getComputedStyle(btn).display || 'inline-block';
                        btn.parentNode.insertBefore(placeholder, btn);
                        // move button to body and fix its position
                        document.body.appendChild(btn);
                        btn.style.position = 'fixed';
                        btn.style.left = Math.round(r.left) + 'px';
                        btn.style.top = Math.round(r.top) + 'px';
                        btn.style.zIndex = '100001';
                        btn.dataset.elevated = '1';
                    }catch(e){}
                }
                function restore(){
                    try{
                        if(!btn.dataset.elevated) return;
                        if(placeholder && placeholder.parentNode){ placeholder.parentNode.insertBefore(btn, placeholder); placeholder.parentNode.removeChild(placeholder); }
                        placeholder = null;
                        // reset styles
                        btn.style.position = '';
                        btn.style.left = '';
                        btn.style.top = '';
                        btn.style.zIndex = '';
                        delete btn.dataset.elevated;
                    }catch(e){}
                }
                btn.addEventListener('mouseenter', elevate);
                btn.addEventListener('focus', elevate);
                btn.addEventListener('mouseleave', restore);
                btn.addEventListener('blur', restore);
                // Keep button positioned over placeholder if window resizes while elevated
                window.addEventListener('resize', function(){ try{ if(btn.dataset.elevated && placeholder){ const r = placeholder.getBoundingClientRect(); btn.style.left = Math.round(r.left) + 'px'; btn.style.top = Math.round(r.top) + 'px'; } }catch(e){} });
                // Ensure we restore when focus-mode is turned off
                document.addEventListener('focus-mode-off', restore);
            })();

            // Initialize respecting the "Always Enable Focus" preference (do not force on from prior session unless Always is enabled)
            const ALWAYS_KEY = '__ui_always_focus_v1';
            let __alwaysFocus = false;
            function __loadAlways(){ try{ __alwaysFocus = localStorage.getItem(ALWAYS_KEY) === '1'; const ab = document.getElementById('alwaysEnableFocusBtn'); if(ab) ab.classList.toggle('always-on', __alwaysFocus); }catch(e){} }
            try{ __loadAlways(); window.addEventListener('storage', (ev)=>{ if(ev.key === ALWAYS_KEY) __loadAlways(); }); }catch(e){}
            // Define a global suppression flag consumed by this controller; when true, focus mode will not auto-enable
            try{ if(typeof window.__suppressFocus === 'undefined') window.__suppressFocus = false; }catch(e){}
            // React to in-tab changes from the Always toggle controller
            try{ document.addEventListener('always-focus-changed', (ev)=>{ try{ __alwaysFocus = !!(ev && ev.detail && ev.detail.on); window.__alwaysFocus = __alwaysFocus; updateBtnVisibility(); }catch(e){} }); }catch(e){}
            // On load: if Always is ON and not suppressed, enable focus; otherwise ensure it's OFF so users aren't forced into it
            try{ window.__alwaysFocus = __alwaysFocus; if(__alwaysFocus && !window.__suppressFocus){ setState(true); } else { setState(false); } }catch(e){}

            // Visibility: show the enableFocusBtn only when #quiz is visible (not .hidden)
            let quizEl = document.getElementById('quiz');
            function updateBtnVisibility(){
                try{
                    // Re-resolve the elements in case they were re-created
                    if(!quizEl) quizEl = document.getElementById('quiz');
                    if(!quizEl) { btn.style.display = 'none'; return; }
                    const hidden = quizEl.classList.contains('hidden');
                    const disp = hidden ? 'none' : 'inline-flex';
                    btn.style.display = disp;
                    // keep the Always-focus container in sync with the button visibility
                    try{ const fic = document.getElementById('focusInlineContainer'); if(fic) fic.style.display = disp; }catch(e){}
                    // If a quiz becomes visible and Always-enable is on, turn on focus mode unless suppressed
                    try{ if(!hidden && typeof __alwaysFocus !== 'undefined' && __alwaysFocus && !window.__suppressFocus){ setState(true); } }catch(e){}
                }catch(e){ }
            }

            // Observe class changes on #quiz so the button appears/disappears automatically
            if(window.MutationObserver){
                const mo = new MutationObserver((changes)=>{ updateBtnVisibility(); });
                // If quizEl not present yet, watch the document for added nodes and then observe quiz
                if(!quizEl){
                    const docMo = new MutationObserver(()=>{
                        quizEl = document.getElementById('quiz');
                        if(quizEl){ mo.observe(quizEl, { attributes:true, attributeFilter:['class'] }); docMo.disconnect(); updateBtnVisibility(); }
                    });
                    docMo.observe(document.body, { childList:true, subtree:true });
                } else {
                    mo.observe(quizEl, { attributes:true, attributeFilter:['class'] });
                }
            }
            // Run once on init
            updateBtnVisibility();
        }

        // Kick off initialization (idempotent)
        try{ initFocusMode(); }catch(e){ setTimeout(initFocusMode, 60); }
    })();
    </script>

    <!-- Light Mode CSS + Toggle Script (inline per user request) -->
    <style id="lightModeStyles">
    /* Overlay-based light-mode inversion using opacity transitions to avoid layout effects.
       The overlay uses mix-blend-mode:difference with a white fill which visually inverts
       underlying pixels while leaving layout/positioning unchanged. Opacity is animated
       so toggling fades the inversion in/out.
    */
    #lightModeOverlay{
        position:fixed; inset:0; z-index:2147483646; pointer-events:none; background:#fff; mix-blend-mode:difference;
        opacity:0; visibility:hidden; transition: opacity .36s ease, visibility .36s ease; will-change: opacity;
    }

    /* Visible state: overlay fades in via opacity. No display toggling to preserve transition. */
    body.light-mode-active #lightModeOverlay{ opacity:1; visibility:visible }

    /* Lift palette orbs above the overlay so their original hues remain unchanged. Labels are inverted separately. */
    body.light-mode-active .theme-orb{ position: relative; z-index:2147483647; }
    body.light-mode-active .theme-orb::before,
    body.light-mode-active .theme-orb::after{ z-index:2147483647; }

    /* Invert orb label text so it contrasts the preserved orb background */
    body.light-mode-active .theme-orb .orb-label{ filter: invert(1); }

    /* Provide a helper class for any element that must keep exact palette colors (place above the overlay). */
    body.light-mode-active .preserve-palette{ position:relative; z-index:2147483647; }

    /* Keep small AI/API indicator dots visually normal (double-invert) when light-mode overlay is active. */
    body.light-mode-active .api-key-dot,
    body.light-mode-active .key-dot,
    body.light-mode-active #aiExplanationKeyDot,
    body.light-mode-active .key-badge .dot,
    body.light-mode-active #dailyKeyDot,
    body.light-mode-active #randomKeyDot,
    body.light-mode-active .rp-title .dot,
    body.light-mode-active .sticky-dot {
        -webkit-filter: invert(1) !important;
        filter: invert(1) !important;
    }

    /* Transition alt-color/filter changes so they fade in/out at the same rate as the overlay. */
    .theme-orb .orb-label,
    .preserve-palette,
    .api-key-dot,
    .key-dot,
    #aiExplanationKeyDot,
    .key-badge .dot,
    #dailyKeyDot,
    #randomKeyDot,
    .rp-title .dot,
    .sticky-dot {
        -webkit-transition: -webkit-filter .36s ease, filter .36s ease, color .36s ease, background-color .36s ease, opacity .36s ease;
        transition: -webkit-filter .36s ease, filter .36s ease, color .36s ease, background-color .36s ease, opacity .36s ease;
        will-change: filter, color, background-color, opacity;
    }

     /* Ensure Saved MCQs dropdown inherits inversion like the rest of the UI.
         No special filter overrides here; it's rendered below the overlay. */

    /* Small visual for toggled state */
    #enableLightModeBtn[aria-pressed="true"]{ box-shadow: 0 6px 18px rgba(0,0,0,0.16); transform: translateY(-1px); }
    /* Light-mode: let the palette editor, its gradient preview, and its color pickers invert with the UI. */
    </style>

    <script>
    (function(){
        const KEY = '__ui_light_mode';
        const btn = document.getElementById('enableLightModeBtn');
        if(!btn) return;

        // Ensure the overlay element exists (created on-demand)
        function ensureOverlay(){
            let ov = document.getElementById('lightModeOverlay');
            if(!ov){ ov = document.createElement('div'); ov.id = 'lightModeOverlay'; document.body.appendChild(ov); }
            return ov;
        }

        // Remove overlay after fade-out to keep DOM tidy. If toggled back on quickly, cancel removal.
        function removeOverlayAfterFade(ov){
            if(!ov) return;
            try{
                const onEnd = function(e){
                    if(e && e.target !== ov) return;
                    ov.removeEventListener('transitionend', onEnd);
                    // Only remove when fully transparent
                    const comp = getComputedStyle(ov);
                    if(comp && comp.opacity === '0'){
                        try{ ov.remove(); }catch(e){}
                    }
                };
                ov.addEventListener('transitionend', onEnd);
                // As a safety, also set a timeout to remove after transition length
                setTimeout(()=>{ try{ if(document.body.contains(ov) && getComputedStyle(ov).opacity === '0') ov.remove(); }catch(e){} }, 520);
            }catch(e){}
        }

        function setState(on){
            try{
                const ov = ensureOverlay();
                if(on){
                    // Cancel any pending removal by ensuring overlay is present, then trigger class change in next frame to allow transition
                    try{ ov.style.transition = ov.style.transition || ''; }catch(e){}
                    requestAnimationFrame(()=>{ document.body.classList.add('light-mode-active'); });
                } else {
                    // fade out
                    document.body.classList.remove('light-mode-active');
                    // remove overlay after fade completes
                    removeOverlayAfterFade(ov);
                }
                btn.setAttribute('aria-pressed', on ? 'true' : 'false');
                btn.textContent = on ? 'Disable Inverted Display' : 'Enable Inverted Display';
                try{ localStorage.setItem(KEY, on ? '1' : '0'); }catch(e){}
            }catch(e){ console.warn('light-mode toggle failed', e); }
        }

        btn.addEventListener('click', function(e){ e.preventDefault(); setState(!document.body.classList.contains('light-mode-active')); });

        // initialize from saved preference
        try{ const s = localStorage.getItem(KEY); if(s === '1') setState(true); }catch(e){}
    })();
    </script>
    <div class="quiz-launch-controls">
        <button id="dailyQuizBtn" class="btn pill" title="Generate a daily random quiz" data-label="Daily Random Quiz" aria-label="Daily Random Quiz"><span id="dailyKeyDot" class="api-key-dot missing" aria-hidden="true"></span></button>
        <span class="random-controls">
            <button id="randomQuizBtn" class="btn pill" title="Generate a random quiz now" data-label="Random Quiz" aria-label="Random Quiz"><span id="randomKeyDot" class="api-key-dot missing" aria-hidden="true"></span></button>
            <span class="gear-badge" id="randomGearWrap"><span class="gear-circle" aria-hidden="true"><button id="randomGearBtn" class="gear-btn" title="Random quiz settings" aria-label="Random quiz settings">⚙︎</button></span></span>
        </span>
    </div>
    </div>

    <!-- Top News Bar (NPR) - full width at very top -->
    <div id="newsBar" class="news-bar" role="region" aria-label="Top news headlines">
        <div id="newsRow" class="news-row"></div>
    </div>
    <div id="contentRoot" class="container mt-6">
    
        <script>
        // Unified Top Safe Area manager + NPR headlines fetcher
        (function(){
            const FEED = 'https://feeds.npr.org/1001/rss.xml';
            // Multiple CORS-safe proxy strategies (try in order)
            const PROXIES = [
                (u)=> `https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`,
                (u)=> `https://cors.isomorphic-git.org/${u}`,
                (u)=> `https://r.jina.ai/https://${u.replace(/^https?:\/\//,'')}`,
                (u)=> `https://r.jina.ai/http://${u.replace(/^https?:\/\//,'')}`,
            ];
            const PREF_KEY = '__newsBarPref'; // 'on' | 'off'
            const CACHE_KEY = '__newsCacheV2';
            const MAX_AGE_MS = 24 * 60 * 60 * 1000; // 24h rolling window
            const REFRESH_MS = 60 * 60 * 1000; // hourly updates
            const newsBar = document.getElementById('newsBar');
            const newsRow = document.getElementById('newsRow');
            const toggleBtn = document.getElementById('newsToggle');
            // Fixed ticker speed (px per second)
            const FIXED_NEWS_TICKER_SPEED = 48; // change this number to adjust scroll speed
            let tickerRAF = 0, tickerX = 0, tickerSpeed = FIXED_NEWS_TICKER_SPEED;
            let trackA = null, trackB = null;
            let itemsState = [];
            let refreshTimer = 0;
            let reloadNewsFn = null;
            let startPeriodicRefreshFn = null;
            let stopPeriodicRefreshFn = null;

            // Top offset manager computes and sets --topSafeArea so all fixed UI moves in sync
            function computeTopSafeArea(){
                let h = 0;
                try{
                    if(newsBar && newsBar.style.display !== 'none'){
                        const r = newsBar.getBoundingClientRect();
                        h = Math.max(0, Math.ceil(r.height));
                    }
                }catch{}
                // Sync both variables so either stylesheet path honors the offset
                document.documentElement.style.setProperty('--topSafeArea', h + 'px');
                document.documentElement.style.setProperty('--newsOffset', h + 'px');
                // Update sticky scaling tied to the safe area
                computeStickyScale();
                return h;
            }

            // -- Daily Random Quiz: fetch a random Wikipedia topic once per 24h, then ask Gemini to create a 10-question, 4-choice quiz
            const DAILY_TOPIC_KEY = '__dailyTopic'; // stores {topic, fetchedAt}
            const DAILY_QUIZ_KEY = '__dailyQuiz'; // stores generated quiz JSON

            // accept optional AbortSignal as first parameter
            async function fetchRandomWikipediaTitle(signal){
                // Use Wikipedia REST random endpoint to get a random page title
                try{
                    // If caller provided a search query via global preference, use search API instead
                    try{ var savedCategory = localStorage.getItem('random.category'); }catch{};
                    if(savedCategory && savedCategory.length){
                        // Use opensearch to find matches, fall back to random when no results
                        const qs = encodeURIComponent(savedCategory);
                        const url = `https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch=${qs}&utf8=&format=json&origin=*`;
                        const r = await fetch(url, signal ? { signal } : undefined);
                        if(r && r.ok){ const d = await r.json(); if(d && d.query && Array.isArray(d.query.search) && d.query.search.length){ return d.query.search[0].title; } }
                        // fallback to random if search failed
                    }
                    const resp = await fetch('https://en.wikipedia.org/api/rest_v1/page/random/title', signal ? { signal } : undefined);
                    if(!resp.ok) throw new Error('random title fetch failed');
                    const data = await resp.json(); // {items: [{id, key, title}] } or {title: '...'} depending on API
                    // handle shape variations
                    if(data && data.title) return data.title;
                    if(Array.isArray(data) && data.length && data[0].title) return data[0].title;
                    if(data && data.items && data.items[0] && data.items[0].title) return data.items[0].title;
                    // fallback: use Special:Random redirect hack
                    const r = await fetch('https://en.wikipedia.org/wiki/Special:Random', signal ? { redirect: 'follow', signal } : { redirect: 'follow' });
                    const final = r.url; const parts = final.split('/'); return decodeURIComponent(parts[parts.length-1].replace(/_/g,' '));
                }catch(e){ console.warn('Random wiki title failed', e); throw e; }
            }

            function getDailyTopic(){
                try{
                    const raw = localStorage.getItem(DAILY_TOPIC_KEY);
                    if(!raw) return null;
                    const obj = JSON.parse(raw);
                    if(!obj || !obj.topic || !obj.fetchedAt) return null;
                    const age = Date.now() - obj.fetchedAt;
                    if(age > 24*60*60*1000) return null;
                    return obj.topic;
                }catch(e){ return null; }
            }

            function saveDailyTopic(topic){ try{ localStorage.setItem(DAILY_TOPIC_KEY, JSON.stringify({ topic, fetchedAt: Date.now() })); }catch(e){} }

            // accept optional AbortSignal as third parameter
            async function askGeminiForQuiz(topic, apiKey, signal){
                // returns { questions: [{q, choices:[a,b,c,d], answerIndex}] }
                if(!topic) throw new Error('No topic');
                // Check for SDK availability and API key
                try{
                    if(!window.GoogleGenerativeAI) {
                        try{ const mod = await import('https://esm.run/@google/generative-ai'); window.GoogleGenerativeAI = mod.GoogleGenerativeAI; }catch(e){ throw new Error('Gemini SDK load failed'); }
                    }
                    const AI = window.GoogleGenerativeAI;
                    const client = apiKey ? new AI(apiKey) : null;
                    if(!client) throw new Error('No Gemini API key provided');
                    const model = client.getGenerativeModel({ model: 'gemini-2.5-flash' });

                    const prompt = `Create a JSON array of 10 multiple-choice questions about the following Wikipedia topic: "${topic}". `+
                        `Each item should be an object with fields: "question" (string), "choices" (array of 4 strings), and "answerIndex" (0-3 index of correct choice). `+
                        `Avoid using the exact phrasing from Wikipedia; make the questions educational and reasonably challenging for someone with general knowledge. Return ONLY valid JSON.`;

                    // Use the SDK's generateContent API (newer SDKs use generateContent)
                    // If a signal is provided, race the SDK call with a promise that rejects on abort
                    const genPromise = model.generateContent({ contents: [{ role: 'user', parts: [{ text: prompt }] }] });
                    let resp;
                    if(signal && signal.aborted){ throw new DOMException('Aborted', 'AbortError'); }
                    if(signal){
                        resp = await Promise.race([
                            genPromise,
                            new Promise((_, rej) => { signal.addEventListener('abort', ()=> rej(new DOMException('Aborted', 'AbortError')), { once: true }); })
                        ]);
                    } else {
                        resp = await genPromise;
                    }

                    // Robust extraction of text from multiple possible response shapes
                    let text = '';
                    try{
                        if(resp && typeof resp === 'object'){
                            // Common: resp.response.text() helper
                            if(resp.response && typeof resp.response.text === 'function'){
                                text = String((await resp.response.text()) || '');
                            } else if(resp.output && Array.isArray(resp.output) && resp.output.length){
                                // Older shape: output -> [{ content: [{ text: '...' }] }]
                                const out0 = resp.output[0];
                                if(out0 && out0.content && Array.isArray(out0.content)){
                                    text = out0.content.map(c=> c?.text || (typeof c === 'string' ? c : '')).join('\n');
                                } else {
                                    text = JSON.stringify(resp.output);
                                }
                            } else if(resp.response && resp.response.outputs && Array.isArray(resp.response.outputs)){
                                // Newer REST-like shape
                                text = resp.response.outputs.map(o=> (o.content||[]).map(c=>c.text||'').join('')).join('\n');
                            } else {
                                text = JSON.stringify(resp);
                            }
                        } else {
                            text = String(resp || '');
                        }
                    }catch(e){ text = JSON.stringify(resp); }

                    // Find first JSON substring in the returned text
                    const m = String(text).match(/\{[\s\S]*\}|\[[\s\S]*\]/);
                    if(!m) throw new Error('No JSON in model output: ' + (String(text).slice(0,300)) );
                    const parsed = JSON.parse(m[0]);
                    if(!Array.isArray(parsed) || parsed.length < 1) throw new Error('Parsed quiz invalid');
                    return { questions: parsed };
                }catch(e){ console.error('Quiz generation failed', e); throw e; }
            }

            // --- New feed fetchers: data.gov and arXiv ---
            // normalize to [{title,link,pubDate}]
            async function fetchPubMed(){
                try{
                    const apiKey = (function(){ try{ return localStorage.getItem('ncbi.apiKey'); }catch(e){ return null; } })();
                    const reldays = 2;
                    const retmax = 50;
                    const esearchUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=pubmed&retmode=json&reldate=${reldays}&datetype=edat&retmax=${retmax}${apiKey?('&api_key='+encodeURIComponent(apiKey)):''}`;
                    const esearchText = await fetchTextFromAny(esearchUrl);
                    const esearch = JSON.parse(esearchText);
                    let idlist = (esearch && esearch.esearchresult && Array.isArray(esearch.esearchresult.idlist)) ? esearch.esearchresult.idlist : [];
                    if(!idlist.length){
                        const altUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=pubmed&retmode=json&sort=pub+date&retmax=${retmax}${apiKey?('&api_key='+encodeURIComponent(apiKey)):''}`;
                        try{ const t = await fetchTextFromAny(altUrl); const alt = JSON.parse(t); idlist = idlist.concat((alt.esearchresult && Array.isArray(alt.esearchresult.idlist) ? alt.esearchresult.idlist : [])); }catch(e){}
                    }
                    idlist = idlist.slice(0, retmax);
                    if(!idlist || !idlist.length) throw new Error('No recent PubMed IDs');

                    // Prefer efetch XML to get reliable ArticleTitle and dates
                    try{
                        const efetchUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=pubmed&id=${encodeURIComponent(idlist.join(','))}&retmode=xml${apiKey?('&api_key='+encodeURIComponent(apiKey)):''}`;
                        const efetchText = await fetchTextFromAny(efetchUrl);
                        const xdoc = new DOMParser().parseFromString(efetchText, 'text/xml');
                        const articles = Array.from(xdoc.getElementsByTagName('PubmedArticle')||[]);
                        const out = [];
                        for(const art of articles){
                            try{
                                const pmidEl = art.getElementsByTagName('PMID')[0];
                                const pmid = pmidEl ? (pmidEl.textContent||'').trim() : null;
                                const titleEl = art.getElementsByTagName('ArticleTitle')[0];
                                const title = titleEl ? (titleEl.textContent||'').trim() : (pmid ? `PubMed ${pmid}` : '(no title)');
                                // attempt to get a publication date
                                let pubDate = '';
                                const pubDateEl = art.getElementsByTagName('PubDate')[0] || art.getElementsByTagName('DateCreated')[0];
                                if(pubDateEl){ pubDate = (pubDateEl.textContent||'').trim(); }
                                // fallback: try Article/Journal/JournalIssue/PubDate
                                if(!pubDate){
                                    try{
                                        const jpd = art.getElementsByTagName('PubDate')[0]; if(jpd){ pubDate = (jpd.textContent||'').trim(); }
                                    }catch(e){}
                                }
                                const link = pmid ? `https://pubmed.ncbi.nlm.nih.gov/${pmid}/` : '#';
                                out.push({ title, link, pubDate: pubDate || new Date().toString() });
                            }catch(e){ /* ignore per-article parse errors */ }
                        }
                        if(out && out.length) { try{ localStorage.setItem(CACHE_KEY+'_pubmed', JSON.stringify({ t: Date.now(), items: out })); }catch{}; return out; }
                    }catch(e){ /* efetch failed, fall back to esummary JSON below */ }

                    // Fallback: use esummary JSON
                    try{
                        const esummaryUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?db=pubmed&id=${encodeURIComponent(idlist.join(','))}&retmode=json${apiKey?('&api_key='+encodeURIComponent(apiKey)):''}`;
                        const sumText = await fetchTextFromAny(esummaryUrl);
                        const sumObj = JSON.parse(sumText);
                        const uids = sumObj.result && sumObj.result.uids ? sumObj.result.uids : [];
                        const results = [];
                        for(const uid of uids){
                            const rec = sumObj.result && sumObj.result[uid] ? sumObj.result[uid] : null;
                            const title = rec ? (rec.title || rec.fulljournalname || rec.sorttitle || '') : '';
                            const pubdate = rec ? (rec.pubdate || rec.epubdate || '') : '';
                            const link = `https://pubmed.ncbi.nlm.nih.gov/${uid}/`;
                            results.push({ title: (String(title||'').trim()) || `PubMed ${uid}`, link, pubDate: pubdate || new Date().toString() });
                        }
                        try{ localStorage.setItem(CACHE_KEY+'_pubmed', JSON.stringify({ t: Date.now(), items: results })); }catch{}
                        return results;
                    }catch(e){ /* final fallback to cache */ }

                    try{ const raw = localStorage.getItem(CACHE_KEY+'_pubmed'); if(raw){ return JSON.parse(raw).items||[]; } }catch{}
                    return [];
                }catch(e){
                    try{ const raw = localStorage.getItem(CACHE_KEY+'_pubmed'); if(raw){ return JSON.parse(raw).items||[]; } }catch{}
                    return [];
                }
            }

            async function fetchArxiv(){
                try{
                    const API = 'https://export.arxiv.org/api/query?search_query=all&start=0&max_results=50&sortBy=submittedDate&sortOrder=descending';
                    let text = null;
                    // 1) try a direct fetch first (may succeed if CORS allowed)
                    try{
                        const r = await fetch(API, { mode: 'cors' });
                        if(r && r.ok){ text = await r.text(); }
                    }catch(e){ /* ignore direct fetch errors */ }
                    // 2) if direct failed or returned very little, use proxy attempts via fetchTextFromAny
                    if(!text || text.length < 50){
                        try{ text = await fetchTextFromAny(API); }catch(e){ /* ignore */ }
                    }
                    if(!text) throw new Error('arXiv fetch failed (no text)');

                    // Try robust XML parsing (namespace tolerant)
                    let items = [];
                    try{
                        const doc = new DOMParser().parseFromString(text, 'text/xml');
                        let entries = [];
                        try{ entries = Array.from(doc.getElementsByTagNameNS('*','entry') || []); }catch(e){}
                        if(!entries || !entries.length){ try{ entries = Array.from(doc.getElementsByTagName('entry') || []); }catch(e){ entries = []; } }
                        items = entries.map(e=>{
                            try{
                                // title
                                let title = '';
                                try{
                                    const tns = e.getElementsByTagNameNS('*','title');
                                    if(tns && tns.length) title = (tns[0].textContent||'').replace(/\s+/g,' ').trim();
                                    else { const t0 = e.getElementsByTagName('title')[0]; if(t0) title = (t0.textContent||'').replace(/\s+/g,' ').trim(); }
                                }catch(err){ title = ''; }

                                // link
                                let link = '';
                                try{
                                    const linkEls = Array.from(e.getElementsByTagNameNS('*','link') || e.getElementsByTagName('link') || []);
                                    for(const le of linkEls){
                                        const rel = (le.getAttribute && le.getAttribute('rel')) || '';
                                        const href = (le.getAttribute && le.getAttribute('href')) || '';
                                        if(href && (!rel || rel === 'alternate')){ link = href; break; }
                                    }
                                }catch(err){}
                                if(!link){ try{ const idEl = e.getElementsByTagNameNS('*','id')[0] || e.getElementsByTagName('id')[0]; if(idEl) link = (idEl.textContent||'').trim(); }catch(err){} }
                                if(link && link.indexOf('export.arxiv.org')>=0) link = link.replace(/^https?:\/\/export\.arxiv\.org/, 'https://arxiv.org');

                                // pubDate
                                let pubDate = '';
                                try{
                                    const ud = e.getElementsByTagNameNS('*','updated')[0] || e.getElementsByTagName('updated')[0];
                                    const pd = e.getElementsByTagNameNS('*','published')[0] || e.getElementsByTagName('published')[0];
                                    if(ud && ud.textContent) pubDate = (ud.textContent||'').trim();
                                    else if(pd && pd.textContent) pubDate = (pd.textContent||'').trim();
                                }catch(err){ pubDate = ''; }
                                if(!pubDate) pubDate = new Date().toString();
                                return { title: title || '(no title)', link: link || '#', pubDate };
                            }catch(e){ return null; }
                        }).filter(Boolean).slice(0,50);
                    }catch(e){ /* xml parse failed */ }

                    // Loose regex fallback if XML parsing produced nothing
                    if(!items || !items.length){
                        try{
                            const matches = Array.from((text.matchAll(/<entry[\s\S]*?<\/entry>/gmi) || []));
                            const loose = matches.map(m=>{
                                const block = m[0];
                                const t = ((block.match(/<title[^>]*>([\s\S]*?)<\/title>/i) || [,''])[1]||'').replace(/\s+/g,' ').trim();
                                const idm = (block.match(/<id[^>]*>([\s\S]*?)<\/id>/i) || [,''])[1] || '';
                                const linkm = (block.match(/<link[^>]*href=["']?([^"'\s>]+)["']?[^>]*>/i) || [,''])[1] || idm || '';
                                const pubm = (block.match(/<(updated|published)[^>]*>([\s\S]*?)<\/(?:updated|published)>/i) || [,'',''])[2] || new Date().toString();
                                let link = (linkm||'').trim(); if(link.indexOf('export.arxiv.org')>=0) link = link.replace(/^https?:\/\/export\.arxiv\.org/, 'https://arxiv.org');
                                if(/^\/abs\//.test(link)) link = 'https://arxiv.org' + link;
                                if(link && link.startsWith('http://arxiv.org')) link = link.replace('http://', 'https://');
                                return { title: t||'(no title)', link: link||'#', pubDate: pubm };
                            }).filter(Boolean).slice(0,50);
                            if(loose && loose.length) items = loose;
                        }catch(e){}
                    }

                    // Normalize pubDate: if an item is older than MAX_AGE_MS, set its pubDate to now so prune24h doesn't remove everything
                    try{
                        const now = Date.now();
                        if(Array.isArray(items)){
                            items = items.map(it=>{
                                try{
                                    const pd = Date.parse(it.pubDate||'');
                                    if(!isFinite(pd) || (now - pd) > (typeof MAX_AGE_MS === 'number' ? MAX_AGE_MS : 24*60*60*1000)){
                                        it.pubDate = new Date().toString();
                                    }
                                }catch(e){}
                                return it;
                            });
                        }
                    }catch(e){}

                    // If still empty, return cached items or a sample fallback so the ticker isn't blank
                    if(!items || !items.length){
                        try{ const raw = localStorage.getItem(CACHE_KEY+'_arxiv'); if(raw){ const j = JSON.parse(raw); if(Array.isArray(j.items) && j.items.length) return j.items; } }catch(e){}
                        return [{ title: 'arXiv headlines unavailable (network/CORS); check console', link:'#', pubDate: new Date().toString() }];
                    }

                    try{ console.debug('[arXiv] returning', (items && items.length) || 0, 'items'); localStorage.setItem(CACHE_KEY+'_arxiv', JSON.stringify({ t: Date.now(), items })); }catch(e){}
                    return items;
                }catch(e){
                    try{ const raw = localStorage.getItem(CACHE_KEY+'_arxiv'); if(raw){ return JSON.parse(raw).items||[]; } }catch{ }
                    return [{ title: 'arXiv fetch failed — using cached/sample fallback', link:'#', pubDate: new Date().toString() }];
                }
            }

            // Dispatcher to fetch by source key
            async function fetchNewsBySource(source){
                if(!source) source = 'pubmed';
                if(source === 'pubmed') return await fetchPubMed();
                if(source === 'arxiv') return await fetchArxiv();
                return [];
            }

            // Cancellation support: store the current generation controller so Close can abort
            window.__currentGenerationController = null;
            function cancelCurrentGeneration(){
                try{
                    const c = window.__currentGenerationController;
                    if(c && typeof c.abort === 'function'){
                        try{ c.abort(); }catch(e){}
                    }
                    // Clear reference so subsequent calls are fresh
                    window.__currentGenerationController = null;
                }catch(e){}
            }

            async function ensureDailyQuiz(){
                try{
                    // Return cached quiz if present and fresh
                    const rawQuiz = localStorage.getItem(DAILY_QUIZ_KEY);
                    if(rawQuiz){
                        const qObj = JSON.parse(rawQuiz);
                        if(qObj && qObj.generatedAt && (Date.now() - qObj.generatedAt) < 24*60*60*1000 && qObj.topic && qObj.questions) return qObj;
                    }
                    // Need to generate
                    let topic = getDailyTopic();
                    if(!topic){ topic = await fetchRandomWikipediaTitle(); saveDailyTopic(topic); }
                    // Resolve Gemini API key: prefer global input, respect enable/remember toggles, then fallback to stored key/prompt
                    function getEffectiveGemKey(){
                        try{
                            const input = document.getElementById('globalGemKey');
                            const enable = document.getElementById('globalGemEnable');
                            const remember = document.getElementById('globalGemRemember');
                            // If explicit "enable" checkbox exists and is unchecked, treat as disabled
                            if(enable && enable.checked === false) return null;
                            // Prefer the visible input value when present
                            if(input && String(input.value||'').trim()){
                                const v = String(input.value).trim();
                                // store if user opted to remember
                                try{ if(remember && remember.checked) localStorage.setItem('gemini.key', v); }catch(e){}
                                return v;
                            }
                            // Fallback to previously stored key
                            try{ const stored = localStorage.getItem('gemini.key'); if(stored) return stored; }catch(e){}
                            return null;
                        }catch(e){ return null; }
                    }

                    let gemKey = getEffectiveGemKey();
                    if(!gemKey){
                        try{ gemKey = prompt('Enter Gemini API key to generate the daily quiz (will be stored in your browser)'); if(gemKey) try{ localStorage.setItem('gemini.key', gemKey); }catch(e){} }catch(e){}
                    }
                    if(!gemKey) throw new Error('Gemini API key required');
                    // Create an AbortController for this generation and expose it (or reuse existing)
                    let controller = window.__currentGenerationController;
                    if(!controller){ controller = new AbortController(); window.__currentGenerationController = controller; }
                    const result = await askGeminiForQuiz(topic, gemKey, controller.signal);
                    const store = { topic, questions: result.questions, generatedAt: Date.now() };
                    try{ localStorage.setItem(DAILY_QUIZ_KEY, JSON.stringify(store)); }catch(e){}
                    return store;
                }catch(e){ console.warn('ensureDailyQuiz failed', e); throw e; }
            }

            // Render quiz into preview area (reuse existing preview card)
            async function showDailyQuiz(){
                const previewCard = document.getElementById('preview');
                const previewList = document.getElementById('previewList');
                const dailyBtn = document.getElementById('dailyQuizBtn');
                const modal = document.getElementById('dailyBuildModal');
                const statusEl = document.getElementById('dailyBuildStatus');
                const closeBtn = document.getElementById('dailyBuildClose');
                function log(...args){ try{ debugLog(...args); }catch(e){ console.log(...args); } }
                // helper to open/close modal
                function openModal(){ try{ modal.classList.remove('hidden'); document.documentElement.classList.add('modal-open'); }catch{} }
                function closeModal(){ try{ modal.classList.add('hidden'); document.documentElement.classList.remove('modal-open'); }catch{} }

                // disable button and show spinner/status
                try{
                    if(dailyBtn) { dailyBtn.disabled = true; }
                    openModal(); if(statusEl) statusEl.textContent = 'Initializing…';
                    // Record when modal was shown so we can enforce a minimum visible duration
                    let modalShownAt = Date.now();
                    const MIN_VISIBLE_MS = 10000; // keep modal visible at least this long (10s)
                    // Close button should be interactable immediately and cancels generation when clicked
                    try{ if(closeBtn){ closeBtn.disabled = false; closeBtn.addEventListener('click', ()=>{ statusEl && (statusEl.textContent = 'Canceled by user'); cancelCurrentGeneration(); try{ if(dailyBtn) dailyBtn.disabled = false; }catch{}; try{ modal.classList.add('hidden'); }catch{} }); } }catch(e){}
                    if(previewCard) previewCard.classList.remove('hidden');
                    if(previewList) previewList.innerHTML = '<div class="hint">Generating daily quiz…</div>';

                    log('Daily quiz: starting generation');
                    statusEl && (statusEl.textContent = 'Resolving topic and key…');
                    // Show the topic early in the modal: use cached topic if present, otherwise try a fast fetch
                    try{
                        const topicSpan = document.getElementById('dailyBuildTopic');
                        let earlyTopic = null;
                        try{ earlyTopic = getDailyTopic(); }catch{}
                        earlyTopic = normalizeTopic(earlyTopic);
                        if(topicSpan){
                            if(earlyTopic){
                                topicSpan.textContent = earlyTopic;
                                // ensure normal (non-inverted) colors for Daily
                                topicSpan.classList.remove('inverse');
                                // retrigger rainbow animation
                                topicSpan.classList.remove('rainbow'); void topicSpan.offsetWidth; topicSpan.classList.add('rainbow');
                                // Fit the title line to the modal width
                                try{ fitTitleToContainer(document.getElementById('dailyBuildTitle')); }catch(e){}
                            } else {
                                topicSpan.textContent = 'choosing...';
                                topicSpan.classList.remove('inverse');
                                topicSpan.classList.remove('rainbow'); void topicSpan.offsetWidth; topicSpan.classList.add('rainbow');
                                statusEl && (statusEl.textContent = 'Choosing a topic…');
                                try{
                                    // ensure a controller exists so this fetch can be aborted
                                    let ctr = window.__currentGenerationController;
                                    if(!ctr){ ctr = new AbortController(); window.__currentGenerationController = ctr; }
                                    const fetched = await fetchRandomWikipediaTitle(ctr.signal);
                                    if(fetched){
                                        const nf = normalizeTopic(fetched);
                                        topicSpan.textContent = nf;
                                        // ensure normal colors for Daily
                                        topicSpan.classList.remove('inverse');
                                        try{ saveDailyTopic(fetched); }catch{};
                                        statusEl && (statusEl.textContent = 'Topic resolved: ' + nf);
                                        try{ fitTitleToContainer(document.getElementById('dailyBuildTitle')); }catch(e){}
                                    }
                                }catch(e){ console.warn('Early topic fetch failed', e); }
                            }
                        }
                    }catch(e){ console.warn('Failed to set early topic', e); }

                    // Ensure quiz (this will fetch topic and call Gemini)
                    let quiz;
                    try{
                        quiz = await ensureDailyQuiz();
                    }catch(e){
                        if(e && e.name === 'AbortError'){
                            statusEl && (statusEl.textContent = 'Canceled');
                            try{ if(previewList) previewList.innerHTML = '<div class="hint">Generation canceled.</div>'; }catch{};
                            return;
                        }
                        throw e;
                    }
                    // Normalize stored topic for display and output
                    const finalTopic = normalizeTopic(quiz && quiz.topic ? quiz.topic : '');
                    // After obtaining the final quiz/topic, update title and ensure it fits
                    try{
                        const titleEl = document.getElementById('dailyBuildTitle');
                        const topicSlug = String(finalTopic||'').trim();
                        const wikiUrl = topicSlug ? ('https://en.wikipedia.org/wiki/' + encodeURIComponent(topicSlug.replace(/\s+/g,'_'))) : '';
                        if(titleEl){
                            if(wikiUrl){
                                titleEl.innerHTML = `Today's Random Quiz is about <a href="${wikiUrl}" target="_blank" rel="noopener noreferrer"><span id="dailyBuildTopic" class="rainbow">${escapeHtml(finalTopic)}</span></a>!`;
                            } else {
                                titleEl.innerHTML = `Today's Random Quiz is about <span id="dailyBuildTopic" class="rainbow">${escapeHtml(finalTopic)}</span>!`;
                            }
                        }
                        fitTitleToContainer(document.getElementById('dailyBuildTitle'));
                    }catch(e){}
                    log('Daily quiz: generation complete, formatting output');
                    statusEl && (statusEl.textContent = 'Formatting questions…');

                    const arr = quiz.questions || [];
                    // Build formatted question text for the paste area: Qn., options as - , and ANSWER KEY
                    let text = '';
                    text += `Daily Quiz: ${finalTopic}\n\n`;
                    const count = Math.min(arr.length, 10);
                    for(let i=0;i<count;i++){
                        const it = arr[i] || {};
                        const qnum = i+1;
                        const qText = (it.question || '').replace(/\n+/g,' ');
                        text += `Q${qnum}. ${qText}\n`;
                        (it.choices||[]).forEach((c)=>{ text += `- ${String(c||'').replace(/\n+/g,' ')}\n`; });
                        text += '\n';
                    }
                    // Answer key
                    text += 'ANSWER KEY\n';
                    for(let i=0;i<count;i++){
                        const it = arr[i] || {};
                        const ansIdx = typeof it.answerIndex === 'number' ? it.answerIndex : (it.answerIndex==null && it.answer ? (Array.isArray(it.choices)? it.choices.indexOf(it.answer) : 0) : 0);
                        const letter = String.fromCharCode(65 + (ansIdx||0));
                        text += `${i+1}. ${letter}\n`;
                    }

                    // Write to the Generate MCQ debug output as well
                    log('Daily quiz: injecting formatted questions into paste area');
                    const paste = document.getElementById('paste');
                    if(paste){ paste.value = text; }

                    // Also render a preview in the preview panel as before
                    try{
                        const finalTopicSlug2 = String(finalTopic||'').trim();
                        const finalWiki = finalTopicSlug2 ? ('https://en.wikipedia.org/wiki/' + encodeURIComponent(finalTopicSlug2.replace(/\s+/g,'_'))) : '';
                        let html = `<h2 class="mb-6 mt-0">Daily Quiz: ${ finalWiki ? ('<a href="' + finalWiki + '" target="_blank" rel="noopener noreferrer">' + escapeHtml(finalTopic) + '</a>') : escapeHtml(finalTopic) }</h2>`;
                        html += '<ol>';
                        for(let i=0;i<count;i++){
                            const it = arr[i];
                            html += `<li class="qcard"><div class="hint">${escapeHtml(it.question||'')}</div><ul>`;
                            (it.choices||[]).forEach((c,ci)=>{ html += `<li class="choice">${String.fromCharCode(65+ci)}. ${escapeHtml(c)}</li>`; });
                            html += '</ul></li>';
                        }
                        html += '</ol>';
                        if(previewList) previewList.innerHTML = html;
                        // Render LaTeX/math only for the math segments inside the preview.
                        // Uses the lightweight KaTeX loader wrapper defined in the page (with heuristics).
                        try{ if(window.renderMathIn && previewList){ window.renderMathIn(previewList); } }catch(e){ console.warn('renderMathIn preview (daily) failed', e); }
                        document.getElementById('previewCount').textContent = String(arr.length||0);
                    }catch(e){ log('Daily quiz: preview render failed', e); }

                    // Trigger Parse & Preview automatically if available
                    try{ const parseBtn = document.getElementById('parseBtn'); if(parseBtn){ parseBtn.click(); log('Daily quiz: triggered Parse & Preview'); } }
                    catch(e){ log('Daily quiz: failed to trigger parse', e); }

                    statusEl && (statusEl.textContent = 'Done');
                    // Close the modal after the minimum visible duration has passed
                    try{
                        const elapsed = Date.now() - (modalShownAt || 0);
                        const remaining = Math.max(0, (MIN_VISIBLE_MS || 10000) - elapsed);
                        setTimeout(()=>{ try{ closeModal(); }catch{} }, remaining);
                    }catch(e){ try{ closeModal(); }catch{} }
                }catch(e){
                    try{ debugLog('Daily quiz failed:', e && e.message ? e.message : e); }catch{};
                    if(previewList) previewList.innerHTML = `<div class="hint">Failed to generate quiz: ${String(e.message||e)}</div>`;
                    const errMsg = (e && e.message) ? e.message : String(e);
                    statusEl && (statusEl.textContent = 'Failed: ' + errMsg);
                    // Keep modal open for user to read error; enable close
                }finally{
                    try{ if(dailyBtn) dailyBtn.disabled = false; }catch{}
                }

                // Close button should always allow closing
                try{ document.getElementById('dailyBuildClose')?.addEventListener('click', ()=>{ document.getElementById('dailyBuildModal')?.classList.add('hidden'); cancelCurrentGeneration(); }); }catch(e){}
            }

            // showRandomQuiz: same UI/flow as showDailyQuiz but always forces a fresh random topic and generation
            async function showRandomQuiz(){
                const previewCard = document.getElementById('preview');
                const previewList = document.getElementById('previewList');
                const randomBtn = document.getElementById('randomQuizBtn');
                const modal = document.getElementById('dailyBuildModal');
                const statusEl = document.getElementById('dailyBuildStatus');
                function log(...args){ try{ debugLog(...args); }catch(e){ console.log(...args); } }
                function openModal(){ try{ modal.classList.remove('hidden'); document.documentElement.classList.add('modal-open'); }catch{} }
                function closeModal(){ try{ modal.classList.add('hidden'); document.documentElement.classList.remove('modal-open'); }catch{} }

                try{
                    if(randomBtn) { randomBtn.disabled = true; }
                    openModal(); if(statusEl) statusEl.textContent = 'Initializing…';
                    // Record when modal was shown so we can enforce a minimum visible duration
                    let modalShownAt = Date.now();
                    const MIN_VISIBLE_MS = 10000; // keep modal visible at least this long (10s)
                    // Close button should be interactable immediately and cancels generation when clicked
                    try{ const closeBtn = document.getElementById('dailyBuildClose'); if(closeBtn){ closeBtn.disabled = false; closeBtn.addEventListener('click', ()=>{ statusEl && (statusEl.textContent = 'Canceled by user'); cancelCurrentGeneration(); try{ if(randomBtn) randomBtn.disabled = false; }catch{}; try{ modal.classList.add('hidden'); }catch{} }); } }catch(e){}
                    if(previewCard) previewCard.classList.remove('hidden');
                    if(previewList) previewList.innerHTML = '<div class="hint">Generating random quiz…</div>';

                    log('Random quiz: selecting topic');
                    statusEl && (statusEl.textContent = 'Choosing a topic…');
                    // Always fetch a fresh topic and normalize it for display
                    let topic = 'choosing...';
                    try{ 
                        // allow aborting the topic fetch
                        let ctr = window.__currentGenerationController;
                        if(!ctr){ ctr = new AbortController(); window.__currentGenerationController = ctr; }
                        topic = await fetchRandomWikipediaTitle(ctr.signal);
                    }catch(e){ console.warn('Random topic fetch failed', e); topic = 'random topic'; }
                    const normTopic = normalizeTopic(topic);
                    const topicSpan = document.getElementById('dailyBuildTopic');
                    if(topicSpan){
                        topicSpan.textContent = normTopic;
                        // use inverted colors for Random Quiz
                        topicSpan.classList.add('inverse');
                        topicSpan.classList.remove('rainbow'); void topicSpan.offsetWidth; topicSpan.classList.add('rainbow');
                        try{
                            const titleEl = document.getElementById('dailyBuildTitle');
                            const slug = String(normTopic||'').trim();
                            const wiki = slug ? ('https://en.wikipedia.org/wiki/' + encodeURIComponent(slug.replace(/\s+/g,'_'))) : '';
                            if(titleEl){
                                if(wiki){
                                    titleEl.innerHTML = `This random quiz is about <a href="${wiki}" target="_blank" rel="noopener noreferrer"><span id="dailyBuildTopic" class="rainbow inverse">${escapeHtml(normTopic)}</span></a>!`;
                                } else {
                                    titleEl.innerHTML = `This random quiz is about <span id="dailyBuildTopic" class="rainbow inverse">${escapeHtml(normTopic)}</span>!`;
                                }
                            }
                            fitTitleToContainer(document.getElementById('dailyBuildTitle'));
                        }catch(e){}
                    }

                    statusEl && (statusEl.textContent = 'Generating quiz…');
                    // Resolve Gemini API key via existing helper
                    let gemKey = (typeof getEffectiveGemKey === 'function') ? getEffectiveGemKey() : null;
                    if(!gemKey){ try{ gemKey = prompt('Enter Gemini API key to generate the random quiz (will be stored in your browser)'); if(gemKey) try{ localStorage.setItem('gemini.key', gemKey); }catch(e){} }catch(e){} }
                    if(!gemKey) throw new Error('Gemini API key required');

                    // Create or reuse controller for this run (ensureDailyQuiz uses the same global controller when applicable)
                    let localController = window.__currentGenerationController;
                    if(!localController){ localController = new AbortController(); window.__currentGenerationController = localController; }
                    let result;
                    try{
                        result = await askGeminiForQuiz(topic, gemKey, localController.signal);
                    }catch(e){
                        if(e && e.name === 'AbortError'){
                            statusEl && (statusEl.textContent = 'Canceled');
                            if(previewList) previewList.innerHTML = '<div class="hint">Generation canceled.</div>';
                            return;
                        }
                        throw e;
                    }
                    statusEl && (statusEl.textContent = 'Formatting questions…');

                    const arr = result.questions || [];
                    // Build formatted question text for the paste area: Qn., options as - , and ANSWER KEY
                    let text = '';
                    text += `Random Quiz: ${normTopic}\n\n`;
                    const count = Math.min(arr.length, 10);
                    for(let i=0;i<count;i++){
                        const it = arr[i] || {};
                        const qnum = i+1;
                        const qText = (it.question || '').replace(/\n+/g,' ');
                        text += `Q${qnum}. ${qText}\n`;
                        (it.choices||[]).forEach((c)=>{ text += `- ${String(c||'').replace(/\n+/g,' ')}\n`; });
                        text += '\n';
                    }
                    // Answer key
                    text += 'ANSWER KEY\n';
                    for(let i=0;i<count;i++){
                        const it = arr[i] || {};
                        const ansIdx = typeof it.answerIndex === 'number' ? it.answerIndex : (it.answerIndex==null && it.answer ? (Array.isArray(it.choices)? it.choices.indexOf(it.answer) : 0) : 0);
                        const letter = String.fromCharCode(65 + (ansIdx||0));
                        text += `${i+1}. ${letter}\n`;
                    }

                    log('Random quiz: injecting formatted questions into paste area');
                    const paste = document.getElementById('paste');
                    if(paste){ paste.value = text; }

                    // Also render a preview in the preview panel
                    try{
                        const normSlug = String(normTopic||'').trim();
                        const normWiki = normSlug ? ('https://en.wikipedia.org/wiki/' + encodeURIComponent(normSlug.replace(/\s+/g,'_'))) : '';
                        let html = `<h2 class="mb-6 mt-0">Random Quiz: ${ normWiki ? ('<a href="' + normWiki + '" target="_blank" rel="noopener noreferrer">' + escapeHtml(normTopic) + '</a>') : escapeHtml(normTopic) }</h2>`;
                        html += '<ol>';
                        for(let i=0;i<count;i++){
                            const it = arr[i];
                            html += `<li class="qcard"><div class="hint">${escapeHtml(it.question||'')}</div><ul>`;
                            (it.choices||[]).forEach((c,ci)=>{ html += `<li class="choice">${String.fromCharCode(65+ci)}. ${escapeHtml(c)}</li>`; });
                            html += '</ul></li>';
                        }
                        html += '</ol>';
                        if(previewList) previewList.innerHTML = html;
                        // Render LaTeX/math only for the math segments inside the preview.
                        try{ if(window.renderMathIn && previewList){ window.renderMathIn(previewList); } }catch(e){ console.warn('renderMathIn preview (random) failed', e); }
                        document.getElementById('previewCount').textContent = String(arr.length||0);
                    }catch(e){ log('Random quiz: preview render failed', e); }

                    // Trigger Parse & Preview automatically if available
                    try{ const parseBtn = document.getElementById('parseBtn'); if(parseBtn){ parseBtn.click(); log('Random quiz: triggered Parse & Preview'); } }
                    catch(e){ log('Random quiz: failed to trigger parse', e); }

                    statusEl && (statusEl.textContent = 'Done');
                    // Close the modal after the minimum visible duration has passed
                    try{
                        const elapsed = Date.now() - (modalShownAt || 0);
                        const remaining = Math.max(0, (MIN_VISIBLE_MS || 10000) - elapsed);
                        setTimeout(()=>{ try{ closeModal(); }catch{} }, remaining);
                    }catch(e){ try{ closeModal(); }catch{} }
                }catch(e){
                    try{ debugLog('Random quiz failed:', e && e.message ? e.message : e); }catch{};
                    if(previewList) previewList.innerHTML = `<div class="hint">Failed to generate quiz: ${String(e.message||e)}</div>`;
                    const errMsg = (e && e.message) ? e.message : String(e);
                    statusEl && (statusEl.textContent = 'Failed: ' + errMsg);
                    // Keep modal open for user to read error; enable close
                }finally{
                    try{ if(randomBtn) randomBtn.disabled = false; }catch{}
                }
            }

            // Utility: simple HTML escape
            function escapeHtml(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

            // Normalize topic strings: convert underscores to spaces and trim
            function normalizeTopic(t){ try{ return String(t||'').replace(/_/g,' ').trim(); }catch(e){ return String(t||''); } }

            // Classify a Wikipedia topic title into a coarse data type by querying categories.
            // Returns one of: person, place, event, science, media, organism, organization, concept, other
            async function classifyTopic(title){
                try{
                    const t = String(title||'').trim();
                    if(!t) return 'other';
                    // Query categories via Wikipedia API (CORS friendly with origin=*)
                    const url = 'https://en.wikipedia.org/w/api.php?action=query&titles=' + encodeURIComponent(t) + '&prop=categories&cllimit=50&format=json&origin=*';
                    const controller = new AbortController();
                    const to = setTimeout(()=>controller.abort(), 3500);
                    const res = await fetch(url, { signal: controller.signal });
                    clearTimeout(to);
                    if(!res.ok) throw new Error('HTTP '+res.status);
                    const data = await res.json();
                    const pages = data && data.query && data.query.pages ? data.query.pages : null;
                    const cats = [];
                    if(pages){
                        for(const k in pages){
                            const p = pages[k];
                            if(p && Array.isArray(p.categories)){
                                p.categories.forEach(c=>{ if(c && c.title) cats.push(c.title.replace(/^Category:/i,'')); });
                            }
                        }
                    }
                    const catStr = (cats||[]).join('||').toLowerCase();
                    // Heuristics based on category keywords
                    if(/births|living people|deaths|born|died/.test(catStr)) return 'person';
                    if(/cities|towns|villages|municipalities|places|countries|geography|populated places|settlements|islands|boroughs/.test(catStr)) return 'place';
                    if(/films|novels|books|albums|songs|television|media|film|episode|series|music|video games/.test(catStr)) return 'media';
                    if(/wars|battles|election|events|historic|history|anniversary/.test(catStr)) return 'event';
                    if(/species|flora|fauna|mammals|birds|reptiles|insects|plants|fungi|taxonomy|taxa/.test(catStr)) return 'organism';
                    if(/chemistry|chemical|compound|enzyme|protein|biochemistry|biology|physics|mathematics|science|geology|ecology|medicine/.test(catStr)) return 'science';
                    if(/companies|organizations|institutes|universities|colleges|schools|corporations|associations|organizations/.test(catStr)) return 'organization';
                    if(/concepts|philosophy|theory|concept|principles|terminology/.test(catStr)) return 'concept';
                    return 'other';
                }catch(e){
                    // Fallback: simple heuristics
                    try{
                        const s = String(title||'');
                        if(/\b(University|College|Institute|School|Hospital|Company|Corporation)\b/i.test(s)) return 'organization';
                        if(/\b(\d{4}|BC|AD)\b/.test(s)) return 'event';
                        if(/\b(Protein|Enzyme|Chemistry|Biology|Physics|Math|Mathematics|Molecular)\b/i.test(s)) return 'science';
                        if(/\b(\w+idae|\w+ales|species|genus)\b/i.test(s)) return 'organism';
                        if(s.split(' ').length === 1 && /^[A-Z][a-z]+$/.test(s)) return 'concept';
                    }catch(err){}
                    return 'other';
                }
            }

            // Apply classification result to an anchor element by adding a topic-type-... class and tooltip
            async function classifyAndApply(anchorEl, title){
                try{
                    if(!anchorEl) return;
                    anchorEl.classList.add('topic-link');
                    const t = String(title||anchorEl.textContent||'').trim();
                    const typ = await classifyTopic(t);
                    anchorEl.classList.add('topic-type-' + typ);
                    anchorEl.setAttribute('data-topic-type', typ);
                    anchorEl.setAttribute('title', (typ ? (typ.charAt(0).toUpperCase()+typ.slice(1)) : 'Topic') + ' — opens in Wikipedia');
                }catch(e){ /* ignore */ }
            }

            // Fit the title text to the modal width by scaling font-size responsively.
            // Attempts to keep the title on one line by shrinking font-size (down to minPx).
            // If it would become smaller than minPx, it falls back to allowing wrapping.
            function fitTitleToContainer(titleEl, opts){
                try{
                    if(!titleEl) return;
                    opts = opts || {};
                    const maxPx = typeof opts.maxPx === 'number' ? opts.maxPx : 48;
                    const minPx = typeof opts.minPx === 'number' ? opts.minPx : 14;
                    const innerSpan = titleEl.querySelector('.rainbow') || titleEl.querySelector('#dailyBuildTopic');
                    // Ensure we try to fit on a single line first
                    titleEl.style.whiteSpace = 'nowrap';

                    // Measure natural width at the max font size by creating a hidden clone
                    const clone = titleEl.cloneNode(true);
                    clone.style.position = 'absolute';
                    clone.style.left = '-9999px';
                    clone.style.top = '0';
                    clone.style.visibility = 'hidden';
                    clone.style.whiteSpace = 'nowrap';
                    clone.style.fontSize = maxPx + 'px';
                    // Ensure clone doesn't inherit layout constraints
                    clone.style.width = 'auto';
                    clone.style.maxWidth = 'none';
                    // Inner rainbow should show text for measurement
                    const topicSpan = clone.querySelector('.rainbow');
                    if(topicSpan) topicSpan.style.fontSize = 'inherit';
                    document.body.appendChild(clone);
                    const naturalW = clone.getBoundingClientRect().width || clone.offsetWidth || clone.scrollWidth || 0;
                    document.body.removeChild(clone);

                    const containerW = titleEl.clientWidth || (titleEl.getBoundingClientRect && titleEl.getBoundingClientRect().width) || 400;
                    if(!naturalW || naturalW <= containerW){
                        // Fits at maxPx
                        titleEl.style.fontSize = maxPx + 'px';
                        if(innerSpan) innerSpan.style.fontSize = 'inherit';
                        return;
                    }

                    // Compute desired font size that would make naturalW scale to containerW
                    let desired = Math.floor(maxPx * (containerW / naturalW));
                    if(desired < minPx){
                        // Too small — allow wrapping and use a readable min size
                        titleEl.style.whiteSpace = 'normal';
                        titleEl.style.fontSize = minPx + 'px';
                        if(innerSpan) innerSpan.style.fontSize = 'inherit';
                        return;
                    }

                    // Apply desired size and ensure it fits; if not, decrement until it does or minPx reached
                    titleEl.style.fontSize = desired + 'px';
                    if(innerSpan) innerSpan.style.fontSize = 'inherit';
                    for(let i=0;i<12;i++){
                        const sw = titleEl.scrollWidth || titleEl.getBoundingClientRect().width;
                        const cw = titleEl.clientWidth || titleEl.getBoundingClientRect().width;
                        if(sw <= cw) break;
                        desired = Math.max(minPx, desired - 1);
                        titleEl.style.fontSize = desired + 'px';
                        if(desired === minPx){ titleEl.style.whiteSpace = 'normal'; break; }
                    }
                }catch(e){ console.warn('fitTitleToContainer failed', e); }
            }

            // Wire the button
            document.getElementById('dailyQuizBtn')?.addEventListener('click', ()=>{ showDailyQuiz().catch(()=>{}); });
            document.getElementById('randomQuizBtn')?.addEventListener('click', ()=>{ showRandomQuiz().catch(()=>{}); });

            // Flashcards button removed: the Flashcards panel is now always visible below Preview.

            // Random category gear wiring
            (function(){
                const gear = document.getElementById('randomGearBtn');
                const gearWrap = document.getElementById('randomGearWrap');
                const modal = document.getElementById('randomCategoryModal');
                const close = document.getElementById('randomCategoryClose');
                const input = document.getElementById('categorySearch');
                const results = document.getElementById('categorySearchResults');
                const saveBtn = document.getElementById('categorySaveBtn');
                const clearBtn = document.getElementById('categoryClear');
                function open(){ try{ if(gear && gear.disabled) return; modal.classList.remove('hidden'); document.documentElement.classList.add('modal-open'); input.focus(); }catch{} }
                function closeModal(){ try{ modal.classList.add('hidden'); document.documentElement.classList.remove('modal-open'); }catch{} }
                function setBadge(on){ try{ if(on) gearWrap.classList.add('active'); else gearWrap.classList.remove('active'); }catch{} }
                // load saved category
                try{ const saved = localStorage.getItem('random.category'); setBadge(!!saved); }catch(e){}

                gear?.addEventListener('click', (ev)=>{ try{ if(gear.disabled) { ev.preventDefault(); ev.stopImmediatePropagation(); return; } open(); }catch(e){} });
                // prevent keyboard activation when disabled
                gear?.addEventListener('keydown', (ev)=>{ try{ if((ev.key === 'Enter' || ev.key === ' ') && gear.disabled){ ev.preventDefault(); ev.stopImmediatePropagation(); } }catch(e){} });
                close?.addEventListener('click', ()=>{ closeModal(); });
                clearBtn?.addEventListener('click', ()=>{ try{ localStorage.removeItem('random.category'); results.innerHTML=''; input.value=''; setBadge(false); }catch(e){} });

                // Debounced search
                let deb = 0; let lastQ = '';
                input?.addEventListener('input', (ev)=>{
                    const q = String(input.value||'').trim(); lastQ = q;
                    if(deb) clearTimeout(deb);
                    if(!q){ results.innerHTML = '<div class="hint">Type to search Wikipedia.</div>'; return; }
                    deb = setTimeout(async ()=>{
                        try{
                            results.innerHTML = '<div class="hint">Searching…</div>';
                            const url = `https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(q)}&utf8=&format=json&origin=*`;
                            const r = await fetch(url);
                            if(!r.ok) throw new Error('search failed');
                            const d = await r.json();
                            const arr = (d && d.query && d.query.search) || [];
                            if(!arr.length){ results.innerHTML = '<div class="hint">No results</div>'; return; }
                            results.innerHTML = '';
                            arr.slice(0,12).forEach(it=>{
                                const div = document.createElement('div'); div.className='result'; div.textContent = it.title; div.addEventListener('click', ()=>{
                                    // select this as the category
                                    input.value = it.title; results.querySelectorAll('.selected').forEach(n=>n.classList.remove('selected'));
                                    div.classList.add('selected');
                                });
                                results.appendChild(div);
                            });
                        }catch(e){ results.innerHTML = '<div class="hint">Search failed</div>'; }
                    }, 350);
                });

                // Save selected/typed value
                saveBtn?.addEventListener('click', ()=>{
                    try{
                        const v = String(input.value||'').trim();
                        if(!v){ alert('Please enter or select a query to save.'); return; }
                        localStorage.setItem('random.category', v);
                        setBadge(true);
                        closeModal();
                    }catch(e){ console.warn('Save category failed', e); }
                });
            })();

            // Observe size/content changes to keep the safe area fresh
            let ro = null; let mo = null; let lastH = -1; let rafId = 0;
            function scheduleMeasure(){
                if(rafId) cancelAnimationFrame(rafId);
                rafId = requestAnimationFrame(()=>{ rafId = 0; const h = computeTopSafeArea(); if(h !== lastH) lastH = h; });
            }
            function startObservers(){
                try{
                    if(window.ResizeObserver && newsBar){
                        ro = new ResizeObserver(scheduleMeasure); ro.observe(newsBar);
                    }
                }catch{}
                try{
                    if(window.MutationObserver && newsBar){
                        mo = new MutationObserver(scheduleMeasure);
                        mo.observe(newsBar, { childList: true, subtree: true, attributes: true, characterData: true });
                    }
                }catch{}
                window.addEventListener('resize', ()=>{ scheduleMeasure(); computeStickyScale(); try{ if(typeof positionDockAndPanel==='function') positionDockAndPanel(); }catch{} });
            }

            function setNewsEnabled(on){
                try{ localStorage.setItem(PREF_KEY, on ? 'on' : 'off'); }catch{}
                if(newsBar) newsBar.style.display = on ? '' : 'none';
                if(toggleBtn) toggleBtn.textContent = on ? 'Disable news' : 'Enable news';
                if(!on){
                    try{ cancelTicker(); }catch(e){}
                    try{ if(typeof stopPeriodicRefreshFn === 'function') stopPeriodicRefreshFn(); }catch(e){}
                } else {
                    try{ if(typeof startPeriodicRefreshFn === 'function') startPeriodicRefreshFn(); }catch(e){}
                    // Ensure we have content when re-enabled.
                    try{
                        if(typeof reloadNewsFn === 'function' && (!itemsState || itemsState.length === 0)){
                            reloadNewsFn().finally(()=>{ try{ scheduleMeasure(); }catch(e){} });
                        } else {
                            try{ startTicker(); }catch(e){}
                        }
                    }catch(e){}
                }
                // Apply offset immediately so elements jump to the correct spot without lag
                try{ computeTopSafeArea(); }catch{}
                scheduleMeasure();
                // Also reposition sticky elements that depend on top safe area
                try{ if(typeof positionDockAndPanel === 'function') positionDockAndPanel(); }catch{}
                // One more pass on next tick to catch any async layout changes
                setTimeout(()=>{ try{ computeTopSafeArea(); if(typeof positionDockAndPanel === 'function') positionDockAndPanel(); }catch{} }, 50);
            }

            // Allow other parts of the app to toggle news cleanly.
            try{ window.__setNewsEnabled = setNewsEnabled; }catch(e){}

            // Compute sticky notes scale so their vertical footprint adapts to the news header
            function computeStickyScale(){
                try{
                    const cs = getComputedStyle(document.documentElement);
                    const topPx = parseFloat(cs.getPropertyValue('--topSafeArea')) || 0;
                    const vh = Math.max(480, window.innerHeight || document.documentElement.clientHeight || 0);
                    // Dedicate up to ~12% vertical compression when a large header is present;
                    // clamp scale to [0.85, 1.00] for readability.
                    const ratio = topPx / Math.max(1, vh);
                    const scale = Math.max(0.85, Math.min(1.0, 1.0 - ratio * 1.6));
                    document.documentElement.style.setProperty('--stickyScale', scale.toFixed(3));
                    // Maintain a small visual gap above the rail/dock/panel
                    const gap = Math.min(16, 8 + Math.round(topPx * 0.08));
                    document.documentElement.style.setProperty('--stickyTopGap', gap + 'px');
                }catch{}
            }

            function formatDate(d){
                try{ const dt = new Date(d); return dt.toLocaleDateString(undefined, { month:'short', day:'numeric' }); }catch{ return ''; }
            }
            function prune24h(items){
                const now = Date.now();
                return (items||[]).filter(it=>{ let t = Date.parse(it.pubDate||''); if(!isFinite(t)) t = now; return (now - t) <= MAX_AGE_MS; });
            }
            function dedupe(items){
                const seen = new Set();
                return (items||[]).filter(it=>{ const k = (it.title||'').trim(); if(!k || seen.has(k)) return false; seen.add(k); return true; });
            }
            // Headlines fetch/render
            function parseFeedXML(text){
                try{
                    const doc = new DOMParser().parseFromString(text, 'text/xml');
                    // RSS 2.0 <item>
                    let nodes = Array.from(doc.querySelectorAll('channel > item, item'));
                    if(nodes && nodes.length){
                        return nodes.map(it=>({
                            title: (it.querySelector('title')?.textContent||'').trim(),
                            link: (it.querySelector('link')?.textContent||'').trim(),
                            pubDate: (it.querySelector('pubDate')?.textContent||it.querySelector('dc\:date')?.textContent||'').trim()
                        }));
                    }
                    // Atom <entry>
                    nodes = Array.from(doc.querySelectorAll('feed > entry, entry'));
                    if(nodes && nodes.length){
                        return nodes.map(it=>({
                            title: (it.querySelector('title')?.textContent||'').trim(),
                            link: (it.querySelector('link[rel="alternate"][href]')?.getAttribute('href') || it.querySelector('link[href]')?.getAttribute('href') || '#').trim(),
                            pubDate: (it.querySelector('updated')?.textContent||it.querySelector('published')?.textContent||'').trim()
                        }));
                    }
                }catch(e){ /* fallthrough */ }
                return [];
            }
            async function fetchTextFromAny(url){
                // Try direct first (may fail due to CORS); then proxies
                const attempts = [ async ()=>{
                    try{ const r = await fetch(url, { mode:'cors' }); if(!r.ok) throw new Error('HTTP '+r.status); return await r.text(); }catch(e){ throw e; }
                }];
                PROXIES.forEach(build=>{
                    attempts.push(async ()=>{ const u = build(url); const r = await fetch(u, { mode:'cors' }); if(!r.ok) throw new Error('HTTP '+r.status); return await r.text(); });
                });
                let lastErr = null;
                for(const fn of attempts){
                    try{ const txt = await fn(); if(txt && txt.length>20) return txt; }catch(e){ lastErr = e; }
                }
                throw lastErr || new Error('All fetch attempts failed');
            }
            
            function buildTicker(items){
                if(!newsRow) return;
                newsRow.innerHTML = '';
                const viewport = document.createElement('div'); viewport.className = 'news-viewport'; newsRow.appendChild(viewport);
                trackA = document.createElement('div'); trackA.className = 'news-track';
                trackB = document.createElement('div'); trackB.className = 'news-track';
                const makeFrag = (arr) => {
                    const frag = document.createDocumentFragment();
                    arr.forEach((it, idx)=>{
                        const a = document.createElement('a'); a.className='news-item'; a.target='_blank'; a.rel='noopener noreferrer'; a.href = it.link || '#';
                            // include date+time inline (no boxed pill)
                            const dateText = (function(dt){
                                try{
                                    const d = new Date(dt);
                                    // Use the shared global source so formatting can vary by source
                                    const src = (typeof window !== 'undefined' && window.__currentNewsSource) ? window.__currentNewsSource : null;
                                    if(src === 'pubmed') return '';
                                    // For arXiv show date only (no hour/minute). For others keep time.
                                    if(src === 'arxiv'){
                                        return d.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
                                    }
                                    return d.toLocaleString(undefined, { month:'short', day:'numeric', hour:'2-digit', minute:'2-digit' });
                                }catch{
                                    return '';
                                }
                            })(it.pubDate);
                            if(dateText){
                                const date = document.createElement('span'); date.className='news-date-inline';
                                date.textContent = dateText;
                                a.appendChild(date);
                            }
                            const title = document.createElement('span'); title.textContent = it.title || 'Untitled';
                            a.appendChild(title); frag.appendChild(a);
                        const sep = document.createElement('span'); sep.className='news-sep'; sep.textContent='•'; frag.appendChild(sep);
                    });
                    return frag;
                };
                trackA.appendChild(makeFrag(items));
                trackB.appendChild(makeFrag(items));
                viewport.appendChild(trackA); viewport.appendChild(trackB);
                // Position B right after A
                requestAnimationFrame(()=>{
                    const wA = trackA.getBoundingClientRect().width;
                    const vw = viewport.getBoundingClientRect().width;
                    // Fixed speed — do not adapt to content width
                    tickerSpeed = FIXED_NEWS_TICKER_SPEED;
                    console.debug('[news] tickerSpeed(px/s)=', tickerSpeed, 'trackWidth=', Math.round(wA));
                    trackA.style.transform = 'translateX(0px)';
                    trackB.style.transform = `translateX(${Math.max(0, Math.ceil(wA))}px)`;
                });
                // Pause on hover
                viewport.addEventListener('mouseenter', ()=>{ cancelTicker(); });
                viewport.addEventListener('mouseleave', ()=>{ startTicker(); });
                scheduleMeasure();
            }
            function startTicker(){
                cancelTicker();
                let lastTs = performance.now();
                const step = (ts)=>{
                    const dt = Math.max(0, ts - lastTs) / 1000; lastTs = ts;
                    const dx = tickerSpeed * dt; tickerX -= dx;
                    if(trackA && trackB){
                        const wA = trackA.getBoundingClientRect().width;
                        const wB = trackB.getBoundingClientRect().width;
                        // wrap when A completely off-screen
                        if(-tickerX >= wA){ tickerX += wA; }
                        const xA = Math.floor(tickerX);
                        const xB = Math.floor(tickerX + wA);
                        trackA.style.transform = `translateX(${xA}px)`;
                        trackB.style.transform = `translateX(${xB}px)`;
                    }
                    tickerRAF = requestAnimationFrame(step);
                };
                tickerRAF = requestAnimationFrame(step);
            }
            function cancelTicker(){ if(tickerRAF){ cancelAnimationFrame(tickerRAF); tickerRAF=0; } }
            function applyItems(items){
                itemsState = items.slice();
                if(itemsState.length === 0){
                    newsRow.innerHTML = '';
                    const hint = document.createElement('span'); hint.className='news-item'; hint.textContent = 'No headlines available right now.';
                    newsRow.appendChild(hint);
                    cancelTicker();
                    scheduleMeasure();
                    return;
                }
                buildTicker(itemsState);
                startTicker();
            }
            function init(){
                // Prevent double-initialization when this script is included/executed more than once.
                if(window.__newsInitDone) return;
                window.__newsInitDone = true;

                // Remember which news source to use (pubmed | arxiv)
                // allow a shared global value so other blocks can read it safely
                if(!window.__currentNewsSource) window.__currentNewsSource = 'pubmed';
                let currentNewsSource = window.__currentNewsSource;
                // Sequence counter to ignore stale/overlapping fetch results
                // Increment before each network fetch; only the latest seq may update UI.
                let newsReqSeq = 0;
                try{ currentNewsSource = localStorage.getItem('__newsSourcePref') || 'pubmed'; }catch(e){}
                // keep the global in sync
                window.__currentNewsSource = currentNewsSource;

                function setActiveNewsButton(){
                    try{
                        document.querySelectorAll('.news-source-opt').forEach(b=>{
                            try{ b.classList.toggle('active', (b.dataset && b.dataset.source) === currentNewsSource); }catch(e){}
                        });
                    }catch(e){}
                }

                async function reloadNews(){
                    // capture a sequence id so we can detect stale completions
                    const mySeq = ++newsReqSeq;
                    try{
                        const fresh = await fetchNewsBySource(currentNewsSource);
                        // If a newer request started while we were fetching, ignore this result
                        if(mySeq !== newsReqSeq){ console.debug('[news] ignoring stale fetch result for', currentNewsSource); return; }
                        const merged = dedupe(prune24h([...(fresh||[]), ...(itemsState||[])]));
                        applyItems(merged);
                    }catch(e){
                        console.warn('reloadNews failed', e);
                        try{ const raw = localStorage.getItem(CACHE_KEY+'_'+currentNewsSource); if(raw){ const cached = JSON.parse(raw).items||[]; if(mySeq === newsReqSeq) applyItems(cached); return; } }catch{}
                        if(mySeq === newsReqSeq) applyItems([]);
                    }
                }

                try{ reloadNewsFn = reloadNews; }catch(e){}

                function startPeriodicRefresh(){
                    if(refreshTimer) return;
                    refreshTimer = setInterval(async ()=>{
                        try{
                            const fresh = await fetchNewsBySource(currentNewsSource);
                            const merged = dedupe(prune24h([...(fresh||[]), ...(itemsState||[])]));
                            applyItems(merged);
                        }catch(e){ console.warn('periodic news refresh failed', e); }
                    }, REFRESH_MS);
                }
                function stopPeriodicRefresh(){
                    if(refreshTimer){ clearInterval(refreshTimer); refreshTimer = 0; }
                }
                try{ startPeriodicRefreshFn = startPeriodicRefresh; stopPeriodicRefreshFn = stopPeriodicRefresh; }catch(e){}

                // Initialize news enabled state from saved preference (default: ON for first run)
                try{
                    const saved = localStorage.getItem(PREF_KEY);
                    const initialOn = (saved === null || saved === 'on');
                    setNewsEnabled(initialOn);
                }catch(e){
                    // on error, enable by default
                    try{ setNewsEnabled(true); }catch(_){ }
                }
                startObservers();
                // initial load via selected source
                setActiveNewsButton();
                // Keep the user's saved preference; just ensure layout measurement runs
                try{ scheduleMeasure(); }catch(e){}

                // wire the enabled toggle
                if(toggleBtn){ toggleBtn.addEventListener('click', ()=>{
                    const on = !(newsBar && newsBar.style.display !== 'none');
                    setNewsEnabled(on);
                }); }

                // wire the source option buttons
                try{
                    document.querySelectorAll('.news-source-opt').forEach(btn=>{
                        try{
                            btn.addEventListener('click', async ()=>{
                                const src = btn.dataset && btn.dataset.source ? btn.dataset.source : 'pubmed';
                                // short-circuit if already active
                                if(currentNewsSource === src) return;
                                currentNewsSource = src;
                                window.__currentNewsSource = src;
                                try{ localStorage.setItem('__newsSourcePref', src); }catch(e){}
                                setActiveNewsButton();

                                // Pause the ticker and show loading hint
                                try{ cancelTicker(); }catch(e){}
                                const prevContent = newsRow.innerHTML;
                                try{
                                    newsRow.innerHTML = '';
                                    const loading = document.createElement('div'); loading.className = 'news-loading hint'; loading.textContent = 'Loading ' + src + ' headlines…';
                                    newsRow.appendChild(loading);
                                }catch(e){}

                                // disable controls while fetching
                                const opts = Array.from(document.querySelectorAll('.news-source-opt'));
                                opts.forEach(o=>{ try{ o.disabled = true; o.classList.add('disabled'); }catch(e){} });

                                // attempt reload; restore UI afterwards
                                try{
                                    await reloadNews();
                                }catch(e){
                                    console.warn('news reload failed on click', e);
                                    // leave loading hint but add notice
                                    try{ const el = newsRow.querySelector('.news-loading'); if(el) el.textContent = 'Failed to load ' + src + ' headlines.'; }catch(e){}
                                } finally {
                                    // re-enable buttons
                                    opts.forEach(o=>{ try{ o.disabled = false; o.classList.remove('disabled'); }catch(e){} });
                                }
                            });
                        }catch(e){}
                    });
                }catch(e){}
            }
            if(document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', init, { once:true }); } else { init(); }
        })();
        </script>
        <!-- Main Title: BUNKR 108 ASCII (restored) -->
        <style>
            /* Tweakable gap under the ASCII title. Try: 0px, 4px, 8px, 12px */
            :root{ --asciiTitleGap: 0px; }
            /* Increase top margin to move title away from the news bar; reduce bottom gap via --asciiTitleGap */
            .page-ascii-title{ margin:18px auto var(--asciiTitleGap); padding:0 2px; color: var(--ink); overflow:visible; pointer-events:none; -webkit-user-select:none; user-select:none; position:relative; display:flex; justify-content:center; align-items:flex-start; }
            .page-ascii-title pre{ margin:0; display:block; font-family: "Courier New", Consolas, monospace; font-weight:700; line-height:1.0; letter-spacing:0.35px; text-shadow:0 1px 0 #000; font-size:24px; white-space:pre; -webkit-user-select:none; user-select:none; transform-origin: top center; will-change: transform; }
            @media (max-width: 800px){ .page-ascii-title pre{ font-size:10px; } }
            @media (max-width: 480px){ .page-ascii-title pre{ font-size:9px; } }
            /* Site credit styling placed under title/boot overlays */
            /* Place credit directly under the title with no gap above; keep 6px below to separate from API bar */
            .site-credit{ margin:0 auto 12px; text-align:center; color:var(--ink); opacity:0.95; font-size:15px; font-weight:600; display:block; -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none; user-select:none; }
            @media (max-width:480px){ .site-credit{ font-size:13px; } }
        </style>
        <div id="mainAsciiTitle" class="page-ascii-title" aria-label="BUNKR 108 title banner">
            <pre>
888888b.   888     888 888b    888 888    d8P  8888888b.         d888    .d8888b.   .d8888b.  
888  "88b  888     888 8888b   888 888   d8P   888   Y88b       d8888   d88P  Y88b d88P  Y88b 
888  .88P  888     888 88888b  888 888  d8P    888    888         888   888    888 Y88b. d88P 
8888888K.  888     888 888Y88b 888 888d88K     888   d88P         888   888    888  "Y88888"  
888  "Y88b 888     888 888 Y88b888 8888888b    8888888P"          888   888    888 .d8P""Y8b. 
888    888 888     888 888  Y88888 888  Y88b   888 T88b           888   888    888 888    888 
888   d88P Y88b. .d88P 888   Y8888 888   Y88b  888  T88b          888   Y88b  d88P Y88b  d88P 
8888888P"   "Y88888P"  888    Y888 888    Y88b 888   T88b       8888888  "Y8888P"   "Y8888P"</pre>
        </div>
    <div class="site-credit" id="pageCredit">Created by <strong>Ethan Shaw</strong></div>
        <script>
        // Keep the ASCII title matched to the module width by scaling DOWN via transform (more reliable)
        (function initAsciiTitleFit(){
            function getEls(){
                const title = document.getElementById('mainAsciiTitle');
                const pre = title ? title.querySelector('pre') : null;
                const module = document.querySelector('.api-key-bar') || document.getElementById('setup') || document.querySelector('.card.pad');
                return { title, pre, module };
            }
            function measureNaturalWidth(pre){
                // Temporarily take the <pre> out of normal flow to measure its max-content width
                const prev = {
                    position: pre.style.position,
                    left: pre.style.left,
                    top: pre.style.top,
                    width: pre.style.width,
                    transform: pre.style.transform,
                    display: pre.style.display
                };
                try{
                    pre.style.position = 'fixed';
                    pre.style.left = '-99999px';
                    pre.style.top = '0';
                    pre.style.width = 'max-content';
                    pre.style.transform = 'none';
                    pre.style.display = 'inline-block';
                    // Use scrollWidth; fallback to bounding rect
                    return Math.max(pre.scrollWidth || 0, pre.getBoundingClientRect().width || 0) || 1;
                } finally {
                    pre.style.position = prev.position;
                    pre.style.left = prev.left;
                    pre.style.top = prev.top;
                    pre.style.width = prev.width;
                    pre.style.transform = prev.transform;
                    pre.style.display = prev.display;
                }
            }
            function fitOnce(){
                try{
                    const { title, pre, module } = getEls();
                    if(!title || !pre || !module) return;
                    const inset = 4; // px of breathing room to avoid any overhang
                    const modRect = module.getBoundingClientRect();
                    const targetW = Math.max(0, Math.round(modRect.width) - inset);
                    // Constrain container to target width but allow centering via margin:auto
                    // Use maxWidth instead of fixed width so the container can be horizontally centered.
                    title.style.width = 'auto';
                    title.style.maxWidth = targetW + 'px';
                    // Measure natural unscaled width
                    const naturalW = measureNaturalWidth(pre);
                    // Compute scale: only downscale; never upscale here
                    let scale = 1;
                    if(naturalW > 0 && targetW > 0){
                        scale = Math.min(1, (targetW / naturalW) * 0.992); // slight fudge to guarantee <= target
                        if(scale < 0.05) scale = 0.05; // hard floor to avoid zeroing out
                    }
                    // Apply transform; center horizontally by translating the scaled box
                    pre.style.transform = 'none';
                    // Force a reflow so getBoundingClientRect reflects unscaled position
                    const preRect0 = pre.getBoundingClientRect();
                    // Apply scale first
                    pre.style.transform = 'scale(' + scale + ')';
                    const titleRect = title.getBoundingClientRect();
                    const preRect = pre.getBoundingClientRect();
                    // Rely on flexbox for horizontal centering. Just apply scale transform.
                    pre.style.transform = 'scale(' + scale + ')';
                    // Reserve height so layout below doesn't jump; add extra pad to avoid clipping
                    const finalRect = pre.getBoundingClientRect();
                    // Respect the CSS gap when reserving height: the container's margin-bottom is external.
                    // Add a larger pad (12px) to ensure tall glyphs are not clipped when scaled.
                    title.style.height = Math.ceil(finalRect.height + 12) + 'px';
                    // Update or create invisible measurement box for diagnostics
                    let box = title.querySelector('#asciiMeasureBox');
                    if(!box){
                        box = document.createElement('div');
                        box.id = 'asciiMeasureBox';
                        box.style.position = 'absolute';
                        box.style.top = '0'; box.style.left = '0';
                        box.style.border = '1px dashed rgba(255,255,255,0)';
                        box.style.pointerEvents = 'none'; box.style.userSelect = 'none';
                        title.appendChild(box);
                    }
                    box.style.width = Math.round(Math.min(finalRect.width, targetW)) + 'px';
                    box.style.height = Math.round(finalRect.height) + 'px';
                    box.dataset.size = `${Math.round(Math.min(finalRect.width, targetW))}x${Math.round(finalRect.height)}`;
                }catch{}
            }
            function fitWithRetries(){
                fitOnce();
                // A couple of delayed passes to catch late layout/font shifts
                setTimeout(fitOnce, 60);
                setTimeout(fitOnce, 180);
            }
            function ready(cb){
                if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', cb, { once:true });
                else cb();
            }
            ready(()=>{
                fitWithRetries();
                window.addEventListener('resize', fitWithRetries);
                // Observe width changes of the target module
                try{
                    const ro = new ResizeObserver(fitWithRetries);
                    const target = document.querySelector('.api-key-bar') || document.getElementById('setup') || document.querySelector('.card.pad');
                    if(target) ro.observe(target);
                }catch{}
                // Ensure the page credit sits immediately under the ASCII title on startup
                try{
                    function ensureCreditUnderTitle(){
                        try{
                            const title = document.getElementById('mainAsciiTitle');
                            const credit = document.getElementById('pageCredit');
                            if(!title || !credit) return;
                            // If credit isn't the next sibling after title, move it there
                            if(title.nextElementSibling !== credit){
                                title.parentNode.insertBefore(credit, title.nextSibling);
                            }
                            // Ensure visual centering and modest spacing
                            credit.style.textAlign = 'center';
                            if(!credit.style.marginTop) credit.style.marginTop = '6px';
                        }catch{}
                    }
                    ensureCreditUnderTitle();
                    // Retry briefly in case other startup code rearranges nodes
                    setTimeout(ensureCreditUnderTitle, 60);
                    setTimeout(ensureCreditUnderTitle, 250);
                }catch{}
                // Re-fit after fonts are ready
                try{ if(document.fonts && document.fonts.ready){ document.fonts.ready.then(()=> fitWithRetries()); } }catch{}
            });
        })();
        </script>
        <!-- Global Gemini API Key (used by any AI feature below) - inside container so it matches width -->
        <div class="api-key-bar">
            <span id="globalKeyDot" class="api-key-dot missing" aria-hidden="true"></span>
            <strong class="fs-14">Gemini API Key</strong>
            <input type="password" id="globalGemKey" placeholder="AIza..." />
            <label class="switch" title="Remember key on this device">
                <input type="checkbox" id="globalGemRemember">
                <span class="slider"></span>
                <span class="switch-label ml-6 fs-12 muted">remember</span>
            </label>
            <label class="switch" title="Enable/disable the API key">
                <input type="checkbox" id="globalGemEnable">
                <span class="slider"></span>
                <span class="switch-label ml-6 fs-12 muted" id="globalGemEnableLabel">disabled</span>
            </label>
        </div>
        <!-- Gemini API key subtext moved to About AI Elements section -->
        <!-- (compact widget removed; expanded TOS box inserted below AI Elements section) -->
        <div class="card pad" id="setup">
            <div class="row">
                <div class="col">
                    <h1>Load Questions → Quiz</h1>
                    <div class="paste-head">
                        <label for="paste" class="paste-label">Paste your document</label>
                        <div class="paste-controls">
                            <button id="formatInfoBtn" class="btn paste-format-btn" type="button">Format Information</button>
                            <button id="quickStartBtn" class="btn paste-format-btn" type="button">Quick Start</button>
                        </div>
                    </div>
                    <div class="paste-wrap">
                    <textarea id="paste" class="flex-1 minh-320 maxw-600 w-100" placeholder="Q1. Why is protein purification essential in biochemistry?
- It prevents oxidation of DNA
- It allows isolation and study of specific proteins free from contaminants
- It enables bacterial transformation
- It increases cell growth rate
Q2. …
...
ANSWER KEY
1. B
2. C
..."></textarea>
                        <button id="indexPasteBtn" class="index-btn" type="button" title="Save this pasted document">Save Set</button>
                    </div>
                    <label class="mt-10">…or load a file (.txt)</label>
                    <div class="file-input">
                        <label class="choose-btn" for="file">Choose File</label>
                        <span class="filename" id="fileNameTxt">No file chosen</span>
                        <input type="file" id="file" accept=".txt" />
                    </div>
                    <!-- AI: Reformat & Assign Answers (same column, same width) -->
                    <div id="aiFixPanel" class="ai-fix-panel mt-10" role="region" aria-label="Reformat MCQs and Assign Answers">
                        <div class="flex center gap-12">
                            <div class="key-badge missing" id="fixKeyBadge" title="Shows whether a Gemini API key is present"><span class="dot"></span><span class="hint">No key set</span></div>
                            <button id="aiFixBtn" class="btn primary btn-wide" type="button" disabled>Reformat & Assign Answers (AI)</button>
                        </div>
                        <div id="aiFixStatus" class="hint mt-8 text-center" role="status" aria-live="polite"></div>
                        <div class="hint mt-6 text-center">Cleans up your pasted MCQ text to the required format (Qn., options with “-”, and an ANSWER KEY). If missing, it assigns a single correct answer per question. Output replaces the text above.</div>
                    </div>
                </div>
                <div class="col">
                    <div class="hint">Options</div>
                    <div class="options-container">
                        <label class="btn opt-cube"><input type="checkbox" id="shuffleQ" checked> Shuffle questions</label>
                        <label class="btn opt-cube"><input type="checkbox" id="shuffleA" checked> Shuffle answers</label>
                        <label class="btn opt-cube"><input type="checkbox" id="instant" checked> Instant feedback</label>
                    </div>
                    <div class="row">
                        <button class="btn primary" id="parseBtn">Parse & Preview</button>
                        <button class="btn" id="startBtn">Start Quiz</button>
                        <button class="btn" id="sampleBtn">Load Sample Snippet</button>
                    </div>
                    <!-- Optional AI file → MCQs generator (docx/pdf) -->
<div class="ai-file-panel">
    <div class="ai-file-row">
    <div class="file-input flex-1-260">
            <label class="choose-btn" for="aiFile">Choose File</label>
            <span class="filename" id="aiFileName">No file chosen</span>
    <input type="file" id="aiFile" multiple accept=".pdf,application/pdf,.docx,application/vnd.openxmlformats-officedocument.wordprocessingml.document,.pptx,application/vnd.openxmlformats-officedocument.presentationml.presentation,image/png,image/jpeg,image/webp,image/gif,image/*">
        </div>
    <!-- Drop target: allow dragging textbook chapters here to feed the Generate MCQs flow -->
    <div id="aiFileTbDrop" class="dropzone ml-8" title="Drop content chapters here to use as source for MCQ generation" aria-label="Drop content chapters here"></div>
    <div class="flex gap-8 center flex-wrap">
    <button id="aiAutoBtn" class="btn pill" title="Let AI choose the question count (defaults to 4 options)" aria-pressed="false">Auto</button>
    <label class="pill" title="Enable OCR on scanned pages"><input type="checkbox" id="aiOcrToggle" checked> OCR images</label>
    <label class="pill" title="How many questions to generate">
            <span class="muted fs-12 mr-4">Questions</span>
            <input type="number" id="aiQCount" min="1" max="50" step="1" value="30" class="w-68" />
        </label>
        <label class="pill" title="How many answer options per question">
            <span class="muted fs-12 mr-4">Options/Q</span>
            <input type="number" id="aiOptCount" min="2" max="6" step="1" value="4" class="w-68" />
        </label>
        <div class="ai-types-group" aria-label="Question types">
            <span class="muted fs-12 ai-types-label">Types</span>
            <label class="pill" title="Generate multiple-choice questions"><input type="checkbox" id="aiTypeMcq" checked> MCQ</label>
            <label class="pill" title="Generate True/False questions"><input type="checkbox" id="aiTypeTf"> T/F</label>
            <label class="pill" title="Generate Fill-in-the-Blank questions"><input type="checkbox" id="aiTypeFib"> Fill blank</label>
            <label class="pill" title="Generate Matching questions"><input type="checkbox" id="aiTypeMatch"> Matching</label>
        </div>
        <button class="btn primary ai-fixed" id="aiFileGenBtn" title="Use Gemini 2.5-flash to read .docx/.pdf/.pptx and create questions (MCQ/TF/Matching/Fill-in-the-Blank)">Generate Questions from .docx/.pdf/.pptx (AI)</button>
    </div>
            <div class="key-badge missing" id="fileGenKeyBadge" title="Shows whether a Gemini API key is present"><span class="dot"></span><span class="hint">No key set</span></div>
    <div class="ai-file-status" id="aiFileStatus" role="status" aria-live="polite"></div>
  </div>
  
        <!-- Visible debug output for the file-gen flow (helps when DevTools isn't open) -->
            <pre id="aiFileDebug"></pre>

            <!-- AI output preview modal (hidden by default) -->
            <div id="aiPreviewModal" class="hidden" aria-hidden="true">
                <div class="overlay">
                    <div class="panel">
                        <div class="flex justify-between center">
                            <h3 id="aiPreviewTitle">AI Output Preview</h3>
                            <button class="btn" id="aiPreviewClose">Close</button>
                        </div>
                                    <div class="hint mt-8" id="aiPreviewHint"></div>
                                    <!-- Tag input removed in Phase 1 -->
                                    <pre id="aiPreviewContent"></pre>
                                    <div class="flex gap-8 justify-end mt-12">
                                        <button class="btn" id="aiPreviewCancel">Cancel</button>
                                        <button class="btn" id="aiPreviewSave">Save generated</button>
                                        <button class="btn primary" id="aiPreviewInsert">Insert full output</button>
                                    </div>
                    </div>
                </div>
            </div>
    <div class="hint mt-6">
        Upload a <strong>.docx</strong>, <strong>.pdf</strong>, or <strong>.pptx</strong>. Gemini will conservatively extract content and return a set of
    questions formatted for this tool (either MCQ text with an <strong>ANSWER KEY</strong>, or a JSON bank with <span class="tag">{ items: [...] }</span>).
  </div>
  </div>

    <!-- Saved Sets retrieval module (separate, dropdown, outside AI panel) -->

<style>
/* Reduce/auto-size option buttons inside the AI file panel so they fit the parent width */
.ai-file-panel .ai-file-row{ display:flex; flex-wrap:wrap; column-gap:8px; row-gap:4px; align-items:center; }
/* Group the Types options with an outline so they read as one unit */
.ai-file-panel .ai-types-group{
    display:flex;
    align-items:center;
    flex-wrap:wrap;
    gap:8px;
    padding:6px 10px;
    border:1px solid var(--btnBorder);
    border-radius:12px;
    background: linear-gradient(180deg, rgba(14,20,32,.35), rgba(10,16,28,.35));
    flex: 0 0 auto;
    width: fit-content;
    box-sizing: border-box;
    justify-content:flex-start;
    max-width: 100%;
    margin-left: auto;
    margin-right: auto;
}
.ai-file-panel .ai-types-group .ai-types-label{ padding-right: 2px; }
    .ai-file-panel .ai-file-row .btn,
    .ai-file-panel .ai-file-row .pill,
    .ai-file-panel .ai-file-row label.pill,
    .ai-file-panel .ai-file-row .pill,
    .ai-file-panel .ai-file-row .btn{
        box-sizing: border-box;
        flex: 0 1 auto;
        max-width: 100%;
        padding: 6px 8px;
        font-size: 13px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        border-radius:8px; /* slightly smaller, consistent pill shape */
    }
/* Ensure checkbox label contents align center with sibling controls */
.ai-file-panel .ai-file-row label.pill{
    display: inline-flex;
    align-items: center; /* vertical centering */
    justify-content: center; /* horizontal centering of inner content */
    gap: 8px;
}
.ai-file-panel .ai-file-row label.pill input[type="checkbox"]{
    width: 16px;
    height: 16px;
    margin: 0;
    vertical-align: middle;
}
/* Center numeric values inside the compact number-entry controls used in the AI file row */
.ai-file-panel .ai-file-row label.pill input[type="number"],
.ai-file-panel .ai-file-row input.w-68 {
    text-align: center;
    padding-left: 6px; /* keep a small inner gap while visually centered */
    padding-right: 6px;
    box-sizing: border-box;
}
/* Let the file-input area shrink when space is tight */
.ai-file-panel .file-input{ min-width: 0; }
/* Reduce the Choose File module height inside the AI panel to match other controls */
.ai-file-panel .file-input{ display:flex; align-items:center; gap:8px; padding:6px 8px; box-sizing:border-box; height:36px }
.ai-file-panel .file-input.flex-1-260{ flex: 0 1 auto; min-width: 0; }
    .ai-file-panel .file-input .choose-btn{
    /* Match global .file-input .choose-btn sizing so the AI panel button is identical */
    display:inline-flex; align-items:center; justify-content:center;
    padding:6px 8px;
    border-radius:8px;
    background: linear-gradient(180deg, var(--btnTop), var(--btnBottom));
    border: 1px solid var(--btnBorder);
    color: var(--ink);
    font-weight:700;
    cursor:pointer;
    font-size:12px;
    line-height:normal;
    box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    flex: 0 0 auto;
    width: auto;
    min-width: 0;
    height: auto;
    min-height: 28px;
    vertical-align: middle;
}
.ai-file-panel .file-input .filename{ display:inline-flex; align-items:center; padding-left:8px; color:var(--muted); font-size:12px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; min-width:0; line-height:1 }
@media (max-width:640px){ .ai-file-panel .file-input .choose-btn{ min-height:36px } }
</style>
<style>
/* Fixed-height scrolling for AI file generation / OCR debug log */
#aiFileDebug{
    height: 140px;
    min-height: 140px;
    max-height: 140px;
    flex: 0 0 140px;
    overflow-y: auto;
    overflow-x: hidden;
    padding: 8px;
    white-space: pre-wrap;
    font-family: monospace;
    box-sizing: border-box;
}
</style>
    <div id="savedMcqs" class="saved-card" role="region" aria-label="Saved Sets">
    <div class="saved-header">
        <div class="flex center gap-8 saved-header-left">
            <strong>Saved Sets</strong>
            <div class="saved-badge-wrap">
                <span class="muted fs-12" id="savedCount">0</span>
            </div>
            <div id="savedTotalKb" class="muted fs-12" title="Total size of saved sets">Total: 0.0 KB</div>
        </div>
        <div class="flex gap-8">
            <button id="toggleSavedBtn" class="btn small" aria-expanded="false" aria-controls="savedMenu">Show</button>
            <button id="exportAllSavedBtn" class="btn small" title="Export all saved sets to a single ZIP">Export all</button>
            <button id="clearSavedBtn" class="btn small" title="Remove all saved sets">Clear</button>
        </div>
    </div>
    <div id="savedMenu" class="saved-menu" role="listbox" aria-label="Saved Sets Menu">
        <div id="savedList" class="saved-list"></div>
        <!-- footer removed to keep saved list compact (no extra spacing or divider) -->
    </div>
  </div>

                </div>
            </div>
        </div>
<style>
/* Ensure consistent vertical spacing between top-level card modules */
.card + .card { margin-top: 12px; }
/* add space between the main setup card and the preview section */
#preview { margin-top: 12px; }
/* Flashcards panel spacing: equal top and bottom margins to avoid asymmetric gaps */
#flashcardsPanel { margin: 12px 0; clear: both; }

</style>
<!-- Ensure missed/validation qcards shrink to fit content (don't stretch full width) -->
<style>
    /* Stack missed items vertically and make each card fill the results panel width
       so missed-answer cards match the Results readout width. */
    #attemptMissedList {
        display: flex;
        flex-direction: column;
        gap: 12px;
        align-items: stretch; /* allow children to grow to full width */
        width: 100%;
        box-sizing: border-box;
    }
    /* Make each missed card expand to the container width (match Results panel) */
    #attemptMissedList .qcard {
        display: block;
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
        margin: 6px 0; /* vertical spacing between cards */
        padding: 12px 14px; /* align with Results card padding */
    }
    /* Prevent the 'hint' row from using flex:space-between which forces wide layout; keep it compact */
    #attemptMissedList .qcard .hint {
        display: block !important;
        margin-top: 6px !important;
        color: var(--muted);
    }
</style>
<style>
/* Simple modal for See All questions */
.modal{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:20000 }
.modal.hidden{ display:none }
.modal{ position: fixed; inset: 0; display:flex; align-items: center; justify-content: center; z-index: 22010; }
.modal-backdrop{ position:absolute; inset:0; background:rgba(2,6,12,0.6); -webkit-backdrop-filter: blur(4px); backdrop-filter: blur(4px); }
.modal-panel{ position:relative; z-index:2; width: min(920px, 96vw); max-height: calc(100vh - 96px); overflow:auto; overscroll-behavior: contain; touch-action: auto; border-radius:12px; padding:16px; background: linear-gradient(180deg, rgba(8,12,18,.98), rgba(6,10,14,.98)); border:1px solid rgba(255,255,255,0.04); box-shadow: 0 12px 40px rgba(0,0,0,0.6); }
@supports (-webkit-overflow-scrolling: touch){
    .modal-panel{ -webkit-overflow-scrolling: touch; }
}
@supports (height: 100dvh){
    .modal-panel{ max-height: calc(100dvh - 96px); }
}
@media (max-width: 640px){
    html.modal-open, html.modal-open body{ overflow:hidden; }
    .modal-panel{ width: min(920px, 96vw); max-height: calc(100vh - 24px); padding: 14px; }
    @supports (height: 100dvh){
        .modal-panel{ max-height: calc(100dvh - 24px); }
    }
}
.modal-open, html.modal-open{ /* modal-open intentionally does not lock overflow so modal-panel can scroll on touch devices */ display:block }
.modal-open body, html.modal-open body{ /* intentionally no-op but keep rule non-empty for linters */ min-height:100% }
.modal-header{ display:flex; justify-content:space-between; align-items:center; margin-bottom:12px }
.modal-body{ color:var(--ink); font-size:14px; line-height:1.4; }
.seeall-item{ padding:8px 6px; border-bottom:1px dashed rgba(255,255,255,0.02); }
.seeall-item h4{ margin:0 0 6px 0; font-size:14px }
.seeall-item pre{ margin:0; white-space:pre-wrap; font-family:monospace; font-size:13px }
/* concise choice rows inside the See-All modal */
.seeall-choices{ margin-top:6px }
.seeall-choice{ margin:6px 0; font-size:13px; color:var(--muted); }
.seeall-choice strong{ display:inline-block; width:2.2em; color:var(--muted); font-weight:700 }
.seeall-match-left{ font-weight:700; color:var(--muted); }
.seeall-choice.correct{ color: #4dd17a; }
.seeall-choice.correct strong{ color: #4dd17a }

/* Inline-style replacements (mobile consistency + lint cleanup) */
.paste-controls{ display:flex; gap:8px; align-items:center; }

.rcm-row{ margin-top:12px; display:flex; gap:8px; align-items:center; }
.rcm-search{ flex:1 1 auto; min-width: 0; padding:8px; font-size:14px; border-radius:10px; background:#0c1526; color:var(--ink); border:1px solid var(--btnBorder); box-sizing:border-box; }
.rcm-actions{ margin-top:10px; display:flex; gap:8px; justify-content:flex-end; }

.fc-head{ display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap; }
.fc-head-left{ display:flex; align-items:center; gap:12px; min-width:0; }
.fc-deck-info{ font-size:13px; }
.fc-head-actions{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
.fc-card-area{ display:none; margin-top:12px; }
.fc-card{ min-height:180px; border-radius:12px; padding:18px; background:linear-gradient(180deg, rgba(8,12,18,1), rgba(6,10,14,1)); border:1px solid rgba(255,255,255,0.04); box-shadow: 0 8px 32px rgba(0,0,0,0.6); }
.fc-front{ font-weight:700; font-size:16px; color:var(--ink); }
.fc-back{ margin-top:12px; color:var(--muted); display:none; }
.fc-controls{ display:flex; gap:8px; margin-top:10px; align-items:center; flex-wrap:wrap; }
.fc-grades{ margin-left:auto; display:flex; gap:6px; flex-wrap:wrap; }

/* Modal sizing (replaces inline styles) */
#formatInfoModal .modal-panel.format-info-panel{ max-width: 600px; width: 90%; }
#quickStartModal .modal-panel.quick-start-panel{ max-width: 900px; width: 92%; }
@media (max-width: 640px){
    #formatInfoModal .modal-panel.format-info-panel,
    #quickStartModal .modal-panel.quick-start-panel{ width: 96%; }
}

/* Remaining inline-style replacements */
.cal-head-grow{ flex: 1 1 auto; min-width: 0; }
.pe-actions{ display:flex; gap:6px; align-items:center; }
.invert-timer-menu{ display:inline-flex; }

.lint-actions{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
.preview-footer-center{ flex:1; display:flex; justify-content:center; align-items:center; gap:10px; flex-wrap:wrap; }
.preview-export-highlight{ display:flex; align-items:center; gap:8px; }

.guide-text{ font-size: 14px; color: var(--ink); }
.guide-text-format{ line-height: 1.6; }
.guide-text-quickstart{ line-height: 1.65; }
.guide-first{ margin-top: 0; }
.guide-last{ margin-bottom: 0; }
.guide-h{ margin: 14px 0 8px; }

#dailyBuildModal .modal-panel.daily-build-panel{ max-width: 880px; width: 90%; }
@media (max-width: 640px){ #dailyBuildModal .modal-panel.daily-build-panel{ width: 96%; } }
.daily-build-title{ margin-bottom: 10px; font-weight: 800; }
.daily-build-spinner{ display:flex; align-items:center; gap:12px; }

.flex-spacer{ flex: 1 1 auto; }

.saved-results-panel{ margin: 12px 0; clear: both; }
.saved-results-card{ margin: 0; }
.last-attempt-block{ margin-top:12px; border-top:1px solid rgba(255,255,255,0.04); padding-top:10px; }

.ai-likeq-copy-panel{ position:relative; z-index:0; pointer-events:auto; }

.gemini-status-row{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
.gemini-status-link{ margin-left:6px; text-decoration: underline; }

.reset-bar{ margin-bottom:18px; }
</style>
<style>
/* TOS modal and widget styles */
.tos-body pre{ white-space: pre-wrap; font-family: inherit; font-size:13px; }
.tos-widget{ display:flex; align-items:center; gap:8px; justify-content:flex-end; margin:8px auto; max-width:960px; }
.tos-status{ color:var(--muted); font-size:13px }
.tos-widget .tos-actions{ display:flex; gap:6px }
.tos-widget .btn.small{ padding:6px 8px; font-size:12px }
</style>
    <!-- Flashcards / SRS Panel (moved above Preview) -->
    <section id="flashcardsPanel" class="card pad">
        <div class="module-outline fc-head">
            <div class="fc-head-left">
                <h3 class="mt-0 m-0">Flashcards & SRS</h3>
                <div id="fcDeckInfo" class="hint fc-deck-info">No deck loaded.</div>
            </div>
            <div class="fc-head-actions">
                <button id="fcStartSession" class="btn primary small" disabled>Start Session</button>
                <div class="dropdown">
                    <button id="fcExportCsv" class="btn small">Export CSV</button>
                    <button id="fcExportAnkiTsv" class="btn small">Export Anki TSV</button>
                </div>
            </div>
        </div>

        <div id="fcCardArea" class="fc-card-area">
            <!-- Flashcard Timer: centered above the card; click to toggle Always vs Hover-only -->
            <style>
                /* Flashcard timer styles */
                .fc-timer-row{ display:flex; justify-content:center; margin:-4px 0 8px; }
                #fcFront, #fcBack{ white-space: pre-wrap; overflow-wrap:anywhere; word-break:break-word; }
                .fc-timer{
                    font: 600 13px ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
                    color: var(--ink, #e6edf3);
                    background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
                    border: 1px solid rgba(255,255,255,0.10);
                    padding: 6px 10px; border-radius: 999px;
                    box-shadow: 0 8px 24px rgba(0,0,0,0.35);
                    cursor: pointer; -webkit-user-select: none; user-select: none;
                    transition: opacity .16s ease, transform .16s ease, box-shadow .16s ease;
                }
                .fc-timer:hover{ transform: translateY(-1px); box-shadow: 0 10px 28px rgba(0,0,0,0.45); }
                .fc-timer.hover-only{ opacity: 0; pointer-events: none; }
                #fcCardArea:hover .fc-timer.hover-only{ opacity: 1; pointer-events: auto; }
                .fc-timer.pulse{ animation: fcTimerPulse 300ms ease; }
                @keyframes fcTimerPulse{ 0%{ transform: scale(1); } 50%{ transform: scale(1.07); } 100%{ transform: scale(1); } }
            </style>
            <div id="fcTimerRow" class="fc-timer-row"><div id="fcTimer" class="fc-timer" title="Click to toggle: Always visible ↔ Show on hover">00:00</div></div>
            <div id="fcCard" class="fc-card">
                <div id="fcFront" class="fc-front">Question</div>
                <div id="fcBack" class="fc-back">Answer</div>
            </div>
            <div class="fc-controls">
                <button id="fcFlip" class="btn">Flip</button>
                <div class="fc-grades">
                    <button id="fcAgain" class="btn" title="Again">Again</button>
                    <button id="fcHard" class="btn" title="Hard">Hard</button>
                    <button id="fcGood" class="btn primary" title="Good">Good</button>
                    <button id="fcEasy" class="btn" title="Easy">Easy</button>
                </div>
            </div>
            <div id="fcProgress" class="hint mt-8">Session: <span id="fcProgressText">0 / 0</span></div>
        </div>
    </section>

        <div id="preview" class="card pad hidden">
            <h2 class="mb-6 mt-0">Preview</h2>
            <div id="previewList"></div>

            <div id="lintPanel" class="lint-panel hidden" role="region" aria-label="Parse lint results">
                <div class="lint-head">
                    <div>
                        <div class="lint-title">Parser Check</div>
                        <div id="lintSummary" class="hint">No lint results yet.</div>
                    </div>
                    <div class="lint-actions">
                        <button class="btn small" id="lintRenumberBtn" type="button" title="Renumber questions sequentially in the current parsed deck" disabled>Renumber</button>
                        <button class="btn small" id="lintRemoveDupesBtn" type="button" title="Remove duplicated question numbers (keeps first occurrence)" disabled>Remove dupes</button>
                        <button class="btn small" id="lintHideBtn" type="button">Hide</button>
                    </div>
                </div>
                <div id="lintList" class="lint-list"></div>
            </div>
            <div class="footer">
                <span class="hint"><span id="previewCount">0</span> items parsed.</span>
                <div class="preview-footer-center">
                    <button class="btn" id="exportPdfBtn" title="Export preview to PDF">Export PDF</button>
                    <div class="preview-export-highlight">
                        <label class="switch" title="Highlight correct answers in exported PDF (green)">
                            <input type="checkbox" id="exportPdfHighlight" />
                            <span class="slider"></span>
                        </label>
                        <span id="exportPdfHighlightLabel" class="export-highlight-label muted fs-12">Highlight correct answers</span>
                    </div>
                </div>
                <button class="btn primary" id="seeAllBtn">See all</button>
            </div>
        </div>

    <!-- Random Quiz settings gear -->
    <style>
    /* Gear button next to Random button */
    .gear-btn{ display:inline-flex; align-items:center; justify-content:center; width:42px; height:42px; border-radius:50%; border:1px solid rgba(0,0,0,0.08); background:var(--card); cursor:pointer; margin-left:0; font-size:18px; line-height:1; color:#fff }
    .gear-badge{ position:relative; display:inline-block }
    /* badge removed per request; keep wrapper for layout only */
    /* Category modal */
    #randomCategoryModal .modal-panel{ max-width:640px }
    #categorySearchResults{ max-height:240px; overflow:auto; margin-top:8px; border:1px solid rgba(0,0,0,0.06); padding:6px; border-radius:6px; background:var(--card) }
    #categorySearchResults .result{ padding:8px; cursor:pointer; border-bottom:1px dashed rgba(0,0,0,0.03) }
    #categorySearchResults .result:last-child{ border-bottom:none }
    #categorySearchResults .result:hover{ background:rgba(0,0,0,0.02) }
    /* container that keeps random + gear together */
    .random-controls{ display:inline-flex; align-items:center; gap: var(--control-gap); margin-left: 0; }
    /* keep daily + random launch buttons vertically spaced by the unified unit */
    .quiz-launch-controls{ display:flex; flex-direction:column; gap: var(--control-gap); align-items:flex-start; }
    .gear-btn.disabled{ opacity:0.45; pointer-events:none }
    /* API key dot indicators */
    .api-key-dot{ display:inline-block; width:10px; height:10px; border-radius:50%; margin-right:8px; vertical-align:middle; box-shadow: 0 0 6px rgba(0,0,0,0.15); }
    /* Force daily/random key dots to a consistent size so they match visually inside pill buttons */
    #dailyKeyDot, #randomKeyDot { width:10px !important; height:10px !important; margin-right:8px !important; }
    /* Ensure perfect circular shape, no CSS transforms, and proper vertical centering beside text */
    #dailyKeyDot, #randomKeyDot { display:inline-block !important; vertical-align:middle !important; border-radius:50% !important; transform:none !important; box-shadow: 0 0 6px rgba(0,0,0,0.12) !important; }
    /* If dots appear inside .btn.pill, ensure the button doesn't apply a conflicting transform that skews the dot */
    .btn.pill { transform: none; }
    .api-key-dot.missing{ background:#ff6b6b; box-shadow:0 0 8px rgba(255,107,107,0.5); }
    .api-key-dot.present{ background:#4dd17a; box-shadow:0 0 10px rgba(77,209,122,0.5); }
    </style>

    <style>
    /* Persist green/red outlines for choice rows even when the inverted/light overlay is active.
       Approach: render a pseudo-element (::after) that draws the colored outline and subtle overlay
       in front of the choice. When the global inverted overlay is active, double-invert only this
       pseudo-element so the outline keeps its native green/red hues while the card background
       remains subject to the inversion overlay (keeps the question background dark as requested).
    */
    .choice{ position: relative; overflow: visible; }

    .choice.correct::after,
    .choice.wrong::after{
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        border-radius: 10px; /* match .choice rounding */
        transition: -webkit-filter .36s ease, filter .36s ease, box-shadow .18s ease, background-color .18s ease;
        will-change: box-shadow, filter, background-color;
        z-index: 1; /* place above the choice content but below any interactive markers */
    }

    /* Outer glow + subtle tinted overlay (very low opacity so underlying card stays readable) */
    .choice.correct::after{
        /* Reduced halo thickness from 6px to 3px per request */
        box-shadow: 0 0 0 3px rgba(77,209,122,0.12);
        background: linear-gradient(180deg, rgba(77,209,122,0.04), rgba(77,209,122,0.02));
    }
    .choice.wrong::after{
        /* Match reduced halo thickness for wrong state */
        box-shadow: 0 0 0 3px rgba(255,107,107,0.12);
        background: linear-gradient(180deg, rgba(255,107,107,0.04), rgba(255,107,107,0.02));
    }

    /* When the global light-mode overlay is active, lift the choice element and its
       colored pseudo-element above the overlay so the green/red tint renders normally
       on top of the (inverted) question background. We use the same z-index level as
       other preserved-palette elements elsewhere on the page. This preserves the
       dark inverted card background while making the outline/overlay green or red.
    */
    body.light-mode-active .choice.correct,
    body.light-mode-active .choice.wrong{
        position: relative;
        /* keep the choice container BELOW the global invert overlay so its contents are inverted,
           then we selectively double-invert the green/red indicator pseudo-element only. */
        z-index: 2147483644; /* below #lightModeOverlay (2147483646) */
        /* ensure no filter is applied to the element itself */
        -webkit-filter: none !important;
        filter: none !important;
    }

    body.light-mode-active .choice.correct::after,
    body.light-mode-active .choice.wrong::after{
        /* keep the indicator just under the overlay and double-invert it so it renders true green/red */
        z-index: 2147483645; /* below overlay (2147483646), above base content */
        -webkit-filter: invert(1) !important;
        filter: invert(1) !important;
    }

    /* Fix inverted-mode background tint: when inverted display is active, we neutralize the
       base element background (so it doesn't get color-inverted) and paint the intended
       green/red background via a ::before layer that is also double-inverted. This keeps
       the inside fill color consistent with the outline (true green/red) in inverted view. */
    body.light-mode-active .choice.correct,
    body.light-mode-active .choice.wrong{
        background: transparent !important; /* avoid inverted base gradient */
    }
    body.light-mode-active .choice.correct::before,
    body.light-mode-active .choice.wrong::before{
        content: "";
        position: absolute;
        inset: 0;
        border-radius: 12px;
        pointer-events: none;
        z-index: 2147483644; /* under the outline (::after), above base content */
        /* Apply the same gradients as normal mode, but double-invert to cancel the global invert */
    }
    body.light-mode-active .choice.correct::before{
        /* Light-theme friendly green fill */
        background: linear-gradient(180deg, rgba(188, 245, 212, .65), rgba(152, 234, 190, .55));
        -webkit-filter: invert(1) !important;
        filter: invert(1) !important;
    }
    body.light-mode-active .choice.wrong::before{
        /* Light-theme friendly red fill */
        background: linear-gradient(180deg, rgba(255, 214, 214, .65), rgba(250, 190, 190, .55));
        -webkit-filter: invert(1) !important;
        filter: invert(1) !important;
    }

    /* Keep the inner tag/label content above the pseudo-element so text/icons remain readable */
    .choice > * { position: relative; z-index: 2147483649; }
    </style>

    <style>
    /* Ensure radios keep true green/red fills and borders even when global light-mode inversion is active */
    /* Neutralize default checked visuals under inverted mode to prevent brand/UA tints */
    body.light-mode-active .qcard .choice input[type="radio"]:checked{
        border-color: rgba(110,150,200,.8) !important;
        background: none !important;
        box-shadow: none !important;
    }
    body.light-mode-active .qcard .choice.correct input[type="radio"]{
        border-color: var(--ok) !important;
        /* Do NOT invert the base radio so the transparent center sees the green overlay behind */
        -webkit-filter: none !important; filter: none !important;
    }
    body.light-mode-active .qcard .choice.wrong input[type="radio"]{
        border-color: var(--bad) !important;
        -webkit-filter: invert(1) !important;
        filter: invert(1) !important;
    }
    /* Ensure wrong un-checked radios also stay red ring + white center in inverted mode */
    body.light-mode-active .qcard .choice.wrong input[type="radio"]:not(:checked){
        border-color: var(--bad) !important;
        background-image: radial-gradient(circle at center, #ffffff 0 46%, rgba(255,255,255,0) 48%),
                          radial-gradient(circle at center, var(--bad) 60%, var(--bad) 78%, rgba(0,0,0,0) 80%) !important;
        background-repeat: no-repeat !important; background-position: center !important; background-size: 100% 100% !important;
        -webkit-filter: invert(1) !important; filter: invert(1) !important;
    }
    /* And for the checked state, draw the smooth inner circle and double-invert so the hue stays correct */
    /* Mirror the checked visuals under inverted (light-mode) by applying the same layered backgrounds and double-inverting so hues remain correct. */
    /* In inverted mode: if the user CHECKED the correct, show white center + ring, and double-invert to preserve hues */
    body.light-mode-active .qcard .choice.correct input[type="radio"]:checked{
        border-color: var(--ok) !important;
        background-image:
            radial-gradient(circle at center, #ffffff 0 46%, rgba(255,255,255,0) 48%),
            radial-gradient(circle at center, var(--ok) 60%, var(--ok) 78%, rgba(0,0,0,0) 80%) !important;
        background-repeat: no-repeat !important; background-position: center !important; background-size: 100% 100% !important;
        -webkit-filter: invert(1) !important; filter: invert(1) !important;
    }
    /* In inverted mode: revealed correct that is NOT selected -> green ring with transparent center; double-invert ring to keep it green */
    body.light-mode-active .qcard .choice.correct input[type="radio"]:not(:checked){
        border-color: var(--ok) !important;
        background: radial-gradient(circle at center,
                     rgba(0,0,0,0) 0%, rgba(0,0,0,0) 56%,
                     var(--ok) 60%, var(--ok) 78%,
                     rgba(0,0,0,0) 82%) !important;
        background-color: transparent !important; background-repeat: no-repeat !important; background-position: center !important; background-size: 100% 100% !important;
        -webkit-filter: invert(1) !important; filter: invert(1) !important;
    }
    body.light-mode-active .qcard .choice.wrong input[type="radio"]:checked{
        border-color: var(--bad) !important;
        background-image:
            radial-gradient(circle at center, #ffffff 0 46%, rgba(255,255,255,0) 48%),
            radial-gradient(circle at center, var(--bad) 60%, var(--bad) 78%, rgba(0,0,0,0) 80%) !important;
        background-repeat: no-repeat !important; background-position: center !important; background-size: 100% 100% !important;
        -webkit-filter: invert(1) !important; filter: invert(1) !important;
    }
    </style>


        <!-- Format Info Modal -->
        <div id="formatInfoModal" class="modal hidden" role="dialog" aria-modal="true" aria-label="Format Information">
            <div class="modal-backdrop"></div>
            <div class="modal-panel format-info-panel">
                <div class="modal-header"><h3>Format Information</h3><button id="formatInfoClose" class="btn">Close</button></div>
                <div class="modal-body">
                    <div class="hint guide-text guide-text-format">
                        <p class="guide-first"><strong>Standard MCQ:</strong><br>
                        <span class="tag">Q1. Question text...</span><br>
                        Options start with <span class="tag">-</span> (e.g., <span class="tag">- Option A</span>).<br>
                        Add an <strong>ANSWER KEY</strong> at the end:<br>
                        <span class="tag">1. B</span><br>
                        <span class="tag">2. C</span></p>

                        <p><strong>True/False:</strong><br>
                        Add <span class="tag">[TF]</span> to the question text.<br>
                        Key: <span class="tag">2. True</span> or <span class="tag">2. False</span>.</p>

                        <p><strong>Fill-in-the-Blank:</strong><br>
                        Add <span class="tag">[FIB]</span> to the question text.<br>
                        Key: <span class="tag">3. Answer</span> (multiple allowed: <span class="tag">3. answer | alt answer</span>).</p>

                        <p><strong>Matching:</strong><br>
                        Add <span class="tag">[MATCH]</span> to the question text.<br>
                        Use lines like <span class="tag">- Left Item -> Right Item</span>.<br>
                        Optional extras: <span class="tag">- Extras: distractor1 | distractor2</span>.</p>

                        <p class="guide-last"><em>Advanced: JSON question banks are also supported.</em></p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Quick Start Modal (paired with Format Information button) -->
        <div id="quickStartModal" class="modal hidden" role="dialog" aria-modal="true" aria-label="Quick Start">
            <div class="modal-backdrop"></div>
            <div class="modal-panel quick-start-panel">
                <div class="modal-header"><h3>Quick Start — Full Guide</h3><button id="quickStartClose" class="btn">Close</button></div>
                <div class="modal-body">
                    <div class="hint guide-text guide-text-quickstart">
                        <p class="guide-first">
                            This app is a <strong>single-file, fully local quiz engine</strong>. Your pasted document is parsed into a deck,
                            then you can quiz, export, save, and back up your data.
                        </p>

                        <h4 class="mt-10 guide-h">1) The core workflow (fast path)</h4>
                        <ol>
                            <li><strong>Paste</strong> MCQs (or load a <span class="tag">.txt</span> file).</li>
                            <li>Click <strong>Parse & Preview</strong>.</li>
                            <li>Scan the <strong>Preview</strong> count and the <strong>Parser Check</strong> panel (fix issues if needed).</li>
                            <li>Click <strong>Start Quiz</strong>.</li>
                        </ol>

                        <h4 class="mt-10 guide-h">2) Input formats (what the parser expects)</h4>
                        <ul>
                            <li><strong>MCQ:</strong> <span class="tag">Q1.</span> then options as <span class="tag">-</span> lines, then an <strong>ANSWER KEY</strong> at the end.</li>
                            <li><strong>True/False:</strong> add <span class="tag">[TF]</span> to the question; key with <span class="tag">True</span>/<span class="tag">False</span>.</li>
                            <li><strong>Fill blank:</strong> add <span class="tag">[FIB]</span> and use <span class="tag">____</span> in the prompt; key with one or more answers.</li>
                            <li><strong>Matching:</strong> add <span class="tag">[MATCH]</span> and use <span class="tag">Left -> Right</span> pairs.</li>
                            <li><strong>Advanced JSON:</strong> you can paste a JSON bank (array or <span class="tag">{ items: [...] }</span>).</li>
                        </ul>

                        <h4 class="mt-10 guide-h">3) Parser Check (lint) — what it means</h4>
                        <ul>
                            <li><strong>Errors</strong> usually mean the deck may behave incorrectly (e.g., invalid correct answer index, missing options).</li>
                            <li><strong>Warnings</strong> are common for messy numbering or missing blanks.</li>
                            <li><strong>Renumber</strong> makes question numbers 1..N for the current parsed deck.</li>
                            <li><strong>Remove dupes</strong> drops repeated question numbers (keeps the first occurrence).</li>
                        </ul>

                        <h4 class="mt-10 guide-h">4) Quiz settings (Options)</h4>
                        <ul>
                            <li><strong>Shuffle questions</strong>: changes order each run.</li>
                            <li><strong>Shuffle answers</strong>: shuffles choices inside each question.</li>
                            <li><strong>Instant feedback</strong>: shows correct/wrong immediately after selection.</li>
                        </ul>

                        <h4 class="mt-10 guide-h">5) Saving & reusing sets (Saved Sets)</h4>
                        <ul>
                            <li>Use <strong>Save Set</strong> to store the current pasted document for reuse later.</li>
                            <li>Saved items are stored <strong>locally in your browser</strong> (no server required).</li>
                        </ul>

                        <h4 class="mt-10 guide-h">6) Exports</h4>
                        <ul>
                            <li><strong>Export PDF</strong>: prints the Preview deck (optional highlight correct answers).</li>
                            <li><strong>Export Anki TSV</strong>: downloads a TSV with <strong>Front</strong> and <strong>Back</strong> columns (Anki import-ready).</li>
                            <li><strong>Flashcards & SRS</strong>: a separate practice mode for spaced repetition (use Export CSV / Export Anki TSV as needed).</li>
                        </ul>

                        <h4 class="mt-10 guide-h">7) AI features (Gemini)</h4>
                        <ul>
                            <li>AI features use the <strong>global Gemini API key</strong> at the top of the page.</li>
                            <li><strong>Reformat & Assign Answers (AI)</strong>: fixes formatting and builds an answer key when missing.</li>
                            <li><strong>Generate Like-Questions (AI)</strong>: rewrites your deck into similar, format-identical items.</li>
                            <li><strong>Validate Answers (AI)</strong>: checks your answer key vs options and reports mismatches.</li>
                            <li>Tip: if your deck won’t parse cleanly, run the AI reformat first, then Parse & Preview.</li>
                        </ul>

                        <h4 class="mt-10 guide-h">8) Backup / Restore / Share (local device state)</h4>
                        <ul>
                            <li><strong>Backup</strong> exports your browser state to a JSON file (Saved sets, saved textbooks, settings).</li>
                            <li><strong>Restore</strong> can <strong>Merge</strong> (keep existing) or <strong>Overwrite</strong> (replace local state).</li>
                            <li><strong>Include API keys</strong> is OFF by default for safety (recommended).</li>
                            <li><strong>Share current doc</strong> exports only the current pasted document + quiz options (no keys, no libraries).</li>
                        </ul>

                        <h4 class="mt-10 guide-h">9) Troubleshooting checklist</h4>
                        <ul>
                            <li>If the quiz is empty: verify Preview shows items parsed.</li>
                            <li>If answers look wrong: verify your ANSWER KEY numbering matches the questions.</li>
                            <li>If AI buttons are disabled: enable the global key toggle and ensure the key is valid.</li>
                            <li>If a device/browser change is coming: export a backup first.</li>
                        </ul>

                        <p class="mt-10 guide-last">
                            Want the shortest possible path? Use: <strong>Paste → Parse & Preview → Fix Parser Check (if needed) → Start Quiz</strong>.
                        </p>
                    </div>
                </div>
            </div>
        </div>
        <script>
            (function(){
                const btn = document.getElementById('formatInfoBtn');
                const modal = document.getElementById('formatInfoModal');
                const close = document.getElementById('formatInfoClose');
                const backdrop = modal ? modal.querySelector('.modal-backdrop') : null;
                
                function show(){ if(modal) modal.classList.remove('hidden'); }
                function hide(){ if(modal) modal.classList.add('hidden'); }
                
                if(btn) btn.addEventListener('click', (e)=>{ e.preventDefault(); show(); });
                if(close) close.addEventListener('click', (e)=>{ e.preventDefault(); hide(); });
                if(backdrop) backdrop.addEventListener('click', hide);
                // Close on Escape
                document.addEventListener('keydown', (e)=>{
                    if(e.key === 'Escape' && modal && !modal.classList.contains('hidden')) hide();
                });
            })();
        </script>

        <!-- Daily-build modal (shown while building questions) -->
        <div id="dailyBuildModal" class="modal hidden" role="dialog" aria-modal="true" aria-label="Building questions">
            <div class="modal-backdrop"></div>
            <div class="modal-panel daily-build-panel">
                    <div class="modal-header"><h3>Building questions…</h3><button id="dailyBuildClose" class="btn">Close</button></div>
                <div class="modal-body">
                        <div id="dailyBuildTitle" class="daily-title daily-build-title">Today's Random Quiz is about&nbsp;<span id="dailyBuildTopic" class="rainbow">choosing...</span>!</div>
                    <div id="dailyBuildSpinner" class="daily-build-spinner">
                        <span class="spinner" aria-hidden="true"></span>
                        <div id="dailyBuildStatus">Preparing…</div>
                    </div>
                    <div class="hint mt-6">This dialog displays progress while the daily quiz is generated. Messages are also logged to the Generate MCQ debug output.</div>
                </div>
            </div>
        </div>
    <style>
    /* Animated full-width rainbow gradient for topic line */
     /* Make the title large and responsive: all words on the line use the same size.
         The title spans the full modal width and centers its content. */
     /* Use block + centered text so the sentence and topic are rendered inline like normal text.
         Increase line-height slightly to avoid glyph clipping while keeping no extra vertical space. */
    .daily-title{ font-size: clamp(22px, 5vw, 48px); color: var(--ink); width: 100%; display: block; text-align: center; margin: 0; overflow: visible; font-weight:700; line-height:1.35; padding:6px 0 8px 0; }
    /* Create a moving gradient background that spans the full width of the title area.
       The text uses background-clip:text with transparent color to show the gradient fill.
       We apply the gradient to a child span (.rainbow) but stretch it so the animation moves
       across the entire title area regardless of the text length. */
    .daily-title .rainbow{
        /* behave exactly like inline text so baseline/descenders match surrounding words */
        display: inline;
        color: transparent;
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        /* Use a wide repeating gradient and animate its offset continuously. */
        /* Tileable gradient: start and end color are the same so repeats seamlessly.
           Colors chosen as three anchor regions (warm -> gold -> cool) with smooth stops.
           background-size is set to 300% and we animate exactly by that amount to avoid seams. */
        background-image: linear-gradient(90deg,
            rgb(255,99,71) 0%,    /* warm red (A) */
            rgb(255,165,64) 30%,  /* orange */
            rgb(255,205,86) 45%,  /* gold (A->G midpoint) */
            rgb(144,210,255) 70%, /* light blue (G->B midpoint) */
            rgb(91,170,255) 85%,  /* sky blue */
            rgb(255,99,71) 100%   /* repeat warm red (A) to tile */
        );
        /* Background size equals the animation travel; animate by -300% to loop seamlessly */
        background-size: 300% 100%;
        background-repeat: repeat-x;
        /* Slower, smoother continuous left-to-right animation for gentle fades */
        animation: rainbowMove 16s linear infinite;
        will-change: background-position, transform;
        /* Inherit size and line-height from the title so all text on the line is the same size and aligned */
        font-size: inherit;
        font-weight: 800;
        line-height: inherit;
        vertical-align: baseline;
        padding: 0 4px;
        /* keep overflow visible so descenders are not clipped */
        overflow: visible;
        white-space: nowrap;
        -webkit-font-smoothing: antialiased;
        backface-visibility: hidden;
        transform: translateZ(0);
    }
    /* Inverted color scheme for Random Quiz (colors reversed) */
    .daily-title .rainbow.inverse{
        display: inline;
        color: transparent;
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        /* Inverted rainbow palette and animation (mirror of .rainbow) */
        background-image: linear-gradient(90deg,
            rgb(144,210,255) 0%, /* light blue start */
            rgb(91,170,255) 20%,  /* sky */
            rgb(255,205,86) 45%,  /* gold */
            rgb(255,165,64) 70%,  /* orange */
            rgb(255,99,71) 90%,   /* warm red */
            rgb(144,210,255) 100% /* repeat light blue */
        );
        background-size: 300% 100%;
        background-repeat: repeat-x;
        animation: rainbowMoveReverse 16s linear infinite;
        will-change: background-position, transform;
        font-size: inherit;
        font-weight: 800;
        line-height: inherit;
        vertical-align: baseline;
        padding: 0 4px;
        overflow: visible;
        white-space: nowrap;
        -webkit-font-smoothing: antialiased;
        backface-visibility: hidden;
        transform: translateZ(0);
    }
    /* Ensure links inside the daily/random quiz title are not underlined (keep styling narrow and scoped) */
    .daily-title a { text-decoration: none; }
    .daily-title a:hover { text-decoration: none; }
    /* ASCII face idle animation in AI explanation panel */
    .ascii-face{ display:block; text-align:center; margin-top:12px }
    .ascii-face .face{ display:inline-block; font-family: inherit; font-size:18px; line-height:1; transform-origin:center; animation: faceIdle 3.6s ease-in-out infinite; }
    .ascii-face .mouth{ display:inline-block; min-width:1.1em; display:inline-block; animation: mouthIdle 3.6s ease-in-out infinite; }
    @keyframes faceIdle{ 0%{ transform: translateY(0) } 50%{ transform: translateY(-3px) } 100%{ transform: translateY(0) } }
    @keyframes mouthIdle{ 0%,100%{ transform: scaleX(1) } 45%{ transform: scaleX(1.02) } 50%{ transform: scaleX(0.56) } 55%{ transform: scaleX(1.02) } }
    /* Eye movement controlled by JS: use CSS variables so JS can set translations while blink uses scaleY
       This gives smooth transitions and lets us keep blink + translate composed together. */
    .ascii-face .eye{
        display:inline-flex; align-items:center; justify-content:center; width:0.9em; text-align:center;
        --ex: 0px; --ey: 0px;
        transform-origin:center;
        transition: transform 900ms cubic-bezier(.2,.8,.2,1);
        transform: translate(var(--ex), var(--ey)) scaleY(1);
    }
    /* Blink: compress vertically while preserving current translate values */
    .ascii-face .eye.blink{ transform: translate(var(--ex), var(--ey)) scaleY(0.12); transition: transform 120ms ease-in-out; }
    /* Lashes — two quotation marks centered right above each eye */
    .ascii-face .eye{ position: relative; }
    .ascii-face .eye .lash{
        position:absolute; top:0; left:50%; transform: translate(-50%, -0.36em);
        font-size:.7em; line-height:1; opacity:0; pointer-events:none; letter-spacing:-0.02em;
    }
    .ascii-face .face.lashed .eye .lash{ opacity:1 }
    /* Flutter when toggled — subtle brightness/spacing shimmer */
    @keyframes lashFlutter{ 0%{ filter: brightness(1); letter-spacing: 0 } 50%{ filter: brightness(1.12); letter-spacing: 0.02em } 100%{ filter: brightness(1); letter-spacing: 0 } }
    .ascii-face .face.lash-toggle .lash{ animation: lashFlutter .28s ease }
    /* Compose with blink: only soften visibility during blink when lashes are enabled */
    .ascii-face .face.lashed .eye.blink .lash{ opacity:.6 }
    /* When AI output is active, JS will pause updates; keep this CSS selector as a safeguard */
    #resultsAiOutput.ai-active .eye{ transition: none !important; }
    /* Respect user preference for reduced motion */
    @media (prefers-reduced-motion: reduce){
        .ascii-face .face, .ascii-face .mouth, .ascii-face .eye { transition: none !important; transform: none !important; }
    }
    
    /* Topic link styling: remove underline but keep rainbow text inside; show a colored dot per type */
    a.topic-link{ text-decoration: none; color: inherit; display: inline-flex; align-items: center; gap:8px }
    a.topic-link:focus{ outline: 2px solid rgba(96,165,250,.18); outline-offset:2px; border-radius:6px }
    a.topic-link .rainbow{ padding:0; }
    /* Prepend a small colored dot to indicate inferred topic type */
    a.topic-link::before{ content: ''; display:inline-block; width:10px; height:10px; border-radius:50%; flex:0 0 auto; box-shadow:0 0 6px rgba(0,0,0,0.12); }
    a.topic-link.topic-type-person::before{ background: #FFB86B; box-shadow:0 0 10px rgba(255,184,107,0.35); }
    a.topic-link.topic-type-place::before{ background: #7AD3FF; box-shadow:0 0 10px rgba(122,211,255,0.35); }
    a.topic-link.topic-type-event::before{ background: #FFD36B; box-shadow:0 0 10px rgba(255,211,107,0.28); }
    a.topic-link.topic-type-science::before{ background: #A6FFBA; box-shadow:0 0 10px rgba(166,255,186,0.28); }
    a.topic-link.topic-type-media::before{ background: #D7A3FF; box-shadow:0 0 10px rgba(215,163,255,0.28); }
    a.topic-link.topic-type-organism::before{ background: #9BE57A; box-shadow:0 0 10px rgba(155,229,122,0.28); }
    a.topic-link.topic-type-organization::before{ background: #FFD1D1; box-shadow:0 0 10px rgba(255,209,209,0.28); }
    a.topic-link.topic-type-concept::before{ background: #9FB0FF; box-shadow:0 0 10px rgba(159,176,255,0.28); }
    a.topic-link.topic-type-other::before{ background: #CCCCCC; box-shadow:0 0 8px rgba(204,204,204,0.18); }
    @keyframes rainbowMove {
        0% { background-position: 0% 50%; }
        /* move exactly one background-size length so the pattern tiles without a seam */
        100% { background-position: -300% 50%; }
    }

    /* Compact modal adjustments for the daily build dialog */
    #dailyBuildModal .modal-panel{ padding: 12px 14px; max-width:880px; }
    #dailyBuildModal .modal-body{ padding: 8px 6px 12px 6px; }
    #dailyBuildModal .modal-header h3{ margin: 0 0 6px 0; font-size: 16px; }
    .daily-title{ font-size: clamp(20px, 4.2vw, 36px); line-height: 1.2; padding:4px 0 6px 0; }
    /* Center spinner + status and make them compact */
    #dailyBuildSpinner{ display:flex; align-items:center; justify-content:center; gap:8px; padding:6px 0; }
    #dailyBuildStatus{ text-align:center; font-weight:600; color:var(--muted); }
    /* Center and tighten hint/subtext */
    #dailyBuildModal .hint{ text-align:center; margin-top:8px; font-size:13px; color:var(--muted); }
    /* Reduce close button size visual impact */
    #dailyBuildClose{ padding:6px 10px; font-size:13px }

     /* Animated capsule outline that follows the button's border-radius exactly.
         Technique: two-layer background. The top layer (padding-box) paints the
         button interior; the bottom layer (border-box) paints the gradient which
         is visible only in the transparent border region. This keeps the center
         untouched and creates a perfect pill-shaped outline. */
    /* Make Daily button match other .btn elements (same filled background and border as the News toggle) */
    /* Keep the Daily button visually identical to other .btn.pill elements; avoid overriding
       background, border, or padding so it inherits the exact same look. */
    #dailyQuizBtn{
        position: relative;
        overflow: visible;
        color: var(--ink);
        z-index: 2;
        /* keep the button visually identical to other .btn.pill elements while ensuring
           internal content (dot + label) is properly centered */
        display: inline-flex;
        align-items: center;
    gap: 6px;
        vertical-align: middle;
        /* do not set background/border/padding here so .btn and .btn.pill rules apply exactly */
    }
    /* (removed) animate the button element itself — animation is applied to ::before ring only */
    /* Visible labels are rendered via ::after; no hidden inner label spans remain */
    /* (removed) previously hid the structural label for Random Quiz; label is now rendered via ::after */
    /* Gradient text remains animated for the label */
    #dailyQuizBtn::after{
        content: attr(data-label);
        position: relative;
        display: inline; /* match regular inline text so sizing matches siblings */
        padding: 0; /* don't add extra padding that increases button size */
        margin: 0;
        color: transparent;
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        background-image: linear-gradient(90deg, rgb(255,99,71) 0%, rgb(255,165,64) 30%, rgb(255,205,86) 45%, rgb(144,210,255) 70%, rgb(91,170,255) 85%, rgb(255,99,71) 100%);
        background-size: 300% 100%;
        background-repeat: repeat-x;
    animation: rainbowMove 16s linear infinite;
    font-weight: 800;
        font-size: inherit;
        line-height: inherit;
        z-index: 2;
        pointer-events: none;
        vertical-align: middle;
    }
    /* Random Quiz: use same gradient but animate in the opposite direction for an inverted effect */
    #randomQuizBtn::after{
        content: attr(data-label);
        position: relative;
        display: inline;
        padding: 0; margin: 0;
        color: transparent;
        -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent;
        /* shifted hue palette: purples -> magenta -> warm -> lime -> teal -> repeat */
        background-image: linear-gradient(90deg,
            hsl(260,90%,60%) 0%,   /* purple */
            hsl(320,85%,62%) 20%,  /* magenta */
            hsl(28,90%,60%) 45%,   /* warm orange */
            hsl(95,60%,48%) 70%,   /* lime */
            hsl(175,65%,50%) 90%,  /* teal */
            hsl(260,90%,60%) 100%  /* back to purple */
        );
        background-size: 300% 100%; background-repeat: repeat-x;
        animation: rainbowMoveReverse 14s linear infinite; /* slightly different duration for variety */
        font-weight: 800; font-size: inherit; line-height: inherit; z-index: 2; pointer-events: none; vertical-align: middle;
    }
    @keyframes rainbowMoveReverse { 0% { background-position: 0% 50%; } 100% { background-position: 300% 50%; } }
    /* Ensure the small API key dot keeps its original appearance and is above the outline/text
       and participates in the flex layout so it vertically centers with the label */
    /* Ensure the small API key dot keeps its original appearance and is above the outline/text
       and participates in the flex layout so it vertically centers with the label */
    #dailyQuizBtn .api-key-dot {
        position: relative;
        z-index: 3;
        flex: 0 0 auto;
        align-self: center;
        display: inline-block;
        width: 12px; height: 12px;
    }

    /* Make Random button match the Daily button's internal layout so labels align exactly */
    #randomQuizBtn{
        display: inline-flex;
        align-items: center;
        gap: 6px;
        vertical-align: middle;
    }
    </style>

        <!-- Terms of Use Modal (initial popup) -->
        <div id="tosModal" class="modal hidden" role="dialog" aria-modal="true" aria-label="Terms of Use and Disclaimer">
            <div class="modal-backdrop"></div>
            <div class="modal-panel" id="tosPanel">
                <div class="modal-header">
                    <h3>Terms of Use & Disclaimer — Effective Dec 25, 2025 (v1.1)</h3>
                    <button id="tosClose" class="btn small" aria-label="Close">Close</button>
                </div>
                <div class="modal-body tos-body" id="tosContent">
                    <pre>Terms of Use & Disclaimer
Effective Date: December 25, 2025
Version: 1.1
________________________________________
1. Overview and Acceptance
This website (the “Service”) provides a hosted demonstration of the BUNKR108 open-source multiple-choice question (MCQ) generator (the “Project").
By accessing or using this Service or any downloaded copy of the Project, you agree to these Terms of Use (“Terms"). If you do not agree, you must not use the Service.
The Project is made publicly available for educational and personal use only. This Service is offered as a client-side demo with no user registration, no server-side storage, and no commercial intent.
________________________________________
2. Open-Source License (MIT)
The Project’s source code is licensed under the MIT License, granting you broad rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the software, subject to inclusion of the original license notice and attribution to the authors.
Nothing in these Terms alters or limits your rights under the MIT License. You may view the complete license text at: https://opensource.org/licenses/MIT
________________________________________
3. Nature of the Hosted Demo
The hosted instance found at https://tkwmo.github.io/BUNKR108/BUNKR108.html is a convenience demo of the open-source Project.
All data processing occurs locally in your browser.
No uploaded documents, quiz content, or API keys are transmitted to or stored by the website operator.
Use of the hosted demo is entirely voluntary. For privacy or customization, users are strongly encouraged to download the repository from GitHub and run the Project locally. Github repository URL: https://github.com/TKWMO/BUNKR108
________________________________________
4. Local Processing and API Keys
The Service runs fully in the browser using local storage (IndexedDB/localStorage).
If you choose to enable AI-powered features, you may enter an external API key (e.g., Gemini). This key is stored only in your browser and never sent to the site operator.
There are no server-side safeguards for key security. You assume all responsibility for protecting, rotating, and revoking your own API keys.
If this is a concern, use the self-hosted version of the Project.
________________________________________
5. User Responsibility and Self-Hosting Option
You are free—and encouraged—to download and adapt the Project for your own use, subject to the MIT License.
You are solely responsible for:
• How you configure and operate the code;
• Any content you input or generate; and
• Compliance with all applicable laws in your jurisdiction.
By using, modifying, or redistributing the Project, you acknowledge that you act independently and assume full responsibility for all associated outcomes.
________________________________________
6. Third-Party APIs and Services
Certain features connect directly from your browser to third-party endpoints, including but not limited to:
• Gemini (Google Generative AI) – remote text generation and parsing (the app imports the Gemini SDK via esm.run which then connects to Google’s Generative Language endpoints when you invoke AI features);
• Library CDNs and package hosts (esm.run, jsDelivr, unpkg, cdnjs) used to load third-party JavaScript libraries such as pdf.js/pdf.worker, JSZip, mammoth (DOCX), tesseract.js (OCR), pako, and related tooling;
• Content proxies and CORS intermediaries (api.allorigins.win, cors.isomorphic-git.org, r.jina.ai) used in a small number of fetch operations as fallbacks or to work around CORS restrictions;
• Public content feeds and audio streams accessed by example features (for instance RSS/news feeds such as feeds.npr.org and public audio stream endpoints such as stream.srg-ssr.ch, ice5.somafm.com, strm112.1.fm, and similar public hosts).

These services are independent of this Project and operate under their own terms and privacy policies. When you invoke an AI feature or request any content that requires an external endpoint, your browser connects directly to those third-party services. The Project does not forward, persist, or otherwise intercept your transmitted data beyond what the third-party service receives in a direct browser request.
________________________________________
7. Acceptable Use and Prohibited Conduct
You agree not to use the Service or Project for:
• Any illegal, harmful, or fraudulent purpose;
• Uploading or generating content that violates privacy, intellectual property, or export laws;
• Impersonation of real persons, officials, or entities;
• Harassment, stalking, or targeted hate speech;
• Political or election manipulation without disclosure;
• Processing regulated data (e.g., PHI under HIPAA, children’s data under COPPA, financial records);
• Creating deceptive synthetic or “deepfake” media;
• Training or redistributing AI model outputs that violate copyright or data-use agreements.
Violation of these rules may result in access being blocked from the hosted demo.
________________________________________
8. Data Privacy and Security Notice
This Service does not:
• Require accounts;
• Collect analytics or telemetry;
• Store user-generated content on a remote server;
• Share or sell any user information.
All user data (documents, API keys, question sets) is confined to your local browser environment and can be deleted at any time via your browser settings.
Because there is no server-side persistence, the operator is not a data controller under GDPR or similar regulations.
________________________________________
9. Intellectual Property and Attribution
• You retain ownership of all content you upload and any questions you generate.
• The Project’s source code, name, and visual design are protected by copyright and MIT license attribution.
• You may modify and distribute the Project, provided that you preserve the original license notice and attribution in visible form.
• You may not present derivative versions as the official [Project Name] release or imply endorsement by its authors.
________________________________________
10. No Warranty / Educational Disclaimer
The Project and all related materials are provided “AS IS” without warranty of any kind, express or implied, including but not limited to:
• Accuracy, completeness, or reliability of generated questions;
• Suitability for educational, professional, or assessment use;
• Error-free or uninterrupted operation.
All outputs generated through AI features should be independently verified before use in any instructional or evaluative setting.
________________________________________
11. Limitation of Liability
To the maximum extent permitted by applicable law:
• The developers, contributors, and maintainers of this Project shall not be liable for any direct, indirect, incidental, consequential, or special damages arising from or in connection with your use or inability to use the Service or Project.
• This includes, without limitation, loss of data, misuse of API keys, or inaccuracies in generated content.
Your sole remedy for dissatisfaction with the Service is to stop using it.
________________________________________
12. Indemnification
You agree to defend, indemnify, and hold harmless the developers, contributors, and affiliates of this Project from and against any claims, damages, liabilities, or expenses arising out of:
• Your use, configuration, or distribution of the Project;
• Any content or data you submit; or
• Any breach of these Terms or applicable law.
________________________________________
13. Termination and Availability
The maintainers may modify, suspend, or discontinue the hosted demo at any time without notice.
This will not affect your right to continue using the open-source Project independently under the MIT License.
You may stop using the Service or delete all locally stored data at any time.
________________________________________
14. Modifications to Terms or Project
These Terms may be updated periodically.
Changes take effect when posted to this site or repository.
Your continued use after updates constitutes acceptance of the new Terms.
The Project’s source code and dependencies may evolve, and functionality may change without prior notice.
________________________________________
15. Governing Law and Jurisdiction
These Terms are governed by the laws of the State of Texas, United States, without regard to conflict-of-law principles.
Any disputes arising under or in connection with these Terms shall be resolved exclusively in the courts located in Harris County, Texas, USA.
_____________________________
17. Effective Date and Version
Effective Date: December 25, 2025
Version: 1.1
</pre>
                </div>
                <div class="flex justify-end gap-8 mt-12">
                    <button id="tosDecline" class="btn">Decline</button>
                    <button id="tosAccept" class="btn primary">Accept</button>
                </div>
            </div>
        </div>
        <script>
        (function(){
            const KEY = 'tos.accepted.v1.1';
            const tosModal = document.getElementById('tosModal');
            const tosPanel = document.getElementById('tosPanel');
            const tosAccept = document.getElementById('tosAccept');
            const tosDecline = document.getElementById('tosDecline');
            const tosClose = document.getElementById('tosClose');
            const viewTosBtn = document.getElementById('viewTosBtn');
            // support either the compact widget (#tosState) or the boxed module (#tosStateBox)
            let tosState = document.getElementById('tosState');
            let tosStateBox = document.getElementById('tosStateBox');
            const tosStatus = document.getElementById('tosStatus');

            function setWidgetState(accepted){
                try{
                    if(!tosState) tosState = document.getElementById('tosState');
                    if(!tosStateBox) tosStateBox = document.getElementById('tosStateBox');
                    if(tosState){ tosState.textContent = accepted ? 'Accepted' : 'Not accepted'; tosState.style.color = accepted ? '#4dd17a' : ''; }
                    if(tosStateBox){ tosStateBox.textContent = accepted ? 'Accepted' : 'Not accepted'; tosStateBox.style.color = accepted ? '#4dd17a' : ''; }
                }catch{}
            }

            // UI lock/unlock: add/remove a class on the root to blur and block interactions
            function lockUI(){ try{ 
                    document.documentElement.classList.add('tos-locked'); 
                    const ov = document.getElementById('tosOverlay'); if(ov) ov.classList.remove('hidden');
                    // Disable keyboard focus/tabbing for all interactive elements outside the TOS overlay and modal
                    try{
                        const tosOverlay = document.getElementById('tosOverlay');
                        const tosModal = document.getElementById('tosModal');
                        const all = Array.from(document.querySelectorAll('a, button, input, select, textarea, [tabindex]'));
                        all.forEach(el=>{
                            try{
                                if(!el) return;
                                // Ignore elements inside the overlay or the modal
                                if((tosOverlay && tosOverlay.contains(el)) || (tosModal && tosModal.contains(el))) return;
                                // Store previous tabindex if present
                                if(el.hasAttribute('tabindex')) el.dataset.prevTabindex = el.getAttribute('tabindex');
                                else el.dataset.prevTabindex = '__none__';
                                // mark as disabled for unlock restoration
                                el.dataset._tosDisabled = '1';
                                // Remove from tab order
                                try{ el.setAttribute('tabindex', '-1'); }catch(e){}
                                // mark as aria-disabled for screen readers
                                try{ el.setAttribute('aria-disabled', 'true'); }catch(e){}
                            }catch(e){}
                        });
                        // Save currently focused element id to restore later
                        try{ const ae = document.activeElement; if(ae && ae.id) document.documentElement.dataset._prevActive = ae.id; }catch(e){}
                        // Move focus to the unlock button for accessibility
                        try{ document.getElementById('tosUnlockBtn')?.focus(); }catch(e){}
                    }catch(e){}
                }catch{} }
            function unlockUI(){ try{ 
                    document.documentElement.classList.remove('tos-locked'); 
                    const ov = document.getElementById('tosOverlay'); if(ov) ov.classList.add('hidden');
                    // Restore tabindex / aria-disabled for elements we modified
                    try{
                        const modified = Array.from(document.querySelectorAll('[data-_tosDisabled]'));
                        modified.forEach(el=>{
                            try{
                                if(!el) return;
                                const prev = el.dataset.prevTabindex;
                                if(typeof prev !== 'undefined'){
                                    if(prev === '__none__') el.removeAttribute('tabindex'); else el.setAttribute('tabindex', prev);
                                    delete el.dataset.prevTabindex;
                                }
                                delete el.dataset._tosDisabled;
                                try{ el.removeAttribute('aria-disabled'); }catch(e){}
                            }catch(e){}
                        });
                        // Restore previous focus if possible
                        try{ const prevId = document.documentElement.dataset._prevActive; if(prevId){ const el = document.getElementById(prevId); if(el) el.focus(); delete document.documentElement.dataset._prevActive; } }catch(e){}
                    }catch(e){}
                }catch{} }

            function saveAccepted(){ try{ localStorage.setItem(KEY, '1'); }catch{} setWidgetState(true); unlockUI(); }
            function clearAccepted(){ try{ localStorage.removeItem(KEY); }catch{} setWidgetState(false); lockUI(); }

            function openModal(){
                try{
                    // Hide the centered unlock overlay so the modal's own backdrop appears above the blurred plane
                    const ov = document.getElementById('tosOverlay'); if(ov){ ov.classList.add('hidden'); ov.setAttribute('aria-hidden','true'); }
                }catch(e){}
                tosModal.classList.remove('hidden'); tosModal.setAttribute('aria-hidden','false'); document.documentElement.classList.add('modal-open'); document.body.classList.add('modal-open');
                // focus the close button for accessibility
                try{ document.getElementById('tosClose')?.focus(); }catch(e){}
            }
            function closeModal(){
                tosModal.classList.add('hidden'); tosModal.setAttribute('aria-hidden','true'); document.documentElement.classList.remove('modal-open'); document.body.classList.remove('modal-open');
                try{
                    // If the TOS has not been accepted, restore the locked overlay so the page remains inaccessible
                    const ov = document.getElementById('tosOverlay'); const has = !!localStorage.getItem(KEY);
                    if(ov){ if(!has){ ov.classList.remove('hidden'); ov.setAttribute('aria-hidden','false'); } else { ov.classList.add('hidden'); ov.setAttribute('aria-hidden','true'); } }
                }catch(e){}
            }

            // Wait until DOM is ready so boxed elements exist, then wire buttons and initialize
            function ready(cb){ if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', cb, { once:true }); else cb(); }
            ready(()=>{
                // Re-query DOM elements that may appear after this script block
                try{
                    // modal buttons
                    const _tosAccept = document.getElementById('tosAccept');
                    const _tosDecline = document.getElementById('tosDecline');
                    const _tosClose = document.getElementById('tosClose');
                    const _viewTosBtn = document.getElementById('viewTosBtn');
                    const _tosBoxView = document.getElementById('tosBoxView');
                    // Wire handlers
                    if(_tosAccept) _tosAccept.addEventListener('click', ()=>{ saveAccepted(); closeModal(); });
                    if(_tosDecline) _tosDecline.addEventListener('click', ()=>{ clearAccepted(); closeModal(); });
                    if(_tosClose) _tosClose.addEventListener('click', ()=>{ closeModal(); });
                    if(_viewTosBtn) _viewTosBtn.addEventListener('click', ()=>{ openModal(); });
                    if(_tosBoxView) _tosBoxView.addEventListener('click', ()=>{ openModal(); });
                    const _tosUnlockBtn = document.getElementById('tosUnlockBtn');
                    if(_tosUnlockBtn) _tosUnlockBtn.addEventListener('click', ()=>{ openModal(); });

                    // Initialize widget/box state now that elements exist
                    try{ const v = localStorage.getItem(KEY); const accepted = !!v; setWidgetState(accepted); if(!accepted){ lockUI(); setTimeout(openModal, 250); } else { unlockUI(); } }catch{ setWidgetState(false); lockUI(); setTimeout(openModal, 250); }
                }catch(e){ console.warn('TOS init failed', e); }
            });

            // Update header count with aggregate size (KB)
            try{ savedCount.textContent = `${arr.length} (${(totalBytes/1024).toFixed(1)} KB)`; }catch(e){}

        })();
        </script>

        <div id="quiz" class="card pad hidden"></div>

        <!-- See All Modal: lists parsed questions for review -->
        <div id="seeAllModal" class="modal hidden" role="dialog" aria-modal="true" aria-label="All parsed questions">
            <div class="modal-backdrop"></div>
            <div class="modal-panel">
                <div class="modal-header">
                    <h3>All Questions</h3>
                    <button id="seeAllClose" class="btn small" aria-label="Close">Close</button>
                </div>
                <div id="seeAllContent" class="modal-body"></div>
            </div>
        </div>

    <!-- Flashcards panel moved earlier in the document -->

        <!-- === Post-Quiz Results & AI Feedback (mirrors validate/like style) === -->
        <section id="results-card" class="card pad hidden">
            <!-- Attempts selector at the top, centered -->
            <div class="flex center gap-12">
                <label for="attemptSelect" class="muted fs-12">Attempts</label>
                <!-- Keep native select for accessibility but visually hide it; mirror with a styled dropdown -->
                <select id="attemptSelect" class="rp-select attempt-select visually-hidden" title="Select attempt to view missed questions" aria-hidden="true" tabindex="-1"></select>
                <div id="attemptDropdown" class="attempt-dd" role="combobox" aria-haspopup="listbox" aria-expanded="false" aria-label="Attempts">
                    <button id="attemptTrigger" class="attempt-trigger" type="button">
                        <span id="attemptTriggerText">Select attempt…</span>
                        <span class="chev">▾</span>
                    </button>
                    <div id="attemptMenu" class="attempt-menu" role="listbox" aria-label="Attempts"></div>
                </div>
                <button id="copyResultsBtn" class="btn small" type="button" title="Copy results to clipboard">Copy Results</button>
            </div>
            <div class="hint mt-8 text-center">
                Summary of your quiz performance. Use the analyzer below for AI feedback on missed questions and trends.
            </div>
            <div id="resultsSummary" class="mt-8"></div>
            <div id="attemptMissedList" class="mt-12"></div>
            <hr class="ai-divider" />
            <!-- Analysis section separated under results -->
            <div class="flex col center gap-8 mt-8">
                <div class="key-badge missing" id="resultsKeyBadge" title="Shows whether a Gemini API key is present"><span class="dot"></span><span class="hint">No key set</span></div>
                <div class="flex center gap-12">
                    <div class="flex-spacer" aria-hidden="true"></div>
                    <button id="analyzeMissedBtn" type="button" class="btn primary btn-wide" disabled>Analyze Missed with AI</button>
                </div>
            </div>
            <div id="resultsAiStatus" class="hint mt-8 text-center"></div>
            <div id="resultsAiOutput" class="hint mt-12" role="status" aria-live="polite"></div>
        </section>

    <!-- Saved Quiz Results Module -->
    <section id="savedResultsPanel" class="card pad saved-results-panel">
        <!-- Title moved into the saved-card header for contained styling -->
        <div id="savedQuizzes" class="saved-card saved-results-card" role="region" aria-label="Saved Quiz Results">
            <div class="saved-header">
                <div class="flex center gap-8 saved-header-left">
                    <h3 class="mt-0 m-0">Saved Quiz Results</h3>
                    <div class="saved-badge-wrap"><span id="savedQuizCount">0</span></div>
                    <div id="savedQuizTotal" class="muted fs-12">Total: 0.0 KB</div>
                </div>
                <div class="flex gap-8">
                    <button id="compileMissedBtn" class="btn small" title="Compile all first-attempt missed questions into a new quiz">Compile Missed</button>
                    <button id="toggleSavedQuizBtn" class="btn small" aria-expanded="false" aria-controls="savedQuizMenu">Show</button>
                    <button id="clearSavedQuizBtn" class="btn small" title="Remove all saved quiz results">Clear</button>
                </div>
            </div>
            <div id="savedQuizMenu" class="saved-menu" role="listbox" aria-label="Saved Quiz Results Menu">
                <div id="savedQuizList" class="saved-list"></div>
            </div>

            <!-- Last Attempted Quiz sub-module within same card -->
            <div class="saved-header last-attempt-block" id="lastAttemptBlock">
                <div class="flex center gap-8 saved-header-left">
                    <h3 class="mt-0 m-0">Last Attempted Quiz</h3>
                    <div id="lastAttemptLabel" class="muted fs-12">None yet</div>
                </div>
                <div class="flex gap-8">
                    <button id="lastAttemptCopyBtn" class="btn small" disabled>Copy</button>
                    <button id="lastAttemptSaveBtn" class="btn small" disabled>Save</button>
                    <button id="lastAttemptOpenBtn" class="btn small" disabled>Return</button>
                </div>
            </div>
        </div>
    </section>

        <!-- === Textbook Library (replaced with index.html app UI + script) === -->
        <section id="textbook-lib" class="card pad">
            <div class="tb-wrap">
                <style>
                    :root{ --bg:#0b1620; --panel:#0f2130; --muted:#9fb0c5; --accent:#4aa3ff; --ok:#4dd17a; --bad:#ff6b6b }
                    .tb-wrap{ max-width:100%; margin-top:0; padding-top:0; overflow:visible }
                    .tb-toc{ width: 100%; }
                    .tb-log{ width: 100%; }
                    /* Layout: compact variant for denser, minimal UI */
                    .flexRow{ display:flex; gap:10px; align-items:flex-start; }
                    /* left column fixed, right column flexes to fill remaining space */
                    .flexRow > .w420 { flex: 0 0 360px; }
                    .flexRow > .flex1 { flex: 1 1 auto; min-width:240px; }
                    /* Tighter, compact cards — use saved-card theme for consistent parent outline */
                    .tb-card{ border-radius:12px; padding:10px; margin:0 0 10px 0; box-shadow: var(--depth); border:1px solid var(--btnBorder); background: linear-gradient(180deg, rgba(16,25,40,.75), rgba(10,16,28,.75)); }
                    .tb-card.small{ padding:8px }
                    .tb-row{ display:flex; gap:8px; align-items:center }
                    .tb-inputNarrow{ width:62px; margin-left:6px; padding:6px 6px; font-size:12px }
                    .tb-pill{ background:rgba(255,255,255,.03); padding:6px 8px; border-radius:8px; font-size:13px }
                    .tb-pill.small{ padding:4px 6px; font-size:12px }
                    .tb-group-sep{ border-top:1px solid rgba(255,255,255,0.04); margin:6px 0 }
                    .tb-node{ padding:4px 6px; border-radius:4px; margin:2px 0 }

                    /* TOC + Log compact sizes */
                    .toc-wrap{ position:relative; width:100%; box-sizing:border-box }
                    /* Make Log and TOC equal fixed height and compact */
                    .tb-toc{ width:100%; box-sizing:border-box; height:120px; overflow:auto; padding:8px; border-radius:6px; background:rgba(0,0,0,.04); font-size:13px }
                    .tb-log{ height:92px; overflow:auto; background:#051018; padding:8px; border-radius:6px; font-family:monospace; font-size:12px }

                    /* saved preview clamp fallback for non-webkit browsers */
                    #savedPreviewWrap{ display:block; max-height:88px; overflow:hidden; line-height:1.2 }

                    /* Center the small headers above each column and remove extra top spacing */
                    .w420 h3.noTopMargin, .flex1 h3.noTopMargin{ text-align: center; margin: 0 0 4px 0; padding-top:0; font-size:16px; font-weight:800 }
                    /* Ensure the card and row don't add extra top padding pushing headers down */
                    .tb-card .flexRow{ margin-top:0 }
                    .flexRow > .w420 h3.noTopMargin, .flexRow > .flex1 h3.noTopMargin{ margin-top:0 }

                    /* Inline meta readout (single row) */
                    .meta-inline{ display:flex; gap:14px; align-items:center; margin-top:4px }
                    .meta-inline .meta-item{ color:var(--muted); font-size:13px }

                    /* Numeric inputs styled as small pills */
                    .num-pill{ width:64px; text-align:center; border-radius:10px; border:1px solid rgba(255,255,255,0.06); background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01)); padding:8px 10px; margin:0 6px; font-size:13px; min-height:36px; box-sizing:border-box; color:var(--ink); }
                    /* Narrow numeric inputs inside TOC controls — use num-pill visual language */
                    .tb-inputNarrow{ width:64px; margin-left:6px; padding:8px 8px; font-size:13px; border-radius:10px; border:1px solid rgba(255,255,255,0.06); background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01)); color:var(--ink); text-align:center; box-shadow: inset 0 1px 0 rgba(255,255,255,0.02) }
                    .tb-inputNarrow:focus{ outline: 2px solid rgba(96,165,250,.16); outline-offset:2px }
                    /* hide number spinners for a cleaner look */
                    input[type=number].tb-inputNarrow::-webkit-outer-spin-button,
                    input[type=number].tb-inputNarrow::-webkit-inner-spin-button{ -webkit-appearance: none; margin: 0 }
                    input[type=number].tb-inputNarrow{ -moz-appearance: textfield; appearance: textfield }
                    .tb-controls-inline{ display:flex; gap:8px; align-items:center }
                    .tb-control-group{ display:flex; align-items:center; gap:6px; padding:6px 8px }

                    /* Saved card should span full width of its parent column */
                    .w420 .card.saved-card, .flex1 .card.saved-card{ width:100%; box-sizing:border-box }
                    /* Ensure saved-card and tb-card share the same visual treatment */
                    .card.saved-card, .tb-card{ background: linear-gradient(180deg, rgba(16,25,40,.75), rgba(10,16,28,.75)); border:1px solid var(--btnBorder); border-radius:12px; box-shadow: var(--depth); }

                    /* Saved sample viewer (monospace, compact) */
                    .saved-sample{ margin-top:6px; background:#051018; padding:6px; border-radius:6px; font-family:monospace; white-space:pre-wrap; max-height:88px; overflow:hidden; color:#cfe9ff; font-size:12px; line-height:1.2 }
                    /* Tighter controls for saved textbook buttons - match .btn.small sizing so they match Saved MCQ buttons */
                    .saved-controls .btn{ padding:6px 8px; font-size:13px; border-radius:10px; font-weight:700; letter-spacing:.2px }
                    /* Map specific clear buttons to the blue clear style */
                    #clearSavedBtn, #tbClearBtn, #sdClearAll { color: #dfeeff; background: rgba(30,110,220,0.08); border: 1px solid rgba(60,120,220,0.25); }
                    .saved-controls .btn.pill{ border-radius:999px }
                    /* Saved select (dropdown) — match paste-section choose-btn / global button palette */
                    .saved-select{ margin-left:6px; margin-right:6px; background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); border: 1px solid var(--btnBorder); color: var(--ink); padding:6px 10px; border-radius:8px; font-weight:700; font-size:13px; min-height:36px; display:inline-flex; align-items:center; position:relative; -webkit-appearance:none; -moz-appearance:none; appearance:none; padding-right:38px; background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24'><path fill='%23cfe9ff' d='M7 10l5 5 5-5z'/></svg>"); background-repeat:no-repeat; background-position: right 10px center; background-size:12px }
                    .saved-select:focus{ outline: 2px solid rgba(96,165,250,.12); outline-offset:2px }
                    /* Style native option list where supported (browsers vary) */
                    .saved-select option{ background: linear-gradient(180deg, rgba(14,20,32,.9), rgba(10,16,24,.95)); color: var(--ink); padding:6px 10px }
                    /* WebKit scrollbar for the native popup in supported browsers */
                    .saved-select::-webkit-scrollbar{ width: 10px; height: 10px }
                    .saved-select::-webkit-scrollbar-thumb{ background: rgba(255,255,255,0.06); border-radius:8px }
                    /* Fallback: if the platform forces native popup, ensure selected look is themed */
                    .saved-select option:checked{ background: linear-gradient(180deg, rgba(7,20,34,.95), rgba(6,10,18,.95)); color: #cfe9ff }
                    .saved-actions{ display:flex; gap:6px }
                    .saved-list{ max-height:220px; overflow:auto; padding:6px; background:rgba(0,0,0,0.03); border-radius:8px }
                    .saved-row{ margin-bottom:4px; padding:4px }

                    /* Hide native file input, use label.tb-pill as button trigger */
                    input[type="file"]#tbFile{ display:none }
                    /* Make Choose PDF label exactly match the paste-section's choose-btn */
                    label.tb-pill[for="tbFile"]{ display:inline-block; padding:6px 10px; border-radius:8px; background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); border: 1px solid var(--btnBorder); color: var(--ink); font-weight:700; cursor:pointer; font-size:13px; line-height:1; box-shadow: inset 0 1px 0 rgba(255,255,255,.06); }
                    @media (max-width: 640px){ label.tb-pill[for="tbFile"]{ min-height:44px; display:flex; align-items:center } }
                    /* Small scan button visual — match Choose/Index buttons */
                    button#btnScan{ padding:6px 10px; font-size:13px; border-radius:8px; background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); border:1px solid var(--btnBorder); color:var(--ink); font-weight:700; box-shadow: inset 0 1px 0 rgba(255,255,255,.06); cursor:pointer }
                    button#btnScan:disabled{ opacity:0.5; cursor:not-allowed }
                    button#btnScan:hover{ transform: translateY(-1px) }

                    /* Floating save FAB inside TOC preview - restyled to match index button (glass-like) */
                    .tb-save-fab{ position:absolute; right:12px; bottom:8px; background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); color: var(--ink); border: 1px solid var(--btnBorder); padding:8px 12px; border-radius:999px; box-shadow: var(--depth); cursor:pointer; font-size:13px; z-index:9999; display:inline-flex; align-items:center; justify-content:center; min-height:36px; transition: transform .12s ease, box-shadow .12s ease }
                    .tb-save-fab[disabled]{ opacity:0.5; cursor:not-allowed }
                    .tb-save-fab:hover{ transform:translateY(-2px); box-shadow: 0 10px 28px rgba(0,0,0,.55) }

                    /* Saved list wrapper and toggle */
                    .saved-list-wrap{ border-radius:6px; padding:8px; background:rgba(0,0,0,0.02); margin-top:8px }
                    /* Saved Content title: centered and match preview header sizing */
                    /* Center the Saved Content title and match preview header sizing */
                    .saved-card .row > h4.noTopMargin.small, .saved-card h4.noTopMargin.small{ display:block; width:100%; text-align:center !important; font-size:16px; font-weight:800; margin:6px 0 10px 0; color:var(--ink) }
                    /* Keep inline title appearance unchanged while editing */
                    .si-title-text[contenteditable="true"]{ outline: none; background: transparent; }
                    .saved-toggle-wrap{ margin-left:auto }
                    /* Custom select control (dark themed) */
                    .custom-select{ background: linear-gradient(180deg, var(--btnTop), var(--btnBottom)); border:1px solid var(--btnBorder); color:var(--ink); padding:8px 12px; border-radius:8px; min-height:36px; display:flex; align-items:center; cursor:pointer }
                    .custom-select::after{ content:''; margin-left:auto; width:12px; height:12px; background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24'><path fill='%23cfe9ff' d='M7 10l5 5 5-5z'/></svg>"); background-repeat:no-repeat; background-position:center }
                    .custom-select.open{ box-shadow: 0 10px 28px rgba(0,0,0,.55); }
                    .custom-select-list{ position:absolute; left:0; top:calc(100% + 8px); width:100%; max-height:260px; overflow:auto; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background: linear-gradient(180deg, rgba(8,12,18,.95), rgba(6,10,14,.95)); box-shadow:0 14px 28px rgba(0,0,0,.6); z-index:99999 }
                    .custom-select-list .opt{ display:block; width:100%; box-sizing:border-box; padding:8px 12px; color:var(--ink); border-bottom:1px solid rgba(255,255,255,0.02); cursor:pointer; white-space:normal; overflow-wrap:anywhere; text-align:left }
                    .custom-select-list .opt *{ box-sizing:border-box; width:100% }
                /* keep the drop area visually minimal: store selected info in data-selected attribute and do not show text */
                #aiFileTbDrop[data-selected]{ color: transparent; text-shadow: none }
                    .custom-select-list .opt:hover, .custom-select-list .opt[aria-selected='true']{ background: linear-gradient(180deg, rgba(14,20,34,.95), rgba(10,16,24,.95)); color:#cfe9ff }
                    /* wrapper for custom select to replace inline styles */
                    .custom-select-wrap{ position:relative }

                    .tb-total-size{ margin-left:12px; align-self:center; color:var(--muted); font-size:0.9rem; }
                    .custom-select-hidden{ position:absolute; left:0; top:0; opacity:0; pointer-events:none; height:0; width:0; overflow:hidden }
                    /* Compact content library tweaks */
                    .tb-card{ padding:12px 12px; border-radius:10px; background: linear-gradient(180deg, rgba(8,12,18,.45), rgba(10,14,20,.45)); border:1px solid rgba(255,255,255,0.03) }
                    /* Blurb styling moved from inline to CSS to satisfy linter */
                    #contentLibBlurb{ text-align:center; color:var(--muted); font-size:13px; margin:6px 0 }
                    /* Remove extra gap when a blurb precedes the card */
                    #contentLibBlurb + .tb-card{ margin-top:0 }
                    .tb-row{ display:flex; gap:8px; align-items:center }
                    .tb-pill{ display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:8px; background: linear-gradient(180deg, rgba(16,25,40,.35), rgba(10,16,28,.35)); border:1px solid rgba(30,40,60,.25); font-size:13px }
                    .tb-controls-inline{ display:flex; gap:8px; align-items:center }
                    .tb-inputNarrow{ width:64px; padding:6px 8px; font-size:13px }
                    .num-pill{ width:56px }
                    .mt8{ margin-top:8px }
                    .meta-inline{ display:flex; gap:12px; align-items:center; font-size:13px }
                    .w420{ width:360px; display:flex; flex-direction:column }
                    .flexRow{ display:flex; gap:12px; align-items:stretch }
                    .flexRow > .flex1, .flexRow > .w420{ display:flex; flex-direction:column }
                    .toc-wrap{ position:relative; display:flex; flex-direction:column; flex:1 }
                    .tb-log{ height:120px; min-height:120px; max-height:120px; overflow:auto; background: linear-gradient(180deg, rgba(10,12,16,.35), rgba(8,10,14,.35)); border-radius:8px; padding:8px }
                    .tb-toc{ height:120px; min-height:120px; max-height:120px; overflow:auto; font-size:13px; padding:8px }

                    /* ensure the inner content region used for TOC preview respects the fixed size */
                    #tocTree{ height:100%; box-sizing:border-box; overflow:auto }
                    .tb-save-fab{ position:absolute; right:8px; bottom:8px; padding:8px 12px; border-radius:10px }
                    .compact-saved .saved-controls{ gap:8px; align-items:center }
                    .compact-saved-pad{ padding:10px }
                    .compact-saved-controls{ gap:8px; align-items:center }
                    .compact-select-wrap{ max-width:680px }
                </style>

                <h2 class="page-title">Content Library</h2>
                <div id="contentLibBlurb">Choose files to extract chapters and text into your Content Library. Scan to preview, then use Save to store items; use the Saved Content controls to show, delete, or clear entries.</div>
                <div class="tb-card">
                    <div class="chooser-row">
                        <div class="chooser-left">
                            <div class="tb-row">
                                <label for="tbFile" class="tb-pill">Choose PDF</label>
                                <input id="tbFile" type="file" accept=".pdf,application/pdf" aria-label="PDF file input" />
                                <button id="btnScan" disabled>Scan TOC</button>
                                <div class="tb-controls-inline">
                                    <div class="tb-pill small tb-control-group">Depth
                                        <input id="depthStart" type="number" min="0" value="0" class="tb-inputNarrow num-pill" title="Minimum outline depth" />
                                        <span class="muted">-</span>
                                        <input id="depthEnd" type="number" min="0" value="0" class="tb-inputNarrow num-pill" title="Maximum outline depth" />
                                    </div>
                                    <div class="tb-pill small tb-control-group">Pages
                                        <input id="pageStart" type="number" min="1" placeholder="start" class="tb-inputNarrow num-pill" />
                                        <span class="muted">-</span>
                                        <input id="pageEnd" type="number" min="1" placeholder="end" class="tb-inputNarrow num-pill" />
                                    </div>
                                </div>
                            </div>
                            <div class="meta mt8 meta-inline">
                                <div class="meta-item">File: <span id="metaName">(none)</span></div>
                                <div class="meta-item">Pages: <span id="metaPages">0</span></div>
                                <div class="meta-item">Estimated: <span id="metaBytes">-</span></div>
                                <!-- Save/Clear buttons moved into the saved-textbook UI block below -->
                            </div>
                        </div>

                        <div class="chooser-divider" aria-hidden="true"></div>

                        <div class="chooser-right">
                            <div class="flexRow">
                                <div class="w420">
                                    <h3 class="noTopMargin">Activity / Progress</h3>
                                    <div id="log" class="tb-log"></div>
                                </div>

                                <div class="flex1">
                                    <h3 class="noTopMargin">Content Preview</h3>
                                    <div class="toc-wrap">
                                        <div id="tocTree" class="tb-toc">(no TOC scanned)</div>
                                        <!-- floating save button inside TOC preview wrapper (not inside tocTree content) -->
                                        <button id="tbSaveBtn" class="tb-save-fab" disabled title="Save scanned content">Save</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- notes removed per request -->
            </div>

            <!-- Saved Textbooks: full-width card placed below feature columns -->
            <div class="card saved-card compact-saved mt8 compact-saved-pad">
                <div class="row">
                    <h4 class="noTopMargin small">Saved Content</h4>
                </div>
                <div class="saved-controls row compact-row mt6 compact-saved-controls">
                    <!-- native select kept hidden for compatibility; custom UI shown below -->
                    <div class="flex1 custom-select-wrap compact-select-wrap">
                        <!-- Hidden native select kept for compatibility with existing JS; visible inline custom dropdown below -->
                        <select id="savedSelect" class="visually-hidden" aria-label="Saved content"></select>
                        <div class="custom-inline-dropdown" id="savedSelectInline" role="combobox" aria-haspopup="listbox" aria-expanded="false" tabindex="0" aria-controls="savedSelectList" aria-label="Select saved content">
                            <span class="inline-selected">(none)</span>
                            <span class="inline-chevron">▾</span>
                        </div>
                        <div class="custom-inline-list hidden" id="savedSelectList" role="listbox" tabindex="-1" aria-labelledby="savedSelectInline"></div>
                    </div>
                    <div class="saved-actions compact-actions">
                        <button id="tbShowBtn" class="btn small" disabled>Show</button>
                        <button id="tbDeleteBtn" class="btn small" disabled>Delete</button>
                        <button id="tbClearBtn" class="btn small" disabled>Clear</button>
                        <div id="tbTotalSize" class="tb-total-size" aria-hidden="true">Total: 0.0 KB</div>
                    </div>
                </div>
                <div class="saved-list-wrap mt6">
                    <div class="mt6 small muted compact-details" id="savedDetails">(select saved content and click Show)</div>
                </div>
            </div>

            <script>
            (function(){
                const $ = id => document.getElementById(id);
                const fileEl = $('tbFile'); const btnScan = $('btnScan');
                const tocTree = $('tocTree'); const logEl = $('log');
                const metaName = $('metaName'); const metaPages = $('metaPages'); const metaBytes = $('metaBytes');
                const depthStartEl = $('depthStart'); const depthEndEl = $('depthEnd'); const pageStart = $('pageStart'); const pageEnd = $('pageEnd');

                let pdfDoc = null; let pdfArrayBuffer = null; let pdfNumPages = 0; let outline = null;
                let flattened = [];
                let pdfjsLoaded = false;
                // per-file TOC cache so repeated scans overwrite previous entries instead of duplicating
                window.tocByFile = window.tocByFile || {};
                window.currentFileKey = window.currentFileKey || null;

                function log(...args){ try{ const s = args.map(a=> typeof a==='string'? a : JSON.stringify(a)).join(' '); const line = new Date().toLocaleTimeString() + ' ' + s; logEl.textContent = line + '\n' + logEl.textContent; }catch(e){ console.log(...args); } }
                function humanBytes(n){ if(!n && n!==0) return '-'; const units=['B','KB','MB','GB']; let u=0; while(n>=1024 && u<units.length-1){ n/=1024; u++; } return n.toFixed(n<10?2:1)+' '+units[u]; }

                async function loadScript(url){ return new Promise((res,rej)=>{ const s=document.createElement('script'); s.src=url; s.onload=res; s.onerror=()=>rej(new Error('load failed '+url)); document.head.appendChild(s); }); }
                async function ensurePdfJs(){ if(window.pdfjsLib && pdfjsLoaded) return true; const ver='2.16.105'; const candidates=[
                    `https://cdn.jsdelivr.net/npm/pdfjs-dist@${ver}/build/pdf.min.js`,
                    `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${ver}/pdf.min.js`,
                    `https://unpkg.com/pdfjs-dist@${ver}/build/pdf.min.js`
                ];
                for(const c of candidates){ try{ await loadScript(c); log('loaded pdfjs', c); window.pdfjsLib = window.pdfjsLib || window['pdfjs-dist/build/pdf']; try{ window.pdfjsLib.GlobalWorkerOptions.workerSrc = c.replace(/pdf.min.js$/, 'pdf.worker.min.js'); }catch{} pdfjsLoaded=true; return true;}catch(e){ log('pdfjs load failed', c); } }
                log('pdfjs could not be loaded from any CDN'); return false; }

                // Remove control/unprintable characters and collapse whitespace in titles
                function sanitizeTitle(s){
                    if(!s && s !== 0) return '';
                    try{
                        // remove C0/C1 control ranges and replacement characters, strip a few filesystem-unsafe chars
                        return String(s)
                            .replace(/[\x00-\x1F\x7F-\x9F\uFFFD]/g, '')
                            .replace(/[\\/:*?"<>|]/g, '')
                            .replace(/\s+/g, ' ')
                            .trim()
                            .slice(0, 180);
                    }catch(e){ return String(s||'').trim(); }
                }

                function flattenOutline(outl){
                    const arr=[];
                    function walk(items, depth){
                        if(!items) return;
                        for(const it of items){
                            const rawTitle = it && it.title ? it.title : 'Untitled';
                            const node = {
                                title: sanitizeTitle(rawTitle),
                                dest: it.dest || it.destref || it.dest || it.title,
                                raw: it,
                                depth: depth
                            };
                            arr.push(node);
                            if(it.items && it.items.length) walk(it.items, depth+1);
                        }
                    }
                    walk(outl, 0);
                    return arr;
                }

                function detectChapterDepth(arr){ if(!arr || !arr.length) return 0; const score = {}; const reNum = /^\s*(?:Chapter\b|Ch\.|\d+[.):]|[IVXLCDM]+[.):]|\d+\s)/i; for(const it of arr){ const d = it.depth||0; if(!score[d]) score[d]=0; if(reNum.test(it.title)) score[d]++; } let bestDepth = 0; let best = -1; for(const k in score){ if(score[k] > best){ best = score[k]; bestDepth = parseInt(k,10); } } if(best <= 0) return 0; return bestDepth; }

                async function resolveDestToPageIndex(doc, dest){ try{ if(!dest) return null; let resolved = null; try{ if(typeof dest === 'string'){ resolved = await doc.getDestination(dest); } else if(Array.isArray(dest)) resolved = dest; else if(dest && dest.getArray) resolved = await dest.getArray(); }catch(e){} if(!resolved){ if(dest && dest.num) resolved = [dest]; } if(!resolved) return null; const ref = resolved[0]; if(!ref) return null; const pageIndex = await doc.getPageIndex(ref); return pageIndex; }catch(e){ log('resolveDestToPageIndex failed', e?.message||e); return null; } }

                async function extractPageText(doc, pnum){ try{ const page = await doc.getPage(pnum); const txt = await page.getTextContent({ normalizeWhitespace:true, disableCombineTextItems:false, includeMarkedContent:true }); const parts = txt.items.map(it=> String(it.str || '') ); const s = parts.join(' ').replace(/\s+/g,' ').trim(); return s; }catch(e){ log('page extract failed', pnum, e?.message||e); return ''; } }

                // Extract a range of pages, optionally performing OCR on rendered page images to capture text inside figures/scans.
                // Returns: { text: string, charCount: number }
                async function extractRangeText(doc, startPage, endPage, opts){
                    opts = Object.assign({ ocr: false, ocrLang: 'eng', ocrScale: 2, ocrIfNoText: true, perPage: false }, opts || {});
                    const results = [];
                    // local helper to ensure tesseract is available when OCR is requested
                    async function ensureTesseractLocal(){
                        if(window.Tesseract && (window.Tesseract.recognize || window.Tesseract.createWorker)) return true;
                        try{
                            await loadScript('https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js');
                            return !!(window.Tesseract && (window.Tesseract.recognize || window.Tesseract.createWorker));
                        }catch(e){ log('tesseract load failed', e?.message||e); return false; }
                    }

                    async function renderPageToBlob(page, scale){
                        try{
                            const viewport = page.getViewport({ scale: scale || 2 });
                            const canvas = document.createElement('canvas');
                            canvas.width = Math.round(viewport.width);
                            canvas.height = Math.round(viewport.height);
                            const ctx = canvas.getContext('2d');
                            const renderTask = page.render({ canvasContext: ctx, viewport });
                            if(renderTask && renderTask.promise) await renderTask.promise; else await new Promise(r=> setTimeout(r,250));
                            return await new Promise(res=> canvas.toBlob(res, 'image/png'));
                        }catch(e){ log('renderPageToBlob failed', e?.message||e); return null; }
                    }

                    // iterate pages in order and combine text + OCR text per page
                    const start = Math.max(1, Number(startPage)||1);
                    const end = Math.min(doc.numPages || endPage, Number(endPage) || start);
                    // If OCR is requested, ensure tesseract is available (but proceed without OCR if it fails)
                    let haveTess = false;
                    if(opts.ocr || opts.ocrIfNoText) haveTess = await ensureTesseractLocal();

                    for(let p = start; p <= end; p++){
                        try{
                            const page = await doc.getPage(p);
                            // page text via pdf.js
                            let pageText = '';
                            try{ const txt = await page.getTextContent({ normalizeWhitespace:true, disableCombineTextItems:false, includeMarkedContent:true }); pageText = (txt && Array.isArray(txt.items))? txt.items.map(it=> String(it.str||'')).join(' ').replace(/\s+/g,' ').trim() : ''; }catch(e){ pageText = ''; }

                            let ocrText = '';
                            const needOcr = opts.ocr || (opts.ocrIfNoText && (!pageText || pageText.length < 40));
                            if(needOcr && haveTess){
                                try{
                                    const blob = await renderPageToBlob(page, opts.ocrScale || 2);
                                    if(blob){
                                        // Tesseract v4 exposes Tesseract.recognize
                                        if(window.Tesseract && window.Tesseract.recognize){
                                            const res = await window.Tesseract.recognize(blob, opts.ocrLang || 'eng');
                                            ocrText = (res && res.data && res.data.text) ? String(res.data.text).trim() : (res && res.text? String(res.text).trim() : '');
                                        } else if(window.Tesseract && window.Tesseract.createWorker){
                                            // fallback worker API
                                            const worker = window.Tesseract.createWorker({ logger: ()=>{} });
                                            await worker.load(); await worker.loadLanguage(opts.ocrLang||'eng'); await worker.initialize(opts.ocrLang||'eng');
                                            const { data } = await worker.recognize(blob); ocrText = (data && data.text)? String(data.text).trim() : ''; await worker.terminate();
                                        }
                                    }
                                }catch(e){ log('OCR failed on page', p, e?.message||e); }
                            }

                            if(opts.perPage){
                                results.push({ page: p, text: pageText, ocr: ocrText, merged: pageText + (ocrText? '\n[OCR]\n' + ocrText : '') });
                            } else {
                                let merged = '';
                                if(pageText) merged += pageText;
                                if(ocrText) merged += (merged? '\n[OCR]\n' : '') + ocrText;
                                if(!merged) merged = '';
                                results.push(merged);
                            }
                            // cooperative yield
                            await new Promise(r=> setTimeout(r,0));
                        }catch(e){ log('extractRangeText page failed', p, e?.message||e); results.push(''); }
                    }

                    if(opts.perPage){
                        // return detailed per-page array
                        return { pages: results, charCount: results.reduce((a,r)=> a + (r && r.merged? r.merged.length : (r && r.merged===''?0:0)), 0) };
                    }
                    const joined = results.filter(Boolean).join('\n\n');
                    return { text: joined, charCount: joined.length };
                }

                function computeChapterRanges(entries, chapterDepth, numPages){ const chapters = entries.filter(e => Number.isFinite(e.page) && e.depth === chapterDepth).sort((a,b)=> a.page - b.page); for(let i=0;i<chapters.length;i++){ const start = chapters[i].page; const end = (i < chapters.length - 1) ? (chapters[i+1].page - 1) : numPages; chapters[i].startPage = Math.max(1, start); chapters[i].endPage = Math.min(numPages, end); } return chapters; }

                async function buildPageLengthCache(doc, ranges){ if(!ranges || !ranges.length) return {}; const minP = Math.min(...ranges.map(r=> r.startPage)); const maxP = Math.max(...ranges.map(r=> r.endPage)); const cache = {}; for (let p = minP; p <= maxP; p++){ try { const t = await extractPageText(doc, p); cache[p] = t.length; } catch (e){ cache[p] = 0; } await new Promise(r=> setTimeout(r,0)); } return cache; }

                function sumCharsFromCache(cache, start, end, limit){ let total = 0; for (let p = start; p <= end; p++){ const len = cache[p] || 0; if (limit && len > limit) continue; total += len; } return total; }

                async function scanTOC(){
                    if(!pdfDoc) return;
                    // clear previous log for this scan
                    try{ if(logEl) logEl.textContent = ''; }catch{}
                    log('scanning TOC...');
                    // reset working state so duplicates don't accumulate
                    outline = null;
                    flattened = [];
                    window.fullToc = [];
                    try{ tocTree.innerHTML = '(scanning...)'; }catch{};

                    outline = await pdfDoc.getOutline();
                    if(!outline || !outline.length){
                        log('no outline/bookmarks found');
                        flattened=[]; renderTOC(flattened);
                        if(window.currentFileKey) window.tocByFile[window.currentFileKey] = window.fullToc || [];
                        return;
                    }

                    const flat = flattenOutline(outline);
                    log('outline entries', flat.length);
                    if(Array.isArray(outline) && outline.some(it => it && Array.isArray(it.items) && it.items.length>0)){
                        detectedChapterDepth = 1;
                        log('detected chapters as secondary items (depth 1) because top-level entries have children');
                    } else {
                        detectedChapterDepth = detectChapterDepth(flat);
                        log('detected chapter depth (heuristic)', detectedChapterDepth);
                    }

                    for(let i=0;i<flat.length;i++){
                        const it=flat[i];
                        try{
                            const pageIndex = await resolveDestToPageIndex(pdfDoc, it.raw.dest || it.raw.destref || it.raw.destref|| it.raw.a || it.raw.dest);
                            it.page = (pageIndex!=null)? (pageIndex+1) : null;
                            log('resolved', i+1, it.title, '->', it.page);
                        }catch(e){ log('resolve failed for', it.title, e?.message||e); it.page=null; }
                    }

                    const withPage = flat.filter(x=> Number.isFinite(x.page)).sort((a,b)=> a.page - b.page);
                    const withoutPage = flat.filter(x=> !Number.isFinite(x.page));
                    const sorted = withPage.concat(withoutPage);

                    const chapterEntries = computeChapterRanges(sorted, detectedChapterDepth, pdfNumPages);
                    for (const e of sorted) {
                        if (e.depth === detectedChapterDepth) {
                            const found = chapterEntries.find(c => c === e || (c.title===e.title && c.page===e.page));
                            if (found) { e.startPage = found.startPage; e.endPage = found.endPage; }
                        } else {
                            e.startPage = e.page || 1;
                            e.endPage = e.page || e.startPage;
                        }
                    }

                    window.fullToc = sorted.map((s, idx)=> ({ uid: idx, order: idx+1, title: s.title, depth: s.depth, startPage: s.startPage, endPage: s.endPage, page: s.page, raw: s.raw }));
                    flattened = window.fullToc.map(s=> ({ uid: s.uid, order: s.order, title: s.title, depth: s.depth, startPage: s.startPage, endPage: s.endPage, page: s.page }));
                    try{ window.flattened = flattened; }catch(e){}

                    const LIMIT = null;
                    // Build page-length cache across all entries that have numeric start/end pages
                    const entriesForCount = window.fullToc.filter(s => Number.isFinite(s.startPage) && Number.isFinite(s.endPage));
                    try{
                        if(entriesForCount.length){
                            const pageLenCache = await buildPageLengthCache(pdfDoc, entriesForCount);
                            for (const s of window.fullToc){
                                if (Number.isFinite(s.startPage) && Number.isFinite(s.endPage)){
                                    s.charCount = sumCharsFromCache(pageLenCache, s.startPage, s.endPage, LIMIT);
                                } else { s.charCount = s.charCount || 0; }
                            }
                            // Attempt to extract full text for each chapter so saved payloads can include full content
                            try{
                                const FULL_SAVE_LIMIT = 500000; // cap per-chapter saved text to avoid runaway sizes
                                for (const s of window.fullToc){
                                    if (!Number.isFinite(s.startPage) || !Number.isFinite(s.endPage)) continue;
                                    try{
                                        let txt = '';
                                        if(typeof extractRangeText === 'function'){
                                            try{ const r = await extractRangeText(pdfDoc, s.startPage, s.endPage); txt = String(r && r.text ? r.text : ''); if(r && Number.isFinite(r.charCount)) s.charCount = r.charCount; }catch(e){ txt = ''; }
                                        } else if(typeof extractPageText === 'function'){
                                            let acc = '';
                                            for(let p = s.startPage; p <= s.endPage; p++){
                                                try{ const ptxt = await extractPageText(pdfDoc, p); if(ptxt) acc += ptxt + '\n\n'; }catch(e){ /* ignore */ }
                                                if(acc.length > FULL_SAVE_LIMIT) break;
                                            }
                                            txt = acc;
                                        }
                                        if(txt){ if(txt.length > FULL_SAVE_LIMIT) txt = txt.slice(0, FULL_SAVE_LIMIT); s.text = txt; s.snippet = txt.slice(0,20000); }
                                    }catch(e){ /* ignore per-chapter extract errors */ }
                                }
                            }catch(e){ log('chapter text extraction in scanTOC failed', e?.message||e); }
                        } else {
                            // nothing to count; set defaults
                            for (const s of window.fullToc) s.charCount = s.charCount || 0;
                        }
                        for (const f of flattened){ const full = window.fullToc.find(x=> x.uid === f.uid); f.charCount = full ? (full.charCount || 0) : 0; }
                    }catch(e){ log('quick count failed', e?.message||e); }

                    // persist/overwrite this file's TOC to avoid duplicates in future scans
                    if(window.currentFileKey) window.tocByFile[window.currentFileKey] = window.fullToc;

                    applyFiltersAndMeta();
                    try{ const sb = document.getElementById('tbSaveBtn'); if(sb) sb.disabled = false; }catch(e){}
                }

                let detectedChapterDepth = 0;
                function renderTOC(arr, startDepth = null){ if(!arr || !arr.length){ tocTree.innerHTML = '<div class="muted">(no TOC)</div>'; return; } const root=document.createElement('div'); let lastGroup = null; arr.forEach((it,idx)=>{ const d = it.depth; const indentBase = (startDepth!=null) ? Math.max(0, d - startDepth) : d; if(startDepth!=null && d === startDepth && lastGroup !== it.startPage){ const sep = document.createElement('div'); sep.className = 'tb-group-sep'; root.appendChild(sep); lastGroup = it.startPage; } const el = document.createElement('div'); el.className = 'tb-node'; el.style.paddingLeft=(indentBase*18)+'px'; const title=document.createElement('div'); title.textContent = `${String(idx+1).padStart(2,'0')} ${it.title}`; const meta=document.createElement('div'); meta.className='small muted'; const cc = (typeof it.charCount === 'number') ? it.charCount : (it.charCount || 0); meta.textContent = `pages ${it.startPage||'?'} - ${it.endPage||'?'} (${cc} chars)`; el.appendChild(title); el.appendChild(meta); root.appendChild(el); }); tocTree.innerHTML=''; tocTree.appendChild(root); }

                function applyFiltersAndMeta(){ const ds = parseInt(depthStartEl.value,10); const de = parseInt(depthEndEl.value,10); const minD = Number.isFinite(ds) ? ds : 0; const maxD = Number.isFinite(de) ? de : Math.max(9, minD); let filtered = flattened.filter(f => f.depth >= minD && f.depth <= maxD); const start = parseInt(pageStart.value,10) || 1; const end = parseInt(pageEnd.value,10) || pdfNumPages; filtered.forEach(f=>{ f.startPage = Math.max(start, f.startPage||1); f.endPage = Math.min(end, f.endPage||pdfNumPages); if(f.startPage>f.endPage) f.invalid=true; }); const finalList = filtered.filter(f=>!f.invalid && f.startPage<=f.endPage); finalList.forEach(f=> f.charCount = f.charCount || 0); renderTOC(finalList, minD); metaName.textContent = fileEl.files && fileEl.files[0] ? fileEl.files[0].name : '(none)'; metaPages.textContent = pdfNumPages; metaBytes.textContent = humanBytes(pdfArrayBuffer?pdfArrayBuffer.byteLength:0); flattened = finalList; try{ window.flattened = finalList; }catch(e){} }

                fileEl.addEventListener('change', async (e)=>{
                    const f = e.target.files && e.target.files[0]; if(!f) return;
                    // stable key: name::size::lastModified to identify same file across scans
                    const fileKey = `${f.name}::${f.size}::${f.lastModified||0}`;
                    window.currentFileKey = fileKey;
                    metaName.textContent = f.name; metaPages.textContent = '...'; metaBytes.textContent = humanBytes(f.size);
                    log('file selected', f.name, humanBytes(f.size), 'key=', fileKey);
                    // clear UI of previous scan results to avoid duplicate accumulation
                    try{ tocTree.innerHTML = '(no TOC scanned)'; logEl.textContent = ''; }catch{}
                    pdfArrayBuffer = await f.arrayBuffer(); await ensurePdfJs();
                    try{
                        pdfDoc = await window.pdfjsLib.getDocument({ data: pdfArrayBuffer }).promise;
                        pdfNumPages = pdfDoc.numPages; metaPages.textContent = pdfNumPages; log('loaded PDF', f.name, 'pages', pdfNumPages);
                        btnScan.disabled=false;
                        // If we have a cached TOC for this exact file, pre-populate it (overwrite semantics maintained on scan)
                        if(window.tocByFile && window.tocByFile[fileKey] && window.tocByFile[fileKey].length){
                            window.fullToc = window.tocByFile[fileKey];
                            flattened = window.fullToc.map(s=> ({ uid: s.uid, order: s.order, title: s.title, depth: s.depth, startPage: s.startPage, endPage: s.endPage, page: s.page, charCount: s.charCount }));
                            applyFiltersAndMeta();
                        }
                    }catch(err){ log('pdf open failed', err?.message||err); btnScan.disabled=true; }
                });

                btnScan.addEventListener('click', async ()=>{ if(!pdfDoc) return; // clear log when user requests a scan
                    try{ if(logEl) logEl.textContent = ''; }catch{}; btnScan.disabled=true; log('Scan TOC starting...'); try{ await scanTOC(); log('scan complete'); }catch(e){ log('scan failed', e?.message||e); } btnScan.disabled=false; });

                // Save scanned textbook into persistent library (saves current preview)
                const tbSaveBtn = document.getElementById('tbSaveBtn');
                tbSaveBtn?.addEventListener('click', async ()=>{
                    // Save what's currently visible in the preview (`flattened`), not the raw full TOC
                    if(!(Array.isArray(flattened) && flattened.length) || !pdfDoc) { alert('No scanned TOC available to save.'); return; }
                    try{
                        tbSaveBtn.disabled = true;
                        log('building save package...');
                        log('debug: window.loadTextbookLib=', !!window.loadTextbookLib, 'window.saveTextbookLib=', !!window.saveTextbookLib);
                        // Build a lightweight chapters array from the preview: title, startPage, endPage, and small text excerpt
                        const chapters = [];
                        for(const item of flattened){
                            try{
                                const start = Number.isFinite(item.startPage)? item.startPage : (Number.isFinite(item.page)? item.page : 1);
                                const end = Number.isFinite(item.endPage)? item.endPage : start;
                                // extract up to first 20k chars across these pages
                                let txt='';
                                for(let p=start; p<=end; p++){
                                    try{ const s = await extractPageText(pdfDoc, p); if(s) txt += s + '\n\n'; if(txt.length > 200000) break; }catch(e){ log('page extract part failed', e?.message||e); }
                                }
                                const snippet = (txt||'').slice(0,20000);
                                const charCount = (txt && txt.length) ? txt.length : 0;
                                chapters.push({ title: item.title || 'Chapter', uid: item.uid, startPage: start, endPage: end, charCount: charCount, snippet: snippet });
                            }catch(e){ log('chapter build failed', e?.message||e); chapters.push({ title: item.title||'Chapter', text: '' }); }
                        }
                        const bookTitle = metaName.textContent || ('Book ' + (new Date()).toLocaleString());
                        log('prepared book', bookTitle, 'chapters', chapters.length);
                        const LS_KEY = 'textbook.lib.v1';
                        let lib = [];
                        try{
                            if(window.loadTextbookLib){ log('using window.loadTextbookLib()'); lib = window.loadTextbookLib(); }
                            else { log('reading localStorage key', LS_KEY); lib = JSON.parse(localStorage.getItem(LS_KEY) || '[]'); }
                        }catch(e){ log('load failed', e?.message||e); lib = []; }
                        // Use consistent record shape with payload so saved entries include full metadata
                        // Persist full content into IndexedDB first (heavy record), then write a lightweight pointer into localStorage
                        let ok = false;
                        try{
                            // Build heavyweight chapters with full text for IDB storage (do this sequentially)
                            const heavyChapters = [];
                            for (const item of flattened){
                                try{
                                    const start = Number.isFinite(item.startPage)? item.startPage : (Number.isFinite(item.page)? item.page : 1);
                                    const end = Number.isFinite(item.endPage)? item.endPage : start;
                                    let fullText = '';
                                    // Prefer range extractor when available
                                    if(window.pdfDoc && typeof extractRangeText === 'function'){
                                        try{ const r = await extractRangeText(window.pdfDoc, start, end); fullText = String(r && r.text ? r.text : ''); }catch(e){ fullText = ''; }
                                    } else if(window.pdfDoc){
                                        // fallback to iterating pages
                                        let acc = '';
                                        for(let p = start; p <= end; p++){
                                            try{ const s = typeof extractPageText === 'function' ? await extractPageText(window.pdfDoc, p) : (typeof tbExtractPageText === 'function' ? await tbExtractPageText(window.pdfDoc, p) : ''); if(s) acc += s + '\n\n'; }catch(e){ /* ignore */ }
                                        }
                                        fullText = acc;
                                    }
                                    const snippet = (fullText||'').slice(0,20000);
                                    const charCount = fullText ? fullText.length : 0;
                                    // include `text` for compatibility with existing readers
                                    heavyChapters.push({ title: item.title||'Chapter', uid: item.uid, startPage: start, endPage: end, charCount: charCount, snippet: snippet, text: fullText, fullText: fullText });
                                }catch(e){ heavyChapters.push({ title: item.title||'Chapter', uid: item.uid, startPage: item.startPage||1, endPage: item.endPage||item.startPage||1, charCount: 0, snippet: '', fullText: '' }); }
                            }

                            const heavyRec = { title: sanitizeTitle(bookTitle), meta: { savedAt: Date.now(), pages: pdfNumPages, fileName: bookTitle }, payload: { savedAt: Date.now(), items: flattened, chapters: heavyChapters, meta: { fileName: bookTitle, pages: pdfNumPages } } };
                            // store full record in IndexedDB
                            try{
                                const storedId = await idbPutBook(heavyRec);
                                log('indexedDB stored heavy book id', storedId);
                                // write a lightweight pointer into localStorage so UI can show the saved entry quickly
                                try{
                                    if(window.loadTextbookLib){ log('using window.loadTextbookLib() to read lib'); lib = window.loadTextbookLib(); }
                                    else { log('reading localStorage key', LS_KEY); lib = JSON.parse(localStorage.getItem(LS_KEY) || '[]'); }
                                }catch(e){ lib = []; }
                                const pointer = { title: bookTitle, text: '', idbRef: storedId, meta: { pages: pdfNumPages, fileName: bookTitle, savedAt: (new Date()).toISOString() } };
                                lib.push(pointer);
                                try{ localStorage.setItem(LS_KEY, JSON.stringify(lib)); ok = true; log('wrote pointer to localStorage'); }
                                catch(localErr){ log('writing pointer to localStorage failed', localErr?.message||localErr); ok = true; /* pointer failed but heavy record is in IDB so mark ok true */ }
                            }catch(idbErr){ log('idbPutBook failed', idbErr?.message||idbErr); ok = false; }
                        }catch(e){ log('save to IDB failed', e?.message||e); ok = false; }
                        if(ok){ log('save succeeded'); try{ if(window.setTextbookStatus) window.setTextbookStatus('Saved content to library.'); else setStatus && setStatus('Saved content to library.'); try{ if(window.refreshTextbookLibrary) window.refreshTextbookLibrary(); }catch(e){ log('refresh failed', e?.message||e); } }catch(e){ log('status update failed', e?.message||e); } }
                        else {
                            log('save failed; no download fallback (removed)');
                            try{ if(window.setTextbookStatus) window.setTextbookStatus('Could not save content.', true); else setStatus && setStatus('Could not save content.', true); }catch(e){}
                        }
                    }catch(e){ log('save failed', e?.message||e); try{ if(window.setTextbookStatus) window.setTextbookStatus('Save failed', true); else setStatus && setStatus('Save failed', true); }catch(err){ log('status fallback failed', err); } }
                    finally{ try{ tbSaveBtn.disabled = false; }catch(e){} }
                });

                ['dragover','drop'].forEach(ev=> document.addEventListener(ev, (e)=>{ e.preventDefault(); }));
                document.addEventListener('drop', (e)=>{ if(e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length){ fileEl.files = e.dataTransfer.files; fileEl.dispatchEvent(new Event('change')); } });

            })();
            </script>
        </section>

    <script>
    (function(){
    // Inserted verbatim from index.html: IndexedDB-backed saved textbook UI + handlers
        // IndexedDB helpers
        async function idbOpen(){ return new Promise((res,rej)=>{ try{ const req = indexedDB.open('pdf-toc-lib', 1); req.onupgradeneeded = (evt)=>{ const db = evt.target.result; if(!db.objectStoreNames.contains('books')){ db.createObjectStore('books', { keyPath: 'id', autoIncrement: true }); } }; req.onsuccess = ()=> res(req.result); req.onerror = ()=> rej(req.error); }catch(e){ rej(e); } }); }
        async function idbPutBook(book){ const db = await idbOpen(); return new Promise((res, rej)=>{ const tx = db.transaction('books','readwrite'); const store = tx.objectStore('books'); const req = store.add(book); req.onsuccess = ()=>{ res(req.result); db.close(); }; req.onerror = ()=>{ rej(req.error); db.close(); }; }); }
        async function idbGetAllBooks(){ const db = await idbOpen(); return new Promise((res, rej)=>{ const tx = db.transaction('books','readonly'); const store = tx.objectStore('books'); const req = store.getAll(); req.onsuccess = ()=>{ res(req.result || []); db.close(); }; req.onerror = ()=>{ rej(req.error); db.close(); }; }); }
        async function idbGetBook(id){ const db = await idbOpen(); return new Promise((res, rej)=>{ const tx = db.transaction('books','readonly'); const store = tx.objectStore('books'); const req = store.get(id); req.onsuccess = ()=>{ res(req.result); db.close(); }; req.onerror = ()=>{ rej(req.error); db.close(); }; }); }
        async function idbDeleteBook(id){ const db = await idbOpen(); return new Promise((res, rej)=>{ const tx = db.transaction('books','readwrite'); const store = tx.objectStore('books'); const req = store.delete(id); req.onsuccess = ()=>{ res(true); db.close(); }; req.onerror = ()=>{ rej(req.error); db.close(); }; }); }

        // --- Export helpers: single .txt download and bulk .zip using JSZip ---
        function downloadBlob(blob, filename){ try{ const a = document.createElement('a'); const url = URL.createObjectURL(blob); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); try{ a.remove(); }catch{} }, 5000); }catch(e){ console.error('downloadBlob failed', e); }
        }

        async function ensureJSZip(){ if(window.JSZip) return window.JSZip; // try common CDN
            try{ await new Promise((res,rej)=>{ const s = document.createElement('script'); s.src = 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js'; s.onload = res; s.onerror = rej; document.head.appendChild(s); }); return window.JSZip; }catch(e){ console.warn('JSZip load failed', e); throw e; } }

        function sanitizeFilename(s){ try{ return String(s||'untitled').replace(/[\\/:*?"<>|\x00-\x1F]/g,'_').replace(/\s+/g,' ').trim().slice(0,180); }catch(e){ return 'untitled'; } }

        async function exportSingleChapter(ch, recTitle){ try{
            // prefer full text fields when available
            const txt = String(ch.text || ch.fullText || ch.snippet || ch.title || '');
            const filename = sanitizeFilename((recTitle? recTitle + ' - ' : '') + (ch.title || 'chapter')) + '.txt';
            const blob = new Blob([txt], { type: 'text/plain;charset=utf-8' });
            downloadBlob(blob, filename);
        }catch(e){ console.error('exportSingleChapter failed', e); alert('Export failed: ' + (e?.message||e)); } }

        async function exportAllSaved(){ try{
            const btn = document.getElementById('exportAllSavedBtn'); if(btn) { btn.disabled = true; const old = btn.textContent; btn.textContent = 'Preparing…'; }
            const all = await idbGetAllBooks(); if(!all || !all.length){ alert('No saved items to export.'); if(btn){ btn.disabled=false; btn.textContent = old || 'Export all (.zip)'; } return; }
            const JSZipLib = await ensureJSZip(); const zip = new window.JSZip();
            for(const rec of all){ try{
                    const title = rec.title || ('record-' + (rec.id||Date.now()));
                    const payload = rec.payload || {};
                    // If record has chapters, export each chapter as its own file, else create a single file per record
                    if(Array.isArray(payload.chapters) && payload.chapters.length){
                        for(const ch of payload.chapters){ const fname = sanitizeFilename(title + ' - ' + (ch.title||'chapter')) + '.txt'; const content = String(ch.text || ch.fullText || ch.snippet || ch.title || ''); zip.file(fname, content); }
                    } else {
                        const fname = sanitizeFilename(title) + '.txt'; const content = String(rec.text || (payload && payload.text) || ''); zip.file(fname, content);
                    }
            }catch(e){ console.warn('skipping record during zip', e); }
            }
            const blob = await zip.generateAsync({ type: 'blob' });
            const zipName = `saved-sets-${(new Date()).toISOString().replace(/[:.]/g,'-')}.zip`;
            downloadBlob(blob, zipName);
            if(btn) { btn.disabled=false; btn.textContent = old || 'Export all (.zip)'; }
        }catch(e){ console.error('exportAllSaved failed', e); alert('Export all failed: ' + (e?.message||e)); try{ const b = document.getElementById('exportAllSavedBtn'); if(b){ b.disabled = false; b.textContent = 'Export all (.zip)'; } }catch{} }
        }

        function log(...args){ try{ const s = args.map(a=> typeof a==='string'? a : JSON.stringify(a)).join(' '); const line = new Date().toLocaleTimeString() + ' ' + s; const logEl = document.getElementById('log') || document.getElementById('tbLog'); if(logEl) logEl.textContent = line + '\n' + logEl.textContent; }catch(e){ console.log(...args); } }

        function populateSavedSelect(items){
            const savedSelect = document.getElementById('savedSelect');
            const inlineTrigger = document.getElementById('savedSelectInline');
            const inlineList = document.getElementById('savedSelectList');
            if(!savedSelect || !inlineTrigger || !inlineList) return;
            // keep the hidden native select in sync for compatibility
            savedSelect.innerHTML = '';
            const emptyOpt = document.createElement('option');
            emptyOpt.value = '';
            emptyOpt.textContent = '(none)';
            savedSelect.appendChild(emptyOpt);
            // clear inline list
            inlineList.innerHTML = '';

            const tbClearBtn = document.getElementById('tbClearBtn');
            const tbShowBtn = document.getElementById('tbShowBtn');
            const tbDeleteBtn = document.getElementById('tbDeleteBtn');
            const tbTotalSizeEl = document.getElementById('tbTotalSize');

            if(!items || !items.length){
                if(tbClearBtn) tbClearBtn.disabled = true;
                if(tbShowBtn) tbShowBtn.disabled = true;
                if(tbDeleteBtn) tbDeleteBtn.disabled = true;
                if(tbTotalSizeEl) tbTotalSizeEl.textContent = 'Total: 0.0 KB';
                const savedDetails = document.getElementById('savedDetails'); if(savedDetails) savedDetails.textContent='(select saved content and click Show)';
                return;
            }

            if(tbClearBtn) tbClearBtn.disabled = false;
            let totalBytes = 0;
            for(const it of items){
                try{
                    const o = document.createElement('option');
                    o.value = String(it.id);
                    let rangeText = (it.meta && it.meta.pages) ? `${it.meta.pages} pages` : '? pages';
                    try{
                        const payload = it.payload || {};
                        if(Array.isArray(payload.chapters) && payload.chapters.length){
                            let s = Infinity, e = -Infinity;
                            for(const c of payload.chapters){ if(Number.isFinite(c.startPage)) s = Math.min(s, Number(c.startPage)); if(Number.isFinite(c.endPage)) e = Math.max(e, Number(c.endPage)); }
                            if(s !== Infinity && e !== -Infinity) rangeText = (s===e)? `${s} pages` : `${s}-${e} pages`;
                            else if(s !== Infinity) rangeText = `${s} pages`;
                        }
                    }catch(e){}
                    let sizeBytes = 0;
                    try{
                        const payload = it.payload || {};
                        if(Array.isArray(payload.chapters) && payload.chapters.length){
                            for(const c of payload.chapters){ const s = (c && (c.text || c.fullText || c.snippet || '')) || ''; sizeBytes += (s.length || 0); }
                        } else if(it.text && typeof it.text === 'string') sizeBytes = it.text.length || 0;
                    }catch(e){ sizeBytes = 0; }
                    totalBytes += (sizeBytes || 0);
                    const sizeText = sizeBytes ? ` • ${(sizeBytes/1024).toFixed(1)} KB` : '';
                    const labelText = `${it.title || '(untitled)'} — ${rangeText}${sizeText}`;
                    o.textContent = labelText;
                    savedSelect.appendChild(o);
                    // also populate inline list item
                    const item = document.createElement('div');
                    item.className = 'custom-inline-item';
                    item.setAttribute('role','option');
                    item.setAttribute('data-id', String(it.id));
                    item.tabIndex = -1;
                    item.textContent = labelText;
                    // click handler
                    item.addEventListener('click', (ev)=>{
                        try{ savedSelect.value = String(it.id); savedSelect.dispatchEvent(new Event('change', { bubbles:true })); }
                        catch(e){}
                        // update trigger label and close
                        try{ inlineTrigger.querySelector('.inline-selected').textContent = labelText; inlineTrigger.setAttribute('aria-expanded','false'); inlineList.classList.add('hidden'); }
                        catch(e){}
                    });
                    inlineList.appendChild(item);
                }catch(e){ /* ignore item errors */ }
            }
            if(tbTotalSizeEl) tbTotalSizeEl.textContent = `Total: ${(totalBytes/1024).toFixed(1)} KB`;
            if(tbShowBtn) tbShowBtn.disabled = false;
            if(tbDeleteBtn) tbDeleteBtn.disabled = false;
            const savedDetails = document.getElementById('savedDetails'); if(savedDetails) savedDetails.textContent='(select saved content and click Show)';
            // update inline trigger label if nothing selected
            try{ const sel = savedSelect.value || ''; const first = sel ? inlineList.querySelector(`.custom-inline-item[data-id="${sel}"]`) : null; if(!first){ inlineTrigger.querySelector('.inline-selected').textContent = '(none)'; } }
            catch(e){}
        }

        async function refreshSavedList(){
            try{
                const all = await idbGetAllBooks();
                // include payload so populateSavedSelect can compute scanned ranges
                const mapped = all.map(a=> ({ id: a.id, title: a.title, meta: a.meta||{}, payload: a.payload||{} }));
                populateSavedSelect(mapped);
            }catch(e){
                log('refresh saved list failed', e?.message||e);
                const savedSelect = document.getElementById('savedSelect');
                savedSelect.innerHTML='';
                const emptyOpt = document.createElement('option');
                emptyOpt.value='';
                emptyOpt.textContent='(error)';
                savedSelect.appendChild(emptyOpt);
            }
        }

        document.getElementById('tbClearBtn')?.addEventListener('click', async ()=>{
            if(!confirm('Delete ALL saved content from the library? This will not affect the currently loaded PDF or preview.')) return;
            try{
                // delete IDB entries (saved textbooks only)
                const all = await idbGetAllBooks();
                for(const a of all){ await idbDeleteBook(a.id); }
                // clear localStorage pointer key used for saved list
                try{ localStorage.removeItem('textbook.lib.v1'); }catch(e){}
                log('cleared all saved textbooks');
                // refresh the saved list UI
                await refreshSavedList();
                // reset saved-list controls only (leave file, toc, flattened and log intact)
                try{ const savedSelect = document.getElementById('savedSelect'); const inlineList = document.getElementById('savedSelectList'); const inlineTrigger = document.getElementById('savedSelectInline'); if(savedSelect){ savedSelect.innerHTML = ''; const emptyOpt = document.createElement('option'); emptyOpt.value=''; emptyOpt.textContent='(none)'; savedSelect.appendChild(emptyOpt); } if(inlineList){ inlineList.innerHTML=''; } if(inlineTrigger){ try{ inlineTrigger.querySelector('.inline-selected').textContent='(none)'; inlineTrigger.setAttribute('aria-expanded','false'); }catch(e){} } }catch(e){}
                try{ const savedDetails = document.getElementById('savedDetails'); if(savedDetails) savedDetails.textContent='(select saved content and click Show)'; }catch(e){}
                try{ const tbShowBtn = document.getElementById('tbShowBtn'); if(tbShowBtn){ tbShowBtn.dataset.visible = '0'; tbShowBtn.textContent = 'Show'; tbShowBtn.disabled = true; } }catch(e){}
                
                try{ const tbDeleteBtn = document.getElementById('tbDeleteBtn'); if(tbDeleteBtn) tbDeleteBtn.disabled = true; }catch(e){}
            }catch(e){ log('clear all failed', e?.message||e); }
        });

    // tbShowBtn now acts as a Hide/Show toggle for the savedDetails view
    document.getElementById('tbShowBtn')?.addEventListener('click', async ()=>{ const btn = document.getElementById('tbShowBtn'); const savedDetails = document.getElementById('savedDetails'); if(!btn || !savedDetails) return; // when toggling off, just hide the details and update label
        if(btn.dataset.visible === '1'){ btn.dataset.visible = '0'; btn.textContent = 'Show'; savedDetails.style.display = 'none'; return; }
        // otherwise, show (and populate) the selected saved record
    const id = parseInt(document.getElementById('savedSelect').value,10); if(!id) return; try{ const rec = await idbGetBook(id); if(!rec || !rec.payload) { savedDetails.textContent='(record not found)'; btn.dataset.visible = '0'; btn.textContent = 'Show'; return; } const payload = rec.payload; savedDetails.innerHTML=''; savedDetails.style.display = 'block'; btn.dataset.visible = '1'; btn.textContent = 'Hide'; const list = document.createElement('div'); list.className = 'saved-list'; const chapters = payload.chapters || []; if(!chapters.length){ savedDetails.textContent='(no chapters)'; btn.dataset.visible = '0'; btn.textContent = 'Show'; return; }
            function visualizeControlChars(s){ if(!s) return '(empty)'; return s.replace(/\t/g, '→\t').replace(/\r\n|\r|\n/g, '\n↵\n').replace(/[\x00-\x1F\x7F]/g, (c)=>{ const code = c.charCodeAt(0).toString(16).toUpperCase().padStart(2,'0'); return '\\u' + code; }); }
            // create a quick map of saved items (if present) so we can respect depth/indentation
            const itemsMap = (payload.items || []).reduce((acc,it)=>{ try{ acc[it.uid] = it; }catch(e){} return acc; }, {});
            for(const ch of chapters){
                const row = document.createElement('div'); row.className = 'saved-row pill';
                // compute display indentation from saved item's depth (fallback 0)
                const savedItem = itemsMap[ch.uid];
                const depth = (savedItem && Number.isFinite(savedItem.depth)) ? Number(savedItem.depth) : 0;
                const indent = Math.max(0, depth) * 16; // 16px per depth level

                const t = document.createElement('div'); t.style.paddingLeft = indent + 'px';
                // prefer authoritative counts from the current scan (if present) when saved payload looks small
                let displayCount = (typeof ch.charCount === 'number') ? ch.charCount : (ch.snippet ? ch.snippet.length : 0);
                try{
                    if((!displayCount || displayCount < 1000) && Array.isArray(window.fullToc) && window.fullToc.length){
                        const found = window.fullToc.find(x => Number(x.uid) === Number(ch.uid));
                        if(found && Number.isFinite(found.charCount)) displayCount = found.charCount;
                    }
                }catch(e){}
                t.textContent = `${ch.title} [${ch.startPage}-${ch.endPage}] (${displayCount} chars)`;

                // action buttons container
                const actions = document.createElement('div'); actions.className = 'si-actions';

                // Generate -> sets the selected generator source (replace semantics)
                const genBtn = document.createElement('button'); genBtn.className = 'btn small'; genBtn.textContent = 'Generate'; genBtn.title = 'Set this chapter as the source for Generate MCQs';
                genBtn.addEventListener('click', async (ev)=>{
                    try{
                        // If the saved chapter snippet is empty or appears truncated, try to extract the full range from the loaded PDF
                        // prefer stored full text when present on the chapter record
                        let useText = (ch.text && String(ch.text).trim()) ? ch.text : ((ch.fullText && String(ch.fullText).trim()) ? ch.fullText : ((ch.snippet && String(ch.snippet).trim()) ? ch.snippet : ''));
                        try{
                            const shouldTryExtract = (typeof ch.charCount === 'number' && ch.charCount > (useText.length || 0)) || (!useText);
                            if(shouldTryExtract && window.pdfDoc){
                                try{
                                    let r = null;
                                    if(typeof extractRangeText === 'function'){
                                        r = await extractRangeText(window.pdfDoc, ch.startPage, ch.endPage);
                                    } else if(window.pdfDoc && typeof window.pdfDoc.getPage === 'function'){
                                        // Inline fallback: iterate pages and extract text content
                                        let acc = '';
                                        const MAX_CHARS = 200000;
                                        for(let p = ch.startPage; p <= ch.endPage; p++){
                                            try{
                                                const page = await window.pdfDoc.getPage(p);
                                                const content = await page.getTextContent({ normalizeWhitespace:true, disableCombineTextItems:false, includeMarkedContent:true });
                                                const s = (content && Array.isArray(content.items)) ? content.items.map(it=> String(it.str||'')).join(' ').replace(/\s+/g,' ').trim() : '';
                                                if(s) acc += s + '\n\n';
                                                if(acc.length > MAX_CHARS) break;
                                            }catch(e){ break; }
                                        }
                                        r = { text: acc, charCount: acc.length };
                                    }
                                    if(r && r.text && String(r.text).trim().length){ useText = String(r.text).trim(); }
                                }catch(e){ /* extraction failed; keep fallback */ }
                            }
                        }catch(e){}
                        if(!useText) useText = `${ch.title} (pages ${ch.startPage}-${ch.endPage})`;
                        const data = { title: ch.title, text: useText, startPage: ch.startPage, endPage: ch.endPage };
                        // replace the generator context so this becomes the chosen file/source
                        window.__tbGenCtx = window.__tbGenCtx || { pieces: [] };
                        window.__tbGenCtx.pieces = [ data ];
                        // update status indicators to reflect selected source
                        const statusDz = document.getElementById('tbDropGenerate'); if(statusDz) statusDz.textContent = `Selected source: ${ch.title} [${ch.startPage}-${ch.endPage}] (1 chapter)`;
                        const aiStatus = document.getElementById('aiFileStatus'); if(aiStatus) aiStatus.textContent = `Selected source: ${ch.title} [${ch.startPage}-${ch.endPage}]`;
                        // update saved preview area with a snippet and charcount
                        try{
                            const preview = document.getElementById('savedPreviewWrap');
                            if(preview){ const s = String(useText||''); const snippet = s.length > 800 ? s.slice(0,800) + '\n\n[TRUNCATED]' : s; preview.textContent = snippet; preview.textContent += `\n\n(${(s.length||0).toLocaleString()} chars)`; }
                        }catch(e){}
                        // clear any other persisted selection and mark this row as selected
                        try{
                            const parent = row.parentElement;
                            if(parent){
                                parent.querySelectorAll('.saved-row.selected').forEach(r=>{
                                    r.classList.remove('selected');
                                    // clear aria-pressed for any Generate buttons in that row
                                    const b = r.querySelector('button'); if(b && b.textContent === 'Generate'){ b.setAttribute('aria-pressed','false'); }
                                });
                            }
                        }catch(e){}
                        row.classList.add('selected');
                        // mark this Generate button as pressed for accessibility
                        try{ genBtn.setAttribute('aria-pressed','true'); }catch(e){}
                        // mirror selection to the file drop element used by the file chooser
                        try{ const chooser = document.getElementById('aiFileTbDrop'); if(chooser) chooser.setAttribute('data-selected', `${ch.title} [${ch.startPage}-${ch.endPage}]`); }catch(e){}
                        log('Set generator source to', ch.title);
                    }catch(e){ log('apply generate failed', e?.message||e); }
                });

                // Validate -> applies to validator context
                const valBtn = document.createElement('button'); valBtn.className = 'btn small'; valBtn.textContent = 'Validate'; valBtn.title = 'Apply this chapter to the Validate Answers panel';
                valBtn.addEventListener('click', async (ev)=>{
                    try{
                        window.__tbValidateCtx = window.__tbValidateCtx || { pieces: [] };
                        const data = { title: ch.title, text: ch.snippet || '', startPage: ch.startPage, endPage: ch.endPage };
                        window.__tbValidateCtx.pieces.push(data);
                        const dz = document.getElementById('tbDropValidate'); if(dz) dz.textContent = `Attached ${window.__tbValidateCtx.pieces.length} chapter(s).`;
                        const valOut = document.getElementById('aiValidateOutput2'); if(valOut) valOut.textContent = `Applied: ${ch.title} [${ch.startPage}-${ch.endPage}]`;
                        // also reveal the global apply button so users can push corrections if needed
                        try{ const gbtn = document.getElementById('validatorApplyBtnGlobal'); if(gbtn) gbtn.classList.remove('hidden'); }catch(e){}
                        row.classList.add('applied'); setTimeout(()=> row.classList.remove('applied'), 1400);
                        log('Applied to validator context', ch.title);
                    }catch(e){ log('apply validate failed', e?.message||e); }
                });

                // support legacy dragstart (keep for compatibility) on the title element
                t.draggable = true;
                t.addEventListener('dragstart', (ev)=>{ try{ const payload = { title: ch.title, text: ch.snippet || '', startPage: ch.startPage, endPage: ch.endPage }; ev.dataTransfer.setData('application/json', JSON.stringify(payload)); ev.dataTransfer.effectAllowed = 'copy'; log('dragstart', ch.title); }catch(e){ log('dragstart failed', e?.message||e); } });

                // Export -> download this chapter as .txt
                const expBtn = document.createElement('button'); expBtn.className = 'btn small'; expBtn.textContent = 'Export'; expBtn.title = 'Export this chapter as .txt';
                expBtn.addEventListener('click', (ev)=>{ try{ ev.stopPropagation(); ev.preventDefault(); exportSingleChapter(ch, (payload && payload.meta && payload.meta.fileName) ? payload.meta.fileName : (rec && rec.title) ); }catch(e){ console.error(e); } });
                actions.appendChild(genBtn); actions.appendChild(valBtn); actions.appendChild(expBtn);
                row.appendChild(t); row.appendChild(actions); list.appendChild(row);
                // clicking the saved row should show the preview (but not auto-select as generator source)
                (function(row, ch){
                    row.addEventListener('click', (ev)=>{
                        try{
                            // ignore clicks on inline buttons
                            if(ev.target && (ev.target.tagName === 'BUTTON' || ev.target.closest('button'))) return;
                            const preview = document.getElementById('savedPreviewWrap'); if(!preview) return;
                            let useText = (ch.text && String(ch.text).trim()) ? ch.text : ((ch.snippet && String(ch.snippet).trim()) ? ch.snippet : '');
                            if(!useText && ch.title) useText = `${ch.title} (pages ${ch.startPage}-${ch.endPage})`;
                            const maxPreviewChars = 420;
                            const s = String(useText||'');
                            const snippet = s.length > maxPreviewChars ? s.slice(0,maxPreviewChars) + '\n\n[TRUNCATED]' : s || '(no excerpt available)';
                            preview.textContent = snippet;
                            preview.textContent += `\n\n(${(s.length||0).toLocaleString()} chars)`;
                            try{ const parent = row.parentElement; if(parent) parent.querySelectorAll('.saved-row.selected').forEach(r=> r.classList.remove('selected')); row.classList.add('selected'); }catch(e){}
                        }catch(e){}
                    });
                })(row, ch);
            }
            savedDetails.appendChild(list);
            // Preview container for selected saved chapter excerpts
            try{
                const previewWrap = document.createElement('div');
                previewWrap.id = 'savedPreviewWrap';
                previewWrap.className = 'saved-sample compact-sample';
                previewWrap.style.marginTop = '6px';
                // shorter preview by default (visual clamp)
                previewWrap.style.maxHeight = '160px';
                previewWrap.style.overflow = 'auto';
                previewWrap.style.position = 'relative';
                previewWrap.style.display = '-webkit-box';
                previewWrap.style.webkitLineClamp = '4';
                previewWrap.style.webkitBoxOrient = 'vertical';
                previewWrap.style.lineHeight = '1.2';
                previewWrap.textContent = '(select a chapter and click Generate to preview excerpt)';
                savedDetails.appendChild(previewWrap);

                // If the first chapter has a snippet that appears truncated and the PDF is loaded, try to extract the full range
                (async ()=>{
                    try{
                        const first = chapters && chapters.length ? chapters[0] : null;
                        if(!first) return;
                        const preview = document.getElementById('savedPreviewWrap');
                        if(!preview) return;
                        const sSnippet = String(first.snippet || '');
                        const sCount = (typeof first.charCount === 'number') ? first.charCount : sSnippet.length;
                        // if PDF loaded and snippet is much smaller than expected, attempt extraction
                        if(window.pdfDoc && (!sCount || sSnippet.length < Math.max(1000, Math.min(50000, sCount)))){
                            let useText = sSnippet || '';
                            try{
                                let r = null;
                                if(typeof extractRangeText === 'function'){
                                    r = await extractRangeText(window.pdfDoc, first.startPage, first.endPage);
                                } else if(window.pdfDoc && typeof window.pdfDoc.getPage === 'function'){
                                    let acc = '';
                                    const MAX_CHARS = 300000;
                                    for(let p = first.startPage; p <= first.endPage; p++){
                                        try{
                                            const page = await window.pdfDoc.getPage(p);
                                            const content = await page.getTextContent({ normalizeWhitespace:true, disableCombineTextItems:false, includeMarkedContent:true });
                                            const s = (content && Array.isArray(content.items)) ? content.items.map(it=> String(it.str||'')).join(' ').replace(/\s+/g,' ').trim() : '';
                                            if(s) acc += s + '\n\n';
                                            if(acc.length > MAX_CHARS) break;
                                        }catch(e){ break; }
                                    }
                                    r = { text: acc, charCount: acc.length };
                                }
                                if(r && r.text && String(r.text).trim().length) useText = String(r.text).trim();
                            }catch(e){}
                            if(!useText) useText = `${first.title} (pages ${first.startPage}-${first.endPage})`;
                            const s = String(useText||'');
                            const maxPreviewChars = 420;
                            const snippet = s.length > maxPreviewChars ? s.slice(0,maxPreviewChars) + '\n\n[TRUNCATED]' : s;
                            preview.textContent = snippet;
                            preview.textContent += `\n\n(${(s.length||0).toLocaleString()} chars)`;
                        } else {
                            // show whatever snippet is available
                            const s = sSnippet || '';
                            const maxPreviewChars = 420;
                            const snippet = s.length ? (s.length > maxPreviewChars ? s.slice(0,maxPreviewChars) + '\n\n[TRUNCATED]' : s) : '(no excerpt available)';
                            preview.textContent = snippet;
                            preview.textContent += `\n\n(${(sCount||0).toLocaleString()} chars)`;
                        }
                    }catch(e){ /* ignore preview extraction failures */ }
                })();
            }catch(e){}
        }catch(e){ log('show failed', e?.message||e); savedDetails.textContent='(error)'; } });

    document.getElementById('tbDeleteBtn')?.addEventListener('click', async ()=>{ const id = parseInt(document.getElementById('savedSelect').value,10); if(!id) return; if(!confirm('Delete selected saved content?')) return; try{ await idbDeleteBook(id); log('deleted saved', id); await refreshSavedList(); document.getElementById('savedDetails').textContent='(none)'; }catch(e){ log('delete failed', e?.message||e); } });

    

    // Migrate selected saved record to include full chapter text (when PDF is loaded)
    

        // Load into UI/generator context
    

    // Save handler (compact payload) + flash saved state
    document.getElementById('tbSaveBtn')?.addEventListener('click', async ()=>{ const tbSaveBtn = document.getElementById('tbSaveBtn'); const savedSelect = document.getElementById('savedSelect'); if(!(window.fullToc && window.fullToc.length)) return; tbSaveBtn.disabled=true; const oldText = tbSaveBtn.textContent; log('Saving scanned textbook to IndexedDB...'); try{ const meta = { savedAt: Date.now(), pages: (window.pdfNumPages||window.pdfNumPages===0)? window.pdfNumPages : (window.pdfNumPages||0), fileName: (document.getElementById('metaName')?.textContent || '') }; const chapters = []; const itemsToSave = Array.isArray(window.flattened)? window.flattened.slice() : (Array.isArray(window.fullToc)? window.fullToc.slice():[]); const fullMap = (window.fullToc||[]).reduce((acc, x)=>{ acc[x.uid] = x; return acc; }, {});
            for (const ch of itemsToSave) {
                // compute start/end pages with safe fallbacks and bounds checking
                const s = Math.max(1, Number.isFinite(ch.startPage) ? ch.startPage : (Number.isFinite(ch.page) ? ch.page : 1));
                let e = Number.isFinite(ch.endPage) ? ch.endPage : (Number.isFinite(ch.page) ? ch.page : s);
                if (Number.isFinite(window.pdfNumPages) && window.pdfNumPages > 0) e = Math.min(window.pdfNumPages, e);

                // we'll try to compute an authoritative charCount for the full range and capture the full text.
                // prefer extractRangeText if available (returns text + charCount). Otherwise fall back to per-page accumulation
                let snippet = '';
                let charCount = 0;
                let fullText = '';
                try{
                    if(window.pdfDoc){
                        if(typeof extractRangeText === 'function'){
                            // extract the full chapter range (s..e)
                            const r = await extractRangeText(window.pdfDoc, s, e);
                            fullText = String(r && r.text ? r.text : '');
                            // cap stored full text to a reasonable limit to avoid extremely large saves
                            const FULL_SAVE_LIMIT = 500000;
                            if(fullText.length > FULL_SAVE_LIMIT) fullText = fullText.slice(0, FULL_SAVE_LIMIT);
                            snippet = fullText.slice(0, 20000);
                            charCount = Number.isFinite(r && r.charCount) ? r.charCount : fullText.length;
                        } else {
                            // no range helper available: iterate pages and accumulate lengths
                            let acc = '';
                            let total = 0;
                            const ACC_LIMIT = 200000; // don't build enormous temporary buffers
                            for(let p = s; p <= e; p++){
                                try{
                                    let pageText = '';
                                    if(typeof extractPageText === 'function'){
                                        pageText = await extractPageText(window.pdfDoc, p);
                                    } else if(typeof tbExtractPageText === 'function'){
                                        pageText = await tbExtractPageText(window.pdfDoc, p);
                                    }
                                    if(pageText){
                                        total += pageText.length;
                                        if(acc.length < ACC_LIMIT) acc += pageText + '\n\n';
                                    }
                                }catch(e){ /* ignore page errors and continue */ }
                            }
                            // use accumulated text as the full text (within ACC_LIMIT)
                            fullText = acc;
                            snippet = fullText.slice(0, 20000);
                            charCount = total;
                        }
                    }
                }catch(err){ log('chapter extract failed', err?.message||err); snippet = snippet || ''; charCount = charCount || 0; }

                // prefer authoritative counts and stored text discovered during scan (fullMap) when present
                const authoritative = fullMap[ch.uid];
                let authCount = (authoritative && Number.isFinite(authoritative.charCount)) ? authoritative.charCount : (Number.isFinite(charCount) ? charCount : (snippet ? snippet.length : 0));
                // if the scan populated full text for this chapter, prefer that and avoid re-extraction
                let storedText = (authoritative && authoritative.text) ? authoritative.text : (authoritative && authoritative.fullText ? authoritative.fullText : (fullText || ''));
                if(storedText && !authCount) authCount = storedText.length;
                const finalSnippet = storedText ? (String(storedText).slice(0,20000)) : snippet;
                const finalText = storedText || fullText || '';
                chapters.push({ title: ch.title, uid: ch.uid, startPage: s, endPage: e, charCount: authCount, snippet: finalSnippet, text: finalText });
            }
            const payload = { savedAt: Date.now(), items: itemsToSave, chapters, meta }; const rec = { title: sanitizeTitle(meta.fileName || ('Saved '+new Date().toISOString())), meta: meta, payload }; const id = await idbPutBook(rec); log('saved textbook id', id); await refreshSavedList();
            // Flash saved state similar to the index MCQ button
            try{ tbSaveBtn.textContent = 'Saved'; tbSaveBtn.classList.add('saved'); setTimeout(()=>{ try{ tbSaveBtn.textContent = oldText || 'Save'; tbSaveBtn.classList.remove('saved'); }catch(e){} }, 1200); }catch(e){}
        }catch(e){ log('save failed', e?.message||e); } document.getElementById('tbSaveBtn').disabled=false; });

    // initial refresh
    refreshSavedList().catch(err=> log('initial saved list refresh failed', err?.message||err));

    // Wire bulk export button for localStorage saved MCQs
    try{ document.getElementById('exportAllSavedBtn')?.addEventListener('click', (e)=>{ e.preventDefault(); exportAllLocalSaved(); }); }catch(e){ console.warn('exportAllLocalSaved wiring failed', e); }

        // Wire savedSelect change
        document.getElementById('savedSelect')?.addEventListener('change', ()=>{ const id = document.getElementById('savedSelect').value; const has = !!id; const tbShowBtn = document.getElementById('tbShowBtn'); document.getElementById('tbShowBtn').disabled = !has; document.getElementById('tbDeleteBtn').disabled = !has; if(tbShowBtn){ tbShowBtn.dataset.visible = '0'; tbShowBtn.textContent = 'Show'; const savedDetails = document.getElementById('savedDetails'); if(savedDetails) savedDetails.style.display = 'none'; } });
        // Keep inline trigger label in sync when the hidden select value changes
        (function(){ const hidden = document.getElementById('savedSelect'); const trigger = document.getElementById('savedSelectInline'); const list = document.getElementById('savedSelectList'); if(!hidden || !trigger) return; hidden.addEventListener('change', ()=>{ try{ const v = hidden.value || ''; const opt = list ? list.querySelector(`.custom-inline-item[data-id="${v}"]`) : null; trigger.querySelector('.inline-selected').textContent = opt ? opt.textContent : '(none)'; }catch(e){} }); })();
        // Wire inline trigger: toggle list and keyboard handling
        (function(){
            const trigger = document.getElementById('savedSelectInline'); const list = document.getElementById('savedSelectList'); const hidden = document.getElementById('savedSelect'); if(!trigger || !list || !hidden) return;
            // open/close (use fixed positioning and compute coordinates to avoid ancestor clipping)
            // We'll portal the list node to document.body while open so transforms/overflow on ancestors
            // cannot clip it. Store the original parent so we can restore it on close.
            const _origParent = list.parentElement;
            const _placeholder = document.createElement('div'); _placeholder.style.display = 'none';
            // helpers for repositioning while open
            let _rafScheduled = null;
            let _boundHandlers = null;
            const applyPosition = ()=>{
                try{
                    const rect = trigger.getBoundingClientRect();
                    // Match trigger width exactly
                    const width = Math.round(rect.width);
                    list.style.boxSizing = 'border-box';
                    list.style.width = width + 'px';
                    list.style.minWidth = width + 'px';
                    list.style.maxWidth = ''; 
                    
                    // measure after width applied
                    const lr = list.getBoundingClientRect();
                    let left = Math.round(rect.left);
                    // Prefer below the trigger only (do not flip above)
                    let top = Math.round(rect.bottom + 6);
                    // If it would overflow bottom, reduce max-height rather than flipping
                    if(top + lr.height > window.innerHeight - 8){
                        const available = Math.max(80, window.innerHeight - top - 8);
                        list.style.maxHeight = available + 'px';
                    } else {
                        list.style.maxHeight = '';
                    }
                    // Keep inside viewport horizontally
                    if(left + lr.width > window.innerWidth - 8){
                        left = Math.max(8, Math.round(window.innerWidth - lr.width - 8));
                    }
                    if(left < 8) left = 8;
                    list.style.left = left + 'px';
                    list.style.top = top + 'px';
                }catch(e){}
            };

            // schedule a single rAF to coalesce many events
            const schedulePosition = ()=>{
                if(_rafScheduled) return;
                _rafScheduled = requestAnimationFrame(()=>{ _rafScheduled = null; applyPosition(); });
            };

            const startRepositionLoop = ()=>{
                if(_boundHandlers) return;
                // Use event listeners (capture) so we catch scrolls on any ancestor. Debounce with rAF.
                const h = (ev)=>{ try{ schedulePosition(); }catch(e){} };
                _boundHandlers = { resize: h, scroll: h, wheel: h, touchmove: h };
                window.addEventListener('resize', h);
                window.addEventListener('scroll', h, true);
                window.addEventListener('wheel', h, { passive: true, capture: true });
                window.addEventListener('touchmove', h, { passive: true, capture: true });
                // Observe trigger size/position changes in case layout shifts (ResizeObserver is well-supported)
                try{
                    _boundHandlers.ro = new ResizeObserver(()=> schedulePosition());
                    _boundHandlers.ro.observe(trigger);
                }catch(e){}
            };

            const stopRepositionLoop = ()=>{
                try{
                    if(_rafScheduled){ cancelAnimationFrame(_rafScheduled); _rafScheduled = null; }
                    if(_boundHandlers){
                        window.removeEventListener('resize', _boundHandlers.resize);
                        window.removeEventListener('scroll', _boundHandlers.scroll, true);
                        window.removeEventListener('wheel', _boundHandlers.wheel, { passive: true, capture: true });
                        window.removeEventListener('touchmove', _boundHandlers.touchmove, { passive: true, capture: true });
                        try{ if(_boundHandlers.ro){ _boundHandlers.ro.disconnect(); } }catch(e){}
                        _boundHandlers = null;
                    }
                }catch(e){}
            };

            const close = ()=>{
                try{ trigger.setAttribute('aria-expanded','false'); }catch(e){}
                try{
                    // hide
                    list.classList.add('hidden');
                    list.style.left = '';
                    list.style.top = '';
                    list.style.width = '';
                    list.style.visibility = '';
                    list.style.position = '';
                    list.style.zIndex = '';
                    // stop reposition loop
                    stopRepositionLoop();
                    // restore into original container if we moved it and remove the placeholder
                    try{ if(_placeholder.parentElement){ _placeholder.parentElement.removeChild(_placeholder); } }catch(e){}
                    try{
                        if(_origParent && _origParent !== list.parentElement){ _origParent.appendChild(list); }
                    }catch(e){}
                }catch(e){}
            };

            const open = ()=>{
                try{ trigger.setAttribute('aria-expanded','true'); }catch(e){}
                try{
                    // Portal the list to document.body while open so it can escape any ancestor
                    // stacking contexts or overflow clipping. Insert a placeholder so we can restore later.
                    try{
                        if(list.parentElement !== document.body){
                            try{ if(list.parentElement){ list.parentElement.insertBefore(_placeholder, list); } }catch(e){}
                            document.body.appendChild(list);
                        }
                    }catch(e){}
                    // Prepare for measurement using viewport-fixed positioning
                    list.classList.remove('hidden');
                    list.style.position = 'fixed';
                    list.style.visibility = 'hidden';
                    // Place the list just below the light-mode overlay (2147483646) so it inverts with the rest of the page
                    list.style.zIndex = '2147483645';
                    // Compute size/position in the next frame and show
                    applyPosition();
                    list.style.visibility = 'visible';
                    try{ list.focus(); }catch(e){}
                    // Begin tracking scroll/resize to keep the portal aligned
                    startRepositionLoop();
                }catch(e){ try{ list.classList.remove('hidden'); list.style.visibility='visible'; }catch(_){} }
            };
            trigger.addEventListener('click', (e)=>{ const expanded = trigger.getAttribute('aria-expanded') === 'true'; if(expanded) close(); else open(); });
            // keyboard: Enter/Space opens, Arrow keys navigate, Escape closes
            trigger.addEventListener('keydown', (e)=>{
                if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); const expanded = trigger.getAttribute('aria-expanded') === 'true'; if(expanded) close(); else open(); }
                if(e.key === 'ArrowDown'){ e.preventDefault(); open(); const first = list.querySelector('.custom-inline-item'); if(first) first.focus(); }
            });
            list.addEventListener('keydown', (e)=>{
                const items = Array.from(list.querySelectorAll('.custom-inline-item'));
                const idx = items.findIndex(n=> n === document.activeElement);
                if(e.key === 'ArrowDown'){ e.preventDefault(); const nxt = items[Math.min(items.length-1, Math.max(0, idx+1))]; if(nxt) nxt.focus(); }
                else if(e.key === 'ArrowUp'){ e.preventDefault(); const prev = items[Math.min(items.length-1, Math.max(0, idx-1))]; if(prev) prev.focus(); }
                else if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); if(document.activeElement && document.activeElement.classList.contains('custom-inline-item')) document.activeElement.click(); }
                else if(e.key === 'Escape'){ e.preventDefault(); close(); trigger.focus(); }
            });
            // click outside to close
            document.addEventListener('click', (ev)=>{ if(!trigger.contains(ev.target) && !list.contains(ev.target)){ close(); } });
        })();

        // toggleSavedList removed — Show/Hide functionality is handled by the TB Show button

        // Drag/drop receive helper (allow files to be dropped into page to trigger file inputs elsewhere)
        ['dragover','drop'].forEach(ev=> document.addEventListener(ev, (e)=>{ e.preventDefault(); }));
        document.addEventListener('drop', (e)=>{ if(e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length){ const fileEl = document.getElementById('file') || document.getElementById('tbFile'); if(fileEl){ try{ fileEl.files = e.dataTransfer.files; fileEl.dispatchEvent(new Event('change')); }catch(e){ } } } });

    // Small helper used above
    function sanitizeTitle(s){ return String(s||'').replace(/[\\/:*?"<>|\x00-\x1F]/g,'_').replace(/\s+/g,' ').trim().slice(0,180); }
    })();
    </script>

        <!-- === AI Like-Question Generator (start-only) === -->
    <section id="ai-likeq-copy" class="card pad ai-likeq ai-likeq-copy-panel">
            <div class="flex col center gap-8">
                <div class="key-badge missing" id="globalKeyBadge2" title="Shows whether a Gemini API key is present"><span class="dot"></span><span class="hint">No key set</span></div>
                <div id="validatorActionRow" class="flex center gap-12">
                <button id="aiLikeBtn2" class="btn primary btn-wide" disabled>Validate Answers (AI)</button>
                <!-- Apply corrections button moved here so it appears inside the same card/action area -->
                <button id="validatorApplyBtnGlobal" class="btn primary hidden ml-8">Apply corrections to text</button>
                </div>
            </div>
            <div class="hint mt-8 text-center">
                Validates each ANSWER KEY entry against its question options. Outputs a single-line summary (CORRECT / INCORRECT counts) followed by only the incorrectly keyed questions and their correct answers into the box below.
            </div>
            <div id="aiLikeStatus2" class="hint mt-8 text-center"></div>
                        <div id="aiValidateOutput2" class="hint mt-12" role="status" aria-live="polite"></div>
                        <div id="aiValidateActions" class="mt-8 flex justify-start gap-8"></div>
                        <!-- global apply button intentionally moved into the ai-like header so it's visible inside the card (see header markup) -->
        </section>

<script>
// Textbook Library: client-side extract + chapter segmentation + drag-drop integration
(function(){
    const $ = (id)=> document.getElementById(id);
    const LS = 'textbook.lib.v1';
    const tbFiles = $('tbFiles'); const tbName = $('tbFilesName'); const tbTree = $('tbTree'); const tbStatus = $('tbStatus'); const tbClear = $('tbClearBtn'); const tbDebug = $('tbDebug'); const tbProcess = $('tbProcessBtn');
    // safe global status updater for textbook module (guard against scope issues)
    try{ window.setTextbookStatus = window.setTextbookStatus || function(t, bad){ try{ const el = document.getElementById('tbStatus'); if(el){ el.textContent = t||''; el.style.color = bad? 'var(--bad)' : ''; } else { console.log('[TB status]', t); } }catch(e){ console.log('[TB status error]', e); } }; }catch(e){}

    // --- IndexedDB helpers for fallback storage when localStorage quota is exceeded ---
    function idbOpen(){
        return new Promise((res, rej)=>{
            try{
                const req = indexedDB.open('textbook_lib_v1', 1);
                req.onupgradeneeded = ()=>{ const db = req.result; if(!db.objectStoreNames.contains('books')) db.createObjectStore('books', { keyPath: 'id', autoIncrement: true }); };
                req.onsuccess = ()=> res(req.result);
                req.onerror = ()=> rej(req.error || new Error('idb open failed'));
            }catch(e){ rej(e); }
        });
    }
    async function idbPutBook(book){ try{ const db = await idbOpen(); return await new Promise((res, rej)=>{ const tx = db.transaction('books','readwrite'); const store = tx.objectStore('books'); const r = store.add(book); r.onsuccess = ()=> res(r.result); r.onerror = ()=> rej(r.error||new Error('idb add failed')); }); }catch(e){ throw e; } }
    // Update existing book record (uses put so object with id will replace)
    async function idbUpdateBook(book){ try{ const db = await idbOpen(); return await new Promise((res, rej)=>{ const tx = db.transaction('books','readwrite'); const store = tx.objectStore('books'); const r = store.put(book); r.onsuccess = ()=> res(r.result); r.onerror = ()=> rej(r.error||new Error('idb put failed')); }); }catch(e){ throw e; } }
    async function idbGetBook(id){ try{ const db = await idbOpen(); return await new Promise((res, rej)=>{ const tx = db.transaction('books','readonly'); const store = tx.objectStore('books'); const r = store.get(Number(id)); r.onsuccess = ()=> res(r.result); r.onerror = ()=> rej(r.error||new Error('idb get failed')); }); }catch(e){ throw e; } }
    // Ensure the visible 'Add Textbook' button triggers the hidden file input (robust click wiring)
    try{ const choose = document.querySelector('label.choose-btn[for="tbFiles"]'); if(choose){ choose.addEventListener('click', (ev)=>{ ev.preventDefault(); tbFiles && tbFiles.click(); }); } }catch(e){ /* ignore */ }
    if(!tbTree) return;
    function logDbg(...args){ try{ const s = args.map(a=> typeof a==='string'? a : JSON.stringify(a)).join(' '); if(tbDebug){ tbDebug.textContent = (new Date()).toLocaleTimeString() + ' ' + s + "\n" + tbDebug.textContent; } else { console.log('[TB]', ...args); } }catch(e){ console.log('[TB]', ...args); } }
    function loadLib(){ try{ const raw = localStorage.getItem(LS); return raw? JSON.parse(raw): []; }catch{ return []; } }
    function saveLib(arr){ try{ localStorage.setItem(LS, JSON.stringify(arr||[])); return true; }catch(e){ logDbg('saveLib failed', e?.message||e); setStatus('Could not save library to this device (storage full or blocked). Data kept in memory for this session.', true); return false; } }
    // expose helpers for other modules to reuse (safe no-op if overwritten)
    try{ window.loadTextbookLib = window.loadTextbookLib || loadLib; window.saveTextbookLib = window.saveTextbookLib || saveLib; window.setTextbookStatus = window.setTextbookStatus || setStatus; }catch(e){}
    function setStatus(t, bad){ if(tbStatus){ tbStatus.textContent = t||''; tbStatus.style.color = bad? 'var(--bad)' : ''; } }

    // --- Resilient CDN/script loader helpers ---
    async function loadScriptWithFallbacks(pairs){
        // pairs: [{script, worker?, onload?}]
        for(const p of pairs){
            try{
                await new Promise((res, rej)=>{
                    const s = document.createElement('script');
                    s.src = p.script; s.async = true; s.onload = ()=> res(); s.onerror = ()=> rej(new Error('load failed'));
                    document.head.appendChild(s);
                });
                if(typeof p.onload === 'function'){ await p.onload(); }
                logDbg('cdn loaded', p.script);
                return p; // return the winning pair
            }catch(e){ logDbg('cdn failed', p.script); }
        }
        return null;
    }

    async function ensurePdfJs(){
        if(window.pdfjsLib && window.pdfjsLib.getDocument) return true;
        const VER = '4.2.67';
        const candidates = [
            { script: `https://cdn.jsdelivr.net/npm/pdfjs-dist@${VER}/build/pdf.min.js`, worker: `https://cdn.jsdelivr.net/npm/pdfjs-dist@${VER}/build/pdf.worker.min.js` },
            { script: `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${VER}/pdf.min.js`, worker: `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${VER}/pdf.worker.min.js` },
            { script: `https://unpkg.com/pdfjs-dist@${VER}/build/pdf.min.js`, worker: `https://unpkg.com/pdfjs-dist@${VER}/build/pdf.worker.min.js` },
        ];
        const picked = await loadScriptWithFallbacks(candidates.map(c=>({ script:c.script })));
        if(picked && window.pdfjsLib){ try{ window.pdfjsLib.GlobalWorkerOptions.workerSrc = candidates.find(c=> c.script===picked.script)?.worker || ''; }catch{} return true; }
        logDbg('pdf.js could not be loaded from any CDN');
        return false;
    }

    async function ensureTesseract(){
        if(window.Tesseract && window.Tesseract.recognize) return true;
        const VER = '4.1.1';
        const candidates = [
            { script: `https://cdn.jsdelivr.net/npm/tesseract.js@${VER}/dist/tesseract.min.js` },
            { script: `https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/${VER}/tesseract.min.js` },
            { script: `https://unpkg.com/tesseract.js@${VER}/dist/tesseract.min.js` },
        ];
        const picked = await loadScriptWithFallbacks(candidates);
        if(picked && window.Tesseract){ return true; }
        logDbg('tesseract.js could not be loaded from any CDN');
        return false;
    }

    async function ensurePako(){
        if(window.pako && window.pako.inflate) return true;
        const VER = '2.1.0';
        const candidates = [
            { script: `https://cdn.jsdelivr.net/npm/pako@${VER}/dist/pako.min.js` },
            { script: `https://cdnjs.cloudflare.com/ajax/libs/pako/${VER}/pako.min.js` },
            { script: `https://unpkg.com/pako@${VER}/dist/pako.min.js` },
        ];
        const picked = await loadScriptWithFallbacks(candidates);
        if(picked && window.pako){ return true; }
        logDbg('pako could not be loaded from any CDN');
        return false;
    }

    function decodeHexString(hex){
        const clean = (hex||'').replace(/[^0-9a-fA-F]/g,'');
        if(clean.length < 2) return '';
        const bytes = [];
        for(let i=0;i<clean.length;i+=2){ bytes.push(parseInt(clean.slice(i,i+2),16)); }
        // UTF-16BE BOM handling
        if(bytes.length>=2 && bytes[0]===0xFE && bytes[1]===0xFF){
            let s=''; for(let i=2;i+1<bytes.length;i+=2){ s += String.fromCharCode((bytes[i]<<8)|bytes[i+1]); }
            return s;
        }
        return String.fromCharCode(...bytes);
    }

    function extractLiteralStrings(s){
        const out=[]; let i=0; const n=s.length;
        while(i<n){
            if(s[i]==='('){
                i++; let buf=''; let depth=1; while(i<n && depth>0){
                    const ch = s[i++];
                    if(ch==='\\'){ // escape
                        const nxt = s[i++]||''; if(nxt){
                            if(/[0-7]/.test(nxt)){ // octal sequence \ddd
                                let oct=nxt; for(let k=0;k<2 && /[0-7]/.test(s[i]);k++){ oct+=s[i++]; }
                                buf += String.fromCharCode(parseInt(oct,8));
                            }else{ const map={n:'\n', r:'\r', t:'\t', b:'\b', f:'\f', '(':'(', ')':')', '\\':'\\'}; buf += (map[nxt]??nxt); }
                        }
                        continue;
                    } else if(ch==='('){ depth++; buf += ch; }
                    else if(ch===')'){ depth--; if(depth>0) buf += ch; }
                    else { buf += ch; }
                }
                if(buf) out.push(buf);
            } else { i++; }
        }
        return out;
    }

    async function pdfFallbackExtractStrings(ab){
        const limitChars = 400000; // cap like the primary path
        const u8 = new Uint8Array(ab);
        const latin1 = new TextDecoder('latin1');
        const txts = [];
        const whole = latin1.decode(u8);
        // Collect candidate streams
        let idx = 0; let streams = 0; let decompressed = 0;
        while((idx = whole.indexOf('stream', idx)) !== -1){
            // Find endstream and slice raw bytes; account for CRLF after 'stream'
            let start = idx + 6; if(whole[start]==='\r' && whole[start+1]==='\n') start+=2; else if(whole[start]==='\n') start+=1;
            const end = whole.indexOf('endstream', start);
            if(end === -1) break;
            const raw = u8.subarray(start, end);
            let contents='';
            // Try inflate; if fails, fall back to latin1 plain
            try{ if(await ensurePako()){ const infl = window.pako.inflate(raw); contents = latin1.decode(infl); decompressed++; } }catch{ contents = latin1.decode(raw); }
            streams++;
            // Extract literal strings and hex strings
            const lits = extractLiteralStrings(contents);
            lits.forEach(s=> { if(s) txts.push(s); });
            const hexRe = /<([0-9A-Fa-f\s]+)>\s*(?:T[Jj]|TJ|Tj)/g; let m;
            while((m = hexRe.exec(contents))){ const decoded = decodeHexString(m[1]); if(decoded) txts.push(decoded); }
            if(txts.join(' ').length > limitChars) break;
            idx = end+9;
        }
        // If nothing from streams, try the whole file for stray literal strings
        if(txts.length===0){ extractLiteralStrings(whole).forEach(s=> txts.push(s)); }
        const out = txts.join('\n').replace(/\s+/g,' ').replace(/\s*\n\s*/g,'\n').trim();
        logDbg('pdf fallback streams', streams, 'inflated', decompressed, 'chars', out.length);
        return out;
    }

    // Simple segmentation heuristics: detect Chapter/Section headings and build nested structure
    function segmentChapters(text){
        const lines = (text||'').split(/\r?\n/);
        const chapters = [];
        let cur = null;
        let sub = null;
        function pushSub(){ if(cur && sub){ cur.sub.push(sub); sub = null; } }
        function pushCur(){ if(cur){ pushSub(); chapters.push(cur); cur = null; } }
        for(const raw of lines){
            const line = raw.trim(); if(!line) continue;
            const chap = line.match(/^(Chapter\s+\d+\b\.?|^\d+\.)\s*(.+)$/i);
            const sect = line.match(/^(Section\s+\d+(?:\.\d+)*\b\.?|^\d+\.\d+)\s*(.+)$/i);
            if(chap){
                pushCur();
                cur = { title: chap[0].replace(/\.$/, ''), text: '', sub: [] };
                continue;
            }
            if(sect){
                if(!cur){ cur = { title: 'Chapter', text:'', sub: [] }; }
                pushSub();
                sub = { title: sect[0].replace(/\.$/, ''), text: '' };
                continue;
            }
            if(sub){ sub.text += (sub.text? '\n':'') + raw; }
            else if(cur){ cur.text += (cur.text? '\n':'') + raw; }
        }
        pushCur();
        // Fallback if nothing detected: chunk into ~8-12k char pieces to keep drag manageable
        if(chapters.length===0){
            const CHUNK = 10000; // ~10k chars per chunk
            if(!text || !text.trim()) return [{ title:'Document (empty)', text:'', sub:[] }];
            for(let i=0;i<text.length;i+=CHUNK){
                const slice = text.slice(i, i+CHUNK);
                chapters.push({ title: `Segment ${Math.floor(i/CHUNK)+1}`, text: slice, sub:[] });
            }
        }
        return chapters;
    }

    async function ensureExtractors(){
        // Reuse existing extractors loaded by AI file gen block
        return true;
    }

    async function extractTextFromFile(file){
        // Reuse the AI file gen extractors to avoid code duplication
        await ensureExtractors();
        // Minimal inline extraction using the same libraries loaded on demand there
        const name = file?.name||'file'; const lower = name.toLowerCase();
        logDbg('extract start', name);
        if(/\.txt$/i.test(lower)) { const t = await file.text(); logDbg('txt bytes', t.length); return t; }
        if(/\.docx$/i.test(lower)){
            const ab = await file.arrayBuffer();
            try{
                if(!(window.mammoth && window.mammoth.convertToHtml)){
                    await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src='https://unpkg.com/mammoth@1.6.0/mammoth.browser.min.js'; s.onload=res; s.onerror=()=>rej(new Error('mammoth load failed')); document.head.appendChild(s); });
                }
                const res = await window.mammoth.convertToHtml({ arrayBuffer: ab });
                const html = (res && res.value) || '';
                const out = html.replace(/<[^>]+>/g,' ').replace(/\s+/g,' ').replace(/\s*\n\s*/g,'\n').trim();
                logDbg('docx mammoth chars', out.length);
                return out;
            }catch{
                if(!window.JSZip){ await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js'; s.onload=res; s.onerror=()=>rej(new Error('jszip load failed')); document.head.appendChild(s); }); }
                const zip = await window.JSZip.loadAsync(ab);
                const entry = zip.file('word/document.xml');
                const xml = await entry.async('string');
                const out = xml.replace(/<w:p[^>]*>/g, '\n').replace(/<w:tab\b[^>]*\/>/g,' ').replace(/<w:t[^>]*>(.*?)<\/w:t>/g,'$1').replace(/<[^>]+>/g,' ').replace(/\s+/g,' ').trim();
                logDbg('docx xml chars', out.length);
                return out;
            }
        }
        if(/\.pdf$/i.test(lower)){
            const ab = await file.arrayBuffer();
            let havePdfJs = await ensurePdfJs();
            if(havePdfJs && window.pdfjsLib && window.pdfjsLib.getDocument){
                try{
                    const pdf = await window.pdfjsLib.getDocument({ data: ab, disableFontFace:true, useSystemFonts:true }).promise; const parts=[]; logDbg('pdf pages', pdf.numPages);
                    let extractedChars = 0; const SOFT_LIMIT = 400000; // ~400k chars cap for memory/perf
                    for(let p=1;p<=pdf.numPages;p++){
                        const page = await pdf.getPage(p);
                        let pageText = '';
                        try{
                            const c = await page.getTextContent({ normalizeWhitespace:true, disableCombineTextItems:false });
                            pageText = c.items.map(it=> it.str).join(' ').replace(/\s+/g,' ').trim();
                        }catch(e){ logDbg('pdf textContent failed page', p, e?.message||e); }
                        if(pageText) { parts.push(pageText); extractedChars += pageText.length; }
                        if(extractedChars > SOFT_LIMIT) { logDbg('pdf soft limit reached'); break; }
                        if(p % 10 === 0) await new Promise(r=> setTimeout(r, 0));
                    }
                    let out = parts.join('\n');
                    logDbg('pdf chars (text extraction)', out.length);
                    const wantOcr = !!document.getElementById('tbOcrToggle')?.checked;
                    const ocrMax = parseInt(document.getElementById('tbOcrMax')?.value||'8',10) || 8;
                    if(out.length < 800 && wantOcr){
                        logDbg('pdf appears image-only, starting OCR up to', ocrMax, 'pages');
                        const ok = await ensureTesseract();
                        if(ok){
                            const ocrParts=[]; const dpi = 160;
                            for(let p=1; p<=Math.min(pdf.numPages, ocrMax); p++){
                                try{
                                    const page = await pdf.getPage(p);
                                    const viewport = page.getViewport({ scale: 1.5 });
                                    const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d', { willReadFrequently:true });
                                    canvas.width = Math.floor(viewport.width * (dpi/96));
                                    canvas.height = Math.floor(viewport.height * (dpi/96));
                                    await page.render({ canvasContext: ctx, viewport }).promise;
                                    const dataUrl = canvas.toDataURL('image/png');
                                    const res = await window.Tesseract.recognize(dataUrl, 'eng');
                                    const txt = (res && res.data && res.data.text) ? res.data.text : '';
                                    if(txt && txt.trim()) ocrParts.push(txt.trim());
                                    canvas.width = canvas.height = 0;
                                }catch(e){ logDbg('ocr page failed', p, e?.message||e); }
                                await new Promise(r=> setTimeout(r, 0));
                            }
                            const ocrText = ocrParts.join('\n');
                            logDbg('ocr chars', ocrText.length);
                            if(ocrText.length > out.length) out = ocrText;
                        } else {
                            logDbg('OCR skipped: tesseract unavailable');
                        }
                    }
                    return out;
                }catch(e){ logDbg('pdf.js extract failed, falling back', e?.message||e); }
            }
            // Fallback path: parse strings directly from PDF content streams
            const fallbackText = await pdfFallbackExtractStrings(ab);
            if(fallbackText && fallbackText.length){ return fallbackText; }
            logDbg('pdf fallback got no text');
            return '';
        }
        if(/\.pptx$/i.test(lower)){
            if(!window.JSZip){ await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js'; s.onload=res; s.onerror=()=>rej(new Error('jszip load failed')); document.head.appendChild(s); }); }
            const ab = await file.arrayBuffer(); const zip = await window.JSZip.loadAsync(ab);
            const names = Object.keys(zip.files).filter(n=>/^ppt\/slides\/slide\d+\.xml$/i.test(n)).sort((a,b)=>parseInt(a.match(/slide(\d+)/i)[1])-parseInt(b.match(/slide(\d+)/i)[1])); logDbg('pptx slides', names.length);
            const chunks=[]; for(const n of names){ const xml = await zip.file(n).async('string'); const t = xml.replace(/<a:br\s*\/>/gi,'\n').replace(/<a:p[^>]*>/gi,'\n').replace(/<a:t[^>]*>([\s\S]*?)<\/a:t>/gi,'$1').replace(/<[^>]+>/g,' ').replace(/\s+/g,' ').trim(); if(t) chunks.push(t); if(chunks.join(' ').length>200000) break; }
            const out = chunks.join('\n\n'); logDbg('pptx chars', out.length); return out;
        }
        const t = await file.text(); logDbg('fallback text chars', t.length); return t;
    }

    // --- Lightweight TOC scanner (uses pdf.js if available) ---
    const tbScanBtn = $('tbScanBtn'); const tbTocTree = $('tbTocTree'); const tbLog = $('tbLog'); const tbMetaName = $('tbMetaName'); const tbMetaPages = $('tbMetaPages'); const tbMetaBytes = $('tbMetaBytes');

    function tbLogLine(...a){ try{ if(tbLog) tbLog.textContent = (new Date()).toLocaleTimeString() + ' ' + a.join(' ') + '\n' + tbLog.textContent; else console.log(...a); }catch(e){ console.log(...a); } }

    // sanitize title text for display (remove control/unprintable chars)
    function tbSanitizeTitle(s){ if(!s && s !== 0) return ''; try{ return String(s).replace(/[\x00-\x1F\x7F-\x9F\uFFFD]/g,'').replace(/[\\/:*?"<>|]/g,'').replace(/\s+/g,' ').trim().slice(0,180); }catch(e){ return String(s||'').trim(); } }

    function tbFlattenOutline(outl){
        const arr = [];
        function walk(items, depth){
            if(!items) return;
            for(const it of items){
                const rawTitle = it && it.title ? it.title : 'Untitled';
                const node = { title: tbSanitizeTitle(rawTitle), raw: it, depth };
                arr.push(node);
                if(it.items && it.items.length) walk(it.items, depth+1);
            }
        }
        walk(outl, 0);
        return arr;
    }

    function tbDetectChapterDepth(arr){ if(!arr || !arr.length) return 0; const score={}; const reNum=/^\s*(?:Chapter\b|Ch\.|\d+[.):]|[IVXLCDM]+[.):]|\d+\s)/i; for(const it of arr){ const d=it.depth||0; score[d]=(score[d]||0)+(reNum.test(it.title)?1:0); } let best=-1,bd=0; for(const k in score){ if(score[k]>best){ best=score[k]; bd=parseInt(k,10); } } return best>0?bd:0; }

    async function tbResolveDestToPageIndex(pdf, dest){ try{ if(!dest) return null; let resolved=null; try{ if(typeof dest === 'string') resolved = await pdf.getDestination(dest); else if(Array.isArray(dest)) resolved = dest; else if(dest && dest.getArray) resolved = await dest.getArray(); }catch{} if(!resolved && dest && dest.num) resolved=[dest]; if(!resolved) return null; const ref = resolved[0]; if(!ref) return null; const idx = await pdf.getPageIndex(ref); return idx; }catch(e){ tbLogLine('resolve fail', e?.message||e); return null; } }

    async function tbExtractPageText(pdf, pnum){ try{ const page = await pdf.getPage(pnum); const txt = await page.getTextContent({ normalizeWhitespace:true, disableCombineTextItems:false, includeMarkedContent:true }); const s = txt.items.map(it=> it.str||'').join(' ').replace(/\s+/g,' ').trim(); return s; }catch(e){ tbLogLine('page extract failed', pnum, e?.message||e); return ''; } }

    function tbComputeChapterRanges(entries, chapterDepth, numPages){ const chapters = entries.filter(e=> Number.isFinite(e.page) && e.depth===chapterDepth).sort((a,b)=>a.page-b.page); for(let i=0;i<chapters.length;i++){ const start=chapters[i].page; const end=(i<chapters.length-1)? chapters[i+1].page-1 : numPages; chapters[i].startPage=Math.max(1,start); chapters[i].endPage=Math.min(numPages,end); } return chapters; }

    async function tbBuildPageLengthCache(pdf, ranges){ if(!ranges || !ranges.length) return {}; const minP = Math.min(...ranges.map(r=>r.startPage)); const maxP = Math.max(...ranges.map(r=>r.endPage)); const cache={}; for(let p=minP;p<=maxP;p++){ try{ const t = await tbExtractPageText(pdf,p); cache[p]=t.length; }catch{ cache[p]=0; } await new Promise(r=>setTimeout(r,0)); } return cache; }

    function tbSumCharsFromCache(cache,start,end,limit){ let total=0; for(let p=start;p<=end;p++){ const len=cache[p]||0; if(limit && len>limit) continue; total+=len; } return total; }

    function tbRenderToc(arr, startDepth){ if(!tbTocTree) return; if(!arr||!arr.length){ tbTocTree.innerHTML='<div class="hint">(no TOC)</div>'; return; } const root=document.createElement('div'); root.setAttribute('role','tree'); let lastGroup=null; let groupEl = null; arr.forEach((it,idx)=>{ const d=it.depth; const indentBase = (startDepth!=null) ? Math.max(0, d-startDepth) : d; if(startDepth!=null && d===startDepth && lastGroup !== it.startPage){ // start a new group
            groupEl = document.createElement('div'); groupEl.setAttribute('role','group'); groupEl.className='group-wrapper'; const sep=document.createElement('div'); sep.className='group-sep'; groupEl.appendChild(sep); root.appendChild(groupEl); lastGroup = it.startPage; }
        const el=document.createElement('div'); el.className='tb-chapter'; el.style.paddingLeft=(indentBase*18)+'px'; el.setAttribute('role','treeitem'); const left=document.createElement('div'); left.textContent = `${String(idx+1).padStart(2,'0')} ${it.title}`; const meta=document.createElement('div'); meta.className='tb-meta'; meta.textContent = `pages ${it.startPage||'?'}-${it.endPage||'?'} • ${it.charCount||0} chars`; el.appendChild(left); el.appendChild(meta); if(groupEl) groupEl.appendChild(el); else root.appendChild(el); }); tbTocTree.innerHTML=''; tbTocTree.appendChild(root); }

    // Scan TOC for selected file (first selected file used)
    tbScanBtn?.addEventListener('click', async ()=>{
        const f = (tbFiles && tbFiles.files && tbFiles.files[0]) || null; if(!f){ setStatus('No file selected to scan.', true); return; }
        try{
            tbScanBtn.disabled = true; tbLogLine('Loading file', f.name);
            const ab = await f.arrayBuffer(); tbMetaName.textContent = f.name; tbMetaBytes.textContent = (f.size/1024/1024).toFixed(2)+' MB';
            const ok = await ensurePdfJs(); if(!ok){ tbLogLine('pdf.js not available'); tbScanBtn.disabled=false; return; }
            const pdf = await window.pdfjsLib.getDocument({ data: ab }).promise; tbMetaPages.textContent = pdf.numPages; tbLogLine('PDF loaded pages', pdf.numPages);
            const outline = await pdf.getOutline(); if(!outline || !outline.length){ tbLogLine('No outline/bookmarks found'); tbRenderToc([], null); tbScanBtn.disabled=false; return; }
            const flat = tbFlattenOutline(outline); tbLogLine('outline entries', flat.length);
            const detected = (Array.isArray(outline) && outline.some(it=> Array.isArray(it.items) && it.items.length>0)) ? 1 : tbDetectChapterDepth(flat);
            tbLogLine('detected chapter depth', detected);
            // resolve dests
            for(let i=0;i<flat.length;i++){ const it=flat[i]; try{ const pageIndex = await tbResolveDestToPageIndex(pdf, it.raw.dest || it.raw.destref || it.raw.a || it.raw.dest); it.page = pageIndex!=null ? pageIndex+1 : null; tbLogLine('resolved', it.title, '->', it.page); }catch(e){ it.page = null; } }
            const withPage = flat.filter(x=>Number.isFinite(x.page)).sort((a,b)=>a.page-b.page); const withoutPage = flat.filter(x=>!Number.isFinite(x.page)); const sorted = withPage.concat(withoutPage);
            const chapterEntries = tbComputeChapterRanges(sorted, detected, pdf.numPages);
            for(const e of sorted){ if(e.depth===detected){ const found = chapterEntries.find(c=> c===e || (c.title===e.title && c.page===e.page)); if(found){ e.startPage=found.startPage; e.endPage=found.endPage; } } else { e.startPage = e.page || 1; e.endPage = e.page || e.startPage; } }
            window.tbFullToc = sorted.map((s,idx)=> ({ uid: idx, order: idx+1, title: s.title, depth: s.depth, startPage: s.startPage, endPage: s.endPage, page: s.page }));
            // quick count
            const chaptersForCount = window.tbFullToc.filter(s=> s.depth===detected && Number.isFinite(s.startPage) && Number.isFinite(s.endPage));
            const cache = await tbBuildPageLengthCache(pdf, chaptersForCount);
            for(const s of window.tbFullToc){ if(s.depth===detected && s.startPage && s.endPage){ s.charCount = tbSumCharsFromCache(cache, s.startPage, s.endPage, null); } else { s.charCount = s.charCount||0; } }
            const flattened = window.tbFullToc.map(s=> ({ uid: s.uid, order: s.order, title: s.title, depth: s.depth, startPage: s.startPage, endPage: s.endPage, page: s.page, charCount: s.charCount }));
            const ds = parseInt($('depthStart')?.value||'0',10); tbRenderToc(flattened, Number.isFinite(ds)?ds:0);
            tbLogLine('scan complete');
        }catch(e){ tbLogLine('scan failed', e?.message||e); }
        tbScanBtn.disabled = false;
    });


    function renderTree(){
        const lib = loadLib();
    if(!lib.length){ tbTree.innerHTML = '<div class="hint">No saved content added yet.</div>'; return; }
        function nodeHtml(id, label, kind){ return `<span class="tb-chip" draggable="true" data-id="${id}" data-kind="${kind}">${label}</span>`; }
        tbTree.innerHTML = lib.map((book, bi)=>{
            const chHtml = (book.chapters||[]).map((ch, ci)=>{
                const subHtml = (ch.sub||[]).map((s, si)=> '<div class="tb-sub" data-path="'+bi+':'+ci+':'+si+'"><div>'+nodeHtml(bi+':'+ci+':'+si, s.title||('Section '+(ci+1)+'.'+(si+1)), 'sub')+'</div><div class="tb-meta">'+((s.text||'').length)+' chars</div></div>').join('');
                return '<div class="tb-chapter" data-path="'+bi+':'+ci+'"><div>'+nodeHtml(bi+':'+ci, ch.title||('Chapter '+(ci+1)), 'chapter')+'</div><div class="tb-meta">'+((ch.text||'').length)+' chars '+(subHtml? (' • '+((ch.sub||[]).length)+' sub') : '')+'</div>'+(subHtml? ('<div class="tb-chapters ml-12 mt-6">'+subHtml+'</div>') : '')+'</div>';
            }).join('');

            // Update header with aggregate size (show total KB next to the count)
            try{ savedCount.textContent = `${arr.length} (${(totalBytes/1024).toFixed(1)} KB)`; }catch(e){}
            // if this entry is a pointer to IndexedDB, show a placeholder and resolve asynchronously
            const bookTitleSafe = book.idbRef ? (book.title || ('Book '+(bi+1)+' (saved)')) : (book.title||('Book '+(bi+1)));
            // estimate size in bytes for display
            let estBytes = null;
            try{
                if(book.idbRef && book.chapters && book.chapters.length){
                    estBytes = book.chapters.reduce((acc,c)=> acc + ((c && (c.text||c.fullText||c.snippet)||'').length || 0), 0);
                } else if(book.text){ estBytes = (book.text||'').length; }
            }catch(e){ estBytes = null; }
            const sizeBadge = estBytes==null ? '' : (' • '+(estBytes/1024).toFixed(1)+' KB');
            const metaText = book.idbRef ? ('Stored (indexedDB id '+book.idbRef+') • '+((book.chapters||[]).length)+' chapters'+sizeBadge) : (((book.text||'').length)+' chars • '+((book.chapters||[]).length)+' chapters'+sizeBadge);
            const html = '<div class="tb-book" data-book="'+bi+'"><div class="tb-head"><div class="tb-title" data-book-idx="'+bi+'">'+bookTitleSafe+'</div><div class="tb-actions"><span class="tb-meta">'+metaText+'</span></div></div>' + (chHtml ? ('<div class="tb-chapters mt-6">'+chHtml+'</div>') : '') + '</div>';
            return html;
        }).join('');

        // Drag payload wiring
        tbTree.querySelectorAll('.tb-chip').forEach(ch=>{
            ch.addEventListener('dragstart', (e)=>{
                const id = ch.getAttribute('data-id'); const [bi, ci, si] = id.split(':').map(n=>parseInt(n,10));
                const lib2 = loadLib(); const book = lib2[bi]; if(!book) return;
                let title='', text='';
                if(si!=null && isFinite(si)) { const s = book?.chapters?.[ci]?.sub?.[si]; title = s?.title||'Section'; text = s?.text||''; }
                else if(ci!=null && isFinite(ci)) { const c = book?.chapters?.[ci]; title = c?.title||'Chapter'; text = [c?.text||'', ...(c?.sub||[]).map(x=>x.text||'')].filter(Boolean).join('\n\n'); }
                else {
                    // top-level book: if it's an idbRef pointer, try to fetch the full record synchronously via idbGetBook
                    if(book.idbRef){ title = book.title || 'Book'; text = ''; try{ idbGetBook(book.idbRef).then(full=>{ const payload = JSON.stringify({ title: full.title||book.title, text: (full.payload && full.payload.chapters ? (full.payload.chapters||[]).map(ch=> ch.text || ch.fullText || ch.snippet || '').join('\n\n') : ((full.chapters||[]).map(ch=> ch.text || ch.fullText || ch.snippet || '').join('\n\n'))) }); e.dataTransfer.setData('application/json', payload); }); }catch(e){ log('idbGetBook for drag failed', e?.message||e); } }
                    title = book.title||'Book';
                }
                const payload = JSON.stringify({ title, text });
                e.dataTransfer.setData('application/json', payload);
                e.dataTransfer.effectAllowed = 'copy';
            }); // end addEventListener('dragstart')
        }); // end forEach('.tb-chip')

        // Resolve idbRef titles asynchronously so UI shows friendly names
        (async ()=>{
            const nodes = tbTree.querySelectorAll('[data-book-idx]');
            for(const n of nodes){
                const idx = parseInt(n.getAttribute('data-book-idx'), 10);
                const lib2 = loadLib(); const book = lib2[idx];
                if(book && book.idbRef){ try{ const full = await idbGetBook(book.idbRef); if(full && full.title) n.textContent = full.title + ' (saved)'; }catch(e){ /* ignore */ } }
            }
        })();
    }
    // allow other parts of the page to refresh the saved textbook UI
    try{ window.refreshTextbookLibrary = window.refreshTextbookLibrary || renderTree; }catch(e){}

    // Upload handling: only record selection; processing happens on button click
    tbFiles?.addEventListener('change', ()=>{
        const files = Array.from(tbFiles.files||[]);
        tbName && (tbName.textContent = files.length? `${files.length} file(s)` : 'No files selected');
        if(!files.length){ setStatus(''); return; }
        logDbg('selected', files.map(f=>f.name));
        setStatus('Ready. Click “Process selected” to begin.');
    });

    // Process selected files on demand
    tbProcess?.addEventListener('click', async ()=>{
        const files = Array.from(tbFiles?.files||[]);
        if(!files.length){ setStatus('No files selected.', true); return; }
        tbProcess.disabled = true; const origLabel = tbProcess.textContent; tbProcess.textContent = 'Processing…';
        setStatus('Extracting…'); logDbg('process begin', files.map(f=>f.name));
        const lib = loadLib(); let added = 0;
        for(let i=0;i<files.length;i++){
            const f = files[i];
            try{
                setStatus(`(${i+1}/${files.length}) ${f.name}…`); logDbg('processing', f.name, f.type||'');
                const text = await extractTextFromFile(f);
                const chapters = segmentChapters(text);
                lib.push({ title: f.name.replace(/\.[^.]+$/, ''), text, chapters });
                added++;
            }catch(e){ console.warn('extract failed', f?.name, e); logDbg('extract failed', f?.name, e?.message||e); }
        }
        const saved = saveLib(lib);
        renderTree();
        setStatus(added? 'Done.' : 'No content extracted. Try another file.', !added);
        tbProcess.textContent = origLabel; tbProcess.disabled = false;
    });

    tbClear?.addEventListener('click', ()=>{ if(confirm('Clear content library?')){ saveLib([]); renderTree(); setStatus('Cleared.'); } });

    // Drop integration: Validate Answers and Generate MCQ
    function makeDropzone(el, onDrop){ if(!el) return; ['dragenter','dragover'].forEach(ev=> el.addEventListener(ev, (e)=>{ e.preventDefault(); el.classList.add('hover'); e.dataTransfer.dropEffect='copy'; })); ['dragleave','dragend','drop'].forEach(ev=> el.addEventListener(ev, ()=> el.classList.remove('hover'))); el.addEventListener('drop', (e)=>{ e.preventDefault(); try{ const json = e.dataTransfer.getData('application/json'); if(!json) return; const data = JSON.parse(json); onDrop && onDrop(data); }catch{} }); }

    // Validate Answers dropzone (under output/actions area)
    (function(){
        const actions = document.getElementById('aiValidateActions');
        if(!actions || actions.dataset.tbDropWired==='1') return; actions.dataset.tbDropWired='1';
    const dz = document.createElement('div'); dz.id='tbDropValidate'; dz.className='dropzone'; dz.textContent='Drop content chapters here to supplement Validate Answers'; actions.appendChild(dz);
        const ctx = { pieces: [] };
        makeDropzone(dz, (data)=>{
            if(!data || !data.text) return; ctx.pieces.push(data); dz.textContent = `Attached ${ctx.pieces.length} chapter(s).`;
        });
        // Hook the Validate button to include context
        const vBtn = document.getElementById('aiLikeBtn2');
        if(vBtn && !vBtn.dataset.tbAug){
            vBtn.dataset.tbAug='1';
            const origHandler = vBtn.onclick; // not used in current wiring (addEventListener used)
            // Monkey-patch the generator to read extra context in prompt build
            const originalFetch = window.GoogleGenerativeAI;
            // Instead of patching SDK, patch the click handler path by intercepting prompt creation via a global flag
            window.__tbValidateCtx = ctx;
        }
        // Patch prompt usage inside validate block by wrapping model.generateContent
        const wrapGen = async (key, promptBuilder)=>{
            const AI = window.GoogleGenerativeAI; const client = new AI(key); const model = client.getGenerativeModel({ model: 'gemini-2.5-flash' });
            const extra = (window.__tbValidateCtx?.pieces||[]).map(p=> p.text).join('\n\n');
            const prompt = promptBuilder(extra);
            const resp = await model.generateContent({ contents: [{ role:'user', parts:[{ text: prompt }] }] });
            return (await resp?.response?.text?.())?.trim();
        };
        // Expose for validate module to call
        window.__tbWrapGen = wrapGen;
    })();

    // Generate MCQ drop target: attach to the AI file panel status area
    (function(){
        const status = document.getElementById('aiFileStatus'); if(!status || status.dataset.tbDropWired==='1') return; status.dataset.tbDropWired='1';
    const dz = document.createElement('div'); dz.id='tbDropGenerate'; dz.className='dropzone mt-8'; dz.textContent='Drop content chapters here to generate MCQs'; status.parentElement?.appendChild(dz);
        const ctx = { pieces: [] };
        makeDropzone(dz, (data)=>{ if(!data || !data.text) return; ctx.pieces.push(data); dz.textContent = `Attached ${ctx.pieces.length} chapter(s).`; });
        window.__tbGenCtx = ctx;
    })();

    // Wire the AI file chooser's drop element (created in the choose-file parent) to the same generator context
    (function(){
        try{
            const dropEl = document.getElementById('aiFileTbDrop');
            if(!dropEl) return;
            // Ensure global gen context exists
            window.__tbGenCtx = window.__tbGenCtx || { pieces: [] };
            makeDropzone(dropEl, (data)=>{
                if(!data || !data.text) return;
                window.__tbGenCtx.pieces.push(data);
                dropEl.textContent = `Attached ${window.__tbGenCtx.pieces.length} chapter(s)`;
                // mirror to existing status dropzone if present
                const statusDz = document.getElementById('tbDropGenerate'); if(statusDz) statusDz.textContent = dropEl.textContent;
            });
        }catch(e){ console.log('aiFileTbDrop wiring failed', e); }
    })();

    // Initial render
    renderTree();
})();
</script>
<script>
// Flashcards + simple SRS (client-side) implementation
(function(){
    const $ = id => document.getElementById(id);
    const SRS_KEY = 'srs.v1';
    let fcDeck = null; // array of cards { id, q, a, choices, ix }
    let fcSession = null; // { queue: [], pos: 0 }

    // Global Flashcard Timer (cumulative, persisted)
    const FCTIMER_KEY = 'fc.timer.v1';
    function readFcTimer(){ try{ return JSON.parse(localStorage.getItem(FCTIMER_KEY) || '{}'); }catch(e){ return {}; } }
    function writeFcTimer(obj){ try{ localStorage.setItem(FCTIMER_KEY, JSON.stringify(obj||{})); }catch(e){} }

    let fcTimerAccumMs = 0;                 // per-session total (resets at session start)
    let fcTimerMode = 'always';             // 'always' | 'hover' (default to visible)
    let fcTimerInterval = null;             // interval id
    let fcTimerRunningSince = null;         // timestamp when started

    function loadFcTimerState(){ const st = readFcTimer(); if(st && (st.mode === 'hover' || st.mode === 'always')) fcTimerMode = st.mode; }
    function saveFcTimerState(){ writeFcTimer({ mode: fcTimerMode }); }
    function formatHMS(ms){ try{ const t = Math.max(0, Math.floor(ms/1000)); const h = Math.floor(t/3600); const m = Math.floor((t%3600)/60); const s = t%60; return (h>0? (h+':'+String(m).padStart(2,'0')+':'+String(s).padStart(2,'0')) : (m+':'+String(s).padStart(2,'0'))); }catch(e){ return '00:00'; } }
    function updateFcTimerUI(){ try{
        const nowPart = fcTimerRunningSince ? (Date.now() - fcTimerRunningSince) : 0; const txt = formatHMS(fcTimerAccumMs + nowPart);
        const el1 = $('fcTimer'); if(el1){ el1.textContent = txt; el1.classList.toggle('hover-only', fcTimerMode === 'hover'); el1.classList.toggle('always', fcTimerMode !== 'hover'); }
        const el2 = document.getElementById('fcOverlayTimer'); if(el2){ el2.textContent = txt; el2.classList.toggle('hover-only', fcTimerMode === 'hover'); el2.classList.toggle('always', fcTimerMode !== 'hover'); }
    }catch(e){} }
    function tickFcTimer(){ try{ updateFcTimerUI(); }catch(e){} }
    function startFcTimer(){ try{ fcTimerAccumMs = 0; if(fcTimerRunningSince) return; fcTimerRunningSince = Date.now(); if(!fcTimerInterval) fcTimerInterval = setInterval(tickFcTimer, 1000); updateFcTimerUI(); }catch(e){} }
    function stopFcTimer(){ try{ if(fcTimerRunningSince){ fcTimerAccumMs += (Date.now() - fcTimerRunningSince); fcTimerRunningSince = null; } if(fcTimerInterval){ clearInterval(fcTimerInterval); fcTimerInterval = null; } updateFcTimerUI(); saveFcTimerState(); }catch(e){} }
    function toggleFcTimerMode(){ try{ fcTimerMode = (fcTimerMode === 'hover') ? 'always' : 'hover'; const el = $('fcTimer'); const el2 = document.getElementById('fcOverlayTimer'); if(el){ try{ el.classList.add('pulse'); }catch(e){} } if(el2){ try{ el2.classList.add('pulse'); }catch(e){} } setTimeout(()=>{ try{ if(el) el.classList.remove('pulse'); if(el2) el2.classList.remove('pulse'); }catch(e){} }, 360); updateFcTimerUI(); saveFcTimerState(); }catch(e){} }
    function initFcTimer(){ try{ loadFcTimerState(); updateFcTimerUI(); const el = $('fcTimer'); if(el){ el.addEventListener('click', toggleFcTimerMode); }
        // Observe for overlay removal to stop timer when session ends/escapes
        try{ const obs = new MutationObserver((muts)=>{ try{
                for(const m of muts){
                    // If the session overlay is removed, stop timer
                    if(m && m.removedNodes && m.removedNodes.length){
                        for(const n of m.removedNodes){ try{ if(n && n.id === 'fcSessionOverlay'){ stopFcTimer(); } }catch(e){} }
                    }
                    // If the pre-session countdown overlay is removed and fcSessionOverlay exists, start timer now
                    if(m && m.removedNodes && m.removedNodes.length){
                        for(const n of m.removedNodes){ try{ if(n && n.id === 'fcPreSessionOverlay' && document.getElementById('fcSessionOverlay')){ try{ startFcTimer(); }catch(e){} } }catch(e){} }
                    }
                }
            }catch(e){} }); obs.observe(document.body, { childList: true, subtree: true }); }catch(e){}
    }catch(e){} }

    function readSrs(){ try{ return JSON.parse(localStorage.getItem(SRS_KEY) || '{}'); }catch(e){ return {}; } }
    function writeSrs(obj){ try{ localStorage.setItem(SRS_KEY, JSON.stringify(obj||{})); }catch(e){} }

    function downloadBlob(filename, blob){ try{ const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); setTimeout(()=>{ try{ a.remove(); URL.revokeObjectURL(url); }catch{} }, 500); }catch(e){ alert('Download failed: '+(e?.message||e)); } }

    function shuffleInplace(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); const t=arr[i]; arr[i]=arr[j]; arr[j]=t; } return arr; }

    function renderDeckInfo(){ const info = $('fcDeckInfo'); if(!info) return; if(!fcDeck) return info.textContent = 'No deck loaded.'; info.textContent = `Deck loaded — ${fcDeck.length} cards.`; }

    function enableStart(enable){ const s = $('fcStartSession'); if(s) s.disabled = !enable; }

    function fcPairsForItem(it){
        try{
            const pairsRaw = Array.isArray(it?.pairs) ? it.pairs
                : Array.isArray(it?.matches) ? it.matches
                : Array.isArray(it?.map) ? it.map
                : [];
            return pairsRaw.map(p=>{
                if(!p) return null;
                if(typeof p === 'string'){
                    const s = p.trim();
                    const parts = s.split(/\s*->\s*/);
                    if(parts.length >= 2) return { left: parts[0], right: parts.slice(1).join('->') };
                    return null;
                }
                if(Array.isArray(p) && p.length >= 2) return { left: String(p[0]??''), right: String(p[1]??'') };
                if(typeof p === 'object'){
                    const left = (p.left != null) ? String(p.left) : (p.l != null ? String(p.l) : '');
                    const right = (p.right != null) ? String(p.right) : (p.r != null ? String(p.r) : '');
                    if(left || right) return { left, right };
                }
                return null;
            }).filter(Boolean);
        }catch(e){
            return [];
        }
    }

    function fcQuestionForItem(it){
        try{
            const base = String(it?.q || it?.text || '');
            const rawType = String(it?.type || 'mcq').toLowerCase();
            const type = rawType.replace(/\s+/g,'');
            if(type === 'matching' || type === 'match'){
                const pairs = fcPairsForItem(it);
                const lefts = pairs.map(p=>String(p.left||'').trim()).filter(Boolean);
                const uniqueLefts = Array.from(new Set(lefts));
                const leftList = uniqueLefts.join('\n');
                const prompt = base.trim();
                if(prompt && leftList) return prompt + '\n\n' + leftList;
                return prompt || leftList;
            }
            return base;
        }catch(e){
            return String(it?.q || it?.text || '');
        }
    }

    function fcAnswerForItem(it){
        try{
            const rawType = String(it?.type || 'mcq').toLowerCase();
            const type = rawType.replace(/\s+/g,'');

            // True/False
            if(type === 'truefalse' || type === 'tf' || type === 't/f'){
                if(Array.isArray(it.choices) && typeof it.correctIdx === 'number'){
                    return String(it.choices[it.correctIdx] || '');
                }
                if(typeof it.answer === 'boolean') return it.answer ? 'True' : 'False';
                if(typeof it.answer === 'string'){
                    const a = it.answer.trim().toLowerCase();
                    if(a === 'true' || a === 't') return 'True';
                    if(a === 'false' || a === 'f') return 'False';
                }
            }

            // Fill-in-the-blank
            if(type === 'fillblank' || type === 'fib' || type === 'fillintheblank' || rawType === 'fill-in-the-blank'){
                const answers = Array.isArray(it.answers) ? it.answers
                    : Array.isArray(it.keys) ? it.keys
                    : (it.answer != null ? [it.answer] : (it.key != null ? [it.key] : []));
                const clean = answers.map(x=>String(x??'').trim()).filter(Boolean);
                return clean.length ? clean.join(' | ') : '';
            }

            // Matching
            if(type === 'matching' || type === 'match'){
                const pairs = fcPairsForItem(it);
                if(!pairs.length) return '';
                return pairs.map(p => `${String(p.left||'').trim()} -> ${String(p.right||'').trim()}`.trim()).join('\n');
            }

            // MCQ
            if(Array.isArray(it.choices) && typeof it.correctIdx === 'number'){
                return String(it.choices[it.correctIdx] || '');
            }
        }catch(e){}
        return '';
    }

    // Expose a safe global setter so other modules (e.g., parser) can overwrite the deck reliably
    try{ window.fcSetDeckFromItems = function(items){ try{
        const hasItems = Array.isArray(items) && items.length > 0;
        fcDeck = hasItems ? items.map((it, ix)=>({ id: it.num || (ix+1), q: fcQuestionForItem(it), a: fcAnswerForItem(it), choices: Array.isArray(it.choices)? it.choices.slice() : [], ix })) : null;
        try{ window.__flashcardsDeck = fcDeck; }catch(e){}
        // Reset any in-progress session and refresh UI
        fcSession = null;
        renderDeckInfo();
        enableStart(!!hasItems);
        try{ const prog = $('fcProgressText'); if(prog) prog.textContent = `0 / ${hasItems ? (items.length||0) : 0}`; }catch(e){}
        // Hide card area if deck cleared
        if(!hasItems){ try{ const area = $('fcCardArea'); const info = $('fcDeckInfo'); if(area) area.style.display='none'; if(info) info.style.display=''; }catch(e){} }
    }catch(e){ console.warn('fcSetDeckFromItems failed', e); } } }catch(e){}

    // Load from parsed items (state.items)
    $('fcFromParsed')?.addEventListener('click', (e)=>{
        try{
            const items = (window.__quizState && window.__quizState.items) ? window.__quizState.items : (window.__STATE__ && window.__STATE__.items) ? window.__STATE__.items : (window.state && state.items) ? state.items : [];
            if(!items || !items.length){ alert('No parsed items found to build a deck. Parse or load a quiz first.'); return; }
            fcDeck = items.map((it, ix)=>({ id: it.num || (ix+1), q: fcQuestionForItem(it), a: fcAnswerForItem(it), choices: Array.isArray(it.choices)? it.choices.slice() : [], ix }));
            try{ window.__flashcardsDeck = fcDeck; }catch(e){}
            renderDeckInfo(); enableStart(true);
        }catch(err){ console.error('fcFromParsed failed', err); alert('Could not load deck from parsed items.'); }
    });

    // Start session — open a distraction-free in-page overlay (black UI) with countdown.
    // Uses the same countdown dialog (but with white outline) and keyboard controls:
    // Space = flip, 1=Again, 2=Hard, 3=Good, 4=Easy, Enter/Right = next, Esc = close
    $('fcStartSession')?.addEventListener('click', (e)=>{
        try{
            if(!fcDeck || !fcDeck.length){ alert('No deck loaded. Click "Load from parsed" first.'); return; }
            const deckCopy = fcDeck.map(c => ({ id: c.id, q: c.q, a: c.a, choices: Array.isArray(c.choices) ? c.choices.slice() : [], ix: c.ix }));
            // Timer will start after the countdown finishes (see MutationObserver in initFcTimer)

            // show a focused white-outlined countdown overlay tailored for flashcards
            function showFcPreSessionOverlay(deck, cb){
                try{
                    if(window.__preQuizOverlayActive){ try{ cb(); }catch(e){} return; }
                    window.__preQuizOverlayActive = true;
                    const overlay = document.createElement('div'); overlay.id = 'fcPreSessionOverlay';
                    overlay.style.position = 'fixed'; overlay.style.left = '0'; overlay.style.top = '0'; overlay.style.right = '0'; overlay.style.bottom = '0';
                    overlay.style.display = 'flex'; overlay.style.alignItems = 'center'; overlay.style.justifyContent = 'center';
                    overlay.style.zIndex = '999999';
                    // less dark during setup so user can still see background; will cross-fade into session UI
                    overlay.style.background = 'rgba(0,0,0,0.55)'; overlay.style.backdropFilter = 'blur(4px)'; overlay.style.color = '#fff'; overlay.style.fontSize = '16px'; overlay.style.padding = '24px'; overlay.style.boxSizing = 'border-box';
                    overlay.style.transition = 'background 320ms ease, opacity 320ms ease, backdrop-filter 320ms ease';
                    overlay.style.opacity = '1';
                    overlay.style.textAlign = 'center'; overlay.style.pointerEvents = 'auto';

                    const card = document.createElement('div'); card.style.maxWidth = '820px'; card.style.width = '92%'; card.style.background = 'linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01))'; card.style.borderRadius = '10px'; card.style.padding = '18px'; card.style.pointerEvents = 'none';
                    // White outline per user request
                    card.style.outline = '2px solid rgba(255,255,255,0.95)'; card.style.outlineOffset = '6px';
                    card.style.boxShadow = '0 12px 36px rgba(0,0,0,0.6)';

                    const title = document.createElement('div'); title.style.fontSize = '18px'; title.style.fontWeight = '700'; title.style.marginBottom = '8px'; title.textContent = 'Study Session — ready in:';
                    // countdown
                    const countdown = document.createElement('div'); countdown.style.marginTop = '8px'; countdown.style.fontSize = '28px'; countdown.style.fontWeight = '700'; countdown.textContent = '3';
                    // show key shortcuts so users see controls before session starts
                    const hintText = document.createElement('div'); hintText.style.marginTop = '12px'; hintText.style.fontSize = '13px'; hintText.style.color = 'rgba(255,255,255,0.9)'; hintText.style.opacity = '0.95'; hintText.textContent = 'Controls: Space or F = flip · 1=Again 2=Hard 3=Good 4=Easy · Enter/Right = next · Esc = exit';
                    card.appendChild(title); card.appendChild(countdown); card.appendChild(hintText);
                    overlay.appendChild(card); document.body.appendChild(overlay);

                    // Immediately open the session overlay beneath this pre-overlay so it can fade in during the countdown
                    // Also disable background interaction (keyboard + pointer) while countdown is active by capturing events.
                    let __preOverlayKeyBlocker = function(ev){ try{
                        // Allow the results "Restart" shortcut (r) to pass through when the
                        // Restart button is visible and enabled. This prevents the countdown
                        // capture from permanently blocking the user's ability to restart
                        // from the results screen while overlays are active.
                        try{
                            const k = (ev && ev.key) ? ev.key : '';
                            if(k && k.toLowerCase && k.toLowerCase() === 'r'){
                                const restartBtn = document.getElementById('restart');
                                if(restartBtn && restartBtn.offsetParent !== null && !restartBtn.disabled){
                                    // allow event to propagate so global handlers can pick it up
                                    return;
                                }
                            }
                        }catch(_){ }
                        ev.stopImmediatePropagation(); ev.preventDefault();
                    }catch(e){} };
                    // Capture keydown events at the document level during countdown to prevent underlying handlers from firing.
                    document.addEventListener('keydown', __preOverlayKeyBlocker, true);
                    // Prevent pointer interactions from reaching the page by ensuring the overlay is the topmost element
                    // and by stopping propagation on pointer events targeting the overlay.
                    overlay.addEventListener('pointerdown', function(ev){ try{ ev.stopPropagation(); ev.preventDefault(); }catch(e){} }, true);

                    // Temporarily de-initialize the last-focused element (commonly the Start button) so an Enter key
                    // won't re-trigger it while the countdown/session is starting. We'll restore it after the session overlay
                    // is created and the countdown finishes.
                    let __prevActiveEl = null; let __prevWasDisabled = false;
                    try{
                        const pa = document.activeElement;
                        if(pa && pa instanceof HTMLElement){ __prevActiveEl = pa; try{ __prevWasDisabled = !!pa.disabled; }catch{} try{ pa.blur && pa.blur(); }catch{}
                            // If it's a button or input that could receive Enter, disable it temporarily
                            try{ if((pa.tagName === 'BUTTON' || pa.tagName === 'INPUT' || pa.getAttribute && pa.getAttribute('role') === 'button')){ pa.disabled = true; pa.setAttribute('data-fc-temp-disabled','1'); } }catch(e){}
                        }
                    }catch(e){}

                    try{ cb(); }catch(e){}
                    // If the session overlay was created, lengthen its fade to match the countdown
                    try{
                        const sess = document.getElementById('fcSessionOverlay');
                        if(sess){
                            const fadeMs = (3 * 1000) + 160; // countdown seconds + small buffer
                            sess.style.transition = `opacity ${fadeMs}ms ease`;
                            // trigger fade-in (openFlashcardsSessionOverlay also tries to fade in; overriding here ensures duration)
                            requestAnimationFrame(()=>{ try{ sess.style.opacity = '1'; }catch(e){} });
                        }
                    }catch(e){}

                    let t = 3; const iv = setInterval(()=>{
                        try{
                            t--;
                            if(t <= 0){
                                clearInterval(iv);
                                // cross-fade the pre-overlay out to reveal the session UI
                                overlay.style.background = 'rgba(0,0,0,0.95)'; overlay.style.backdropFilter = 'blur(8px)';
                                requestAnimationFrame(()=>{ overlay.style.opacity = '0'; });
                                // remove after transition completes and restore normal event flow
                                setTimeout(()=>{ try{ if(document.body.contains(overlay)) document.body.removeChild(overlay); }catch(_ ){}
                                    try{ document.removeEventListener('keydown', __preOverlayKeyBlocker, true); }catch(_){}
                                    // restore any temporarily-disabled element
                                    try{ if(__prevActiveEl && __prevActiveEl.getAttribute && __prevActiveEl.getAttribute('data-fc-temp-disabled')){ try{ __prevActiveEl.disabled = __prevWasDisabled ? true : false; __prevActiveEl.removeAttribute('data-fc-temp-disabled'); }catch(e){} } }catch(e){}
                                    window.__preQuizOverlayActive = false; }, 420);
                            } else { countdown.textContent = String(t); }
                        }catch(e){ clearInterval(iv); try{ document.body.removeChild(overlay); }catch{} window.__preQuizOverlayActive = false; }
                    }, 1000);
                }catch(e){ console.warn('showFcPreSessionOverlay failed', e); try{ cb(); }catch(e){} }
            }

            // Open the in-page full-screen overlay session
            function openFlashcardsSessionOverlay(deck){
                try{
                    // create overlay container
                    const ol = document.createElement('div'); ol.id = 'fcSessionOverlay';
                    ol.style.position = 'fixed'; ol.style.left = '0'; ol.style.top = '0'; ol.style.right = '0'; ol.style.bottom = '0';
                    ol.style.zIndex = '999998'; ol.style.background = '#000'; ol.style.color = '#fff'; ol.style.display = 'flex'; ol.style.alignItems = 'center'; ol.style.justifyContent = 'center'; ol.style.padding = '18px'; ol.style.boxSizing = 'border-box';
                    // start invisible and fade in so the pre-overlay can cross-fade to it
                    ol.style.opacity = '0'; ol.style.transition = 'opacity 360ms ease';
                    ol.innerHTML = `
                        <style>
                        .fc-bg-decor{ position:absolute; inset:0; pointer-events:none; overflow:hidden; z-index:1 }
                        .fc-bg-decor .dot{ position:absolute; border-radius:50%; filter:blur(64px); opacity:0.10; transform:translateZ(0); }
                        .fc-bg-decor .one{ width:520px; height:520px; left:-120px; top:-90px; background: radial-gradient(circle at 30% 30%, rgba(106,169,255,0.95), rgba(106,169,255,0.35) 30%, transparent 60%); }
                        .fc-bg-decor .two{ width:420px; height:420px; right:-140px; bottom:-100px; background: radial-gradient(circle at 70% 70%, rgba(130,100,255,0.95), rgba(130,100,255,0.32) 30%, transparent 60%); }
                        /* Overlay timer: positioned above the question number but centered over the flashcard text */
                        .fc-otimer-wrap{ position:absolute; left:50%; transform:translateX(-50%); top:5%; z-index:5; display:flex; justify-content:center; }
                        .fc-otimer{ font:700 18px ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; color:#e6edf3; background: transparent; border: none; padding:0 2px; border-radius:0; box-shadow:none; cursor:pointer; -webkit-user-select:none; user-select:none; transition: transform .12s ease, opacity .12s ease; }
                        .fc-otimer:hover{ transform: translateY(-2px); }
                        .fc-otimer.hover-only{ opacity:0; pointer-events:none }
                        .fc-card:hover .fc-otimer.hover-only{ opacity:1; pointer-events:auto }
                        .fc-otimer.pulse{ animation: fcTimerPulse 300ms ease; }
                        .fc-card{ position:relative; z-index:2; padding:48px 22px; box-sizing:border-box; max-width:1100px; margin:0 auto }
                        /* Flip container */
                        .fc-flip-wrap{ perspective: 1400px; display:flex; justify-content:center }
                        .fc-flip{ width:100%; max-width:980px; transform-style: preserve-3d; transition: transform 520ms cubic-bezier(.2,.9,.3,1); cursor:pointer }
                        .fc-flip.flipped{ transform: rotateY(180deg); }
                        .fc-face{ backface-visibility: hidden; -webkit-backface-visibility: hidden; position:relative; display:block; min-height:120px; padding-bottom:6px }
                        .fc-face.front{ transform: rotateY(0deg) }
                        .fc-face.back{ transform: rotateY(180deg); position:absolute; left:0; top:0; width:100% }
                        .fc-question{ font-size:34px; font-weight:700; text-align:center; line-height:1.3; color:#fff; max-height:8.6em; overflow:auto; white-space: pre-wrap; padding:4px 0 6px }
                        /* Make both faces share identical text styling for consistency */
                        .fc-answer, .fc-question{ font-size:34px; font-weight:700; text-align:center; line-height:1.3; color:#fff; padding-bottom:6px; white-space: pre-wrap; }
                        .fc-controls{ display:flex; gap:14px; justify-content:center; margin-top:16px; transition: opacity .18s ease, transform .18s ease; opacity:0; transform: translateY(6px); }
                        /* Reveal all rating buttons when the control group is hovered or when any child has focus */
                        .fc-controls:hover, .fc-controls:focus-within{ opacity:1; transform: translateY(0); }
                        .fc-controls button{ background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02)); border: 1px solid rgba(255,255,255,0.10); color:#fff; padding:12px 20px; border-radius:999px; box-shadow: 0 8px 24px rgba(0,0,0,0.55); cursor:pointer; font-weight:600; transition: transform .12s ease, box-shadow .12s ease, opacity .12s ease; }
                        .fc-controls button:hover{ transform: translateY(-2px); box-shadow: 0 12px 36px rgba(0,0,0,0.6) }
                        .fc-controls button:active{ transform: translateY(0) }
                        /* Individual button colors */
                        #fcOAgain{ background: linear-gradient(180deg, rgba(239,68,68,0.92), rgba(220,38,38,0.92)); border-color: rgba(190,18,60,0.9); }
                        #fcOHard{ background: linear-gradient(180deg, rgba(249,115,22,0.95), rgba(234,88,12,0.95)); border-color: rgba(200,80,10,0.9); }
                        #fcOGood{ background: linear-gradient(180deg, rgba(34,197,94,0.92), rgba(16,185,129,0.92)); border-color: rgba(4,120,87,0.9); }
                        #fcOEasy{ background: linear-gradient(180deg, rgba(96,165,250,0.9), rgba(59,130,246,0.9)); border-color: rgba(30,90,200,0.9); }
                        .fc-close{ position:absolute; left:14px; bottom:12px; z-index:3; opacity:0; transform: translateY(6px); transition: opacity .18s ease, transform .18s ease; }
                        /* Only reveal the close control when it itself is hovered */
                        .fc-close:hover{ opacity:1; transform: translateY(0); }
                        .fc-prog{ position:absolute; left:14px; top:14px; color:#c9d6e6; font-size:13px; z-index:3 }
                        </style>
                        <div class="fc-bg-decor" aria-hidden="true"><div class="dot one"></div><div class="dot two"></div></div>
                        <div class="fc-card">
                            <div id="fcOverlayProg" class="fc-prog">0 / 0</div>
                            <div class="fc-otimer-wrap"><div id="fcOverlayTimer" class="fc-otimer" title="Click to toggle: Always visible ↔ Show on hover">00:00</div></div>
                            <div class="fc-flip-wrap"><div id="fcFlipContainer" class="fc-flip" role="button" tabindex="0">
                                <div class="fc-face front"><div id="fcOverlayQ" class="fc-question"></div></div>
                                <div class="fc-face back"><div id="fcOverlayA" class="fc-answer"></div></div>
                            </div></div>
                            <div class="fc-controls">
                                <button id="fcOAgain">Again</button>
                                <button id="fcOHard">Hard</button>
                                <button id="fcOGood">Good</button>
                                <button id="fcOEasy">Easy</button>
                            </div>
                            <div class="fc-close"><button id="fcOExit" class="btn small">Close</button></div>
                        </div>
                    `;
                    document.body.appendChild(ol);
                    // trigger fade-in
                    requestAnimationFrame(()=>{ try{ ol.style.opacity = '1'; }catch(e){} });

                    // create session queue
                    const queue = deck.map(c=> ({ ...c })); shuffleInplace(queue);
                    fcSession = { queue, pos: 0 };

                    const SRS_KEY = 'srs.v1';
                    function readSrsLocal(){ try{ return JSON.parse(localStorage.getItem(SRS_KEY) || '{}'); }catch(e){ return {}; } }
                    function writeSrsLocal(obj){ try{ localStorage.setItem(SRS_KEY, JSON.stringify(obj||{})); }catch(e){} }

                    function renderOverlayCard(){
                        const card = (fcSession && fcSession.queue && fcSession.queue.length) ? fcSession.queue[fcSession.pos] : null;
                        const qEl = document.getElementById('fcOverlayQ');
                        const aEl = document.getElementById('fcOverlayA');
                        const prog = document.getElementById('fcOverlayProg');
                        const flipEl = document.getElementById('fcFlipContainer');
                        if(!card){
                            if(qEl) qEl.textContent = 'No cards.';
                            if(aEl) aEl.textContent = '';
                            if(flipEl) flipEl.classList.remove('flipped');
                            if(prog) prog.textContent = '0 / 0';
                            return;
                        }
                        if(qEl) qEl.textContent = String(card.q||'');
                        if(aEl) aEl.textContent = String(card.a||'');
                        // ensure front is shown
                        if(flipEl) flipEl.classList.remove('flipped');
                        if(prog) prog.textContent = `${(fcSession.pos+1)} / ${fcSession.queue.length}`;
                    }

                    function saveRatingAndAdvance(level){ try{
                        const card = fcSession.queue[fcSession.pos]; if(!card) return;
                        const srs = readSrsLocal(); const key = String(card.id); const now = Date.now(); const rec = srs[key] || { box: 0, last: null, streak: 0 };
                        // map level: 0=Again,1=Hard,2=Good,3=Easy
                        if(level === 0){ rec.box = 0; rec.streak = 0; rec.last = now; }
                        else if(level === 1){ rec.box = Math.max(0, (rec.box||0) - 1); rec.streak = 0; rec.last = now; }
                        else if(level === 2){ rec.box = Math.min(5,(rec.box||0)+1); rec.streak = (rec.streak||0)+1; rec.last = now; }
                        else if(level === 3){ rec.box = Math.min(6,(rec.box||0)+2); rec.streak = (rec.streak||0)+1; rec.last = now; }
                        srs[key] = rec; writeSrsLocal(srs);
                        // move or remove from queue depending on level (Again/Hard -> move to end; Good/Easy -> remove)
                        if(level === 0 || level === 1){ const item = fcSession.queue.splice(fcSession.pos,1)[0]; fcSession.queue.push(item); }
                        else { fcSession.queue.splice(fcSession.pos,1); }
                        // sync: storage event will fire for other windows
                        // if session finished
                        if(fcSession.queue.length === 0){
                            // Show an in-overlay completion sequence: message -> "Returning to Main Menu" -> fade out
                            try{
                                const overlayEl = document.getElementById('fcSessionOverlay');
                                if(overlayEl){
                                    // create centered message container
                                    try{ const prev = document.getElementById('fcCompleteContainer'); if(prev) prev.remove(); }catch(e){}
                                    const cont = document.createElement('div'); cont.id = 'fcCompleteContainer';
                                    // Mount on body so it persists while the overlay fades — use fixed to cover viewport
                                    cont.style.position = 'fixed'; cont.style.inset = '0'; cont.style.display = 'flex'; cont.style.alignItems = 'center'; cont.style.justifyContent = 'center'; cont.style.zIndex = '9999999'; cont.style.pointerEvents = 'none';
                                    // blur what's behind the pop-up (like the countdown overlay)
                                    cont.style.backdropFilter = 'blur(6px)'; cont.style.background = 'rgba(0,0,0,0.28)';
                                    const box = document.createElement('div');
                                    box.style.background = 'linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.5))';
                                    box.style.border = '1px solid rgba(255,255,255,0.06)';
                                    box.style.padding = '18px 22px'; box.style.borderRadius = '12px'; box.style.textAlign = 'center'; box.style.color = '#fff'; box.style.maxWidth = '820px'; box.style.boxSizing = 'border-box'; box.style.opacity = '0'; box.style.transition = 'opacity .28s ease';
                                    /* match flashcard face text size and strong outline like the countdown card */
                                    box.style.outline = '2px solid rgba(255,255,255,0.95)'; box.style.outlineOffset = '6px';
                                    const main = document.createElement('div'); main.textContent = 'Completed all Flashcards'; main.style.fontSize = '34px'; main.style.fontWeight = '700'; main.style.lineHeight = '1.2'; main.style.marginBottom = '8px';
                                    const sub = document.createElement('div'); sub.id = 'fcCompleteSub'; sub.textContent = 'Returning to Main Menu'; sub.style.fontSize = '20px'; sub.style.fontWeight = '700'; sub.style.opacity = '0'; sub.style.transition = 'opacity .36s ease';
                                    box.appendChild(main); box.appendChild(sub); cont.appendChild(box); document.body.appendChild(cont);
                                    // fade in main then sub, then start returning to main menu
                                    requestAnimationFrame(()=>{ try{ box.style.opacity = '1'; }catch(e){} });
                                    setTimeout(()=>{ try{ sub.style.opacity = '1'; }catch(e){} }, 900);
                                    // Start the overlay-close sequence after a short delay so the popup remains visible
                                    // while the overlay fades; actual de-blur+fade of the popup is handled by closeOverlay().
                                    setTimeout(()=>{ try{ closeOverlay(); }catch(e){} }, 1540);
                                    return;
                                }
                            }catch(e){}
                            // Fallback: close overlay then show a simple alert
                            try{ closeOverlay(); }catch(e){}
                            setTimeout(()=>{ try{ alert('Session complete.'); }catch(e){} }, 420);
                            return;
                        }
                        if(fcSession.pos >= fcSession.queue.length) fcSession.pos = 0;
                        renderOverlayCard();
                    }catch(e){ console.error('saveRatingAndAdvance', e); } }

                    function flipOverlay(){ const flipEl = document.getElementById('fcFlipContainer'); if(!flipEl) return; flipEl.classList.toggle('flipped'); }
                    function nextOverlay(){ if(!fcSession) return; fcSession.pos = (fcSession.pos + 1) % fcSession.queue.length; renderOverlayCard(); }
                    function closeOverlay(){ try{
                        const el = document.getElementById('fcSessionOverlay');
                        // Robust fade-out: prefer transitionend event, fall back to timeout.
                        function _cleanup(){ try{ document.removeEventListener('keydown', overlayKeyHandler); }catch(e){} try{ fcSession = null; }catch(e){}
                            try{ const startBtn = document.getElementById('fcStartSession'); if(startBtn) { try{ startBtn.focus(); }catch(e){} } }catch(e){}
                            try{ if(typeof window.__updateMainMenuButtonsVisibility === 'function') window.__updateMainMenuButtonsVisibility(); }catch(e){}
                        }
                        if(el){
                            try{
                                // Detect completion popup either inside overlay or portaled on body
                                const compInside = (el.querySelector && el.querySelector('#fcCompleteContainer')) || null;
                                const compOnBody = document.getElementById('fcCompleteContainer');
                                // Helper to remove a portaled completion container with de-blur + fade sequence
                                const removePortaledCompletion = function(cont){
                                    try{
                                        if(!cont) return;
                                        const box = cont.firstElementChild || cont.querySelector('div');
                                        // Animate backdrop -> transparent so the page de-blurs before the box fades
                                        try{
                                            cont.style.transition = cont.style.transition || 'background .28s ease, backdrop-filter .28s ease, -webkit-backdrop-filter .28s ease';
                                            // Trigger reflow then de-blur
                                            void cont.offsetWidth;
                                            requestAnimationFrame(()=>{
                                                try{ cont.style.background = 'transparent'; cont.style.backdropFilter = 'none'; cont.style.WebkitBackdropFilter = 'none'; }catch(e){}
                                            });
                                        }catch(e){}
                                        // After backdrop transition, fade the inner box then remove
                                        setTimeout(()=>{
                                            try{
                                                if(box){ box.style.transition = box.style.transition || 'opacity .22s ease'; box.style.opacity = '0'; }
                                            }catch(e){}
                                            // remove cont after box fade
                                            setTimeout(()=>{ try{ if(document.body.contains(cont)) document.body.removeChild(cont); }catch(e){} }, 320);
                                        }, 260);
                                    }catch(e){ try{ if(cont && document.body.contains(cont)) document.body.removeChild(cont); }catch(e){} }
                                };

                                const startOverlayFade = function(afterOverlayRemoved){
                                    try{
                                        // ensure we have a transition; force a reflow then start fade
                                        el.style.transition = el.style.transition || 'opacity 320ms ease, transform 220ms ease';
                                        void el.offsetWidth;
                                        const onEnd = function(ev){ try{ if(ev && ev.target !== el) return; el.removeEventListener('transitionend', onEnd); try{ if(document.body.contains(el)) document.body.removeChild(el); }catch(e){} if(typeof afterOverlayRemoved === 'function') afterOverlayRemoved(); _cleanup(); }catch(e){} };
                                        el.addEventListener('transitionend', onEnd);
                                        requestAnimationFrame(()=>{ try{ el.style.opacity = '0'; el.style.transform = 'scale(0.995)'; }catch(e){} });
                                        // Fallback in case transitionend doesn't fire
                                        setTimeout(()=>{ try{ if(document.body.contains(el)) { try{ document.body.removeChild(el); }catch(e){} } if(typeof afterOverlayRemoved === 'function') afterOverlayRemoved(); _cleanup(); }catch(e){} }, 640);
                                    }catch(e){ try{ if(document.body.contains(el)) document.body.removeChild(el); }catch(e){} if(typeof afterOverlayRemoved === 'function') afterOverlayRemoved(); _cleanup(); }
                                };

                                // If completion popup exists and is portaled to body (not nested in overlay), keep it
                                // visible while the overlay fades, then de-blur it, fade it, and remove it.
                                if(compOnBody && compOnBody.parentNode === document.body && !compInside){
                                    // Start overlay fade but tell it to run removePortaledCompletion after overlay removed
                                    startOverlayFade(()=> removePortaledCompletion(compOnBody));
                                } else {
                                    // If a completion box is nested inside the overlay, fade the inner box first, then fade overlay
                                    try{
                                        const comp = compInside || compOnBody;
                                        if(comp){
                                            const box = comp.firstElementChild || comp.querySelector('div');
                                            if(box){ box.style.transition = box.style.transition || 'opacity .22s ease'; requestAnimationFrame(()=>{ try{ box.style.opacity = '0'; }catch(e){} }); }
                                            setTimeout(()=> startOverlayFade(), 220);
                                        } else {
                                            startOverlayFade();
                                        }
                                    }catch(e){ startOverlayFade(); }
                                }
                            }catch(e){ try{ if(document.body.contains(el)) document.body.removeChild(el); }catch(e){} _cleanup(); }
                        } else { _cleanup(); }
                    }catch(e){} }

                    document.getElementById('fcOAgain').addEventListener('click', ()=> saveRatingAndAdvance(0));
                    document.getElementById('fcOHard').addEventListener('click', ()=> saveRatingAndAdvance(1));
                    document.getElementById('fcOGood').addEventListener('click', ()=> saveRatingAndAdvance(2));
                    document.getElementById('fcOEasy').addEventListener('click', ()=> saveRatingAndAdvance(3));
                    // Show the same 'Returning to Main Menu' popup when user clicks Close
                    function showReturningPopup(){
                        try{
                            try{ const prev = document.getElementById('fcCompleteContainer'); if(prev) prev.remove(); }catch(e){}
                            const cont = document.createElement('div'); cont.id = 'fcCompleteContainer';
                            cont.style.position = 'fixed'; cont.style.inset = '0'; cont.style.display = 'flex'; cont.style.alignItems = 'center'; cont.style.justifyContent = 'center'; cont.style.zIndex = '9999999'; cont.style.pointerEvents = 'none';
                            cont.style.backdropFilter = 'blur(6px)'; cont.style.background = 'rgba(0,0,0,0.28)';
                            const box = document.createElement('div');
                            box.style.background = 'linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.5))';
                            box.style.border = '1px solid rgba(255,255,255,0.06)';
                            box.style.padding = '18px 22px'; box.style.borderRadius = '12px'; box.style.textAlign = 'center'; box.style.color = '#fff'; box.style.maxWidth = '820px'; box.style.boxSizing = 'border-box'; box.style.opacity = '0'; box.style.transition = 'opacity .28s ease';
                            box.style.outline = '2px solid rgba(255,255,255,0.95)'; box.style.outlineOffset = '6px';
                            const main = document.createElement('div'); main.textContent = 'Returning to Main Menu'; main.style.fontSize = '34px'; main.style.fontWeight = '700'; main.style.lineHeight = '1.2'; main.style.marginBottom = '8px';
                            const sub = document.createElement('div'); sub.id = 'fcCompleteSub'; sub.textContent = ''; sub.style.fontSize = '20px'; sub.style.fontWeight = '700'; sub.style.opacity = '0'; sub.style.transition = 'opacity .36s ease';
                            box.appendChild(main); box.appendChild(sub); cont.appendChild(box); document.body.appendChild(cont);
                            requestAnimationFrame(()=>{ try{ box.style.opacity = '1'; }catch(e){} });
                            setTimeout(()=>{ try{ sub.style.opacity = '1'; }catch(e){} }, 600);
                            // Keep the popup visible while overlay fades; let closeOverlay() handle de-blur and popup fade/removal after overlay removal.
                            setTimeout(()=>{ try{ closeOverlay(); }catch(e){} }, 1400);
                        }catch(e){}
                    }
                    document.getElementById('fcOExit').addEventListener('click', ()=> showReturningPopup());
                    // Bind overlay timer toggle and sync UI
                    try{ document.getElementById('fcOverlayTimer')?.addEventListener('click', ()=> toggleFcTimerMode()); }catch(e){}
                    try{ updateFcTimerUI(); }catch(e){}

                    // enable click/keyboard flip on the card
                    const _bindFlip = ()=>{
                        const fcFlip = document.getElementById('fcFlipContainer');
                        if(!fcFlip) return;
                        // click to flip
                        fcFlip.addEventListener('click', (ev)=>{ ev.stopPropagation(); flipOverlay(); });
                        // keyboard: Space / F when focused on the flip container
                        // Note: do NOT treat Enter as a flip/advance here — Enter was causing an unexpected reset in some environments.
                        fcFlip.addEventListener('keydown', (ev)=>{ try{ const k = (ev && ev.key) ? ev.key : ''; if(k === ' ' || k === 'Spacebar' || (k && k.toLowerCase && k.toLowerCase() === 'f')){ ev.preventDefault(); flipOverlay(); } }catch(e){} });
                    };
                    _bindFlip();

                    function overlayKeyHandler(e){ try{
                        const ek = (e && e.key) ? e.key : '';
                        if(ek === ' ' || (ek && ek.toLowerCase && ek.toLowerCase() === 'f')){ e.preventDefault(); flipOverlay(); }
                        else if(e.key === '1'){ saveRatingAndAdvance(0); }
                        else if(e.key === '2'){ saveRatingAndAdvance(1); }
                        else if(e.key === '3'){ saveRatingAndAdvance(2); }
                        else if(e.key === '4'){ saveRatingAndAdvance(3); }
                        else if(e.key === 'ArrowRight'){ nextOverlay(); }
                        /* NOTE: intentionally ignore Enter here — Enter triggered unexpected resets/blank state in flashcard view.
                           If you'd like Enter to advance, we can enable it conditionally (for example only when the card is flipped),
                           but for now we keep it disabled to avoid the reported issue. */
                        else if(e.key === 'Escape'){ 
                            try{ showReturningPopup(); }catch(e){}
                        }
                    }catch(e){} }
                    document.addEventListener('keydown', overlayKeyHandler);

                    // initial render
                    renderOverlayCard();
                }catch(e){ console.error('openFlashcardsSessionOverlay failed', e); }
            }

            // Show countdown then open overlay
            showFcPreSessionOverlay(deckCopy, ()=> openFlashcardsSessionOverlay(deckCopy));

        }catch(err){ console.error('fcStartSession', err); }
    });

    function currentCard(){ if(!fcSession || !fcSession.queue || fcSession.queue.length===0) return null; return fcSession.queue[fcSession.pos] || null; }

    function renderFcCard(){ const card = currentCard(); if(!card){ $('fcCardArea').style.display='none'; $('fcDeckInfo').style.display=''; renderDeckInfo(); return; }
        const front = $('fcFront'), back = $('fcBack'); if(front) front.textContent = String(card.q||''); if(back) back.textContent = String(card.a||''); if(back) back.style.display = 'none'; }

    function updateFcProgress(){ try{ const total = fcSession ? fcSession.queue.length : 0; const pos = fcSession ? (fcSession.pos+1) : 0; $('fcProgressText').textContent = `${pos > total ? total : (fcSession && total? pos : 0)} / ${total}`; }catch(e){} }

    // Flip
    $('fcFlip')?.addEventListener('click', ()=>{ try{ const back = $('fcBack'); if(!back) return; back.style.display = (back.style.display==='none') ? '' : 'none'; }catch(e){} });

    // Rating handlers — simple scheduler: Again -> push to end, mark box 0; Hard -> box1; Good -> remove; Easy -> remove and optionally mark mastered
    function handleRating(level){ try{
        const card = currentCard(); if(!card) return;
        const srs = readSrs(); const key = String(card.id);
        const now = Date.now(); const rec = srs[key] || { box: 0, last: null, streak: 0 };
        // map level to action
        // 0: Again, 1: Hard, 2: Good, 3: Easy
        if(level === 0){ rec.box = 0; rec.streak = 0; rec.last = now; srs[key]=rec; // move to end
            const item = fcSession.queue.splice(fcSession.pos,1)[0]; fcSession.queue.push(item);
        } else if(level === 1){ rec.box = Math.max(0, rec.box-1); rec.streak = 0; rec.last = now; srs[key]=rec; // move to end
            const item = fcSession.queue.splice(fcSession.pos,1)[0]; fcSession.queue.push(item);
        } else if(level === 2){ rec.box = Math.min(5, rec.box+1); rec.streak = (rec.streak||0)+1; rec.last = now; srs[key]=rec; // remove from queue as learned for session
            fcSession.queue.splice(fcSession.pos,1);
        } else if(level === 3){ rec.box = Math.min(6, rec.box+2); rec.streak = (rec.streak||0)+1; rec.last = now; srs[key]=rec; fcSession.queue.splice(fcSession.pos,1);
        }
        writeSrs(srs);
        // do not advance pos when we removed current — keep same index (next item shifts into pos)
        if(fcSession && fcSession.queue.length===0){ // session finished
            try{
                // Show a centered completion message (non-modal) then return to main view
                const existing = document.getElementById('fcCompleteContainerMain'); if(existing) existing.remove();
                const cont = document.createElement('div'); cont.id = 'fcCompleteContainerMain';
                cont.style.position = 'fixed'; cont.style.inset = '0'; cont.style.display = 'flex'; cont.style.alignItems = 'center'; cont.style.justifyContent = 'center'; cont.style.zIndex = '100010'; cont.style.pointerEvents = 'none';
                // blur the background behind the completion card (like the countdown popup)
                cont.style.backdropFilter = 'blur(6px)'; cont.style.background = 'rgba(0,0,0,0.28)';
                const box = document.createElement('div');
                box.style.background = 'linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.5))';
                box.style.border = '1px solid rgba(255,255,255,0.06)'; box.style.padding = '16px 20px'; box.style.borderRadius = '10px'; box.style.textAlign = 'center'; box.style.color = '#fff'; box.style.maxWidth = '760px'; box.style.boxSizing = 'border-box'; box.style.opacity = '0'; box.style.transition = 'opacity .28s ease';
                /* match flashcard face text size and countdown outline */
                box.style.outline = '2px solid rgba(255,255,255,0.95)'; box.style.outlineOffset = '6px';
                const main = document.createElement('div'); main.textContent = 'Completed all Flashcards'; main.style.fontSize = '34px'; main.style.fontWeight = '700'; main.style.lineHeight = '1.2'; main.style.marginBottom = '6px';
                const sub = document.createElement('div'); sub.id = 'fcCompleteSubMain'; sub.textContent = 'Returning to Main Menu'; sub.style.fontSize = '20px'; sub.style.fontWeight = '700'; sub.style.opacity = '0'; sub.style.transition = 'opacity .36s ease';
                box.appendChild(main); box.appendChild(sub); cont.appendChild(box); document.body.appendChild(cont);
                requestAnimationFrame(()=>{ try{ box.style.opacity = '1'; }catch(e){} });
                setTimeout(()=>{ try{ sub.style.opacity = '1'; }catch(e){} }, 900);
                // fade box out then remove and show main UI so the transition is continuous
                setTimeout(()=>{ try{ box.style.opacity = '0'; sub.style.opacity = '0'; }catch(e){} }, 1400);
                setTimeout(()=>{
                    try{ if(document.body.contains(cont)) document.body.removeChild(cont); }catch(e){}
                    try{ $('fcCardArea').style.display='none'; $('fcDeckInfo').style.display=''; renderDeckInfo(); updateFcProgress(); }catch(e){}
                }, 1700);
            }catch(e){
                try{ alert('Session complete.'); $('fcCardArea').style.display='none'; $('fcDeckInfo').style.display=''; renderDeckInfo(); updateFcProgress(); }catch(e){}
            }
            return; }
        if(fcSession.pos >= fcSession.queue.length) fcSession.pos = 0;
        renderFcCard(); updateFcProgress();
    }catch(e){ console.error('handleRating', e); } }

    $('fcAgain')?.addEventListener('click', ()=> handleRating(0));
    $('fcHard')?.addEventListener('click', ()=> handleRating(1));
    $('fcGood')?.addEventListener('click', ()=> handleRating(2));
    $('fcEasy')?.addEventListener('click', ()=> handleRating(3));

    // Export CSV
    $('fcExportCsv')?.addEventListener('click', (e)=>{
        try{
            if(!fcDeck || !fcDeck.length){ alert('No deck loaded.'); return; }
            const srs = readSrs();
            const rows = [['id','question','answer','choices','srsBox','lastReview','streak']];
            fcDeck.forEach(c=>{
                const rec = srs[String(c.id)] || {};
                const q = String(c.q || '').replace(/\n/g,' ');
                const a = String(c.a || '').replace(/\n/g,' ');
                const choices = (c.choices || []).map(x=>String(x||'')).join(' || ').replace(/\n/g,' ');
                rows.push([String(c.id), q, a, choices, String(rec.box||''), rec.last ? new Date(rec.last).toISOString() : '', String(rec.streak||0)]);
            });
            const csv = rows.map(r=> r.map(v=> '"'+String(v||'').replace(/"/g,'""')+'"').join(',')).join('\n');
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
            downloadBlob('flashcards.csv', blob);
        }catch(err){ console.error('fcExportCsv', err); alert('CSV export failed: '+(err?.message||err)); }
    });

    // Export Anki TSV (preferred over APKG shim)
    $('fcExportAnkiTsv')?.addEventListener('click', (e)=>{
        try{
            if(typeof window.exportAnkiTsvFromParsed === 'function'){
                window.exportAnkiTsvFromParsed();
                return;
            }
            alert('Anki TSV export is not available yet.');
        }catch(err){ console.error('fcExportAnkiTsv', err); alert('Anki TSV export failed: ' + (err?.message||err)); }
    });

    // small helpers: auto-load deck from parsed items when available (auto-invoke previous 'Load from parsed')
    (function autoLoadFcFromParsed(){
        try{
            function tryLoad(){
                try{
                    const items = (window.__quizState && window.__quizState.items) ? window.__quizState.items : (window.__STATE__ && window.__STATE__.items) ? window.__STATE__.items : (window.state && state.items) ? state.items : [];
                    if(items && items.length){
                        fcDeck = items.map((it, ix)=>({
                            id: it.num || (ix+1),
                            q: fcQuestionForItem(it),
                            a: fcAnswerForItem(it),
                            choices: Array.isArray(it.choices)? it.choices.slice() : [],
                            ix
                        }));
                        try{ window.__flashcardsDeck = fcDeck; }catch(e){}
                        renderDeckInfo(); enableStart(true);
                        return true;
                    }
                }catch(e){ console.warn('tryLoad flashcards failed', e); }
                return false;
            }

            if(tryLoad()) return;
            // Poll briefly in case parsing completes shortly after this script runs
            let attempts = 0; const maxAttempts = 12; const intervalMs = 500; const iv = setInterval(()=>{
                attempts++;
                if(tryLoad() || attempts >= maxAttempts){ try{ clearInterval(iv); }catch(e){} }
            }, intervalMs);
        }catch(e){ console.warn('autoLoadFcFromParsed failed', e); }
    })();

    // Listen for SRS updates from other windows (popup) and storage events so the main UI stays in sync.
    try{
        window.addEventListener('storage', function(e){ try{ if(e && e.key === 'srs.v1'){ renderDeckInfo(); } }catch(e){}});
        window.addEventListener('message', function(ev){ try{ if(ev && ev.data && ev.data.type === 'srs.updated'){ /* srs updated in popup */ renderDeckInfo(); } }catch(e){} });
    }catch(e){ /* ignore if not allowed */ }

    // Initialize timer UI and state on load
    try{ initFcTimer(); }catch(e){}

})();
</script>

        <!-- === AI Like-Question Generator (start-only) === -->
        <section id="ai-likeq" class="card pad ai-likeq">
            <div class="flex col center gap-8">
                <div class="key-badge missing" id="globalKeyBadge" title="Shows whether a Gemini API key is present"><span class="dot"></span><span class="hint">No key set</span></div>
                <div class="flex center gap-12">
                    <button id="aiLikeBtn" class="btn primary btn-wide" disabled>Generate Like-Questions (AI)</button>
                </div>
            </div>
            <div class="hint mt-8 text-center">
                Carefully replaces your pasted set with new, <em>format-identical</em> items. Uses conservative
                rewriting; keeps same count, structure, and single correct answer per question.
            </div>
            <div id="aiLikeStatus" class="hint mt-8 text-center"></div>
        </section>

        <!-- Utilities -->
        <section id="utilitiesPanel" class="card pad">
            <div class="module-outline utilities-head">
                <div class="utilities-title">
                    <h3 class="mt-0 mb-0 m-0">Utilities</h3>
                    <div class="hint utilities-sub">&middot; Backup your local data, share docs, and run diagnostics.</div>
                </div>
                <div class="utilities-actions">
                    <button class="btn" id="backupPanelBtn" type="button">Backup / Restore</button>
                    <button class="btn" id="selfTestBtn" type="button" title="Runs a quick built-in validation">Self Test</button>
                </div>
            </div>

            <div id="backupPanel" class="lint-panel hidden util-panel" role="region" aria-label="Backup and Restore">
                <div class="lint-head">
                    <div class="lint-title">Backup &amp; Restore</div>
                    <button class="btn small" id="backupCloseBtn" type="button">Close</button>
                </div>
                <div class="hint util-desc">
                    Exports your local browser state (Saved sets, saved textbooks, settings). Use this before switching devices/browsers.
                </div>

                <div class="util-merged">
                    <div class="util-controls">
                        <div>
                            <div class="util-mini">Included in backup</div>
                            <div class="options-container">
                                <label class="pill" title="Includes Gemini and other API keys (not recommended for sharing)"><input type="checkbox" id="backupIncludeKeys"> Include API keys</label>
                                <label class="pill" title="Includes headline cache to reduce re-fetching"><input type="checkbox" id="backupIncludeNewsCache"> Include news cache</label>
                            </div>
                        </div>
                        <div>
                            <div class="util-mini">Restore mode</div>
                            <div class="options-container">
                                <label class="pill" title="Restores saved content without clearing existing data"><input type="radio" name="restoreMode" value="merge" checked> Merge</label>
                                <label class="pill" title="Clears local data then restores from backup"><input type="radio" name="restoreMode" value="overwrite"> Overwrite</label>
                            </div>
                        </div>
                    </div>

                    <div class="util-actions">
                        <button class="btn" id="exportBackupBtn" type="button">Export backup (.json)</button>
                        <button class="btn small" id="exportShareBtn" type="button" title="Exports the current pasted document + quiz options (no API keys)">Share current doc (.json)</button>
                        <div class="file-input">
                            <label class="choose-btn" for="importBackupFile">Choose Backup</label>
                            <span class="filename" id="importBackupName">No file chosen</span>
                            <input type="file" id="importBackupFile" accept="application/json,.json" />
                        </div>
                        <button class="btn" id="restoreBackupBtn" type="button" disabled>Restore</button>
                    </div>

                    <div id="backupStatus" class="hint util-status" role="status" aria-live="polite"></div>
                </div>
            </div>

            <pre id="selfTestLog" class="selftest-log"></pre>
        </section>

        <!-- === AI Caveat + Credit (paste near the end of your main container) === -->
        <section id="ai-disclaimer" class="card pad ai-legal">
            <h3 class="mt-0 mb-8">About AI Elements (Gemini 2.5 Flash)</h3>
            <p class="muted"><strong>AI requests are sent directly from your browser to Google Gemini when enabled. Your key is stored locally on this device only if you turn on “remember”, and you can exclude keys from backups.</strong></p>
            <p class="muted">
                The rationale shown in the panel is generated by Google’s Gemini model. While useful for learning,
                it may occasionally misidentify the correct option or provide incomplete justification. Reasons include:
            </p>
            <ul class="muted">
                <li><strong>Non-determinism & sampling:</strong> temperature/top-p sampling can yield different
                    rationales across runs, including confident but incorrect claims.</li>
                <li><strong>Prompt/format drift:</strong> if the question/options aren’t parsed exactly as intended,
                    the model may reason over the wrong input.</li>
                <li><strong>Hallucinations & shortcut bias:</strong> large models sometimes invent facts or over-rely
                    on surface cues rather than domain-accurate reasoning.</li>
                <li><strong>Answer-key disagreement:</strong> if your key or parsing is off, the model could be “right”
                    while disagreeing with the displayed key (or vice-versa).</li>
            </ul>

            <p class="muted mt-10">
                For guidance on safety, evaluation, and reliability, see:
                <a href="https://ai.google.dev/gemini-api/docs" target="_blank" rel="noopener">API Docs</a>
            </p>

            

            <!-- Gemini status indicator: shows remote/ local API status (green/yellow/red) -->
            <div id="geminiStatus" class="muted mt-8 gemini-status-row">
                <span id="geminiStatusDot" class="status-dot status-unknown" aria-hidden="true"></span>
                <div id="geminiStatusLabel">Gemini status: <strong id="geminiStatusText">unknown</strong></div>
                <a id="geminiStatusLink" href="https://aistudio.google.com/status" target="_blank" rel="noopener" class="muted gemini-status-link">status</a>
            </div>

            <div class="ai-credit">
                <!-- credit moved to page header and boot overlay -->
            </div>
        </section>

    <!-- === Terms of Use Box (placed under 'About AI Elements') === -->
    <section id="tos-box" class="card pad tos-box">
        <h3 class="mt-0 mb-8">Terms of Use & Disclaimer</h3>
        <div class="muted">
            <p>Effective Date: December 25, 2025 — Version: 1.1</p>
            <p>This hosted demo runs entirely in your browser. Acceptance of the full Terms of Use is required to use AI features. Click "View TOS" to read the full Terms.</p>
        </div>
        <div class="flex gap-8 mt-8">
            <span id="tosBoxState" class="muted">Signed: <strong id="tosStateBox">Unknown</strong></span>
            <div class="right">
                <button id="tosBoxView" class="btn small">View TOS</button>
            </div>
        </div>
    </section>
    <script>
    (function(){
        const dot = document.getElementById('geminiStatusDot');
        const label = document.getElementById('geminiStatusText');
        const link = document.getElementById('geminiStatusLink');

        function setStatus(kind, text){
            try{
                dot.className = 'status-dot';
                if(kind === 'operational') dot.classList.add('status-operational');
                else if(kind === 'degraded') dot.classList.add('status-degraded');
                else if(kind === 'down') dot.classList.add('status-down');
                else dot.classList.add('status-unknown');
                label.textContent = text || kind || 'unknown';
            }catch(e){}
        }

        async function probeRemoteStatus(){
            // Try to fetch the Google AI status page (public endpoint)
            // The provided site is https://aistudio.google.com/status — try a JSON endpoint fallback if available
            try{
                const url = 'https://aistudio.google.com/status';
                const r = await fetch(url, { cache: 'no-store', mode: 'cors' });
                if(!r.ok) return { kind: 'unknown', text: 'remote unreachable' };
                const txt = await r.text();
                // Heuristic: look for 'operational' or 'degraded' keywords in the page text
                const lower = txt.toLowerCase();
                if(lower.includes('operational') || lower.includes('all systems operational')) return { kind: 'operational', text: 'remote: operational' };
                if(lower.includes('degraded') || lower.includes('partial outage') || lower.includes('degradation')) return { kind: 'degraded', text: 'remote: degraded' };
                if(lower.includes('outage') || lower.includes('down') || lower.includes('major outage')) return { kind: 'down', text: 'remote: outage' };
                return { kind: 'unknown', text: 'remote: status unknown' };
            }catch(e){ return { kind: 'unknown', text: 'remote: fetch failed' }; }
        }

        function checkLocalStatus(){
            try{
                const key = (document.getElementById('globalGemKey') && document.getElementById('globalGemKey').value) || localStorage.getItem('gemini.key');
                const enabled = !!(document.getElementById('globalGemEnable') && document.getElementById('globalGemEnable').checked);
                // Presence of a key + enabled checkbox counts as local operational; presence only of key is degraded
                if(enabled && key) return { kind: 'operational', text: 'local: enabled' };
                if(key) return { kind: 'degraded', text: 'local: key present' };
                return { kind: 'unknown', text: 'local: no key' };
            }catch(e){ return { kind: 'unknown', text: 'local: unknown' }; }
        }

        async function updateGeminiStatus(){
            try{
                setStatus('unknown','checking...');
                const [remote, local] = await Promise.allSettled([probeRemoteStatus(), Promise.resolve(checkLocalStatus())]);
                let remoteRes = { kind: 'unknown', text: '' };
                if(remote.status === 'fulfilled' && remote.value) remoteRes = remote.value;
                let localRes = { kind: 'unknown', text: '' };
                if(local.status === 'fulfilled' && local.value) localRes = local.value;

                // Prioritize remote outage signals (down => red). If remote degraded, show degraded unless local is down.
                if(remoteRes.kind === 'down') { setStatus('down', remoteRes.text + (localRes.text ? ' • ' + localRes.text : '')); return; }
                if(remoteRes.kind === 'degraded') { setStatus('degraded', remoteRes.text + (localRes.text ? ' • ' + localRes.text : '')); return; }
                // If remote looks fine or unknown, use local signal
                if(localRes.kind === 'operational') { setStatus('operational', localRes.text + (remoteRes.text ? ' • ' + remoteRes.text : '')); return; }
                if(localRes.kind === 'degraded') { setStatus('degraded', localRes.text + (remoteRes.text ? ' • ' + remoteRes.text : '')); return; }
                // default
                setStatus(remoteRes.kind || localRes.kind || 'unknown', (remoteRes.text || '') + (localRes.text ? ' • ' + localRes.text : '') || 'unknown');
            }catch(e){ setStatus('unknown','error'); }
        }

        // Run on load and periodically
        try{ updateGeminiStatus(); setInterval(updateGeminiStatus, 60 * 1000); }catch(e){}

        // Also update when key/enable inputs change
        try{ document.getElementById('globalGemKey')?.addEventListener('input', updateGeminiStatus); document.getElementById('globalGemEnable')?.addEventListener('change', updateGeminiStatus); }catch(e){}
    })();
    </script>

    <!-- Overlay used when TOS not accepted to block/blur the UI; contains centered unlock panel -->
    <div id="tosOverlay" class="tos-overlay hidden" aria-hidden="true">
        <div class="tos-unlock-panel" role="dialog" aria-label="Accept Terms to access site">
            <p class="tos-unlock-text">This site is restricted until you accept the Terms of Use. You can view and accept the Terms to unlock access.</p>
            <div class="tos-unlock-actions">
                <button id="tosUnlockBtn" class="btn primary">View & Sign TOS</button>
            </div>
        </div>
    </div>

        <!-- === style touch-ups (can live in your existing <style> block) === -->
        <style>

            .ai-legal {
                margin-top: 12px;
            }

            .ai-legal .muted {
                color: var(--muted, #9fb0c5);
                font-size: 12px;
            }

            .ai-legal a {
                color: var(--brand, #6aa9ff);
                text-decoration: underline;
            }

            .ai-legal a:focus-visible {
                outline: none;
                box-shadow: 0 0 0 2px rgba(106, 169, 255, .35);
                border-radius: 4px;
            }

            .ai-divider {
                border: 0;
                height: 1px;
                margin: 6px 0; /* reduced vertical gap */
                background: rgba(160, 180, 220, .18);
            }

            .ai-credit {
                font-size: 13px;
                color: var(--ink, #e9f0f7);
                opacity: .85;
            }

            .ai-likeq {
                margin-top: 12px;
            }

            .ai-likeq {
                margin-bottom: 12px;
            }

            .ai-likeq .hint {
                color: var(--muted, #9fb0c5);
            }
        </style>

        <style>
            /* Gemini status dot: green (operational), yellow (degraded), red (outage), gray unknown */
            .status-dot{ display:inline-block; width:12px; height:12px; border-radius:50%; border:1px solid rgba(0,0,0,0.08); box-shadow: 0 0 6px rgba(0,0,0,0.12); }
            .status-operational{ background: #4dd17a; box-shadow: 0 0 10px rgba(77,209,122,0.18); }
            .status-degraded{ background: #ffd166; box-shadow: 0 0 10px rgba(255,209,102,0.12); }
            .status-down{ background: #ff6b6b; box-shadow: 0 0 10px rgba(255,107,107,0.18); }
            .status-unknown{ background: #9fb0c5; box-shadow: none; }
            #geminiStatusLabel{ font-size:13px; color:var(--muted,#9fb0c5); }
            #geminiStatusText{ color:var(--ink,#e9f0f7); }
            /* AI explanation persistent key dot driven by root classes so it survives re-renders */
            #aiExplanationKeyDot{ background: var(--ai-key-missing-color, #ef4444); box-shadow:none; }
            .ai-key-ok #aiExplanationKeyDot{ background: var(--ai-key-ok-color, #16a34a) !important; box-shadow: 0 0 8px rgba(22,163,74,0.14); }
            .ai-key-missing #aiExplanationKeyDot{ background: var(--ai-key-missing-color, #ef4444) !important; box-shadow: none; }
        </style>

        <style>
        /* Compact TOS box: reduced vertical footprint while preserving content and controls */
        .tos-box{
            max-width: none;
            width: 100%;
            box-sizing: border-box;
            margin-top: 8px;
            margin-bottom: 12px;
            padding: 8px 12px; /* tighter padding */
            border-radius: 12px;
        }
        /* Tighter text sizing and spacing for the compact card */
        .tos-box .muted, .tos-box p, .tos-box span { font-size: 11px; color: var(--muted, #9fb0c5); line-height:1.3; margin:0 }
        .tos-box h3{ font-size: 14px; margin: 0 0 6px 0; font-weight:700 }
        /* Reduce gap between state and actions and align vertically */
        .tos-box .flex { gap: 6px }
        .tos-box .right { margin-left: auto }
        .tos-box #tosBoxState { font-size: 11px }
        /* Make the View TOS button slightly smaller and tighter */
        .tos-box .btn.small{ padding: 6px 8px; font-size: 12px; border-radius: 8px }
        /* Responsive adjustments: keep compact spacing on narrow screens */
        @media (max-width: 960px){ .tos-box{ width: calc(100% - 24px); margin-left:12px; margin-right:12px; } }
        
        /* Compact overlay unlock panel */
        .tos-unlock-panel{ padding: 10px 12px; max-width: 520px; border-radius: 10px }
        .tos-unlock-text{ font-size:13px; margin:0 0 8px }
        .tos-unlock-actions .btn.primary{ padding: 8px 10px; font-size:13px }
        </style>

    </div>

    <!-- Reset to Main Menu (shown only during quiz) -->
    <div id="resetBar" class="mt-12 hidden text-center reset-bar">
        <button id="resetToMenuBtn" class="btn">Return to Main Menu</button>
    </div>

    

        <!-- Layout reinforcement for AI explanation sizing -->
        <style>
            /* Make the AI explanation fill the right panel on desktop */
            @media (min-width: 981px){
                #quiz .side{ display:flex; flex-direction:column; min-height:0; }
                #quiz #gemOut{ height:auto !important; max-height:none !important; flex:1 1 auto; min-height:420px; }
            }
        </style>

    <!-- Official Gemini JS SDK -->
    <script
        type="module">import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai"; window.GoogleGenerativeAI = GoogleGenerativeAI;</script>

    <script>
        // --- GLOBAL HELPERS: normalizeGreek and friends ---
        const GREEK_MAP = {
            '&alpha;':'α','&beta;':'β','&gamma;':'γ','&delta;':'δ','&epsilon;':'ε','&zeta;':'ζ','&eta;':'η','&theta;':'θ','&iota;':'ι','&kappa;':'κ','&lambda;':'λ','&mu;':'μ','&nu;':'ν','&xi;':'ξ','&omicron;':'ο','&pi;':'π','&rho;':'ρ','&sigma;':'σ','&tau;':'τ','&upsilon;':'υ','&phi;':'φ','&chi;':'χ','&psi;':'ψ','&omega;':'ω',
            '&Alpha;':'Α','&Beta;':'Β','&Gamma;':'Γ','&Delta;':'Δ','&Epsilon;':'Ε','&Zeta;':'Ζ','&Eta;':'Η','&Theta;':'Θ','&Iota;':'Ι','&Kappa;':'Κ','&Lambda;':'Λ','&Mu;':'Μ','&Nu;':'Ν','&Xi;':'Ξ','&Omicron;':'Ο','&Pi;':'Π','&Rho;':'Ρ','&Sigma;':'Σ','&Tau;':'Τ','&Upsilon;':'Υ','&Phi;':'Φ','&Chi;':'Χ','&Psi;':'Ψ','&Omega;':'Ω',
            '&sigmaf;':'ς','&thetasym;':'ϑ','&upsih;':'ϒ','&varphi;':'ϕ'
        };
        const decodeNumericEntities = (s)=> String(s||'').replace(/&#(x?)([0-9A-Fa-f]+);/g, (m, x, code) => {
            try{ const cp = x ? parseInt(code,16) : parseInt(code,10); if(!isFinite(cp) || cp<0 || cp>0x10FFFF) return m; return String.fromCodePoint(cp); }catch{ return m; }
        });
        const decodeGreekNamed = (s)=> String(s||'').replace(/&(alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Alpha|Beta|Gamma|Delta|Epsilon|Zeta|Eta|Theta|Iota|Kappa|Lambda|Mu|Nu|Xi|Omicron|Pi|Rho|Sigma|Tau|Upsilon|Phi|Chi|Psi|Omega|sigmaf|thetasym|upsih|varphi);/g, (m)=> GREEK_MAP[m]||m);
        const normalizeGreek = (s)=>{
            try{
                if(s==null) return s;
                let t = String(s);
                // Decode HTML numeric/named entities first so we normalize the real code points
                t = decodeNumericEntities(t);
                t = decodeGreekNamed(t);
                t = t.replace(/[\u200B-\u200D\u2060\uFEFF]/g, '');
                t = t.replace(/Âµ/g, 'µ');
                t = t.replace(/\u00B5/g, '\u03BC');
                // Map common Latin/IPA/Cyrillic lookalikes and math alphas to true Greek
                const VARIANT = {
                    'ϑ':'θ','ϵ':'ε','ϕ':'φ','ϱ':'ρ','ϖ':'π','ϰ':'κ','ϴ':'Θ','ϐ':'β','ϒ':'Υ',
                    'ɣ':'γ','Ɣ':'Γ','Ʃ':'Σ','∑':'Σ','∏':'Π','ɑ':'α','ᵅ':'α','⍺':'α','ɸ':'φ','ı':'ι','ĸ':'κ'
                };
                t = t.replace(/[ϑϵϕϱϖϰϴϐϒɣƔƩ∑∏ɑᵅ⍺ɸıĸ]/g, ch => VARIANT[ch] || ch);
                // Use NFKC to fold mathematical bold/italic Greek (e.g., 𝛼, 𝛾) to plain Greek
                if(t.normalize){ t = t.normalize('NFKC'); }
                return t;
            }catch{ return s; }
        };
        try{ window.normalizeGreek = normalizeGreek; }catch(e){}

        (function () {
            const $ = id => document.getElementById(id);
            const setup = $('setup'), preview = $('preview'), quiz = $('quiz');
            const resetBar = $('resetBar');
            const letters = ['A', 'B', 'C', 'D', 'E', 'F'];
            const state = { items: [], order: [], idx: 0, score: 0, answered: {}, skipped: new Set(), started: false, mode: 'quiz', reviewPool: [], returnIdx: null, returnMode: null, quizStartTime: null, quizEndTime: null, timerInterval: null, attempts: [], currentAttempt: null, tags: new Set(), showSourceHints: false };
            // Expose quiz state for modules outside this closure (e.g., results analyzer)
            try{ window.__quizState = state; }catch{}

            // Theme switching: updates CSS vars to recolor bg lighting and button gradients
            (function initThemes(){
                const root = document.documentElement;
                const orbSel = document.querySelectorAll('.theme-capsule .theme-orb');
                const themes = {
                    ocean:  { glow1:'rgba(74,144,255,.20)', glow2:'rgba(112,220,255,.14)', glow3:'rgba(130,100,255,.16)', btnTop:'rgba(96,165,250,.35)', btnBottom:'rgba(24,60,120,.65)', btnBorder:'#1f3a64', brand:'#6aa9ff' },
                    sunset: { glow1:'rgba(255,122,122,.22)', glow2:'rgba(255,184,77,.16)', glow3:'rgba(255,216,107,.18)', btnTop:'rgba(255,184,122,.30)', btnBottom:'rgba(120,60,24,.65)', btnBorder:'#7a3e1f', brand:'#f59e0b' },
                    forest: { glow1:'rgba(43,212,122,.20)', glow2:'rgba(117,230,140,.15)', glow3:'rgba(63,178,160,.17)', btnTop:'rgba(45,160,110,.30)', btnBottom:'rgba(18,64,44,.65)', btnBorder:'#1a3f2c', brand:'#22c55e' },
                    violet: { glow1:'rgba(139,92,246,.22)', glow2:'rgba(96,165,250,.16)', glow3:'rgba(34,211,238,.18)', btnTop:'rgba(124,58,237,.32)', btnBottom:'rgba(49,46,129,.65)', btnBorder:'#3b2f6d', brand:'#8b5cf6' },
                    ember:  { glow1:'rgba(255,107,107,.22)', glow2:'rgba(245,158,11,.16)', glow3:'rgba(251,146,60,.18)', btnTop:'rgba(239,68,68,.32)', btnBottom:'rgba(80,30,24,.65)', btnBorder:'#4a1f1f', brand:'#ef4444' },
                                        greyscale: { 
                                            glow1:'rgba(180, 180, 180, .20)', 
                                            glow2:'rgba(120, 120, 120, .16)', 
                                            glow3:'rgba(70, 70, 70, .18)', 
                                            btnTop:'rgba(200, 200, 200, .30)', 
                                            btnBottom:'rgba(40, 40, 40, .70)', 
                                            btnBorder:'#4b5563', 
                                            brand:'#c0c0c0' 
                                        },
                };
                function hexToRgbaLocal(h, a){ try{ if(!h) return 'rgba(128,128,128,'+a+')'; h = h.replace('#',''); if(h.length===3) h = h.split('').map(ch=>ch+ch).join(''); const r = parseInt(h.substring(0,2),16); const g = parseInt(h.substring(2,4),16); const b = parseInt(h.substring(4,6),16); return 'rgba('+r+','+g+','+b+','+a+')'; }catch(e){ return 'rgba(128,128,128,'+a+')'; } }

                function applyTheme(name){
                    // Normalize theme key to lowercase to handle variants like 'Custom' or 'greyscale'
                    const lname = (name || '').toString().toLowerCase();
                    // If the user has a custom greyscale palette saved, prefer it when 'greyscale' or 'custom' is chosen
                    if(lname === 'greyscale' || lname === 'custom'){
                        try{
                            const raw = localStorage.getItem('__custom_orb_greyscale_v1');
                            if(raw){
                                const parsed = JSON.parse(raw);
                                if(parsed && parsed.colors && parsed.colors.c1){
                                    const c1 = parsed.colors.c1; const c2 = parsed.colors.c2; const c3 = parsed.colors.c3;
                                    root.style.setProperty('--glow1', hexToRgbaLocal(c1, 0.20));
                                    root.style.setProperty('--glow2', hexToRgbaLocal(c2, 0.14));
                                    root.style.setProperty('--glow3', hexToRgbaLocal(c3, 0.16));
                                    root.style.setProperty('--btnTop', hexToRgbaLocal(c1, 0.30));
                                    root.style.setProperty('--btnBottom', hexToRgbaLocal(c2, 0.28));
                                    /* Dye borders to match the custom palette (use a stronger c3 tint for outlines) */
                                    try{ root.style.setProperty('--btnBorder', hexToRgbaLocal(c3, 0.9)); }catch(e){ root.style.setProperty('--btnBorder', themes.greyscale.btnBorder); }
                                    root.style.setProperty('--brand', c1);
                                    // ensure the greyscale/custom orb reflects the inline colors as well
                                    try{ const gre = document.querySelector('.theme-orb[data-theme="greyscale"]') || document.querySelector('.theme-orb[data-theme="custom"]') || document.querySelector('.orb-greyscale') || document.querySelector('.orb-custom'); if(gre){ gre.style.setProperty('--c1', c1); gre.style.setProperty('--c2', c2); gre.style.setProperty('--c3', c3); } }catch(e){}
                                    // mark active
                                    orbSel.forEach(o=>o.classList.toggle('active', (o.dataset.theme||'').toString().toLowerCase()===lname));
                                    try{ localStorage.setItem('__theme', lname); }catch(e){}
                                    try{ document.dispatchEvent(new CustomEvent('theme-changed', { detail: { name: lname } })); }catch(e){}
                                    return;
                                }
                            }
                        }catch(e){ /* fallback to built-in greyscale below */ }
                    }
                    // default theme handling
                    const t = themes[lname] || themes.ocean;
                    root.style.setProperty('--glow1', t.glow1);
                    root.style.setProperty('--glow2', t.glow2);
                    root.style.setProperty('--glow3', t.glow3);
                    root.style.setProperty('--btnTop', t.btnTop);
                    root.style.setProperty('--btnBottom', t.btnBottom);
                    root.style.setProperty('--btnBorder', t.btnBorder);
                    root.style.setProperty('--brand', t.brand);
                    orbSel.forEach(o=>o.classList.toggle('active', (o.dataset.theme||'').toString().toLowerCase()===lname));
                    // persist selection and notify listeners
                    try{ localStorage.setItem('__theme', lname); }catch(e){}
                    try{ document.dispatchEvent(new CustomEvent('theme-changed', { detail: { name: lname } })); }catch(e){}
                }
                orbSel.forEach(o=> o.addEventListener('click', ()=> applyTheme(o.dataset.theme)));
                // Restore last theme or default to ocean (handle previously saved 'Custom' or other-cased values)
                let initial = 'ocean';
                try{ const saved = localStorage.getItem('__theme'); if(saved){ const s = saved.toString().toLowerCase(); if(s === 'custom') initial = 'greyscale'; else if(themes[s]) initial = s; } }catch(e){}
                applyTheme(initial);
            })();

            /* ---------- Skipped modal (lazy) ---------- */
            function ensureSkippedModal() {
                if (document.getElementById('skippedModal')) return;
                const wrap = document.createElement('div'); wrap.id = 'skippedModal'; wrap.className = 'hidden';
                wrap.innerHTML = `<div class="overlay"><div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center"><h3>Skipped Questions</h3><button class="btn" id="closeSkipped">Close</button></div>
      <div class="hint">Click a question to jump. Use <span class="tag">Return</span> to go back to your current spot.</div>
      <div id="skippedList" class="list" style="margin-top:10px"></div>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-end"><button class="btn" id="returnToCurrent">Return</button></div>
    </div></div>`;
                document.body.appendChild(wrap);
                $('closeSkipped').onclick = () => wrap.classList.add('hidden');
                $('returnToCurrent').onclick = () => { if (state.returnIdx != null) { state.idx = state.returnIdx; state.mode = state.returnMode || 'quiz'; } wrap.classList.add('hidden'); renderCurrent(); };
            }
            const showSkipped = () => $('skippedModal')?.classList.remove('hidden');
            const hideSkipped = () => $('skippedModal')?.classList.add('hidden');

            /* ---------- Parse ---------- */
            function parseDoc(text) {
                const raw = normalizeGreek(text || '').replace(/\r\n?/g, '\n').trim();

                // 1) JSON bank support (for TF / Matching / Fill-in-the-Blank as well as MCQ)
                // Accepts either: [ {..item..}, ... ] OR { items: [ ... ] }
                // Item schema examples:
                //  - MCQ: { type:'mcq', num:'1', q:'...', choices:['...'], correctIdx:1 }
                //  - TF: { type:'truefalse', num:'2', q:'...', answer:true }
                //  - FIB: { type:'fillblank', num:'3', q:'... ____ ...', answers:['x','y'] }
                //  - Matching: { type:'matching', num:'4', q:'Match...', pairs:[{left:'A', right:'1'}, ...], rightExtras:['distractor'] }
                if (/^[\[{]/.test(raw)) {
                    try {
                        const parsed = JSON.parse(raw);
                        const arr = Array.isArray(parsed) ? parsed : (parsed && Array.isArray(parsed.items) ? parsed.items : null);
                        if (Array.isArray(arr)) {
                            const out = [];
                            const toStr = (v) => (v == null ? '' : String(v));
                            const normType = (t) => toStr(t).toLowerCase().trim();
                            const normText = (s) => normalizeGreek(toStr(s)).trim();
                            const uniq = (xs) => {
                                const seen = new Set();
                                const res = [];
                                (xs || []).forEach(v => {
                                    const k = normText(v);
                                    if (!k) return;
                                    if (seen.has(k)) return;
                                    seen.add(k);
                                    res.push(k);
                                });
                                return res;
                            };
                            for (let i = 0; i < arr.length; i++) {
                                const src = arr[i] || {};
                                const type = normType(src.type || src.questionType || src.kind || 'mcq');
                                const num = normText(src.num || src.id || (i + 1));
                                const q = normText(src.q || src.prompt || src.question || src.text);
                                if (!q) continue;

                                if (type === 'truefalse' || type === 'tf') {
                                    const aRaw = src.answer;
                                    const correct = (typeof aRaw === 'boolean') ? aRaw : (/^(true|t|yes|y|1)$/i.test(toStr(aRaw).trim()));
                                    out.push({ type: 'truefalse', num, q, choices: ['True', 'False'], correctIdx: correct ? 0 : 1 });
                                    continue;
                                }
                                if (type === 'fillblank' || type === 'fib' || type === 'fill-in-the-blank') {
                                    const answers = Array.isArray(src.answers) ? src.answers : (src.answer != null ? [src.answer] : []);
                                    const clean = uniq(answers);
                                    out.push({ type: 'fillblank', num, q, answers: clean });
                                    continue;
                                }
                                if (type === 'matching' || type === 'match') {
                                    const pairs = Array.isArray(src.pairs) ? src.pairs : Array.isArray(src.matches) ? src.matches : [];
                                    const cleanPairs = pairs
                                        .map(p => ({ left: normText(p && (p.left ?? p.l ?? p.a)), right: normText(p && (p.right ?? p.r ?? p.b)) }))
                                        .filter(p => p.left && p.right);
                                    if (!cleanPairs.length) continue;
                                    const rightExtras = Array.isArray(src.rightExtras) ? uniq(src.rightExtras) : [];
                                    const rights = uniq(cleanPairs.map(p => p.right).concat(rightExtras));
                                    out.push({ type: 'matching', num, q, pairs: cleanPairs, rightOptions: rights });
                                    continue;
                                }

                                // Default: MCQ
                                const choices = Array.isArray(src.choices) ? src.choices.map(normText).filter(Boolean) : [];
                                if (choices.length < 2) continue;
                                let correctIdx = (typeof src.correctIdx === 'number' && isFinite(src.correctIdx)) ? src.correctIdx : null;
                                if (correctIdx == null) {
                                    const m = toStr(src.correct || src.key || src.answer || '').match(/([A-Z])/i);
                                    if (m) correctIdx = m[1].toUpperCase().charCodeAt(0) - 65;
                                }
                                correctIdx = Math.max(0, Math.min(choices.length - 1, (correctIdx == null ? 0 : correctIdx | 0)));
                                out.push({ type: 'mcq', num, q, choices, correctIdx });
                            }
                            // Attach source hints if available
                            try {
                                if (window.__aiMcqSourceHints && out.length) {
                                    for (const it of out) {
                                        const k = String(it.num);
                                        if (Object.prototype.hasOwnProperty.call(window.__aiMcqSourceHints, k)) {
                                            it.sourceHint = window.__aiMcqSourceHints[k];
                                        }
                                    }
                                }
                            } catch (e) {}
                            return out;
                        }
                    } catch (e) {
                        // fall through to plain-text parser
                    }
                }

                // 2) Plain-text parser (legacy MCQ format + lightweight TF/FIB markers)
                const lines = raw.split('\n');
                const items = [];
                const qre = /^Q\s*(\d+)\.\s*(.+)$/i;
                const keyMap = {};
                const keyIdx = lines.findIndex(l => /^\s*ANSWER\s+KEY\s*$/i.test(l));
                if (keyIdx !== -1) {
                    for (let k = keyIdx + 1; k < lines.length; k++) {
                        const line = lines[k].trim();
                        if (!line) continue;
                        // Accept A-D, A-F, T/F/True/False, or free-text answers
                        const m = line.match(/^(\d+)\s*\.?\s*[:\-]?\s*(.+)$/);
                        if (!m) continue;
                        const qn = m[1];
                        const ans = (m[2] || '').trim();
                        if (ans) keyMap[qn] = ans;
                    }
                }

                function stripTypeTag(qtext) {
                    // allow tags like [TF], [T/F], [FIB], [FILL], etc.
                    let t = (qtext || '').trim();
                    const m = t.match(/^\[(TF|T\/F|TRUEFALSE|FIB|FILL|FILL-IN-THE-BLANK|MATCH|MATCHING)\]\s*/i);
                    if (m) t = t.replace(m[0], '').trim();
                    return t;
                }
                function detectType(qtext, keyAns, choiceCount) {
                    const t = (qtext || '').trim();
                    const tag = (t.match(/^\[(TF|T\/F|TRUEFALSE|FIB|FILL|FILL-IN-THE-BLANK|MATCH|MATCHING)\]/i) || [])[1];
                    const tagNorm = tag ? tag.toLowerCase() : '';
                    if (tagNorm === 'tf' || tagNorm === 't/f' || tagNorm === 'truefalse') return 'truefalse';
                    if (tagNorm === 'fib' || tagNorm === 'fill' || tagNorm === 'fill-in-the-blank') return 'fillblank';
                    if (tagNorm === 'match' || tagNorm === 'matching') return 'matching';
                    if (choiceCount >= 2) return 'mcq';
                    if (keyAns && /^(t|f|true|false)$/i.test(String(keyAns).trim())) return 'truefalse';
                    if (keyAns) return 'fillblank';
                    return 'mcq';
                }

                function uniqText(list){
                    const seen = new Set();
                    const out = [];
                    (list || []).forEach(v=>{
                        const t = normalizeGreek(String(v || '')).trim();
                        if(!t) return;
                        const k = t.toLowerCase();
                        if(seen.has(k)) return;
                        seen.add(k);
                        out.push(t);
                    });
                    return out;
                }

                function parseMatchingLines(choiceLines){
                    const pairs = [];
                    const rightExtras = [];
                    const arrowRe = /^(.+?)\s*(?:->|=>)\s*(.+)$/;
                    const extraRe = /^(?:extra|extras|distractor|distractors)\s*[:\-]\s*(.+)$/i;
                    (choiceLines || []).forEach(line=>{
                        const t = normalizeGreek(String(line || '')).trim();
                        if(!t) return;
                        const m = t.match(arrowRe);
                        if(m){
                            const left = normalizeGreek(m[1]).trim();
                            const right = normalizeGreek(m[2]).trim();
                            if(left && right) pairs.push({ left, right });
                            return;
                        }
                        const ex = t.match(extraRe);
                        if(ex && ex[1]){ rightExtras.push(normalizeGreek(ex[1]).trim()); return; }
                        // If user listed extra right-side options without labeling them, accept them as distractors.
                        if(pairs.length) rightExtras.push(t);
                    });
                    const cleanPairs = pairs.filter(p=>p.left && p.right);
                    const rightOptions = uniqText(cleanPairs.map(p=>p.right).concat(rightExtras));
                    return { pairs: cleanPairs, rightOptions };
                }

                for (let i = 0; i < lines.length; i++) {
                    const q = lines[i].match(qre);
                    if (!q) continue;
                    const qnum = q[1];
                    const qraw = q[2].trim();
                    const choices = [];
                    for (let j = i + 1; j < lines.length; j++) {
                        const s = lines[j].trim();
                        if (/^Q\s*\d+\./i.test(s) || /^ANSWER\s+KEY/i.test(s)) { i = j - 1; break; }
                        if (/^[\-\u2013\u2014]\s+/.test(s)) choices.push(normalizeGreek(s.replace(/^[\-\u2013\u2014]\s+/, '')));
                        if (j === lines.length - 1) i = j;
                    }
                    const keyAnsRaw = keyMap[qnum];
                    const type = detectType(qraw, keyAnsRaw, choices.length);
                    const qtext = stripTypeTag(qraw);

                    if (type === 'truefalse') {
                        const a = (keyAnsRaw || '').toString().trim();
                        const correct = /^(t|true)$/i.test(a) || /^(a)$/i.test(a); // allow legacy A=True mapping
                        items.push({ type: 'truefalse', num: qnum, q: qtext, choices: ['True', 'False'], correctIdx: correct ? 0 : 1 });
                        continue;
                    }

                    if (type === 'fillblank') {
                        const a = (keyAnsRaw || '').toString().trim();
                        // Allow multiple acceptable answers separated by | or ;
                        const answers = a ? a.split(/\s*(?:\||;)\s*/g).map(x => normalizeGreek(x).trim()).filter(Boolean) : [];
                        items.push({ type: 'fillblank', num: qnum, q: qtext, answers });
                        continue;
                    }

                    if (type === 'matching') {
                        const parsed = parseMatchingLines(choices);
                        if (parsed.pairs && parsed.pairs.length) {
                            items.push({ type: 'matching', num: qnum, q: qtext, pairs: parsed.pairs, rightOptions: parsed.rightOptions });
                        } else {
                            // Keep as a placeholder fillblank so the quiz can still run
                            const a = (keyAnsRaw || '').toString().trim();
                            const answers = a ? [normalizeGreek(a).trim()].filter(Boolean) : [];
                            items.push({ type: 'fillblank', num: qnum, q: qtext, answers });
                        }
                        continue;
                    }

                    if (choices.length >= 2) {
                        const letter = ((keyAnsRaw || 'A') + '').toUpperCase().trim().match(/([A-Z])/);
                        const correctLetter = letter ? letter[1] : 'A';
                        const correctIdx = Math.max(0, Math.min(choices.length - 1, correctLetter.charCodeAt(0) - 65));
                        items.push({ type: 'mcq', num: qnum, q: qtext, choices, correctIdx });
                    }
                }

                // Attach any AI-generated source hints captured during generation
                try {
                    if (window.__aiMcqSourceHints && items.length) {
                        for (const it of items) {
                            const k = String(it.num);
                            if (Object.prototype.hasOwnProperty.call(window.__aiMcqSourceHints, k)) {
                                it.sourceHint = window.__aiMcqSourceHints[k];
                            }
                        }
                    }
                } catch (e) {}

                return items;
            }
            // Expose parser globally for validator/apply-corrections helpers
            try{ window.parseDoc = parseDoc; }catch{}

            /* ---------- Helpers ---------- */
            const shuffle = a => { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[a[i], a[j]] = [a[j], a[i]]; } return a; };
            // Reshuffle choices for an item, ensuring the correct answer changes position if possible
            function shuffleChoicesEnsureMove(it){
                try{
                    if(!it || !Array.isArray(it.choices) || it.choices.length < 2) return;
                    const prev = typeof it.correctIdx === 'number' ? it.correctIdx|0 : 0;
                    const base = it.choices.map((c,i)=>({ c, i }));
                    let z = base.slice();
                    let tries = 0;
                    do{ z = base.slice(); shuffle(z); tries++; } while(z.findIndex(t=>t.i===prev) === prev && tries < 8);
                    it.choices = z.map(t=>t.c);
                    it.correctIdx = z.findIndex(t=>t.i===prev);
                }catch(e){ console.warn('shuffleChoicesEnsureMove failed', e); }
            }
            const esc = s => (s + '').replace(/[&<>"']/g, c => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#39;" }[c]));
            // Safely decode only numeric entities and common Greek named entities, then escape for HTML
            const decodeNumericEntities = (s)=> String(s||'').replace(/&#(x?)([0-9A-Fa-f]+);/g, (m, x, code) => {
                try{ const cp = x ? parseInt(code,16) : parseInt(code,10); if(!isFinite(cp) || cp<0 || cp>0x10FFFF) return m; return String.fromCodePoint(cp); }catch{ return m; }
            });
            const GREEK_MAP = {
                '&alpha;':'α','&beta;':'β','&gamma;':'γ','&delta;':'δ','&epsilon;':'ε','&zeta;':'ζ','&eta;':'η','&theta;':'θ','&iota;':'ι','&kappa;':'κ','&lambda;':'λ','&mu;':'μ','&nu;':'ν','&xi;':'ξ','&omicron;':'ο','&pi;':'π','&rho;':'ρ','&sigma;':'σ','&tau;':'τ','&upsilon;':'υ','&phi;':'φ','&chi;':'χ','&psi;':'ψ','&omega;':'ω',
                '&Alpha;':'Α','&Beta;':'Β','&Gamma;':'Γ','&Delta;':'Δ','&Epsilon;':'Ε','&Zeta;':'Ζ','&Eta;':'Η','&Theta;':'Θ','&Iota;':'Ι','&Kappa;':'Κ','&Lambda;':'Λ','&Mu;':'Μ','&Nu;':'Ν','&Xi;':'Ξ','&Omicron;':'Ο','&Pi;':'Π','&Rho;':'Ρ','&Sigma;':'Σ','&Tau;':'Τ','&Upsilon;':'Υ','&Phi;':'Φ','&Chi;':'Χ','&Psi;':'Ψ','&Omega;':'Ω',
                '&sigmaf;':'ς','&thetasym;':'ϑ','&upsih;':'ϒ','&varphi;':'ϕ'
            };
            const decodeGreekNamed = (s)=> String(s||'').replace(/&(alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Alpha|Beta|Gamma|Delta|Epsilon|Zeta|Eta|Theta|Iota|Kappa|Lambda|Mu|Nu|Xi|Omicron|Pi|Rho|Sigma|Tau|Upsilon|Phi|Chi|Psi|Omega|sigmaf|thetasym|upsih|varphi);/g, (m)=> GREEK_MAP[m]||m);
            // Normalize Greek letters: unify variant glyphs, fix micro sign, strip zero-width; prefer NFKC for math alphas
            const normalizeGreek = (s)=>{
                try{
                    if(s==null) return s;
                    let t = String(s);
                    // Decode HTML entities first
                    t = decodeNumericEntities(t);
                    t = decodeGreekNamed(t);
                    // strip zero-width spaces/marks and BOMs
                    t = t.replace(/[\u200B-\u200D\u2060\uFEFF]/g, '');
                    // common UTF-8 mis-decode for micro sign
                    t = t.replace(/Âµ/g, 'µ');
                    // unify micro sign to Greek mu
                    t = t.replace(/\u00B5/g, '\u03BC');
                    // map variant Greek symbols + Latin/IPA lookalikes to canonical letters
                    const VARIANT = { 'ϑ':'θ','ϵ':'ε','ϕ':'φ','ϱ':'ρ','ϖ':'π','ϰ':'κ','ϴ':'Θ','ϐ':'β','ϒ':'Υ',
                                       'ɣ':'γ','Ɣ':'Γ','Ʃ':'Σ','∑':'Σ','∏':'Π','ɑ':'α','ᵅ':'α','⍺':'α','ɸ':'φ','ı':'ι','ĸ':'κ' };
                    t = t.replace(/[ϑϵϕϱϖϰϴϐϒɣƔƩ∑∏ɑᵅ⍺ɸıĸ]/g, ch => VARIANT[ch] || ch);
                    // NFKC to fold mathematical Greek (𝛼, 𝛾, …) to plain Greek
                    if(t.normalize){ t = t.normalize('NFKC'); }
                    return t;
                }catch{ return s; }
            };
                try{ window.normalizeGreek = normalizeGreek; }catch(e){}
            const safeText = (s)=> esc(normalizeGreek(decodeGreekNamed(decodeNumericEntities(s))));
            const activeList = () => state.mode === 'quiz' ? state.order : state.reviewPool;
            const activeLength = () => activeList().length;
            const activeIndex = () => activeList()[state.idx];

            /* ---------- Preview ---------- */
            function renderPreview(items) {
                preview.classList.remove('hidden');
                const list = $('previewList'); list.innerHTML = '';
                const n = Math.min(items.length, 5); // Limit to 5 items for preview
                for (let k = 0; k < n; k++) {
                    const it = items[k];
                    const div = document.createElement('div'); div.className = 'qcard';
                    const t = (it.type || 'mcq').toString().toLowerCase();
                    if (t === 'fillblank') {
                        const ans = Array.isArray(it.answers) && it.answers.length ? it.answers.join(' | ') : '(no key provided)';
                        div.innerHTML =
                            `<div><strong>Q${esc(it.num)}.</strong> ${safeText(it.q)}</div>` +
                            `<div class="hint" style="margin-top:6px">Type: <span class="tag">Fill-in-the-Blank</span></div>` +
                            `<div class="hint" style="margin-top:6px">Answer: <span class="tag">${safeText(ans)}</span></div>`;
                    } else if (t === 'matching') {
                        const pairs = Array.isArray(it.pairs) ? it.pairs : [];
                        const pairsHtml = pairs.slice(0, 6).map(p => `<div class="hint"><span class="tag">${safeText(p.left)}</span> → <span class="tag">${safeText(p.right)}</span></div>`).join('');
                        div.innerHTML =
                            `<div><strong>Q${esc(it.num)}.</strong> ${safeText(it.q)}</div>` +
                            `<div class="hint" style="margin-top:6px">Type: <span class="tag">Matching</span></div>` +
                            `<div style="margin-top:6px">${pairsHtml || '<div class="hint">(no pairs)</div>'}</div>`;
                    } else {
                        const choices = Array.isArray(it.choices) ? it.choices : [];
                        div.innerHTML =
                            `<div><strong>Q${esc(it.num)}.</strong> ${safeText(it.q)}</div>` +
                            `<div class="hint" style="margin-top:6px">Type: <span class="tag">${t === 'truefalse' ? 'True/False' : 'Multiple Choice'}</span></div>` +
                            `<div style="margin-top:6px">${choices.map((c, i) => `<span class="tag">${letters[i] || '?'}.</span> ${safeText(c)}`).join('<br>')}</div>` +
                            `<div class="hint" style="margin-top:6px">Key: <span class="tag">${letters[it.correctIdx] || 'A'}</span></div>`;
                    }
                    list.appendChild(div);
                }
                $('previewCount').textContent = items.length;
                try{
                    // Scroll so the preview module starts ~100px below the top of the viewport
                    const rect = preview.getBoundingClientRect();
                    const target = Math.max(0, (rect.top + (window.scrollY||window.pageYOffset||0)) - 100);
                    window.scrollTo({ top: target, behavior: 'smooth' });
                }catch(e){ window.scrollTo({ top: Math.max(0, (preview.offsetTop||0) - 100), behavior: 'smooth' }); }
                try{ setTimeout(()=>{ try{ window.renderMathIn && window.renderMathIn(list); }catch(e){} }, 80); }catch(e){}
            }

            /* Helpers: save/restore Gemini enabled state around quizzes */
            function saveGeminiStateForQuiz(){
                try{
                    const cb = document.getElementById('globalGemEnable');
                    if(!cb) return;
                    // Save the previous checked state so it can be restored after the quiz if needed.
                    window.__prevGemEnabled = !!cb.checked;
                    // Immediately turn OFF the global Gemini enable when a quiz starts so accidental
                    // per-question requests won't fire. Do NOT permanently disable the control;
                    // leave it enabled so the user may re-enable it at any time during the quiz.
                    try{ cb.checked = false; cb.dispatchEvent(new Event('change')); }catch(e){}
                }catch(e){}
            }
            function restoreGeminiStateAfterQuiz(){
                try{
                    const cb = document.getElementById('globalGemEnable');
                    if(!cb) return;
                    // Do NOT automatically re-enable the global Gemini toggle after a quiz.
                    // Keep it disabled by default so users must explicitly opt-in again.
                    try{ cb.checked = false; }catch(e){}
                    cb.disabled = false;
                    cb.dispatchEvent(new Event('change'));
                    try{ delete window.__prevGemEnabled }catch(e){}
                }catch(e){}
            }

            /* ---------- Start Quiz + Pre-quiz overlay ---------- */
            // Show a short, non-interactive instructional overlay with a countdown and sample question.
            function showPreQuizOverlay(items, cb){
                try{
                    // If overlay already active, just callback immediately
                    if(window.__preQuizOverlayActive) { try{ cb(); }catch(e){} return; }
                    window.__preQuizOverlayActive = true;
                    const overlay = document.createElement('div'); overlay.id = 'preQuizOverlay';
                    overlay.style.position = 'fixed'; overlay.style.left = '0'; overlay.style.top = '0'; overlay.style.right = '0'; overlay.style.bottom = '0';
                    overlay.style.display = 'flex'; overlay.style.alignItems = 'center'; overlay.style.justifyContent = 'center';
                    // ensure overlay sits above focus-mode quiz (quiz uses z-index:100000 when focus-mode active)
                    overlay.style.zIndex = '100010';
                    // darker translucent backdrop plus blur for focus
                    overlay.style.background = 'rgba(0,0,0,0.78)';
                    overlay.style.backdropFilter = 'blur(6px)'; overlay.style.WebkitBackdropFilter = 'blur(6px)';
                    overlay.style.color = '#fff'; overlay.style.fontSize = '16px'; overlay.style.padding = '24px'; overlay.style.boxSizing = 'border-box';
                    overlay.style.textAlign = 'center'; overlay.style.pointerEvents = 'auto';
                    // Inner card (visual only) - no interactive controls
                    const card = document.createElement('div'); card.style.maxWidth = '820px'; card.style.width = '92%';
                    // subtle translucent card that contrasts with the blurred backdrop
                    card.style.background = 'linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02))';
                    card.style.borderRadius = '10px'; card.style.padding = '18px';
                    // outline uses the currently selected palette color (try --brand, then --accent, then --btnTop)
                    try{
                        const rootEl = document.documentElement;
                        const cs = window.getComputedStyle ? window.getComputedStyle(rootEl) : null;
                        let accent = null;
                        if(cs){ accent = cs.getPropertyValue('--brand') || cs.getPropertyValue('--accent') || cs.getPropertyValue('--btnTop'); }
                        accent = (accent || '').trim() || '#6aa9ff';
                        card.style.outline = `2px solid ${accent}`; card.style.outlineOffset = '6px';
                        // add a faint colored glow using the resolved accent color
                        card.style.boxShadow = `0 12px 36px rgba(0,0,0,0.6), 0 0 20px rgba(0,0,0,0.0), 0 0 18px ${accent}`;
                    }catch(e){ card.style.outline = '2px solid rgba(80,140,255,0.9)'; card.style.outlineOffset = '6px'; card.style.boxShadow = '0 12px 36px rgba(0,0,0,0.6)'; }
                    card.style.pointerEvents = 'none'; // ensure non-interactible
                    const title = document.createElement('div'); title.style.fontSize = '18px'; title.style.fontWeight = '700'; title.style.marginBottom = '8px'; title.textContent = 'Quick shortcuts — ready in:';
                    const hint = document.createElement('div'); hint.style.marginBottom = '12px'; hint.innerHTML = 'Press 1-9 or A-F to choose an answer. Enter to submit / next. N = Next, S = Skip.';
                    // Only show the title, shortcuts hint, and countdown — remove sample question for a cleaner pre-quiz overlay
                    const countdown = document.createElement('div'); countdown.style.marginTop = '8px'; countdown.style.fontSize = '28px'; countdown.style.fontWeight = '700'; countdown.textContent = '3';
                    card.appendChild(title); card.appendChild(hint); card.appendChild(countdown);
                    overlay.appendChild(card); document.body.appendChild(overlay);

                    // Prevent global keyboard shortcuts from acting while overlay is present
                    const prevOverlayFlag = !!window.__preQuizOverlayActive;
                    // Countdown then remove overlay and call callback
                    let t = 3; const iv = setInterval(()=>{
                        try{ t--; if(t <= 0){ clearInterval(iv); document.body.removeChild(overlay); window.__preQuizOverlayActive = false; try{ cb(); }catch(e){} } else { countdown.textContent = String(t); } }catch(e){ clearInterval(iv); try{ document.body.removeChild(overlay); }catch{} window.__preQuizOverlayActive = false; try{ cb(); }catch(e){} }
                    }, 1000);
                }catch(e){ console.warn('showPreQuizOverlay failed', e); try{ if(cb) cb(); }catch(e){} }
            }

            function startQuiz() {
                if (!state.items.length) { alert('Parse & Preview first.'); return; }
                const items = state.items.map(it => {
                    const copy = { ...it };
                    try{ if(Array.isArray(it.choices)) copy.choices = it.choices.slice(); }catch(e){}
                    return copy;
                });
                state.order = items.map((_, i) => i);
                if ($('shuffleQ').checked) shuffle(state.order);
                if ($('shuffleA').checked) items.forEach(it => { // Shuffle answer choices if enabled
                    try{
                        if(!Array.isArray(it.choices) || it.choices.length < 2) return;
                        const z = it.choices.map((c, i) => ({ c, i })); shuffle(z);
                        it.choices = z.map(t => t.c); it.correctIdx = z.findIndex(t => t.i === it.correctIdx);
                    }catch(e){}
                });
                // show non-interactive overlay with shortcuts and a 3s countdown, then actually start the quiz
                showPreQuizOverlay(items, function(){
                    state.items = items; state.idx = 0; state.score = 0; state.mode = 'quiz'; state.started = true;
                    // track whether we've shown the one-time AI placeholder message for this quiz
                    try{ state._aiPlaceholderShown = false; }catch(e){}
                    try{ document.body.classList.add('quiz-running'); }catch{}
                    try{ saveGeminiStateForQuiz(); }catch{}
                    state.answered = {}; state.skipped.clear(); state.reviewPool = []; state.returnIdx = null; state.returnMode = null;
                    // Reset attempts and start initial attempt slice
                    state.attempts = []; state.currentAttempt = null;
                    startAttempt('initial', state.order.slice());
                    setup.classList.add('hidden'); preview.classList.add('hidden'); quiz.classList.remove('hidden');
                    // hide the Content Library during quiz
                    try{ document.getElementById('textbook-lib')?.classList.add('hidden'); }catch{}
                    if(resetBar) resetBar.style.display = 'block';
                    // Hide Validate/Like-Questions sections during the entire quiz session
                    try{ document.getElementById('ai-likeq')?.classList.add('hidden'); }catch{}
                    try{ document.getElementById('ai-likeq-copy')?.classList.add('hidden'); }catch{}
                    // Always hide results/attempts card when entering quiz
                    try{ document.getElementById('results-card')?.classList.add('hidden'); }catch{}
                    // Clear suppression when actively entering a fresh review flow (non-saved flow uses _loadedFromSaved=false)
                    try{ if(!state._loadedFromSaved) window.__suppressFocus = false; }catch(e){}
                    // start timer
                    state.quizStartTime = Date.now(); state.quizEndTime = null; if(state.timerInterval){ clearInterval(state.timerInterval); state.timerInterval = null; }
                    state.timerInterval = setInterval(()=>{ try{ const el = document.getElementById('quizTimer'); if(!el) return; const timerStart = (state.quizStartTime || (state.currentAttempt && state.currentAttempt.startedAt) || null); if(!timerStart) return; const ms = Math.max(0, Date.now() - timerStart); el.textContent = formatDuration(ms); }catch{} }, 500);
                    // Ensure focus mode is only enabled at quiz start when the user explicitly chose "Always enable focus".
                    // Some older flows or manual toggles could leave focus-mode active; prefer honoring the persisted Always setting.
                    try{
                        const ALWAYS_KEY = '__ui_always_focus_v1';
                        const alwaysOn = (function(){ try{ return localStorage.getItem(ALWAYS_KEY) === '1'; }catch(e){ return false; } })();
                        if(!alwaysOn){ try{ if(typeof window.__setFocusMode === 'function') window.__setFocusMode(false); else document.body.classList.remove('focus-mode-active'); }catch(e){} }
                        else if(!window.__suppressFocus){ try{ if(typeof window.__setFocusMode === 'function') window.__setFocusMode(true); else document.body.classList.add('focus-mode-active'); }catch(e){} }
                    }catch(e){}
                    hideSkipped(); renderCurrent();
                });
            }

            // Ensure Content Library is restored whenever the UI returns to setup
            document.addEventListener('click', function(e){
                try{
                    const btn = e.target.closest && e.target.closest('#backSetup');
                    if(btn){ 
                        document.getElementById('textbook-lib')?.classList.remove('hidden');
                        try{ if(window.refreshTextbookLibrary) window.refreshTextbookLibrary(); }catch{}
                    }
                }catch(e){}
            });

            // Keep Daily/Random quiz buttons visible ONLY when the main setup (main menu) is shown
            (function mainMenuButtonsVisibility(){
                function updateMainMenuButtonsVisibility(){
                    try{
                        const daily = document.getElementById('dailyQuizBtn');
                        const random = document.getElementById('randomQuizBtn');
                        const gear = document.getElementById('randomGearWrap');
                        const setupEl = document.getElementById('setup');
                        const quizEl = document.getElementById('quiz');
                        const savedPanel = document.getElementById('savedResultsPanel');
                        const utilitiesPanel = document.getElementById('utilitiesPanel');

                        // Main menu = setup visible, quiz hidden, and not in a running quiz session.
                        // Note: Preview may be visible on the main page (after parsing); Random/Daily should still show.
                        const quizHidden = !quizEl || quizEl.classList.contains('hidden') || (function(){ try{ return getComputedStyle(quizEl).display === 'none'; }catch(e){ return false; } })();
                        // If a fallback hid the quiz without clearing the body flag, repair it.
                        if(quizHidden && document.body.classList.contains('quiz-running')){
                            try{ document.body.classList.remove('quiz-running'); }catch(e){}
                        }
                        const isMain = !!setupEl && !setupEl.classList.contains('hidden') &&
                                       quizHidden &&
                                       !document.body.classList.contains('quiz-running');
                        [daily, random, gear].forEach(el=>{ if(!el) return; try{ el.style.display = isMain ? '' : 'none'; }catch(e){} });
                        // Only show saved results module on the main menu
                        if(savedPanel){ try{ savedPanel.style.display = isMain ? '' : 'none'; }catch(e){} }
                        // Only show Utilities on the main menu
                        if(utilitiesPanel){
                            try{ utilitiesPanel.style.display = isMain ? '' : 'none'; }catch(e){}
                            // If hiding utilities, also collapse any open subpanel so it doesn't linger
                            if(!isMain){ try{ utilitiesPanel.querySelectorAll('.util-panel').forEach(p=> p.classList.add('hidden')); }catch(e){} }
                        }
                    }catch(e){ }
                }

                // Expose a callable sync so other flows (e.g., flashcards overlay close) can force-refresh.
                try{ window.__updateMainMenuButtonsVisibility = updateMainMenuButtonsVisibility; }catch(e){}

                // Observe body class changes (quiz-running toggled) and setup visibility
                const bodyObserver = new MutationObserver(()=> updateMainMenuButtonsVisibility());
                try{ bodyObserver.observe(document.body, { attributes: true, attributeFilter: ['class'] }); }catch(e){}

                const setupEl = document.getElementById('setup');
                if(setupEl){
                    try{ const setupObserver = new MutationObserver(()=> updateMainMenuButtonsVisibility()); setupObserver.observe(setupEl, { attributes: true, attributeFilter: ['class', 'style'] }); }catch(e){}
                }

                const quizEl = document.getElementById('quiz');
                if(quizEl){
                    try{ const quizObserver = new MutationObserver(()=> updateMainMenuButtonsVisibility()); quizObserver.observe(quizEl, { attributes: true, attributeFilter: ['class', 'style'] }); }catch(e){}
                }

                const previewEl = document.getElementById('preview');
                if(previewEl){
                    try{ const previewObserver = new MutationObserver(()=> updateMainMenuButtonsVisibility()); previewObserver.observe(previewEl, { attributes: true, attributeFilter: ['class', 'style'] }); }catch(e){}
                }

                // Initial run and ensure runs after DOM ready
                if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', updateMainMenuButtonsVisibility, { once:true }); else updateMainMenuButtonsVisibility();
                // Also run on window focus to catch external state changes
                window.addEventListener('focus', updateMainMenuButtonsVisibility);
            })();

            function startAttempt(mode, poolIndices){
                try{
                    state.currentAttempt = { id: (state.attempts.length + 1), mode: mode||'initial', pool: (poolIndices||[]).slice(), startedAt: Date.now(), endedAt: null, durationMs: 0, missed: [] };
                }catch(e){ console.warn('startAttempt failed', e); }
            }

            function finalizeCurrentAttempt(){
                try{
                    if(!state.currentAttempt) return;
                    const att = state.currentAttempt; att.endedAt = Date.now(); att.durationMs = Math.max(0, (att.endedAt - (att.startedAt||att.endedAt)));
                    const missed = [];
                    for(const ix of (att.pool||[])){
                        const it = state.items[ix]; const rec = state.answered[ix];
                        const wasWrong = !rec || !rec.submitted || !rec.correct;
                        if(wasWrong){
                            missed.push({
                                index: ix,
                                type: it?.type || 'mcq',
                                num: it?.num,
                                q: it?.q,
                                choices: (it?.choices||[]).slice(),
                                correctIdx: it?.correctIdx,
                                user: (rec && rec.selected!=null ? rec.selected : null),
                                userText: (rec && typeof rec.text === 'string') ? rec.text : null,
                                userMatch: (rec && Array.isArray(rec.match)) ? rec.match.slice() : null,
                                answers: (it && Array.isArray(it.answers)) ? it.answers.slice() : null,
                                pairs: (it && Array.isArray(it.pairs)) ? it.pairs.map(p=>({ left: p.left, right: p.right })) : null,
                                rightOptions: (it && Array.isArray(it.rightOptions)) ? it.rightOptions.slice() : null,
                                durationMs: (rec && typeof rec._lastDurationMs === 'number') ? rec._lastDurationMs : null,
                                attemptId: att.id,
                                mode: att.mode
                            });
                        }
                    }
                            att.missed = missed;
                            // Save per-question timing snapshot for this attempt so results UI can show timings for all items
                            try{
                                att.qTimes = (att.pool||[]).map(ix => {
                                    const it = state.items[ix]; const rec = state.answered[ix];
                                    return {
                                        index: ix,
                                        num: it?.num,
                                        durationMs: (rec && typeof rec._lastDurationMs === 'number') ? rec._lastDurationMs : null,
                                        correct: !!(rec && rec.correct),
                                        submitted: !!(rec && rec.submitted),
                                        user: (rec && rec.selected!=null) ? rec.selected : null
                                    };
                                });
                            }catch(e){}
                    state.attempts.push(att);
                    state.currentAttempt = null;
                }catch(e){ console.warn('finalizeCurrentAttempt failed', e); }
            }

            /* ---------- Render current ---------- */
            function renderCurrent() {
                // Ensure any in-progress AI output (text/audio) is stopped and cleared immediately
                try{
                    if(typeof window.stopAiOutput === 'function') window.stopAiOutput();
                }catch{}
                try{ const w = document.getElementById('resultsAiOutput'); if(w){ try{ if(w._page) w._page.textContent = ''; else w.textContent = ''; }catch{} } }catch{}
                const list = activeList();
                if (!list.length) { if (state.mode === 'review') return showReviewDone(); alert('Nothing to show.'); return; }
                // Ensure results/attempts card is hidden while viewing questions
                try{ document.getElementById('results-card')?.classList.add('hidden'); }catch{}
                const itemIndex = activeIndex(); const it = state.items[itemIndex]; const total = activeLength();
                if (!state.answered[itemIndex]) state.answered[itemIndex] = { selected: null, submitted: false, correct: false, skipped: false };
                const rec = state.answered[itemIndex];
                // mark when this question was shown so we can compute per-question durations
                try{ rec._lastShownAt = Date.now(); }catch(e){}
                const prog = Math.round((state.idx) / Math.max(1, total) * 100);

                                // Compute current elapsed time so the timer doesn't flash to 00:00
                                const timerStart = (state.quizStartTime || (state.currentAttempt && state.currentAttempt.startedAt) || null);
                                const elapsedMsForRender = timerStart ? Math.max(0, Date.now() - timerStart) : 0;

                                const grid = document.createElement('div'); grid.className = 'quizgrid';
                // ensure the grid stretches so the sidebar can fill vertical space
                grid.style.alignItems = 'stretch'; grid.style.minHeight = '420px';
                const left = document.createElement('div');
                                left.innerHTML = `
            <div class="footer" style="margin-bottom:6px">
                <div class="row" style="gap:8px;align-items:center">
          <span class="tag">${state.mode === 'quiz' ? 'Quiz' : 'Review'}</span>
          <span class="tag">#${state.idx + 1} / ${total}</span>
          <span class="tag">Score: ${state.score}</span>
          <span class="tag">Skipped: <span id="skippedCount">${state.skipped.size}</span></span>
                                        <span class="tag" title="Elapsed time"><span id="quizTimer">${formatDuration(elapsedMsForRender)}</span></span>
                    <button id="sourceHintToggle" class="btn small" type="button" title="Toggle source search hint" style="min-height:0;height:26px;padding:2px 8px;font-size:11px;line-height:1;border-radius:999px">ⓘ</button>
          <span class="link" id="openSkipped" style="cursor:pointer;color:var(--brand);text-decoration:underline">Open Skipped</span>
        </div>
        <div class="progress" style="flex:1 1 auto; max-width:420px"><div style="width:${prog}%"></div></div>
      </div>
            <div class="qcard">
        <div class="q-head" style="display:grid;grid-template-columns:1fr auto;align-items:end;margin-bottom:4px">
            <div style="font-weight:700">Q${esc(it.num)}. ${safeText(it.q)}</div>
            <button type="button" class="tts-btn" title="Read question aloud" aria-pressed="false" style="border:none;background:transparent;font-size:18px;padding:4px;cursor:pointer;line-height:1">🔊</button>
        </div>
        <div id="sourceHint" class="hint" style="margin-bottom:8px;${state.showSourceHints && it && it.sourceHint ? '' : 'display:none;'}">${it && it.sourceHint ? safeText(it.sourceHint) : ''}</div>
                <div id="choices"></div>
        <div id="status" class="hint" style="margin-top:6px"></div>
      </div>
                <div class="footer">
                <div class="toolbar">
                    <button class="btn warn" id="skipBtn">Skip</button>
                    <button class="btn" id="backBtn" ${state.idx === 0 ? 'disabled' : ''}>Back</button>
                </div>
                <div class="toolbar">
                    <button class="btn" id="revealBtn">Reveal</button>
                    <button class="btn" id="tagBtn" title="Tag this question for later review">Tag</button>
                    <button class="btn primary" id="nextBtn">${state.idx === total - 1 ? 'Finish' : 'Next'}</button>
                </div>
            </div>`;
                const ch = left.querySelector('#choices');

                function normAnswerText(s){
                    try{
                        return normalizeGreek(String(s||'')).trim().replace(/\s+/g, ' ').toLowerCase();
                    }catch(e){ return String(s||'').trim().toLowerCase(); }
                }
                function getType(it){ return (it && it.type ? String(it.type) : 'mcq').toLowerCase(); }
                function ensureTf(it){
                    if(!it) return;
                    if(!Array.isArray(it.choices) || it.choices.length !== 2) it.choices = ['True','False'];
                    if(typeof it.correctIdx !== 'number' || !isFinite(it.correctIdx)) it.correctIdx = 0;
                }

                function renderInteraction(){
                    ch.innerHTML = '';
                    const t = getType(it);
                    if(t === 'truefalse') ensureTf(it);
                    if(t === 'mcq' || t === 'truefalse'){
                        const choices = Array.isArray(it.choices) ? it.choices : [];
                        choices.forEach((c, idx) => {
                            const lab = document.createElement('label'); lab.className = 'choice';
                            lab.innerHTML = `<input type="radio" name="c"> <strong>${letters[idx]}.</strong> <span class="choice-body">${safeText(c)}</span>`;
                            const input = lab.querySelector('input'); input.checked = rec.selected === idx;
                            input.addEventListener('change', () => {
                                if (!rec.submitted) { rec.selected = idx; doSubmit(it, itemIndex); }
                            });
                            if (rec.submitted) lab.classList.add('disabled');
                            ch.appendChild(lab);
                        });
                        return;
                    }

                    if(t === 'fillblank'){
                        const wrap = document.createElement('div');
                        wrap.innerHTML = `
                            <div class="hint" style="margin-bottom:8px">Type your answer, then submit.</div>
                            <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap">
                                <input id="fibInput" type="text" autocomplete="off" spellcheck="false" placeholder="Your answer" style="flex:1 1 260px; min-width:220px; height:36px; border-radius:10px; background: rgba(12,21,38,.85); color: var(--ink); border: 1px solid var(--btnBorder); padding: 6px 10px; box-sizing:border-box" />
                                <button id="fibSubmit" class="btn primary" type="button" style="height:36px">Submit</button>
                            </div>
                            <div id="fibKey" class="hint" style="margin-top:10px; display:none"></div>
                        `;
                        ch.appendChild(wrap);
                        const inp = wrap.querySelector('#fibInput');
                        if(inp){
                            try{ inp.value = (typeof rec.text === 'string') ? rec.text : ''; }catch(e){}
                            if(rec.submitted){ inp.disabled = true; }
                            inp.addEventListener('input', ()=>{ try{ rec.text = inp.value; }catch(e){} });
                            inp.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); if(!rec.submitted) doSubmit(it, itemIndex); } });
                        }
                        const btn = wrap.querySelector('#fibSubmit');
                        if(btn){ btn.disabled = !!rec.submitted; btn.onclick = ()=> doSubmit(it, itemIndex); }
                        // After submission, show key
                        if(rec.submitted){
                            const key = wrap.querySelector('#fibKey');
                            const ans = Array.isArray(it.answers) && it.answers.length ? it.answers.join(' | ') : '(no key provided)';
                            if(key){ key.style.display=''; key.innerHTML = `Answer: <span class="tag">${safeText(ans)}</span>`; }
                        }
                        return;
                    }

                    if(t === 'matching'){
                        const pairs = Array.isArray(it.pairs) ? it.pairs : [];
                        const baseRights = Array.isArray(it.rightOptions) && it.rightOptions.length
                            ? it.rightOptions.slice()
                            : Array.from(new Set(pairs.map(p=>p.right))).filter(Boolean);
                        // shuffle right options for this render
                        const rights = baseRights.slice();
                        try{ shuffle(rights); }catch(e){}

                        const wrap = document.createElement('div');
                        wrap.innerHTML = `
                            <div class="hint" style="margin-bottom:6px">Match each left item to a right item, then submit.</div>
                            <div id="matchRows" style="display:flex; flex-direction:column; gap:6px"></div>
                            <div style="display:flex; gap:8px; align-items:center; justify-content:flex-end; margin-top:8px">
                                <button id="matchSubmit" class="btn primary" type="button">Submit</button>
                            </div>
                        `;
                        ch.appendChild(wrap);
                        const rows = wrap.querySelector('#matchRows');
                        const selArr = Array.isArray(rec.match) ? rec.match.slice() : [];
                        pairs.forEach((p, i)=>{
                            const row = document.createElement('div');
                            row.className = 'choice match-row';
                            row.style.display = 'flex';
                            row.style.alignItems = 'center';
                            row.style.gap = '8px';
                            row.innerHTML = `
                                <div style="flex:1 1 320px"><strong>${safeText(p.left)}</strong></div>
                                <div style="flex:0 0 240px">
                                    <select data-left-idx="${i}" style="width:100%; height:32px; border-radius:10px; background: rgba(12,21,38,.85); color: var(--ink); border: 1px solid var(--btnBorder); padding: 6px 10px; box-sizing:border-box">
                                        <option value="">Select…</option>
                                        ${rights.map((r, idx)=>`<option value="${idx}">${esc(r)}</option>`).join('')}
                                    </select>
                                </div>
                            `;
                            const sel = row.querySelector('select');
                            if(sel){
                                // attempt to restore selection by matching right text
                                const prevIdx = selArr[i];
                                if(typeof prevIdx === 'number' && prevIdx >= 0 && prevIdx < rights.length){ sel.value = String(prevIdx); }
                                sel.disabled = !!rec.submitted;
                                sel.addEventListener('change', ()=>{
                                    const v = sel.value === '' ? null : (parseInt(sel.value,10));
                                    if(!Array.isArray(rec.match)) rec.match = [];
                                    rec.match[i] = (v==null || !isFinite(v)) ? null : v;
                                });
                            }
                            if(rows) rows.appendChild(row);
                        });
                        const btn = wrap.querySelector('#matchSubmit');
                        if(btn){ btn.disabled = !!rec.submitted; btn.onclick = ()=> doSubmit(it, itemIndex); }
                        return;
                    }

                    // fallback
                    ch.innerHTML = `<div class="hint">Unsupported question type: <span class="tag">${safeText(t)}</span></div>`;
                }

                renderInteraction();
                const statusEl = left.querySelector('#status'); if (rec.submitted) { statusEl.textContent = rec.correct ? 'Already submitted: Correct.' : 'Already submitted: Incorrect.'; }
                // Wire source-hint toggle button per render
                try{
                    const srcToggle = left.querySelector('#sourceHintToggle');
                    if(srcToggle){
                        const applyHintVisibility = ()=>{
                            const h = left.querySelector('#sourceHint');
                            if(!h) return;
                            if(state.showSourceHints && it && it.sourceHint){ h.style.display=''; h.textContent = safeText(it.sourceHint); }
                            else { h.style.display='none'; }
                        };
                        applyHintVisibility();
                        srcToggle.onclick = ()=>{
                            state.showSourceHints = !state.showSourceHints;
                            applyHintVisibility();
                        };
                    }
                }catch(e){}
                // Initialize Tag button state for this question
                try{
                    const tagBtn = left.querySelector('#tagBtn');
                    if(tagBtn){
                        const isTagged = state.tags && state.tags.has(itemIndex);
                        tagBtn.classList.toggle('primary', isTagged);
                        tagBtn.textContent = isTagged ? 'Untag' : 'Tag';
                        tagBtn.addEventListener('click', ()=>{
                            try{
                                if(!state.tags) state.tags = new Set();
                                if(state.tags.has(itemIndex)) state.tags.delete(itemIndex); else state.tags.add(itemIndex);
                                const nowTagged = state.tags.has(itemIndex);
                                tagBtn.classList.toggle('primary', nowTagged);
                                tagBtn.textContent = nowTagged ? 'Untag' : 'Tag';
                            }catch(e){}
                        });
                    }
                }catch(e){}

                                                                const right = document.createElement('aside'); right.className = 'side';
                                                                // make the sidebar a column flexbox so gemOut can flex-grow
                                                                right.style.display = 'flex'; right.style.flexDirection = 'column'; right.style.gap = '8px'; right.style.minHeight = '0'; right.style.alignSelf = 'stretch'; right.style.height = '100%'; right.style.flex = '0 0 320px';
                                                                // Ensure the sidebar visually occludes anything behind it (avoid buffering effect)
                                                                try{ right.style.background = 'linear-gradient(180deg, rgba(14,21,34,1), rgba(9,15,26,1))'; right.style.border = '1px solid var(--stroke)'; right.style.boxSizing = 'border-box'; right.style.zIndex = '3'; right.style.position = 'relative'; }catch(e){}
                                                                right.innerHTML = `
                                            <h3 style="margin:0 0 6px 0; display:inline-flex; align-items:center;"> <span id="aiExplanationKeyDot" class="key-dot missing" aria-hidden="true" title="API key status" style="display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:8px;vertical-align:middle;"></span>AI Explanation</h3>
                                            <div style="flex:1 1 0; min-height:0; display:flex; flex-direction:column;">
                                                <div id="resultsAiOutput" class="hint mt-12" role="status" aria-live="polite"></div>
                                            </div>
                                        `;
                grid.appendChild(left); grid.appendChild(right); quiz.innerHTML = ''; quiz.appendChild(grid);

                // Stop any in-progress per-question TTS when re-rendering
                try{ if(typeof window.stopTtsOutput === 'function') window.stopTtsOutput(); }catch{}
                // Wire up per-question TTS button (SpeechSynthesis) and render LaTeX in the newly inserted quiz content (questions, choices, AI output)
                try{ setTimeout(()=>{ try{ const qarea = quiz; window.renderMathIn && window.renderMathIn(qarea); const aiOut = document.getElementById('resultsAiOutput'); if(aiOut) window.renderMathIn && window.renderMathIn(aiOut); }catch(e){ console.warn('renderMathIn quiz failed', e); } }, 60); }catch(e){}

                // TTS: build a small controller for this page so other code can stop speech when needed
                try{
                    // helper to strip HTML tags for spoken text
                    const _stripTags = s => String(s||'').replace(/<[^>]*>/g, '').replace(/&nbsp;/g,' ').trim();
                    const tbtn = left.querySelector('.tts-btn');
                    if(tbtn){
                        // ensure previous attribute state
                        tbtn.setAttribute('aria-pressed','false');
                        tbtn.onclick = function(ev){
                            try{
                                // toggle: if speaking, stop; otherwise start
                                if(window.__ttsSpeaking){
                                    try{ window.stopTtsOutput && window.stopTtsOutput(); }catch{};
                                    return;
                                }
                                // Build spoken text: question then choices
                                const qtxt = (it.q || '').toString();
                                const choicesTxt = (it.choices || []).map((c, i) => `${letters[i] || String(i+1)}. ${_stripTags(c)}`).join('. ');
                                const speak = `${qtxt}. Choices: ${choicesTxt}.`;

                                // Cancel any lingering speech and speak
                                try{ speechSynthesis.cancel(); }catch(e){}
                                const u = new SpeechSynthesisUtterance(speak);
                                // Lower spoken voice volume to avoid being too loud by default (0.0 - 1.0)
                                try{ u.volume = 0.5; }catch(e){}
                                try{ u.lang = document.documentElement.lang || 'en-US'; }catch(e){}
                                // Save globals so other code can stop playback
                                window.__ttsUtterance = u;
                                window.__ttsSpeaking = true;
                                tbtn.setAttribute('aria-pressed','true');
                                speechSynthesis.speak(u);
                                u.onend = u.onerror = function(){ try{ window.__ttsSpeaking = false; window.__ttsUtterance = null; tbtn.setAttribute('aria-pressed','false'); }catch(e){} };
                            }catch(e){ console.warn('TTS start failed', e); }
                        };
                    }
                    // Expose a stop function so other modules can halt TTS
                    window.stopTtsOutput = function(){ try{ if(window.__ttsUtterance){ try{ speechSynthesis.cancel(); }catch(e){} window.__ttsUtterance = null; } window.__ttsSpeaking = false; const b = document.querySelector('.tts-btn'); if(b) b.setAttribute('aria-pressed','false'); }catch(e){} };
                }catch(e){ console.warn('TTS wiring failed', e); }

                // Ensure the AI Explanation wrapper (text + ASCII face) is initialized.
                // Show the one-time placeholder only once per quiz; after that, ensure the wrapper exists
                // but do not repeat the spoken/typed placeholder.
                try{
                    setTimeout(()=>{
                        try{
                            const showOnce = !(state && state._aiPlaceholderShown);
                            // Preferred: use the animated wrapper initializer if available
                            if(typeof window.showAiOutput === 'function'){
                                if(showOnce){
                                    try{ window.showAiOutput('AI explanation panel ready. Enable the API Key and select an answer to see a short AI analysis.'); }catch(e){}
                                    try{ state._aiPlaceholderShown = true; }catch(e){}
                                } else {
                                    // Ensure wrapper exists without speaking the placeholder
                                    try{ if(typeof ensureWrapper === 'function') ensureWrapper(); else if(typeof window.showAiOutput === 'function') window.showAiOutput(''); }catch(e){}
                                }
                            } else {
                                // Fallback: augment the resultsAiOutput element so it shows a page box and face
                                const out = document.getElementById('resultsAiOutput');
                                if(out){
                                    if(out.innerHTML.trim() === ''){
                                        out.classList.add('aiTextbookOutput');
                                        if(showOnce){
                                            // Make the output container opaque to prevent the underlying panel from showing through
                                            try{ out.style.background = 'linear-gradient(180deg, rgba(14,21,34,1), rgba(9,15,26,1))'; out.style.border = '1px solid var(--stroke)'; out.style.boxSizing = 'border-box'; out.style.zIndex = '4'; }catch(e){}
                                            out.innerHTML = '<div class="page" role="status" aria-live="polite">AI explanation panel ready. Select an answer to see a short AI analysis.</div>' +
                                                            '<div class="ascii-face"><div class="face" role="button" tabindex="0">(<span class="eye left"><span class="lash">&quot;&quot;</span><span class="dot">•</span></span><span class="mouth">___</span><span class="eye right"><span class="lash">&quot;&quot;</span><span class="dot">•</span></span>)</div></div>';
                                            try{ state._aiPlaceholderShown = true; }catch(e){}
                                        } else {
                                            out.innerHTML = '<div class="page" role="status" aria-live="polite"></div>' +
                                                            '<div class="ascii-face"><div class="face" role="button" tabindex="0">(<span class="eye left"><span class="lash">&quot;&quot;</span><span class="dot">•</span></span><span class="mouth">___</span><span class="eye right"><span class="lash">&quot;&quot;</span><span class="dot">•</span></span>)</div></div>';
                                        }
                                        // Apply persisted lashes state and wire toggle for fallback markup
                                        try{
                                            const face = out.querySelector('.ascii-face .face');
                                            const LASH_KEY = 'ai.face.lashed';
                                            if(face){
                                                const saved = localStorage.getItem(LASH_KEY) === '1';
                                                if(saved) face.classList.add('lashed');
                                                function setLash(on){ try{ face.classList.toggle('lashed', !!on); localStorage.setItem(LASH_KEY, on?'1':'0'); face.classList.add('lash-toggle'); setTimeout(()=>{ try{ face.classList.remove('lash-toggle'); }catch(e){} }, 380); }catch(e){} }
                                                face.addEventListener('click', ()=> setLash(!face.classList.contains('lashed')));
                                                face.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); setLash(!face.classList.contains('lashed')); }});
                                            }
                                        }catch(e){}
                                    } else {
                                        // If content exists but we haven't marked placeholder as shown, mark it so we don't repeat
                                        if(showOnce){ try{ state._aiPlaceholderShown = true; }catch(e){} }
                                    }
                                }
                            }
                        }catch(e){}
                    }, 90);
                }catch(e){}

                // AI explanation uses the global key in #globalGemKey; no per-quiz key input required here.

                left.querySelector('#revealBtn').onclick = () => reveal(it, rec);
                left.querySelector('#nextBtn').onclick = next;
                left.querySelector('#backBtn').onclick = back;
                left.querySelector('#skipBtn').onclick = skipCurrent;
                // Disable the Open Skipped control when there are no skipped questions
                try{
                    const os = left.querySelector('#openSkipped');
                    if(os){
                        const has = !!(state && state.skipped && state.skipped.size);
                        if(!has){ os.style.pointerEvents = 'none'; os.style.opacity = '0.55'; }
                        else { os.style.pointerEvents = 'auto'; os.style.opacity = '1'; os.onclick = openSkippedPanel; }
                    }
                }catch(e){}
            }

            // Reset to main menu: clear quiz state and return to setup screen
            (function bindReset(){
                const btn = $('resetToMenuBtn');
                if(!btn) return;
                // Prevent keyboard activation; only allow pointer/tap/click
                try{ btn.addEventListener('keydown', (ev)=>{ const k = ev.key; if(k === 'Enter' || k === ' ' || k === 'Spacebar'){ ev.preventDefault(); ev.stopPropagation(); } }); }catch(e){}
                btn.addEventListener('pointerup', (ev)=>{
                    try{
                        state.items = []; state.order = []; state.idx = 0; state.score = 0; state.answered = {}; state.skipped.clear(); state.reviewPool = []; state.started = false; state.mode = 'quiz';
                        // stop and clear timer
                        if(state.timerInterval){ clearInterval(state.timerInterval); state.timerInterval = null; }
                        state.quizStartTime = null; state.quizEndTime = null;
                        // Hide quiz, show setup
                        quiz.classList.add('hidden');
                        preview.classList.add('hidden');
                        setup.classList.remove('hidden');
                        try{ document.body.classList.remove('quiz-running'); }catch{}
                        try{ restoreGeminiStateAfterQuiz(); }catch{}
                        // Ensure textbook library UI is visible and refreshed
                        try{ document.getElementById('textbook-lib')?.classList.remove('hidden'); }catch{}
                        try{ if(window.refreshTextbookLibrary) window.refreshTextbookLibrary(); }catch{}
                        if(resetBar) resetBar.style.display = 'none';
                        // Unhide AI panels that were hidden after parsing/starting
                        try{ document.getElementById('ai-likeq')?.classList.remove('hidden'); }catch{}
                        try{ document.getElementById('ai-likeq-copy')?.classList.remove('hidden'); }catch{}
                        try{ document.querySelector('.ai-file-panel')?.classList.remove('hidden'); }catch{}
                        // Re-run light UI sync for key badges/buttons
                        try{
                            const evt = new Event('change');
                            document.getElementById('globalGemKey')?.dispatchEvent(new Event('input'));
                            document.getElementById('globalGemEnable')?.dispatchEvent(evt);
                        }catch{}
                        // Clear AI explanation panel and any transient UI
                        try{ if(typeof window.stopAiOutput === 'function'){ window.stopAiOutput(); } else { const gemOut = document.getElementById('gemOut'); if(gemOut) gemOut.value = ''; } }catch{}
                        const skipped = document.getElementById('skippedModal'); if(skipped) skipped.classList.add('hidden');
                        // hide results card
                        try{ document.getElementById('results-card')?.classList.add('hidden'); document.getElementById('resultsSummary').innerHTML=''; document.getElementById('resultsAiStatus').textContent=''; try{ if(typeof window.stopAiOutput === 'function'){ window.stopAiOutput(); } else { document.getElementById('resultsAiOutput').textContent=''; } }catch{} }catch{}
                        // Mark as not parsed so initializers won't hide AI panels until next parse
                        try{ window.__parsed = false; }catch{}
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                    }catch(e){ console.error('resetToMenu failed', e); }
                });
            })();

            const lockChoices = () => {
                // visually mark and prevent further interaction with choices
                quiz.querySelectorAll('.choice').forEach(n => {
                    n.classList.add('disabled');
                    // disable contained input and make label inert
                    const inp = n.querySelector('input'); if(inp){ inp.disabled = true; inp.checked = inp.checked; }
                    n.style.pointerEvents = 'none';
                    n.style.opacity = '0.95';
                });
            };

            function lockCurrentInteraction(){
                try{
                    // Disable radios
                    quiz.querySelectorAll('.choice input').forEach(inp=>{ try{ inp.disabled = true; }catch(e){} });
                    // Disable text inputs/selects
                    quiz.querySelectorAll('#fibInput, #choices input[type="text"], #choices select').forEach(el=>{ try{ el.disabled = true; }catch(e){} });
                    // Disable per-type submit buttons
                    quiz.querySelectorAll('#fibSubmit, #matchSubmit').forEach(b=>{ try{ b.disabled = true; }catch(e){} });
                    // Visually disable choice rows
                    quiz.querySelectorAll('.choice').forEach(n=>{ try{ n.classList.add('disabled'); }catch(e){} });
                }catch(e){}
            }

            function evaluateAnswer(it, rec){
                const t = (it && it.type ? String(it.type) : 'mcq').toLowerCase();
                if(t === 'truefalse' || t === 'mcq'){
                    const sel = (rec && rec.selected != null) ? (rec.selected|0) : null;
                    if(sel == null) return false;
                    return sel === (it.correctIdx|0);
                }
                if(t === 'fillblank'){
                    const ans = (rec && typeof rec.text === 'string') ? rec.text : '';
                    const v = normalizeGreek(String(ans||'')).trim().replace(/\s+/g,' ').toLowerCase();
                    const keys = Array.isArray(it.answers) ? it.answers : [];
                    if(!keys.length) return false;
                    return keys.some(k => normalizeGreek(String(k||'')).trim().replace(/\s+/g,' ').toLowerCase() === v);
                }
                if(t === 'matching'){
                    const pairs = Array.isArray(it.pairs) ? it.pairs : [];
                    const opts = Array.isArray(it.rightOptions) && it.rightOptions.length ? it.rightOptions : Array.from(new Set(pairs.map(p=>p.right))).filter(Boolean);
                    const match = Array.isArray(rec.match) ? rec.match : [];
                    if(!pairs.length) return false;
                    for(let i=0;i<pairs.length;i++){
                        const selIdx = match[i];
                        if(selIdx == null || !isFinite(selIdx)) return false;
                        const chosen = opts[selIdx];
                        if(!chosen) return false;
                        if(normalizeGreek(String(chosen)).trim() !== normalizeGreek(String(pairs[i].right)).trim()) return false;
                    }
                    return true;
                }
                return false;
            }

            function doSubmit(it, itemIndex) {
                const rec = state.answered[itemIndex] || (state.answered[itemIndex] = { selected: null, submitted: false, correct: false, skipped: false });
                if (rec.submitted) return;
                const t = (it && it.type ? String(it.type) : 'mcq').toLowerCase();

                // capture response from DOM for non-radio types
                if(t === 'fillblank'){
                    try{
                        const inp = document.getElementById('fibInput') || quiz.querySelector('#choices input[type="text"]');
                        if(inp) rec.text = inp.value;
                    }catch(e){}
                    if(!rec.text || !String(rec.text).trim()){ alert('Type an answer first.'); return; }
                }
                if(t === 'matching'){
                    try{
                        const selects = quiz.querySelectorAll('#choices select[data-left-idx]');
                        const arr = [];
                        selects.forEach(sel=>{
                            const i = parseInt(sel.getAttribute('data-left-idx')||'0',10) || 0;
                            const v = sel.value === '' ? null : parseInt(sel.value,10);
                            arr[i] = (v==null || !isFinite(v)) ? null : v;
                        });
                        rec.match = arr;
                    }catch(e){}
                    const pairs = Array.isArray(it.pairs) ? it.pairs : [];
                    if(!pairs.length){ alert('This matching question has no pairs.'); return; }
                    // require all rows selected
                    if(!Array.isArray(rec.match) || rec.match.length < pairs.length || pairs.some((_,i)=>rec.match[i]==null)){
                        alert('Complete all matches first.');
                        return;
                    }
                }

                if(t === 'mcq' || t === 'truefalse'){
                    if (rec.selected == null) {
                        const checked = quiz.querySelector('.choice input:checked');
                        if(checked){
                            const labs = Array.from(quiz.querySelectorAll('.choice input'));
                            const ix = labs.indexOf(checked);
                            if(ix >= 0) rec.selected = ix;
                        }
                    }
                    if (rec.selected == null) { alert('Choose an option first.'); return; }
                }

                // Visual feedback per type
                if(t === 'mcq' || t === 'truefalse'){
                    const nodes = quiz.querySelectorAll('.choice');
                    nodes.forEach((n, idx) => { n.classList.remove('correct', 'wrong'); if (idx === it.correctIdx) n.classList.add('correct'); if (idx === rec.selected && rec.selected !== it.correctIdx) n.classList.add('wrong'); });
                }
                if(t === 'fillblank'){
                    const inp = document.getElementById('fibInput') || quiz.querySelector('#choices input[type="text"]');
                    if(inp){
                        try{ inp.style.borderColor = 'var(--btnBorder)'; }catch(e){}
                    }
                }
                if(t === 'matching'){
                    // highlight rows
                    const pairs = Array.isArray(it.pairs) ? it.pairs : [];
                    const opts = Array.isArray(it.rightOptions) && it.rightOptions.length ? it.rightOptions : Array.from(new Set(pairs.map(p=>p.right))).filter(Boolean);
                    const rows = Array.from(quiz.querySelectorAll('#choices #matchRows .choice'));
                    rows.forEach((row, i)=>{
                        try{
                            row.classList.remove('correct','wrong');
                            const selIdx = Array.isArray(rec.match) ? rec.match[i] : null;
                            const chosen = (selIdx!=null && isFinite(selIdx)) ? opts[selIdx] : null;
                            const ok = chosen && normalizeGreek(String(chosen)).trim() === normalizeGreek(String(pairs[i].right)).trim();
                            row.classList.add(ok ? 'correct' : 'wrong');
                        }catch(e){}
                    });
                }

                rec.submitted = true;
                rec.correct = evaluateAnswer(it, rec);
                rec.skipped = false;
                if (rec.correct) state.score++;
                // capture per-question answered timestamp and duration
                try{
                    const now = Date.now();
                    rec._lastAnsweredAt = now;
                    const start = rec._lastShownAt || (state.currentAttempt && state.currentAttempt.startedAt) || now;
                    rec._lastDurationMs = Math.max(0, now - start);
                }catch(e){ console.warn('timing capture failed', e); }
                const el = $('status'); if (el) el.textContent = rec.correct ? 'Correct!' : 'Not quite.';
                lockCurrentInteraction();
                // For MCQ/TF keep the old lock styling too
                try{ if(t === 'mcq' || t === 'truefalse') lockChoices(); }catch(e){}
                requestGeminiRationale(it, rec);
            }

            function reveal(it, rec) {
                const t = (it && it.type ? String(it.type) : 'mcq').toLowerCase();
                if(t === 'mcq' || t === 'truefalse'){
                    const nodes = quiz.querySelectorAll('.choice');
                    nodes.forEach((n, idx) => { n.classList.toggle('correct', idx === it.correctIdx); });
                    if (rec && rec.submitted) lockChoices();
                    return;
                }
                if(t === 'fillblank'){
                    try{
                        const key = document.getElementById('fibKey');
                        const ans = Array.isArray(it.answers) && it.answers.length ? it.answers.join(' | ') : '(no key provided)';
                        if(key){ key.style.display=''; key.innerHTML = `Answer: <span class="tag">${safeText(ans)}</span>`; }
                        if(rec && rec.submitted) lockCurrentInteraction();
                    }catch(e){}
                    return;
                }
                if(t === 'matching'){
                    try{
                        const pairs = Array.isArray(it.pairs) ? it.pairs : [];
                        const rows = Array.from(quiz.querySelectorAll('#choices #matchRows .choice'));
                        rows.forEach((row, i)=>{
                            try{ row.classList.add('correct'); }catch(e){}
                        });
                        if(rec && rec.submitted) lockCurrentInteraction();
                    }catch(e){}
                    return;
                }
            }

            function skipCurrent() {
                try{ if(typeof window.stopAiOutput === 'function') window.stopAiOutput(); }catch{}
                try{ const w = ensureWrapper(); if(w && w._page) w._page.textContent = ''; }catch{}
                // capture elapsed time for this question if missing before skipping
                try{ captureCurrentDurationIfMissing(); }catch(e){}
                const idx = activeIndex();
                const rec = state.answered[idx] || (state.answered[idx] = { selected: null, submitted: false, correct: false, skipped: false });
                // if no explicit duration recorded (no submit), capture now
                if(typeof rec._lastDurationMs !== 'number') try{ rec._lastDurationMs = Math.max(0, Date.now() - (rec._lastShownAt || (state.currentAttempt && state.currentAttempt.startedAt) || Date.now())); }catch(e){}
                rec.skipped = true; state.skipped.add(idx);
                if (state.idx < activeLength() - 1) { state.idx++; renderCurrent(); } else next();
            }

            function openSkippedPanel() {
                if (!state.started) return;
                ensureSkippedModal();
                state.returnIdx = state.idx; state.returnMode = state.mode;
                const listEl = $('skippedList'); listEl.innerHTML = '';
                if (!state.skipped.size) {
                    listEl.innerHTML = '<div class="hint">No skipped questions.</div>';
                } else {
                    [...state.skipped].forEach(ix => {
                        const chip = document.createElement('div'); chip.className = 'chip';
                        const n = state.items[ix]?.num || '?'; chip.textContent = `Q${n}`;
                        chip.onclick = () => { state.mode = 'quiz'; const pos = activeList().indexOf(ix); if (pos >= 0) { state.idx = pos; } else { state.order.unshift(ix); state.idx = 0; } hideSkipped(); renderCurrent(); };
                        listEl.appendChild(chip);
                    });
                }
                showSkipped();
            }

            function next() { try{ if(typeof window.stopAiOutput === 'function') window.stopAiOutput(); }catch{} try{ const w = ensureWrapper(); if(w && w._page) w._page.textContent = ''; }catch{} try{ captureCurrentDurationIfMissing(); }catch(e){} if (state.idx < activeLength() - 1) { state.idx++; renderCurrent(); } else { if (state.mode === 'quiz') return showSummary(); return showReviewDone(); } }
            function back() { try{ if(typeof window.stopAiOutput === 'function') window.stopAiOutput(); }catch{} try{ const w = ensureWrapper(); if(w && w._page) w._page.textContent = ''; }catch{} try{ captureCurrentDurationIfMissing(); }catch(e){} if (state.idx > 0) { state.idx--; renderCurrent(); } }

            // Format ms -> HH:MM:SS (or MM:SS if under 1 hour)
            function formatDuration(ms){
                ms = Math.max(0, ms|0);
                const s = Math.floor(ms/1000);
                const hh = Math.floor(s/3600);
                const mm = Math.floor((s%3600)/60);
                const ss = s%60;
                const pad = n=> String(n).padStart(2,'0');
                return hh>0 ? `${pad(hh)}:${pad(mm)}:${pad(ss)}` : `${pad(mm)}:${pad(ss)}`;
            }

            // Render a compact timing summary given an array of {index,num,durationMs,correct}
            function renderTimingSummary(qTimes){
                try{
                    if(!Array.isArray(qTimes) || qTimes.length===0) return 'No timing data available.';
                    const times = qTimes.map(q=> (typeof q.durationMs === 'number' ? q.durationMs : null)).filter(t=>t!=null);
                    if(times.length===0) return 'No per-question times recorded.';
                    const total = times.reduce((a,b)=>a+b,0);
                    const avg = Math.round(total / times.length);
                    const min = Math.min(...times);
                    const max = Math.max(...times);
                    // Build small per-question list (num: time)
                    const items = (qTimes||[]).map(q => {
                        const t = (typeof q.durationMs === 'number') ? formatDuration(q.durationMs) : 'N/A';
                        const mark = q.correct ? '' : ' • ⨯';
                        return `Q${q.num||'?'}: ${t}${mark}`;
                    });
                    // Show top-level metrics and first 8 items
                    const sample = items.slice(0,8).join('<br>');
                    return `Average: ${formatDuration(avg)} • Fastest: ${formatDuration(min)} • Slowest: ${formatDuration(max)}<br>${sample}${items.length>8 ? '<br>…' : ''}`;
                }catch(e){ return 'Timing summary unavailable.'; }
            }

            // Ensure current question has a duration recorded if it was shown but not yet answered
            function captureCurrentDurationIfMissing(){
                try{
                    const idx = activeIndex();
                    const rec = state.answered[idx];
                    if(!rec) return;
                    if(typeof rec._lastDurationMs === 'number') return; // already captured
                    const start = rec._lastShownAt || (state.currentAttempt && state.currentAttempt.startedAt) || null;
                    if(!start) return;
                    rec._lastDurationMs = Math.max(0, Date.now() - start);
                }catch(e){ /* ignore */ }
            }

            window.showSummary = function showSummary() {
                // stop timer
                if(state.timerInterval){ clearInterval(state.timerInterval); state.timerInterval = null; }
                state.quizEndTime = Date.now();
                // finalize the just-completed attempt so its duration is recorded
                finalizeCurrentAttempt();
                // Compute total time as the combined durations of all finalized attempts
                const totalAttemptMs = Array.isArray(state.attempts) ? state.attempts.reduce((s,a)=>s + (a.durationMs||0), 0) : 0;
                // Fallback: if no attempts recorded, fall back to quizStart/End delta
                const elapsedMs = totalAttemptMs || ((state.quizStartTime && state.quizEndTime) ? (state.quizEndTime - state.quizStartTime) : 0);
                // Ensure Validate/Like-Questions sections remain hidden on the summary screen
                try{ document.getElementById('ai-likeq')?.classList.add('hidden'); }catch{}
                try{ document.getElementById('ai-likeq-copy')?.classList.add('hidden'); }catch{}
                try{ document.body.classList.remove('quiz-running'); }catch{ }
                try{ restoreGeminiStateAfterQuiz(); }catch{}
                // Record whether focus mode was active before we show the summary,
                // so we can restore it when starting a Review Missed session.
                try{ state._wasFocusOn = !!document.body.classList.contains('focus-mode-active'); }catch(e){}
                // Ensure focus mode is disabled while the summary/results view is visible without changing user preference
                try{ document.body.classList.remove('focus-mode-active'); }catch(e){}
                const missed = [];
                state.items.forEach((_, ix) => { const r = state.answered[ix]; if (!r || !r.submitted || !r.correct) missed.push(ix); });
                const taggedCount = (state.tags && state.tags.size) ? state.tags.size : 0;
                const skippedCount = state.skipped ? state.skipped.size : 0;
                const pct = state.items.length ? (state.score / state.items.length * 100) : 0;
                // Wrap finished readout in a low z-index layer so overlays/popups appear above
                quiz.innerHTML =
                    `<div class="finished-summary-layer"><div class="qcard"><h2 style="margin:0 0 8px">Finished</h2>
                        <div>Score: ${state.score} / ${state.items.length} (${pct.toFixed(1)}%)</div>
                        <div>Time: ${formatDuration(elapsedMs)}</div>
                        <div class="hint" style="margin-top:8px">${missed.length ? 'You have questions to (re)try.' : 'All questions correct! 🎉'}</div>
                        <div class="mt-8" style="font-size:12px;color:var(--muted)">
                            Tagged this run: <strong>${taggedCount}</strong>
                        </div>
                    </div>` +
                    `<div class="footer finished-summary-layer"><div><div>
                        ${skippedCount ? `<button class="btn" id="openSkipped2">Open Skipped (${skippedCount})</button>` : ''}
                        ${taggedCount ? ' <button class="btn xs" id="copyTaggedBtn" type="button">Copy tagged</button>' : ''}
                        ${taggedCount ? ' <button class="btn xs" id="exportTaggedBtn" type="button">Save tagged to Saved Sets</button>' : ''}
                    </div></div><div><button class="btn" id="saveResultBtn">Save Result</button> ${missed.length ? '<button class="btn primary" id="reviewMissed">Review Missed</button>' : ''} <button class="btn" id="restart">Restart</button> <button class="btn" id="backSetup">Back to Setup</button></div></div>`;
                // Also render a results card below mirroring the validate/like style
                try{
                    const results = document.getElementById('results-card');
                    const sum = document.getElementById('resultsSummary');
                    if(results && sum){
                        if(missed.length === 0){
                            const pct = state.items.length? (state.score/state.items.length*100):0;
                            sum.innerHTML = `<div class="qcard">
                                <div><strong>Results</strong></div>
                                <div class="mt-6">Score: ${state.score} / ${state.items.length}</div>
                                <div>Percent Correct: ${pct.toFixed(1)}%</div>
                                <div>Time: ${formatDuration(elapsedMs)}</div>
                                <div>Missed (this pass): ${missed.length}</div>
                            </div>`;
                            // Build attempts UI and reveal only when fully complete
                            renderAttemptsUI();
                            results.classList.remove('hidden');
                            // Re-sync analyze button enabled state and key badge when results are shown
                            try{
                                const keyVal = (document.getElementById('globalGemKey')?.value||'').trim();
                                const enabled = !!document.getElementById('globalGemEnable')?.checked;
                                const ok = !!keyVal && enabled;
                                const analyze = document.getElementById('analyzeMissedBtn'); if(analyze) analyze.disabled = !ok;
                                const rBadge = document.getElementById('resultsKeyBadge'); if(rBadge){ rBadge.classList.toggle('ok', ok); rBadge.classList.toggle('missing', !ok); const h=rBadge.querySelector('.hint'); if(h) h.textContent = ok ? 'Key set' : 'No key set'; }
                            }catch{}
                        } else {
                            // Hide the results/attempts card until all questions have been completed correctly
                                results.classList.add('hidden');
                                sum.innerHTML = '';
                                const sel = document.getElementById('attemptSelect'); if(sel) sel.innerHTML = '';
                                const missList = document.getElementById('attemptMissedList'); if(missList) missList.innerHTML = '';
                                const stat = document.getElementById('resultsAiStatus'); if(stat) stat.textContent = '';
                                // Prefer aborting any animated AI output; fall back to clearing text if not available
                                try{ if(typeof window.stopAiOutput === 'function'){ window.stopAiOutput(); } else { const out = document.getElementById('resultsAiOutput'); if(out) out.textContent = ''; } }catch{}
                        }
                    }
                }catch{}
                const saveBtnEl = $('saveResultBtn');
                if(saveBtnEl) saveBtnEl.onclick = () => {
                    // User explicitly chose to save; this also updates last-attempt snapshot
                    try{ window.__setLastAttemptFromState && window.__setLastAttemptFromState('Saved result'); }catch(e){}
                    saveQuizResult();
                };
                // Tagged questions export actions (Finished/results view)
                try{
                    const exportTagBtn = document.getElementById('exportTaggedBtn');
                    const copyTagBtn = document.getElementById('copyTaggedBtn');
                    if(exportTagBtn) exportTagBtn.onclick = ()=>{ try{ window.__exportTaggedToSavedMcqs && window.__exportTaggedToSavedMcqs(); }catch(e){} };
                    if(copyTagBtn) copyTagBtn.onclick = ()=>{ try{ window.__copyTaggedToClipboard && window.__copyTaggedToClipboard(); }catch(e){} };
                }catch(e){}
                const restartEl = $('restart'); if(restartEl) restartEl.onclick = () => { try{ window.__suppressFocus = false; }catch(e){} state.idx = 0; state.score = 0; startQuiz(); };
                (function wireBackSetupOnlyPointer(){
                    const b = $('backSetup');
                    if(!b) return;
                    // Block Enter/Space so keyboard cannot trigger it
                    try{ b.addEventListener('keydown', (ev)=>{ const k = ev.key; if(k === 'Enter' || k === ' ' || k === 'Spacebar'){ ev.preventDefault(); ev.stopPropagation(); } }); }catch(e){}
                    const handler = ()=>{
                        // On leaving the summary, record this as the last attempted quiz
                        try{ window.__setLastAttemptFromState && window.__setLastAttemptFromState(); }catch(e){}
                        setup.classList.remove('hidden');
                        quiz.classList.add('hidden');
                        try{ document.getElementById('textbook-lib')?.classList.remove('hidden'); }catch{}
                        // Ensure the results card and any transient result UI are fully hidden/cleared
                        try{
                            const rc = document.getElementById('results-card'); if(rc) rc.classList.add('hidden');
                            const rs = document.getElementById('resultsSummary'); if(rs) rs.innerHTML = '';
                            const ra = document.getElementById('resultsAiStatus'); if(ra) ra.textContent = '';
                            const roa = document.getElementById('resultsAiOutput'); if(roa) roa.textContent = '';
                        }catch(e){}
                        // Hide the reset bar if visible
                        try{ if(resetBar) resetBar.style.display = 'none'; }catch(e){}
                        // Leaving summary — allow focus behavior to resume
                        try{ window.__suppressFocus = false; }catch(e){}
                    };
                    // Ensure legacy onclick does nothing
                    try{ b.onclick = null; }catch(e){}
                    b.addEventListener('pointerup', handler);
                })();
                try{ const os2 = $('openSkipped2'); if(os2) os2.onclick = openSkippedPanel; }catch(e){}
                // Wire Review Missed only if the button exists (we may omit it when there are no missed questions)
                try{
                    const _revBtn = $('reviewMissed');
                    if(_revBtn){
                        _revBtn.onclick = () => {
                            if (!missed.length) return;
                            state.mode = 'review';
                            state.reviewPool = missed.slice();
                            // Re-enable focus mode when re-entering quiz-view if Always-enable is ON.
                            // Clear suppression so overlay can engage during reattempts.
                            try{
                                window.__suppressFocus = false;
                                const ALWAYS_KEY = '__ui_always_focus_v1';
                                const alwaysOn = (function(){ try{ return localStorage.getItem(ALWAYS_KEY) === '1'; }catch(e){ return false; } })();
                                if(alwaysOn){ if(typeof window.__setFocusMode === 'function') window.__setFocusMode(true); else document.body.classList.add('focus-mode-active'); }
                            }catch(e){}
                            // Hide results card and attempts UI during review
                            try{ document.getElementById('results-card')?.classList.add('hidden'); }catch{}

                            // ⬅️ unlock items for re-answering
                            state.reviewPool.forEach(ix => {
                                const r = state.answered[ix] || (state.answered[ix] = {});
                                r.submitted = false;   // allow resubmit
                                r.selected = null;    // optional: clear old choice
                                try{ r.text = ''; }catch(e){}
                                try{ r.match = []; }catch(e){}
                                r.skipped = false;
                                // reshuffle choices ensuring the correct answer moves to a new slot
                                shuffleChoicesEnsureMove(state.items[ix]);
                            });

                            state.idx = 0;
                            // start a new attempt covering the review pool
                            startAttempt('review', state.reviewPool.slice());
                            // start quiz timer for the review session (match startQuiz behavior)
                            try{ state.quizStartTime = Date.now(); state.quizEndTime = null; if(state.timerInterval){ clearInterval(state.timerInterval); state.timerInterval = null; } state.timerInterval = setInterval(()=>{ try{ const el = document.getElementById('quizTimer'); if(!el) return; const timerStart = (state.quizStartTime || (state.currentAttempt && state.currentAttempt.startedAt) || null); if(!timerStart) return; const ms = Math.max(0, Date.now() - timerStart); el.textContent = formatDuration(ms); }catch{} }, 500); }catch(e){}
                            // Re-enable focus mode if user had it on, or if Always-enable is set (but NOT for saved-result flows)
                            try{
                                const ALWAYS_KEY = '__ui_always_focus_v1';
                                let alwaysOn = false;
                                try{ alwaysOn = (localStorage.getItem(ALWAYS_KEY) === '1'); }catch(e){}
                                const suppress = !!state._loadedFromSaved;
                                const shouldEnable = !suppress && !!(alwaysOn || state._wasFocusOn);
                                if(shouldEnable){ if(typeof window.__setFocusMode === 'function') window.__setFocusMode(true); else document.body.classList.add('focus-mode-active'); }
                            }catch(e){}
                            renderCurrent();
                        };
                    }
                }catch(e){}
            }
            try{ window.showSummary = showSummary; }catch(e){}

            // Copy Results button handler: builds a compact summary string and copies to clipboard
            (function wireCopyResults(){
                function formatTime(ms){
                    if(!ms && ms !== 0) return '';
                    const s = Math.floor(ms/1000);
                    const mm = Math.floor(s/60); const ss = s%60;
                    return `${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
                }

                function getLectureName(){
                    try{
                        const el = document.getElementById('aiFileName');
                        if(el && el.textContent && el.textContent.trim() && el.textContent.trim() !== 'No file chosen') return el.textContent.trim();
                        // fallback: page title
                        if(document.title){
                            const t = document.title.replace(/\s*-\s*BUNKR.*$/,'').trim();
                            // If the default site title is present, use a neutral placeholder per request
                            if(/BUNKR\s*108|AI-powered Study Interface/i.test(document.title)) return '[QUIZ NAME]';
                            return t;
                        }
                    }catch(e){}
                    return 'Lecture';
                }

                async function copyResults(){
                    try{
                        const btn = document.getElementById('copyResultsBtn');
                        const lecture = getLectureName();
                        const atts = Array.isArray(state.attempts) ? state.attempts.slice() : [];
                        if(atts.length === 0 && state.currentAttempt){ atts.push(state.currentAttempt); }
                        // Build exact-format output. Example:
                        // [1] Lecture 21 [OCR; RESCAN] -- 16/29
                        // [2] 24/29; [3] 28/29; [4] 29/29
                        const lines = [];
                        // Use finalized attempts if present, otherwise include currentAttempt
                        const attemptsList = atts;
                        if(attemptsList.length){
                            // Determine total questions: prefer first attempt pool length, else union of all pools
                            let totalQuestions = 0;
                            if(Array.isArray(attemptsList[0].pool)) totalQuestions = attemptsList[0].pool.length;
                            else {
                                const allPools = new Set();
                                attemptsList.forEach(a=>{ if(Array.isArray(a.pool)) a.pool.forEach(ix=> allPools.add(ix)); });
                                totalQuestions = allPools.size;
                            }

                            // Maintain cumulative set of correctly answered indices across attempts
                            const cumulativeCorrect = new Set();

                            // First attempt line includes lecture name and cumulative after attempt 1
                            const a0 = attemptsList[0];
                            const pool0 = Array.isArray(a0.pool) ? a0.pool.slice() : [];
                            const missedSet0 = new Set((Array.isArray(a0.missed) ? a0.missed.map(m => (typeof m === 'number' ? m : (m && m.index != null ? m.index : null))).filter(x=>x!=null) : []));
                            pool0.forEach(ix => { if(!missedSet0.has(ix)) cumulativeCorrect.add(ix); });
                            const score0 = cumulativeCorrect.size;
                            lines.push(`[1] ${lecture} -- ${score0}/${totalQuestions}`);

                            // Subsequent attempts on second line, semicolon-separated, show cumulative after each attempt
                            if(attemptsList.length > 1){
                                const others = [];
                                for(let i=1;i<attemptsList.length;i++){
                                    const ai = attemptsList[i];
                                    const pool = Array.isArray(ai.pool) ? ai.pool.slice() : [];
                                    const missedSet = new Set((Array.isArray(ai.missed) ? ai.missed.map(m => (typeof m === 'number' ? m : (m && m.index != null ? m.index : null))).filter(x=>x!=null) : []));
                                    pool.forEach(ix => { if(!missedSet.has(ix)) cumulativeCorrect.add(ix); });
                                    const cumScore = cumulativeCorrect.size;
                                    const num = (typeof ai.id === 'number' || typeof ai.id === 'string') ? ai.id : (i+1);
                                    others.push(`[${num}] ${cumScore}/${totalQuestions}`);
                                }
                                lines.push(others.join('; '));
                            }
                        } else {
                            // No attempts at all: fallback to a simple single-line summary
                            lines.push(`[1] ${lecture} -- 0/0`);
                        }
                        const out = lines.join('\n');
                        if(navigator.clipboard && navigator.clipboard.writeText){
                            await navigator.clipboard.writeText(out);
                        } else {
                            // fallback: use execCommand
                            const ta = document.createElement('textarea'); ta.value = out; ta.style.position='fixed'; ta.style.left='-9999px'; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove();
                        }
                        if(btn){ const old = btn.textContent; btn.textContent = 'Copied!'; setTimeout(()=>{ try{ btn.textContent = old; }catch{} }, 1600); }
                    }catch(e){ console.error('copyResults failed', e); alert('Copy failed: ' + (e && e.message ? e.message : e)); }
                }

                document.addEventListener('click', function(ev){ try{ const t = ev.target; if(!t) return; if(t.closest && t.closest('#copyResultsBtn')){ ev.preventDefault(); copyResults(); } }catch(e){} }, true);
            })();

            function renderAttemptsUI(){
                try{
                    const sel = document.getElementById('attemptSelect');
                    const list = document.getElementById('attemptMissedList');
                    const sum = document.getElementById('resultsSummary');
                    const status = document.getElementById('resultsAiStatus');
                    const dd = document.getElementById('attemptDropdown');
                    const trigger = document.getElementById('attemptTrigger');
                    const trigText = document.getElementById('attemptTriggerText');
                    const menu = document.getElementById('attemptMenu');
                    if(!sel || !list) return;
                    // Ensure we have at least the finalized attempts
                    const attempts = state.attempts.slice();
                    // Aggregate totals (across all attempts)
                    const allMissed = attempts.flatMap(a => a.missed || []);
                    // Build labels once
                    const labels = attempts.map(a=>({ id:String(a.id), text:`${a.id}. ${a.mode} — missed ${a.missed?.length||0}, time ${formatDuration(a.durationMs||0)}` }));
                    // Fill native select (kept hidden)
                    sel.innerHTML = '';
                    labels.forEach(l=>{ const opt=document.createElement('option'); opt.value=l.id; opt.textContent=l.text; sel.appendChild(opt); });
                    // Fill custom menu
                    if(menu){ menu.innerHTML = labels.map(l=>`<div class="attempt-option" role="option" data-id="${l.id}"><span class="tag">${l.id}.</span> <span>${l.text.replace(/^\d+\.\s+/, '')}</span></div>`).join(''); }
                    // Default selection: most recent with misses, else last
                    if(attempts.length){ let def=null; for(let i=attempts.length-1;i>=0;i--){ if(attempts[i]?.missed && attempts[i].missed.length){ def=String(attempts[i].id); break; } } if(!def) def=String(attempts[attempts.length-1].id); sel.value=def; if(trigText) trigText.textContent = labels.find(x=>x.id===def)?.text || 'Select attempt…'; }
                    // Open/close behavior
                    function syncMenuWidth(){ try{ if(!dd||!menu||!trigger) return; const w = Math.ceil(trigger.getBoundingClientRect().width); menu.style.width = w + 'px'; }catch{} }
                    // Use only the in-flow menu; elevate via z-index in CSS
                    function setOpen(open){ if(!dd) return; dd.classList.toggle('open', !!open); dd.setAttribute('aria-expanded', open?'true':'false'); if(open){ syncMenuWidth(); } }
                    // Direct wiring removed to prevent double-toggle conflicts; delegated handler below handles trigger clicks robustly
                    // Robust delegated wiring (survives DOM refreshes)
                    if(!window.__attemptDdWired){
                        window.__attemptDdWired = true;
                        document.addEventListener('click', function(evt){
                            const dropdown = document.getElementById('attemptDropdown');
                            if(!dropdown) return;
                            const t = evt.target.closest ? evt.target.closest('#attemptTrigger') : null;
                            const opt = evt.target.closest ? evt.target.closest('.attempt-option') : null;
                            const menuEl = document.getElementById('attemptMenu');
                            const trigEl = document.getElementById('attemptTrigger');
                            // Toggle open when trigger clicked
                            if(t){ evt.preventDefault(); const willOpen = !dropdown.classList.contains('open');
                                // use setOpen so portal is managed too
                                const s = document.getElementById('attemptSelect'); if(!s || !s.options.length){ return; }
                                setOpen(willOpen);
                                return; }
                            // Select an option
                            if(opt){ const id = opt.getAttribute('data-id'); const selEl = document.getElementById('attemptSelect'); if(id && selEl){ selEl.value = id; try{ selEl.dispatchEvent(new Event('change', { bubbles:true })); }catch{} } setOpen(false); return; }
                            // Clicked outside -> close
                            if(!dropdown.contains(evt.target)){ setOpen(false); }
                        });
                        document.addEventListener('keydown', (e)=>{ if(e.key==='Escape'){ setOpen(false); } });
                        window.addEventListener('resize', ()=>{ const d=document.getElementById('attemptDropdown'); const trig=document.getElementById('attemptTrigger'); const m=document.getElementById('attemptMenu'); if(d && d.classList.contains('open') && trig && m){ try{ m.style.width = Math.ceil(trig.getBoundingClientRect().width) + 'px'; }catch{} }
                        });
                    }
                    // Renderer for a selected attempt
                    function renderAttempt(id){
                        const a = attempts.find(z => String(z.id) === String(id));
                        if(!a){ list.innerHTML = '<div class="hint">No attempt selected.</div>'; if(sum) sum.innerHTML=''; return; }
                        // Keep analyze button in sync with current selection (for robust reads)
                        try{ const ab = document.getElementById('analyzeMissedBtn'); if(ab){ ab.dataset.selAttemptId = String(a.id); } }catch{}
                        // Sync the custom trigger text
                        try{ if(trigText){ const l = labels.find(x=>x.id===String(a.id)); if(l) trigText.textContent = l.text; } }catch{}
                        // Update summary block for the selected attempt (isolated score/time)
                        try{
                            const pool = Array.isArray(a.pool) ? a.pool.length : 0;
                            const missedN = Array.isArray(a.missed) ? a.missed.length : 0;
                            const correct = Math.max(0, pool - missedN);
                            const pct = pool ? (correct/pool*100) : 0;
                            if(sum){
                                sum.innerHTML = `<div class="qcard">
                                    <div><strong>Results</strong></div>
                                    <div class="mt-6">Score: ${correct} / ${pool}</div>
                                    <div>Percent Correct: ${pct.toFixed(1)}%</div>
                                    <div>Time: ${formatDuration(a.durationMs||0)}</div>
                                    <div>Missed (this attempt): ${missedN}</div>
                                    <div class="mt-4 flex gap-8" style="display:flex; gap:8px; margin-top:12px">
                                        <button class="btn small" id="redoMissedBtn" ${missedN?'':'disabled'}>Redo Missed</button>
                                        <button class="btn small" id="redoCorrectBtn" ${correct?'':'disabled'}>Redo Correct</button>
                                    </div>
                                    <div class="mt-6"><strong>Per-question timing</strong></div>
                                    <div class="hint" style="margin-top:6px">${renderTimingSummary(a.qTimes||[])}</div>
                                </div>`;
                                // Wire up the redo buttons
                                setTimeout(()=>{
                                    const rm = document.getElementById('redoMissedBtn');
                                    const rc = document.getElementById('redoCorrectBtn');
                                    if(rm) rm.onclick = () => openMiniRedo(a.id, 'missed');
                                    if(rc) rc.onclick = () => openMiniRedo(a.id, 'correct');
                                }, 0);
                            }
                        }catch(e){ /* ignore summary update errors */ }
                        if(!a.missed || a.missed.length===0){
                            list.innerHTML = '<div class="hint text-center">No missed questions in this attempt.</div>';
                            if(status) status.textContent = 'No missed questions in the selected attempt to analyze.';
                            return;
                        }
                        // Similar to preview, show missed questions with A/B/C labels and key
                        // CRITICAL: Always render from the attempt snapshot (m.choices, m.correctIdx)
                        // to avoid mismatches when choices were reshuffled in later attempts.
                        const letters = ['A','B','C','D','E','F'];
                        const html = a.missed.map(m=>{
                            const it = state.items[m.index];
                            const type = String(m.type ?? it?.type ?? 'mcq').toLowerCase();
                            const q = (m.q ?? it?.q ?? '');
                            const num = (m.num ?? it?.num ?? '?');
                            const timeHtml = `<div class="hint" style="margin-top:6px">Time: ${formatDuration(m.durationMs||0)}</div>`;

                            if(type === 'fillblank'){
                                const keys = Array.isArray(m.answers) && m.answers.length ? m.answers : (Array.isArray(it?.answers)? it.answers : []);
                                const key = keys.length ? keys.join(' | ') : '(no key provided)';
                                const user = (m.userText == null ? '—' : String(m.userText));
                                return `<div class="qcard">
                                    <div><strong>Q${esc(String(num))}.</strong> ${safeText(q)}</div>
                                    <div class="hint" style="margin-top:6px">Type: <span class="tag">Fill-in-the-Blank</span></div>
                                    <div class="hint" style="margin-top:6px">Key: <span class="tag">${safeText(key)}</span></div>
                                    <div class="hint" style="margin-top:6px">Answered: <span class="tag">${safeText(user)}</span></div>
                                    ${timeHtml}
                                </div>`;
                            }

                            if(type === 'matching'){
                                const pairs = Array.isArray(m.pairs) && m.pairs.length ? m.pairs : (Array.isArray(it?.pairs)? it.pairs : []);
                                const pairsHtml = pairs.slice(0,10).map(p=>`<div class="hint"><span class="tag">${safeText(p.left)}</span> → <span class="tag">${safeText(p.right)}</span></div>`).join('');
                                return `<div class="qcard">
                                    <div><strong>Q${esc(String(num))}.</strong> ${safeText(q)}</div>
                                    <div class="hint" style="margin-top:6px">Type: <span class="tag">Matching</span></div>
                                    <div style="margin-top:6px">${pairsHtml || '<div class="hint">(no pairs)</div>'}</div>
                                    ${timeHtml}
                                </div>`;
                            }

                            // MCQ / True-False
                            const choicesArr = Array.isArray(m.choices) && m.choices.length ? m.choices : (it?.choices || []);
                            const choices = choicesArr.map((c,i)=>`<span class="tag">${letters[i]||'?'}.</span> ${safeText(c)}`).join('<br>');
                            const keyIdx = (typeof m.correctIdx === 'number') ? m.correctIdx : (it?.correctIdx ?? 0);
                            const keyLetter = letters[keyIdx] || 'A';
                            const userLetter = (m.user==null? '—' : (letters[m.user]||'?'));
                            return `<div class="qcard">
                                <div><strong>Q${esc(String(num))}.</strong> ${safeText(q)}</div>
                                <div class="hint" style="margin-top:6px">Type: <span class="tag">${type === 'truefalse' ? 'True/False' : 'Multiple Choice'}</span></div>
                                <div style="margin-top:6px">${choices}</div>
                                <div class="hint" style="margin-top:6px">Key: <span class="tag">${keyLetter}</span></div>
                                <div class="hint" style="margin-top:6px">Answered: <span class="tag">${userLetter}</span></div>
                                ${timeHtml}
                            </div>`;
                        }).join('');
                        list.innerHTML = html;
                        if(status) status.textContent = `Selected attempt ${a.id}: ${a.missed.length} missed will be analyzed.`;
                        // Tagging UI removed for Phase 1 — tags and tag-based generation are deferred
                    }
                    sel.onchange = ()=> { renderAttempt(sel.value); try{ const ab = document.getElementById('analyzeMissedBtn'); if(ab){ ab.dataset.selAttemptId = String(sel.value||''); } }catch{} };
                    // Menu selection wiring
                    if(menu && menu.children.length){
                        Array.from(menu.children).forEach(el=>{
                            el.addEventListener('click', ()=>{ const id = el.getAttribute('data-id'); if(id){ sel.value = id; renderAttempt(id); } setOpen(false); syncMenuWidth(); });
                        });
                    }
                    if(attempts.length){ renderAttempt(sel.value); }
                }catch(e){ console.warn('renderAttemptsUI failed', e); }
            }

            function showReviewDone() {
                const remaining = state.reviewPool.filter(ix => { const r = state.answered[ix]; return !r || !r.correct; });
                if (remaining.length) {
                    // Ensure results card remains hidden on Keep Going screens
                    try{ document.getElementById('results-card')?.classList.add('hidden'); }catch{}
                    // Temporarily disable focus mode while the Keep Going screen is visible,
                    // mirroring the behavior of the main Results/Summary view without
                    // changing the user's Always-enable preference.
                    try{ document.body.classList.remove('focus-mode-active'); }catch(e){}
                    // Ensure the just-completed slice is recorded so attempts UI can show it now
                    finalizeCurrentAttempt();
                    quiz.innerHTML =
                        `<div class="qcard"><h2 style="margin:0 0 8px">Keep Going</h2><div class="hint">Attempt ${(state.currentAttempt && state.currentAttempt.id) ? state.currentAttempt.id : (state.attempts[state.attempts.length-1]?.id || '?')} (${(state.currentAttempt && state.currentAttempt.mode) ? state.currentAttempt.mode : (state.attempts[state.attempts.length-1]?.mode || 'review')}): Some questions are still incorrect or unsubmitted. Continue until all are correct.</div></div>` +
                        `<div class="footer"><button class="btn" id="continueReview">Continue</button><button class="btn" id="summary">Summary</button></div>`;
                    $('continueReview').onclick = () => {
                        // start a new attempt for the remaining items
                        try{ document.getElementById('results-card')?.classList.add('hidden'); }catch{}
                        state.reviewPool = remaining;

                        // ⬅️ unlock remaining items again
                        state.reviewPool.forEach(ix => {
                            const r = state.answered[ix] || (state.answered[ix] = {});
                            r.submitted = false;
                            r.selected = null;
                            try{ r.text = ''; }catch(e){}
                            try{ r.match = []; }catch(e){}
                            r.skipped = false;
                            // reshuffle again so position can't be memorized
                            shuffleChoicesEnsureMove(state.items[ix]);
                        });

                        state.idx = 0;
                        startAttempt('review', state.reviewPool.slice());
                        // start quiz timer for this review continuation (match startQuiz behavior)
                        try{ state.quizStartTime = Date.now(); state.quizEndTime = null; if(state.timerInterval){ clearInterval(state.timerInterval); state.timerInterval = null; } state.timerInterval = setInterval(()=>{ try{ const el = document.getElementById('quizTimer'); if(!el) return; const timerStart = (state.quizStartTime || (state.currentAttempt && state.currentAttempt.startedAt) || null); if(!timerStart) return; const ms = Math.max(0, Date.now() - timerStart); el.textContent = formatDuration(ms); }catch{} }, 500); }catch(e){}
                        renderCurrent();
                    };
                    $('summary').onclick = showSummary;
                } else {
                    // finalize the last review attempt slice and auto-redirect to Summary
                    finalizeCurrentAttempt();
                    try{ document.body.classList.remove('quiz-running'); }catch{};
                    try{ restoreGeminiStateAfterQuiz(); }catch{};
                    showSummary();
                }
            }

            /* ---------- Mini Quiz Redo Logic ---------- */
            let miniQuizState = { items: [], idx: 0 };
            // key handler reference so we can attach/detach when modal opens/closes
            let __miniQuizKeyHandler = null;
            let __miniFocusTrapHandler = null;
            let __miniTabTrapHandler = null;
            let __miniIsolated = false;
            function __activateMiniIsolation(on){
                try{
                    if(on === __miniIsolated) return; __miniIsolated = !!on;
                    const modal = document.getElementById('miniQuizModal'); if(!modal) return;
                    const body = document.body;
                    if(on){
                        // Mark body for styling hooks
                        body.classList.add('mini-quiz-active');
                        // Set inert+aria-hidden on all top-level siblings except the modal wrapper
                        Array.from(body.children).forEach(ch=>{
                            if(!ch) return;
                            if(ch.id === 'miniQuizModal' || ch.querySelector?.('#miniQuizModal')) return;
                            try{ ch.setAttribute('aria-hidden','true'); }catch{}
                            try{ ch.setAttribute('inert',''); }catch{}
                        });
                        // Focus trap: on focusin, if focus leaves modal, bring it back
                        __miniFocusTrapHandler = function(ev){ try{ if(!modal || modal.classList.contains('hidden')) return; if(modal.contains(ev.target)) return; const target = document.getElementById('miniQuizClose') || document.getElementById('miniNext') || modal; target.focus && target.focus(); ev.preventDefault(); ev.stopPropagation(); }catch{} };
                        document.addEventListener('focusin', __miniFocusTrapHandler, true);
                        // Tab trap: keep focus cycling within modal
                        __miniTabTrapHandler = function(ev){ try{ if(ev.key !== 'Tab') return; if(!modal || modal.classList.contains('hidden')) return; const focusables = modal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'); const list = Array.from(focusables).filter(el=>!el.disabled && el.offsetParent!==null); if(!list.length) return; const first = list[0], last = list[list.length-1]; if(ev.shiftKey && document.activeElement === first){ last.focus(); ev.preventDefault(); ev.stopPropagation(); } else if(!ev.shiftKey && document.activeElement === last){ first.focus(); ev.preventDefault(); ev.stopPropagation(); } }catch{} };
                        document.addEventListener('keydown', __miniTabTrapHandler, true);
                    } else {
                        body.classList.remove('mini-quiz-active');
                        Array.from(body.children).forEach(ch=>{ try{ ch.removeAttribute('aria-hidden'); ch.removeAttribute('inert'); }catch{} });
                        if(__miniFocusTrapHandler){ document.removeEventListener('focusin', __miniFocusTrapHandler, true); __miniFocusTrapHandler = null; }
                        if(__miniTabTrapHandler){ document.removeEventListener('keydown', __miniTabTrapHandler, true); __miniTabTrapHandler = null; }
                    }
                }catch(e){ console.warn('mini isolation failed', e); }
            }
            function openMiniRedo(attemptId, type) {
                const a = state.attempts.find(z => String(z.id) === String(attemptId));
                if (!a) return;
                
                // Determine items
                let items = [];
                if (type === 'missed') {
                    // Use the missed array directly, but map back to full item objects if needed
                    // a.missed contains { index, q, num, choices, correctIdx, user, ... }
                    // We need to reconstruct a mini-item object that has enough info to render
                    items = (a.missed || []).map(m => ({
                        type: m.type || 'mcq',
                        q: m.q,
                        choices: m.choices,
                        correctIdx: m.correctIdx,
                        answers: m.answers,
                        pairs: m.pairs,
                        rightOptions: m.rightOptions,
                        num: m.num,
                        // Store original index if needed, though not strictly required for mini-view
                        origIndex: m.index
                    }));
                } else {
                    // Correct items: items in pool that are NOT in missed
                    // a.pool contains indices into state.items
                    const missedIndices = new Set((a.missed || []).map(m => m.index));
                    const correctIndices = (a.pool || []).filter(ix => !missedIndices.has(ix));
                    items = correctIndices.map(ix => {
                        const it = state.items[ix];
                        return {
                            type: it.type || 'mcq',
                            q: it.q,
                            choices: it.choices,
                            correctIdx: it.correctIdx,
                            answers: it.answers,
                            pairs: it.pairs,
                            rightOptions: it.rightOptions,
                            num: it.num,
                            origIndex: ix
                        };
                    });
                }
                
                if (!items.length) { alert('No questions to redo.'); return; }
                
                miniQuizState = { items, idx: 0 };
                
                // Ensure modal exists
                let modal = document.getElementById('miniQuizModal');
                if (!modal) {
                    // Inject modal HTML and CSS if missing
                    const div = document.createElement('div');
                    div.innerHTML = `
<style>
/* Mini Quiz Modal */
#miniQuizModal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 200005; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); }
#miniQuizModal.hidden { display: none; }
#miniQuizModal .modal-panel { width: 90%; max-width: 800px; max-height: 80vh; height: auto; display: flex; flex-direction: column; background: var(--bg); border: 1px solid var(--stroke); border-radius: 20px; box-shadow: 0 20px 50px rgba(0,0,0,0.6); overflow: hidden; }
#miniQuizModal .modal-header { padding: 16px; margin: 12px; border: 1px solid var(--stroke); display: flex; justify-content: space-between; align-items: center; background: rgba(0,0,0,0.4); border-radius: 20px; }
#miniQuizModal .modal-body { flex: 1; overflow-y: auto; padding: 12px 24px; }
#miniQuizModal .modal-footer { padding: 16px; margin: 12px; border: 1px solid var(--stroke); display: flex; justify-content: space-between; align-items: center; background: rgba(0,0,0,0.4); border-radius: 20px; }
#miniQuizModal .choice { display: flex; gap: 12px; padding: 12px; border: 1px solid var(--btnBorder); border-radius: 12px; margin-bottom: 8px; cursor: pointer; transition: all 0.2s; align-items: flex-start; background: linear-gradient(180deg, rgba(14, 20, 32, .55), rgba(10, 15, 26, .55)); }
#miniQuizModal .choice:hover { background: rgba(255,255,255,0.08); }
#miniQuizModal .choice.correct { background: rgba(16, 185, 129, 0.15); border-color: rgba(16, 185, 129, 0.4); }
#miniQuizModal .choice.wrong { background: rgba(239, 68, 68, 0.15); border-color: rgba(239, 68, 68, 0.4); }
#miniQuizModal .choice.disabled { pointer-events: none; opacity: 0.8; }
</style>
<div id="miniQuizModal" class="hidden">
    <div class="modal-panel">
        <div class="modal-header">
            <h3 style="margin:0">Redo <span id="miniQuizType"></span></h3>
            <button class="btn icon-only" id="miniQuizClose">✕</button>
        </div>
        <div id="miniQuizBody" class="modal-body"></div>
        <div class="modal-footer">
            <button class="btn" id="miniPrev">Previous</button>
            <span id="miniProgress" class="hint"></span>
            <button class="btn primary" id="miniNext">Next</button>
        </div>
    </div>
</div>`;
                    document.body.appendChild(div);
                    modal = document.getElementById('miniQuizModal');
                    document.getElementById('miniQuizClose').onclick = closeMiniQuiz;
                    document.getElementById('miniPrev').onclick = () => { if(miniQuizState.idx > 0) { miniQuizState.idx--; renderMiniQuizCurrent(); } };
                    document.getElementById('miniNext').onclick = () => { if(miniQuizState.idx < miniQuizState.items.length - 1) { miniQuizState.idx++; renderMiniQuizCurrent(); } else { closeMiniQuiz(); } };

                    // Keyboard shortcuts for the mini quiz modal: 1-9 / A-F to select, Enter to progress
                    __miniQuizKeyHandler = function(e){
                        try{
                            // ignore modifier combos
                            if(e.ctrlKey || e.metaKey || e.altKey) return;
                            // ignore when typing in inputs or editable elements
                            const ae = document.activeElement;
                            if(ae){ const tag = (ae.tagName||'').toLowerCase(); if(tag==='input' || tag==='textarea' || ae.isContentEditable) return; }
                            const modalEl = document.getElementById('miniQuizModal'); if(!modalEl || modalEl.classList.contains('hidden')) return;
                            const k = (e.key||'').toLowerCase();
                            const chContainer = document.getElementById('miniChoices');
                            if(!chContainer) return;
                            // If the key is one we care about, consume it so global handlers don't act
                            const isInterest = (/^[1-9]$/.test(k) || /^[a-f]$/.test(k) || k === 'enter' || k === ' ');
                            if(isInterest){ try{ e.preventDefault(); e.stopPropagation(); }catch(_){}}

                            // map 1-9 (support main keyboard and numpad via e.key or e.code)
                            let digitIdx = null;
                            if(/^[1-9]$/.test(k)){
                                digitIdx = parseInt(k,10) - 1;
                            } else if(e.code && /^Numpad([1-9])$/.test(e.code)){
                                const m = e.code.match(/^Numpad([1-9])$/); digitIdx = parseInt(m[1],10) - 1;
                            }
                            if(digitIdx !== null){ const child = chContainer.children[digitIdx]; if(child){ child.click(); } return; }

                            // map letters a-i (case-insensitive) so choices beyond 4 can be selected
                            if(/^[a-i]$/.test(k)){
                                const idx = k.charCodeAt(0) - 'a'.charCodeAt(0);
                                const child = chContainer.children[idx]; if(child){ child.click(); }
                                return;
                            }
                            // Enter: if already answered (disabled children), go next; otherwise do nothing
                            if(k === 'enter'){
                                const anyDisabled = Array.from(chContainer.children).some(c=>c.classList.contains('disabled'));
                                if(anyDisabled){ const nextBtn = document.getElementById('miniNext'); if(nextBtn){ nextBtn.click(); } }
                                return;
                            }
                        }catch(err){ console.warn('mini quiz key handler', err); }
                    };
                    try{ document.addEventListener('keydown', __miniQuizKeyHandler, true); }catch(e){}
                }
                
                // Ensure keyboard handler is attached even when the modal was created earlier
                if(!__miniQuizKeyHandler){
                    __miniQuizKeyHandler = function(e){
                        try{
                            if(e.ctrlKey || e.metaKey || e.altKey) return;
                            const ae = document.activeElement;
                            if(ae){ const tag = (ae.tagName||'').toLowerCase(); if(tag==='input' || tag==='textarea' || ae.isContentEditable) return; }
                            const modalEl = document.getElementById('miniQuizModal'); if(!modalEl || modalEl.classList.contains('hidden')) return;
                            const k = (e.key||'').toLowerCase();
                            const chContainer = document.getElementById('miniChoices');
                            if(!chContainer) return;
                            const isInterest = (/^[1-9]$/.test(k) || /^[a-f]$/.test(k) || k === 'enter' || k === ' ');
                            if(isInterest){ try{ e.preventDefault(); e.stopPropagation(); }catch(_){} }
                            let digitIdx = null;
                            if(/^[1-9]$/.test(k)){
                                digitIdx = parseInt(k,10) - 1;
                            } else if(e.code && /^Numpad([1-9])$/.test(e.code)){
                                const m = e.code.match(/^Numpad([1-9])$/); digitIdx = parseInt(m[1],10) - 1;
                            }
                            if(digitIdx !== null){ const child = chContainer.children[digitIdx]; if(child){ child.click(); } return; }
                            if(/^[a-i]$/.test(k)){
                                const idx = k.charCodeAt(0) - 'a'.charCodeAt(0);
                                const child = chContainer.children[idx]; if(child){ child.click(); }
                                return;
                            }
                            if(k === 'enter'){
                                const anyDisabled = Array.from(chContainer.children).some(c=>c.classList.contains('disabled'));
                                if(anyDisabled){ const nextBtn = document.getElementById('miniNext'); if(nextBtn){ nextBtn.click(); } }
                                return;
                            }
                        }catch(err){ console.warn('mini quiz key handler', err); }
                    };
                    try{ document.addEventListener('keydown', __miniQuizKeyHandler, true); }catch(e){}
                }
                document.getElementById('miniQuizType').textContent = type === 'missed' ? 'Missed' : 'Correct';
                modal.classList.remove('hidden');
                try{ __activateMiniIsolation(true); }catch(e){}
                // Focus trap: move focus into the modal close button or next button
                try{
                    const firstFocus = document.getElementById('miniQuizClose') || document.getElementById('miniNext');
                    if(firstFocus && firstFocus.focus) firstFocus.focus();
                }catch(e){}
                renderMiniQuizCurrent();
            }
            
            function closeMiniQuiz() {
                const modal = document.getElementById('miniQuizModal');
                if (modal) modal.classList.add('hidden');
                try{ if(__miniQuizKeyHandler){ document.removeEventListener('keydown', __miniQuizKeyHandler, true); __miniQuizKeyHandler = null; } }catch(e){}
                try{ __activateMiniIsolation(false); }catch(e){}
            }
            
            function renderMiniQuizCurrent() {
                const it = miniQuizState.items[miniQuizState.idx];
                const total = miniQuizState.items.length;
                const body = document.getElementById('miniQuizBody');
                const prog = document.getElementById('miniProgress');
                const prev = document.getElementById('miniPrev');
                const next = document.getElementById('miniNext');
                
                prog.textContent = `${miniQuizState.idx + 1} / ${total}`;
                prev.disabled = miniQuizState.idx === 0;
                next.textContent = miniQuizState.idx === total - 1 ? 'Finish' : 'Next';
                
                const qType = String(it.type || 'mcq').toLowerCase();
                const letters = ['A','B','C','D','E','F'];

                function lockAll(){
                    try{ body.querySelectorAll('button, input, select').forEach(el=>{ try{ el.disabled = true; }catch(e){} }); }catch(e){}
                    try{ Array.from(body.querySelectorAll('.choice')).forEach(el=>el.classList.add('disabled')); }catch(e){}
                }
                function norm(s){ try{ return normalizeGreek(String(s||'')).trim().replace(/\s+/g,' ').toLowerCase(); }catch(e){ return String(s||'').trim().toLowerCase(); } }

                if(qType === 'fillblank'){
                    const keys = Array.isArray(it.answers) ? it.answers : [];
                    body.innerHTML = `
                        <div style="font-weight:700; font-size:1.1em; margin-bottom:16px">Q${it.num}. ${safeText(it.q)}</div>
                        <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap">
                            <input id="miniFib" type="text" autocomplete="off" spellcheck="false" placeholder="Your answer" style="flex:1 1 260px; min-width:220px; height:36px; border-radius:10px; background: rgba(12,21,38,.85); color: var(--ink); border: 1px solid var(--btnBorder); padding: 6px 10px; box-sizing:border-box" />
                            <button id="miniFibSubmit" class="btn primary" type="button" style="height:36px">Submit</button>
                        </div>
                        <div id="miniFeedback" class="hint" style="margin-top:12px; min-height:20px"></div>
                        <div id="miniKey" class="hint" style="margin-top:10px">Answer: <span class="tag">${safeText(keys.length ? keys.join(' | ') : '(no key provided)')}</span></div>
                    `;
                    const inp = body.querySelector('#miniFib');
                    const btn = body.querySelector('#miniFibSubmit');
                    const fb = body.querySelector('#miniFeedback');
                    const submit = ()=>{
                        const v = inp ? inp.value : '';
                        const ok = keys.length ? keys.some(k=> norm(k) === norm(v)) : false;
                        if(fb){ fb.textContent = ok ? 'Correct!' : 'Incorrect.'; fb.style.color = ok ? 'var(--good)' : 'var(--bad)'; }
                        lockAll();
                    };
                    if(inp) inp.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); submit(); }});
                    if(btn) btn.onclick = submit;
                    try{ if(window.renderMathIn) window.renderMathIn(body); }catch(e){}
                    return;
                }

                if(qType === 'matching'){
                    const pairs = Array.isArray(it.pairs) ? it.pairs : [];
                    const opts = Array.isArray(it.rightOptions) && it.rightOptions.length ? it.rightOptions : Array.from(new Set(pairs.map(p=>p.right))).filter(Boolean);
                    body.innerHTML = `
                        <div style="font-weight:700; font-size:1.1em; margin-bottom:16px">Q${it.num}. ${safeText(it.q)}</div>
                        <div id="miniMatchRows" style="display:flex; flex-direction:column; gap:8px"></div>
                        <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:12px">
                            <button id="miniMatchSubmit" class="btn primary" type="button">Submit</button>
                        </div>
                        <div id="miniFeedback" class="hint" style="margin-top:12px; min-height:20px"></div>
                    `;
                    const rows = body.querySelector('#miniMatchRows');
                    pairs.forEach((p,i)=>{
                        const row = document.createElement('div');
                        row.className = 'choice';
                        row.style.display = 'flex';
                        row.style.alignItems = 'center';
                        row.style.gap = '10px';
                        row.style.cursor = 'default';
                        row.innerHTML = `
                            <div style="flex:1 1 320px"><strong>${safeText(p.left)}</strong></div>
                            <div style="flex:0 0 240px">
                                <select data-left-idx="${i}" style="width:100%; height:34px; border-radius:10px; background: rgba(12,21,38,.85); color: var(--ink); border: 1px solid var(--btnBorder); padding: 6px 10px; box-sizing:border-box">
                                    <option value="">Select…</option>
                                    ${opts.map((r, idx)=>`<option value="${idx}">${esc(r)}</option>`).join('')}
                                </select>
                            </div>
                        `;
                        rows.appendChild(row);
                    });
                    const fb = body.querySelector('#miniFeedback');
                    const btn = body.querySelector('#miniMatchSubmit');
                    const submit = ()=>{
                        const selects = body.querySelectorAll('select[data-left-idx]');
                        let all = true;
                        selects.forEach(sel=>{ if(!sel.value) all=false; });
                        if(!all){ if(fb){ fb.textContent='Complete all matches first.'; fb.style.color='var(--bad)'; } return; }
                        // evaluate and highlight
                        let okAll = true;
                        Array.from(rows.children).forEach((row,i)=>{
                            const sel = row.querySelector('select');
                            const chosen = sel && sel.value ? opts[parseInt(sel.value,10)] : '';
                            const ok = norm(chosen) === norm(pairs[i].right);
                            row.classList.add(ok ? 'correct' : 'wrong');
                            if(!ok) okAll = false;
                        });
                        if(fb){ fb.textContent = okAll ? 'Correct!' : 'Incorrect.'; fb.style.color = okAll ? 'var(--good)' : 'var(--bad)'; }
                        lockAll();
                    };
                    if(btn) btn.onclick = submit;
                    try{ if(window.renderMathIn) window.renderMathIn(body); }catch(e){}
                    return;
                }

                // MCQ / TF
                body.innerHTML = `
                    <div style="font-weight:700; font-size:1.1em; margin-bottom:16px">Q${it.num}. ${safeText(it.q)}</div>
                    <div id="miniChoices"></div>
                    <div id="miniFeedback" class="hint" style="margin-top:12px; min-height:20px"></div>
                `;
                const chContainer = body.querySelector('#miniChoices');
                const fb = body.querySelector('#miniFeedback');
                const choices = Array.isArray(it.choices) ? it.choices : [];
                choices.forEach((c, idx) => {
                    const div = document.createElement('div');
                    div.className = 'choice';
                    div.innerHTML = `<strong>${letters[idx]}.</strong> <span>${safeText(c)}</span>`;
                    div.onclick = () => {
                        const isCorrect = idx === it.correctIdx;
                        div.classList.add(isCorrect ? 'correct' : 'wrong');
                        if (!isCorrect) {
                            const correctDiv = chContainer.children[it.correctIdx];
                            if (correctDiv) correctDiv.classList.add('correct');
                            fb.textContent = 'Incorrect.';
                            fb.style.color = 'var(--bad)';
                        } else {
                            fb.textContent = 'Correct!';
                            fb.style.color = 'var(--good)';
                        }
                        Array.from(chContainer.children).forEach(child => child.classList.add('disabled'));
                    };
                    chContainer.appendChild(div);
                });
                try{ if(window.renderMathIn) window.renderMathIn(body); }catch(e){}
            }

            /* ---------- Gemini 2.5 rationale (SDK) ---------- */
            async function requestGeminiRationale(it, rec) {
                const key = (document.getElementById('globalGemKey')?.value || '').trim(); const out = $('resultsAiOutput') || $('gemOut');
                const enabled = !!document.getElementById('globalGemEnable')?.checked;
                if (!key || !enabled) {
                    // Do not write a user-facing message into the AI Explanation panel when API is disabled.
                    // The UI instead shows a small red/green dot next to the AI Explanation header to indicate status.
                    try{ console.debug('AI explanations disabled or API key missing; skipping Gemini request.'); }catch(e){}
                    return;
                }
                const AI = window.GoogleGenerativeAI; if (!AI) { try{ if(typeof window.showAiOutput === 'function'){ window.showAiOutput('SDK failed to load. Check network.'); } else { if(out) out.value = 'SDK failed to load. Check network.'; } }catch{}; return; }
                const client = new AI(key);
                const model = client.getGenerativeModel({ model: 'gemini-2.5-flash' });
                const t = (it && it.type ? String(it.type) : 'mcq').toLowerCase();
                let prompt = '';
                if(t === 'fillblank'){
                    const user = (rec && typeof rec.text === 'string') ? rec.text : '';
                    const keys = Array.isArray(it.answers) ? it.answers : [];
                    prompt = `You are a concise tutor. Provide a compact, meaningful explanation.
Constraints:
- Keep the whole response brief (≈80–140 words). No fluff.
- Start with a one-line verdict: "Verdict: Correct." or "Verdict: Incorrect." (if incorrect, show the correct answer).
- Then give 1–2 short sentences explaining the core concept.
- End with a one-line takeaway.

Question (fill-in-the-blank): ${it.q}
Student answer: ${user}
Correct answer(s): ${keys.join(' | ')}`;
                } else if(t === 'matching'){
                    const pairs = Array.isArray(it.pairs) ? it.pairs : [];
                    const userMatch = (rec && Array.isArray(rec.match)) ? rec.match : [];
                    const opts = Array.isArray(it.rightOptions) && it.rightOptions.length ? it.rightOptions : Array.from(new Set(pairs.map(p=>p.right))).filter(Boolean);
                    const userLines = pairs.map((p,i)=>{
                        const selIdx = userMatch[i];
                        const chosen = (selIdx!=null && isFinite(selIdx)) ? opts[selIdx] : '';
                        return `${p.left} -> ${chosen}`;
                    }).join('\n');
                    const keyLines = pairs.map(p=>`${p.left} -> ${p.right}`).join('\n');
                    prompt = `You are a concise tutor. Provide a compact, meaningful explanation.
Constraints:
- Keep the whole response brief (≈90–160 words). No fluff.
- Start with a one-line verdict: "Verdict: Correct." or "Verdict: Incorrect." (if incorrect, mention 1–2 mismatches).
- Then give 1–2 short sentences explaining the core concept.
- End with a one-line takeaway.

Question (matching): ${it.q}
Student matches:
${userLines}
Correct matches:
${keyLines}`;
                } else {
                    // MCQ / True-False
                    const choiceIdx = (rec && rec.selected != null) ? rec.selected : null;
                    const choices = Array.isArray(it.choices) ? it.choices : [];
                    const selText = (choiceIdx!=null && choices[choiceIdx]!=null) ? choices[choiceIdx] : '';
                    const corrText = (typeof it.correctIdx === 'number' && choices[it.correctIdx]!=null) ? choices[it.correctIdx] : '';
                    prompt = `You are a concise tutor. Provide a compact, meaningful explanation of the student’s choice and evaluate each option.
Constraints:
- Keep the whole response brief (≈80–140 words). No fluff.
- Start with a one-line verdict: "Verdict: Correct." or "Verdict: Incorrect." (if incorrect, say which letter is correct).
- Then give 1–2 short sentences explaining the core concept.
- Then list every option (A., B., C., …): one short reason each; mark the correct one with "(correct)".
- End with a one-line takeaway.

Question: ${it.q}
Options:
${choices.map((c, i) => `${letters[i]}. ${c}`).join('\n')}
Student selected: ${(choiceIdx!=null ? letters[choiceIdx] : '?')}. ${selText}
Correct answer: ${letters[it.correctIdx] || 'A'}. ${corrText}`;
                }
                // Show immediate UI feedback (animated preferred)
                try{ if(typeof window.stopAiOutput === 'function'){ window.stopAiOutput(); } }catch{}
                // Capture the quiz index at the time of request so we can ignore late responses
                const _requestIdx = (typeof state.idx === 'number') ? state.idx : null;
                try{ if(typeof window.showAiOutput === 'function'){ window.showAiOutput('Analyzing with Gemini 2.5...'); } else { if(out) { out.value = 'Analyzing with Gemini 2.5...'; out.disabled = true; } } }catch{}
                // Capture the controller token created by showAiOutput (if any) so we only overwrite
                // the same output area when the original request is still active. Capture AFTER calling
                // showAiOutput so we get the actual controller instance created for this request.
                const _myAiController = window.__aiOutputController || null;
                // Snapshot the results-analysis request counter so that if an Analyze flow
                // or any other code increments the counter (via stopAiOutput or starting
                // an analysis), this per-question request will not write into the results
                // area. This protects against the observed rollover where a late per-question
                // response overwrote the Analyze output.
                const _resultsReqSnapshot = (window.__resultsAnalysisRequestCounter||0);
                // spinner visual removed for AI Explanation (use animated textbook output instead)
                const spin = null;
                try {
                    const resp = await model.generateContent({ contents: [{ role: 'user', parts: [{ text: prompt }] }] });
                    const text = await resp?.response?.text?.();
                    const final = (text || '').trim() || 'No explanation returned.';
                    // Before writing, ensure the user is still on the same question and
                    // that no newer Gemini request has replaced the global controller.
                    try{
                        const stillOnQuestion = (_requestIdx === null) || (typeof state.idx === 'number' && state.idx === _requestIdx);
                        const globalCtrl = window.__aiOutputController;
                        // Allow write when still on question and either this request's controller
                        // is the global one, or there's no active global controller (null/undefined).
                        const canWriteAnimated = (globalCtrl === _myAiController) || (globalCtrl == null);
                        if(!stillOnQuestion){
                            console.log('Gemini response ignored: question changed since request');
                        } else if(window.__resultsAnalysisRequestCounter !== _resultsReqSnapshot){
                            console.log('Gemini per-question response ignored: newer results/stop occurred');
                        } else if(typeof window.showAiOutput === 'function'){
                            if(canWriteAnimated){
                                window.showAiOutput(final);
                            } else {
                                // Fallback: if animated output can't be written, try legacy textarea
                                if(out) out.value = final; else console.log('Gemini response skipped: newer request active');
                            }
                        } else if(out){ out.value = final; }
                    }catch(e){ if(out) out.value = final; }
                } catch (e) {
                    console.error('Gemini request error', e);
                    const raw = (e?.message || String(e || '')).toString();
                    // Detect invalid API key error and provide actionable guidance
                    if (/API_KEY_INVALID|API key not valid/i.test(raw)){
                        // mask key preview
                        let preview = '<no key provided>';
                        try{ if(key && key.length){ preview = key.length>8 ? (key.slice(0,4) + '…' + key.slice(-4)) : ('*'.repeat(Math.max(4,key.length))); } }catch{}
                        const msg = `Gemini request failed: API key invalid.\nKey preview: ${preview}\n\nFixes to try:\n1) Confirm the global API key at the top of the page is correct. (Open devtools and run: document.getElementById('globalGemKey').value)\n2) In Google Cloud Console, enable the Generative Language API (generativelanguage.googleapis.com) and ensure billing is enabled for your project.\n3) Check API key restrictions: if the key is restricted by HTTP referrers or IPs, either remove restrictions for testing or add this origin (for local files consider running a localhost server).\n4) If issues persist, create a new API key and try again.\n`;
                        try{
                            const stillOnQuestion = (_requestIdx === null) || (typeof state.idx === 'number' && state.idx === _requestIdx);
                            const globalCtrl = window.__aiOutputController;
                            const canWriteAnimated = (globalCtrl === _myAiController) || (globalCtrl == null);
                            if(stillOnQuestion){
                                if(window.__resultsAnalysisRequestCounter !== _resultsReqSnapshot){
                                    console.log('Gemini per-question error ignored due to newer results/stop');
                                } else if(typeof window.showAiOutput === 'function'){
                                    if(canWriteAnimated){ window.showAiOutput(msg); }
                                    else { console.log('Gemini error skipped: newer request active'); }
                                } else if(out){ out.value = msg; }
                            } else { console.log('Gemini error ignored: question changed'); }
                        }catch{}
                    } else {
                        const msg = 'Gemini request failed: ' + raw;
                        try{
                            const stillOnQuestion = (_requestIdx === null) || (window.state && state.idx === _requestIdx);
                            const globalCtrl = window.__aiOutputController;
                            const canWriteAnimated = (globalCtrl === _myAiController) || (globalCtrl == null);
                            if(stillOnQuestion){
                                if(window.__resultsAnalysisRequestCounter !== _resultsReqSnapshot){
                                    console.log('Gemini per-question error ignored due to newer results/stop');
                                } else if(typeof window.showAiOutput === 'function'){ if(canWriteAnimated){ window.showAiOutput(msg); } else { console.log('Gemini error skipped: newer request active'); } } else if(out){ out.value = msg; }
                            }
                            else { console.log('Gemini error ignored: question changed'); }
                        }catch{}
                    }
                } finally {
                    try{
                        // Only re-enable the legacy textarea if the user is still on the same question
                        // and this request is still the latest one (or there is no active global controller).
                            const stillOnQuestion = (_requestIdx === null) || (typeof state.idx === 'number' && state.idx === _requestIdx);
                            const globalCtrl = window.__aiOutputController;
                            const isLatestOrNoGlobal = (globalCtrl === _myAiController) || (globalCtrl == null);
                        if(out && stillOnQuestion && isLatestOrNoGlobal && window.__resultsAnalysisRequestCounter === _resultsReqSnapshot){ out.disabled = false; }
                    }catch{}; if(spin) try{ spin.remove(); }catch{}
                }
            }

            /* ---------- Wire up ---------- */
            function doParse() {
                const text = $('paste').value || ''; state.items = parseDoc(text); state.order = state.items.map((_, i) => i);
                state.answered = {}; state.skipped.clear(); state.reviewPool = []; state.idx = 0; state.score = 0; state.mode = 'quiz'; state.started = false;
                // mark that the document has been parsed so UI hides (AI cards) only after parse
                try{ window.__parsed = true; }catch{}
                renderPreview(state.items); hideSkipped();
                // Enable Start Quiz only when there are parsed items
                try{ const sbtn = document.getElementById('startBtn'); if(sbtn) sbtn.disabled = !(state.items && state.items.length); }catch(e){}
                // Overwrite Flashcards deck via global setter (avoids scope/timing issues)
                try{ if(typeof window.fcSetDeckFromItems === 'function'){ window.fcSetDeckFromItems(state.items || []); } }catch(e){ console.warn('fcSetDeckFromItems call failed', e); }
            }
            // Ensure Start Quiz is disabled until a successful parse
            try{ const sbtnInit = document.getElementById('startBtn'); if(sbtnInit) sbtnInit.disabled = true; }catch(e){}
            $('parseBtn').onclick = doParse;

        // Keyboard shortcuts: answer selection, submit/next, skip
        (function(){
            function isTypingInInput(){
                const el = document.activeElement;
                if(!el) return false;
                const tag = (el.tagName||'').toLowerCase();
                if(tag === 'input' || tag === 'textarea' || tag === 'select') return true;
                if(el.isContentEditable) return true;
                return false;
            }

            function handleKey(e){
                try{
                    // If the mini-quiz modal is visible, disable global shortcuts
                    try{ const mq = document.getElementById('miniQuizModal'); if(mq && !mq.classList.contains('hidden')) return; }catch{}
                    // If TOS lock is active, disable all keyboard shortcuts
                    try{ if(document.documentElement && document.documentElement.classList && document.documentElement.classList.contains('tos-locked')) return; }catch{}
                    // If a pre-quiz overlay is active, ignore shortcuts
                    if(window.__preQuizOverlayActive) return;
                    if(!state || !state.started) return; // only when quiz active
                    if(isTypingInInput()) return; // don't interfere with typing
                    // If user is holding a modifier (Ctrl/Cmd/Alt), let the browser handle
                    // the key (e.g., Ctrl+C for copy). Do not consume modifier combos here.
                    try{ if(e && (e.ctrlKey || e.metaKey || e.altKey)) return; }catch(_){}
                    const k = (e.key || '').toLowerCase();
                    // If the summary screen is showing review/restart buttons, map Enter/N -> Review Missed and R -> Restart
                    try{
                        // Back to Setup must not be triggered by shortcuts anymore; require pointer interaction only.
                        // Therefore, deliberately do not map Enter (or any key) to the Back to Setup action.

                        const reviewBtn = document.getElementById('reviewMissed');
                        const restartBtn = document.getElementById('restart');
                        // Handle review controls only when Review Missed is visible AND enabled
                        if(reviewBtn && reviewBtn.offsetParent !== null && !reviewBtn.disabled){
                            if(k === 'enter' || k === 'n'){
                                try{ reviewBtn.click(); e.preventDefault(); }catch(e){}
                                return;
                            }
                            if(k === 'r'){
                                if(restartBtn){ try{ restartBtn.click(); e.preventDefault(); }catch(e){} }
                                return;
                            }
                        }
                        // Fallback: even if Review Missed is disabled (e.g., 0 missed),
                        // honor the 'r' key when the Restart button is visible/enabled.
                        if(restartBtn && restartBtn.offsetParent !== null && !restartBtn.disabled){
                            if(k === 'r'){
                                try{ restartBtn.click(); e.preventDefault(); }catch(e){}
                                return;
                            }
                        }

                        // If the Keep Going / Continue screen is showing, pressing Enter should trigger Continue
                        const continueBtn = document.getElementById('continueReview');
                        if(continueBtn && continueBtn.offsetParent !== null){
                            if(k === 'enter'){
                                try{ continueBtn.click(); e.preventDefault(); }catch(e){}
                                return;
                            }
                        }

                        // If a Back button is present (e.g., Back navigation in quiz view), allow 'b' to activate it
                        const backBtn = document.getElementById('backBtn');
                        if(backBtn && backBtn.offsetParent !== null){
                            if(k === 'b'){
                                try{ if(!backBtn.disabled){ backBtn.click(); e.preventDefault(); } }catch(err){}
                                return;
                            }
                        }
                    }catch(e){}

                    // map 1-9 -> choice indices 0..8
                    if(/^[1-9]$/.test(k)){
                        const idx = parseInt(k,10) - 1;
                        const inputs = quiz.querySelectorAll('.choice input');
                        if(inputs && inputs[idx]){ inputs[idx].click(); e.preventDefault(); }
                        return;
                    }
                    // map letters a-f to choices
                    if(/^[a-f]$/.test(k)){
                        const idx = k.charCodeAt(0) - 'a'.charCodeAt(0);
                        const inputs = quiz.querySelectorAll('.choice input');
                        if(inputs && inputs[idx]){ inputs[idx].click(); e.preventDefault(); }
                        return;
                    }
                    // Enter: if current question already submitted -> next, else submit if selection exists
                    if(k === 'enter'){
                        const idx = activeIndex(); const rec = state.answered[idx];
                        const it = state.items[idx];
                        if(rec && rec.submitted){ e.preventDefault(); next(); return; }
                        // try to submit using recorded selection, or find checked input
                        const sel = rec && (rec.selected!=null) ? rec.selected : null;
                        if(sel!=null){ try{ doSubmit(it, idx); e.preventDefault(); }catch(e){} return; }
                        const checked = quiz.querySelector('.choice input:checked');
                        if(checked){ try{ checked.dispatchEvent(new Event('change', { bubbles:true })); e.preventDefault(); }catch(e){} return; }
                        return;
                    }
                    // Next (n)
                    if(k === 'n') { e.preventDefault(); next(); return; }
                    // Skip (s)
                    if(k === 's') { e.preventDefault(); skipCurrent(); return; }
                }catch(err){ console.warn('keyboard shortcut handler error', err); }
            }
            // Attach once
            try{ document.addEventListener('keydown', handleKey, { capture:false }); }catch(e){ document.addEventListener('keydown', handleKey); }
        })();

        // See All modal wiring
        (function(){
            const seeAllBtn = document.getElementById('seeAllBtn');
            const modal = document.getElementById('seeAllModal');
            const closeBtn = document.getElementById('seeAllClose');
            const content = document.getElementById('seeAllContent');
            function openModal(){
                try{
                    // populate content from quiz state
                    const items = (window.__quizState && window.__quizState.items) ? window.__quizState.items : (window.state && state.items) ? state.items : [];
                    if(!items || !items.length){
                        content.innerHTML = '<div class="hint">No parsed items yet. Parse your document first.</div>';
                    } else {
                        // Render concise question + lettered choices for each parsed item
                        const esc = s => String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;');
                        const letters = ['A','B','C','D','E','F','G','H'];
                        content.innerHTML = items.map((it, ix) => {
                            const num = it.num || (ix + 1);
                            const q = esc(it.q || it.text || '');
                            const type = String(it.type || 'mcq').toLowerCase();

                            if(type === 'fillblank'){
                                const keys = Array.isArray(it.answers) ? it.answers : (it.answer != null ? [it.answer] : []);
                                const key = keys.length ? esc(keys.join(' | ')) : '(no key provided)';
                                return `<div class="seeall-item">` +
                                    `<div style="font-weight:700;margin-bottom:6px">Q${num}. ${q}</div>` +
                                    `<div class="seeall-choices">` +
                                        `<div class="seeall-choice"><strong>Type</strong> Fill-in-the-Blank</div>` +
                                        `<div class="seeall-choice correct"><strong>Key</strong> ${key}</div>` +
                                    `</div>` +
                                    `</div>`;
                            }

                            if(type === 'matching'){
                                const pairs = Array.isArray(it.pairs) ? it.pairs : [];
                                const pairHtml = pairs.map(p=>`<div class="seeall-choice seeall-match"><span class="seeall-match-left">${esc(p.left)}</span> → ${esc(p.right)}</div>`).join('');
                                return `<div class="seeall-item">` +
                                    `<div style="font-weight:700;margin-bottom:6px">Q${num}. ${q}</div>` +
                                    `<div class="seeall-choices">` +
                                        `<div class="seeall-choice"><strong>Type</strong> Matching</div>` +
                                        `${pairHtml || '<div class="seeall-choice">(no pairs)</div>'}` +
                                    `</div>` +
                                    `</div>`;
                            }

                            const choices = Array.isArray(it.choices) ? it.choices : [];
                            // determine correct index: prefer numeric correctIdx, else try to parse a key letter
                            let correctIdx = (typeof it.correctIdx === 'number' && isFinite(it.correctIdx)) ? it.correctIdx : null;
                            if(correctIdx === null && it.answer){
                                const m = String(it.answer).match(/([A-F])/i);
                                if(m) correctIdx = 'ABCDEF'.indexOf(m[1].toUpperCase());
                            }
                            if(correctIdx === null && it.key){ const m = String(it.key).match(/([A-F])/i); if(m) correctIdx = 'ABCDEF'.indexOf(m[1].toUpperCase()); }
                            const choicesHtml = choices.map((c, i) => {
                                const cls = (correctIdx !== null && i === correctIdx) ? 'seeall-choice correct' : 'seeall-choice';
                                return `<div class="${cls}"><strong>${letters[i]||String(i+1)}.</strong> ${esc(c)}</div>`;
                            }).join('');
                            return `<div class="seeall-item">` +
                                `<div style="font-weight:700;margin-bottom:6px">Q${num}. ${q}</div>` +
                                `<div class="seeall-choices">` +
                                    `<div class="seeall-choice"><strong>Type</strong> ${type === 'truefalse' ? 'True/False' : 'Multiple Choice'}</div>` +
                                    `${choicesHtml}` +
                                `</div>` +
                                `</div>`;
                        }).join('');
                    }
                    // disable page scroll while modal is open (robust across platforms)
                    try{
                        // save current scroll and inline styles so we can restore exactly
                        document.body.dataset._prevOverflow = document.body.style.overflow || '';
                        document.body.dataset._prevPosition = document.body.style.position || '';
                        document.body.dataset._prevTop = document.body.style.top || '';
                        const scrollY = window.scrollY || window.pageYOffset || 0;
                        document.body.dataset._scrollY = String(scrollY);
                        // lock by fixing body position which prevents mobile overscroll too
                        document.body.style.position = 'fixed';
                        document.body.style.top = `-${scrollY}px`;
                        document.body.style.left = '0';
                        document.body.style.right = '0';
                        document.body.style.overflow = 'hidden';
                    }catch(e){}
                    modal.classList.remove('hidden');
                }catch(e){ console.log('openModal failed', e); }
            }
            function closeModal(){ try{ modal.classList.add('hidden'); try{
                        // restore scroll and body styles
                        const prevOverflow = document.body.dataset._prevOverflow || '';
                        const prevPosition = document.body.dataset._prevPosition || '';
                        const prevTop = document.body.dataset._prevTop || '';
                        const scrollY = parseInt(document.body.dataset._scrollY || '0', 10) || 0;
                        document.body.style.overflow = prevOverflow;
                        document.body.style.position = prevPosition;
                        document.body.style.top = prevTop;
                        // remove temp dataset keys
                        delete document.body.dataset._prevOverflow; delete document.body.dataset._prevPosition; delete document.body.dataset._prevTop; delete document.body.dataset._scrollY;
                        // restore scroll position
                        window.scrollTo(0, scrollY);
                    }catch(e){} }catch(e){} }
            seeAllBtn?.addEventListener('click', openModal);
            closeBtn?.addEventListener('click', closeModal);
            // close on backdrop click (also restore scroll)
            modal?.addEventListener('click', (ev)=>{ if(ev.target === modal || ev.target.classList.contains('modal-backdrop')) closeModal(); });
        })();
            // Ensure bindings work even if the $ helper isn't in this scope
            try{ document.getElementById('beginFromPreview')?.addEventListener('click', startQuiz); }catch(e){}
            try{ document.getElementById('startBtn')?.addEventListener('click', startQuiz); }catch(e){}
            (function(){
                const btn = document.getElementById('sampleBtn');
                if(!btn) return;
                btn.addEventListener('click', function(){
                    try{
                        const paste = document.getElementById('paste');
                        if(paste) paste.value = normalizeGreek([
                            'Q1. Why is protein purification essential in biochemistry?',
                            '- It prevents oxidation of DNA',
                            '- It allows isolation and study of specific proteins free from contaminants',
                            '- It enables bacterial transformation',
                            '- It increases cell growth rate',
                            '',
                            'Q2. [TF] In general, higher purity is required for X-ray crystallography than for basic activity assays.',
                            '',
                            'Q3. [FIB] The primary structure of a protein refers to its ____ sequence.',
                            '',
                            'Q4. [MATCH] Match the technique to what it typically provides:',
                            '- SDS-PAGE -> Approximate molecular weight',
                            '- Western blot -> Detection of a specific protein with an antibody',
                            '- Size-exclusion chromatography -> Separation by apparent size',
                            '- Extras: Separation by charge',
                            '',
                            'ANSWER KEY',
                            '1. B',
                            '2. True',
                            '3. amino acid | amino-acid'
                        ].join('\n'));
                        // call the parsing routine if available
                        try{ if(typeof doParse === 'function') doParse(); else document.getElementById('parseBtn')?.click(); }catch(e){}
                    }catch(e){ console.warn('sampleBtn handler failed', e); }
                });
            })();
            $('file').addEventListener('change', async (e) => { const f = e.target.files[0]; if (!f) return; const txt = await f.text(); $('paste').value = normalizeGreek(txt); doParse(); });
            // show chosen filenames in styled wrappers
            $('file')?.addEventListener('change', (e)=>{ const f = e.target.files?.[0]; const name = f ? f.name : 'No file chosen'; const span = document.getElementById('fileNameTxt'); if(span) span.textContent = name; });
            $('aiFile')?.addEventListener('change', (e)=>{
                const files = Array.from(e.target.files||[]);
                const span = document.getElementById('aiFileName');
                if(!span){ return; }
                if(files.length === 0){ span.textContent = 'No file chosen'; }
                else if(files.length === 1){ span.textContent = files[0].name; }
                else { span.textContent = `${files.length} files selected`; }
            });

        })();
    </script>
    <script>
    /* === Saved MCQs: storage + UI wiring === */
    (function(){
        const LS_KEY = 'mcq.pastes.v1';
        const byId = (id)=> document.getElementById(id);
    const savedList = byId('savedList');
    const savedCount = byId('savedCount');
    const savedMenu = byId('savedMenu');
    const toggleBtn = byId('toggleSavedBtn');
        const refreshBtn = byId('refreshSavedBtn');
        const clearBtn = byId('clearSavedBtn');
        const indexBtn = byId('indexPasteBtn');
        const pasteEl = byId('paste');

        function loadAll(){ try{ return JSON.parse(localStorage.getItem(LS_KEY)||'[]'); }catch{ return []; } }
        function saveAll(arr){ try{ localStorage.setItem(LS_KEY, JSON.stringify(arr)); }catch(e){ alert('Could not save to local storage.'); } }
        function loadFolders(){ try{ return JSON.parse(localStorage.getItem(LS_KEY+':folders')||'[]'); }catch{ return []; } }
        function saveFolders(f){ try{ localStorage.setItem(LS_KEY+':folders', JSON.stringify(f)); }catch(e){ /* non-fatal */ } }
        function now(){ const d=new Date(); return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`; }
        function shortTitle(s){ s=s||''; return s.split('\n').map(l=>l.trim()).filter(Boolean)[0]||'Untitled'; }

    // helper: safe filename
    function sanitizeFilenameLocal(s){ try{ return String(s||'untitled').replace(/[\\/:*?"<>|\x00-\x1F]/g,'_').replace(/\s+/g,' ').trim().slice(0,180); }catch(e){ return 'untitled'; } }

    // helper: ensure JSZip for bulk export of local saved MCQs
    async function loadJSZip(){ if(window.JSZip) return window.JSZip; try{ await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js'; s.onload=res; s.onerror=rej; document.head.appendChild(s); }); return window.JSZip; }catch(e){ console.warn('Failed to load JSZip', e); throw e; } }

        function render(){
            if(!savedList||!savedCount) return;
            const arr = loadAll(); savedCount.textContent = String(arr.length);
            let folders = loadFolders();
            // Sort folders by lastSelected (most recent first), falling back to creation date if needed
            try{
                folders = folders.slice().sort((a,b)=>{
                    const at = a.lastSelected || a.createdAt || 0;
                    const bt = b.lastSelected || b.createdAt || 0;
                    return bt - at;
                });
            }catch(e){}
            // compute total bytes across saved items
            try{
                const totalBytes = arr.reduce((acc,it)=>{
                    try{ if(it && it.text) return acc + (it.text.length||0); }catch(e){}
                    return acc;
                },0);
                const elTotal = document.getElementById('savedTotalKb'); if(elTotal) elTotal.textContent = `Total: ${(totalBytes/1024).toFixed(1)} KB`;
            }catch(e){}
            if(!arr.length && !folders.length){ savedList.innerHTML = '<div class="hint">No saved items yet. Use "Save Set" to save your paste.</div>'; return; }

                // Before rendering folders, normalize their item lists against existing saved MCQs
                try{
                    const validIds = new Set(arr.map(it=>it.id));
                    let changedFolders = false;
                    folders.forEach(f=>{
                        if(Array.isArray(f.items)){
                            const filtered = f.items.filter(id=>validIds.has(id));
                            if(filtered.length !== f.items.length){
                                f.items = filtered;
                                changedFolders = true;
                            }
                        }
                    });
                    if(changedFolders) saveFolders(folders);
                }catch(e){}

                const folderHtml = folders.map((f, idx)=>{
                    const safeName = (f.name||'Folder').replace(/&/g,'&amp;').replace(/</g,'&lt;');
                    const itemCount = Array.isArray(f.items) ? f.items.length : 0;
                    const created = f.createdAt ? new Date(f.createdAt) : null;
                    const createdStr = created && !isNaN(created.getTime())
                        ? `${created.getFullYear()}-${String(created.getMonth()+1).padStart(2,'0')}-${String(created.getDate()).padStart(2,'0')}`
                        : '';
                    return `<div class="saved-item saved-folder" data-folder-id="${(f.id||'f'+idx).replace(/"/g,'')}">
                        <div class="si-main">
                            <div class="si-title"><span class="si-folder-name" contenteditable="true" spellcheck="false">${safeName}</span><span class="si-qcount" style="margin-left:8px;color:var(--muted);font-size:12px">· ${itemCount} set${itemCount===1?'':'s'}</span></div>
                            <div class="si-meta">Created: ${createdStr || 'n/a'}</div>
                        </div>
                        <div class="si-actions">
                            <button class="btn small" data-act="folder-assign">Assign</button>
                            <button class="btn small" data-act="folder-delete">Delete</button>
                        </div>
                    </div>`;
                }).join('');

                const itemsHtml = arr.map((it, i)=>{
                    // Determine number of questions in this saved MCQ text. Prefer parseDoc if available.
                    let qCount = 0;
                    try{
                        if(typeof parseDoc === 'function'){
                            const parsed = parseDoc(it.text || ''); qCount = (parsed && parsed.length) ? parsed.length : 0;
                        } else if(it.text){ const m = String(it.text).match(/^\s*Q\s*\d+\./gim); qCount = m ? m.length : 0; }
                    }catch(e){ qCount = 0; }
                    const safeTitle = (it.title||'Untitled').replace(/&/g,'&amp;').replace(/</g,'&lt;');
                    const date = it.date || '';
                    const hasRefs = !!(it.meta && it.meta.sourceHints && typeof it.meta.sourceHints === 'object' && Object.keys(it.meta.sourceHints).length);
                    const qcountHtml = `<span class="si-qcount" style="margin-left:8px;color:var(--muted);font-size:12px">· ${qCount} Q</span>`;
                    return `<div class="saved-item" data-i="${i}" data-id="${(it.id||'').replace(/"/g,'')}">
                        <div class="si-main">
                                <div class="si-title"><span class="si-title-text" contenteditable="true" spellcheck="false">${safeTitle}</span>${qcountHtml}</div>
                                <div class="si-meta">${date}${hasRefs ? ' · ✔ refs' : ' · ✖ no refs'}</div>
                            </div>
                            <div class="si-actions">
                                <button class="btn small" data-act="export">Export</button>
                                <button class="btn small" data-act="delete">Delete</button>
                            </div>
                    </div>`;
                }).join('');

                savedList.innerHTML = folderHtml + itemsHtml + `<div class="saved-item saved-folder-footer"><button class="btn small" id="addFolderBtn">+ Folder</button></div>`;

            // Wire folder rows
            const foldersNow = loadFolders();
            savedList.querySelectorAll('.saved-folder').forEach(el=>{
                const fid = el.getAttribute('data-folder-id');
                const nameEl = el.querySelector('.si-folder-name');
                function commitFolderName(newName){
                    const fs = loadFolders(); const f = fs.find(x=>String(x.id)===String(fid)); if(!f) return;
                    const t = String(newName||'').replace(/[\r\n]+/g,' ').trim() || 'Folder';
                    f.name = t; saveFolders(fs); render();
                }
                nameEl && nameEl.addEventListener('keydown', (e)=>{
                    if(e.key==='Enter') { e.preventDefault(); nameEl.blur(); }
                    else if(e.key==='Escape'){ e.preventDefault(); const fs = loadFolders(); const f = fs.find(x=>String(x.id)===String(fid)); if(f){ nameEl.textContent = f.name || 'Folder'; } nameEl.blur(); }
                    e.stopPropagation();
                });
                nameEl && nameEl.addEventListener('blur', ()=>{ commitFolderName(nameEl.textContent||''); });

                el.addEventListener('click', (e)=>{
                    const fs = loadFolders(); const f = fs.find(x=>String(x.id)===String(fid)); if(!f) return;
                    const btn = (e.target && e.target.closest) ? e.target.closest('[data-act]') : null;
                    if(btn){
                        const act = btn.getAttribute('data-act');
                        if(act==='folder-delete'){
                            if(confirm('Delete this folder (MCQ sets remain)?')){
                                const j = fs.findIndex(x=>String(x.id)===String(fid)); if(j>=0){ fs.splice(j,1); saveFolders(fs); render(); }
                            }
                        } else if(act==='folder-assign'){
                            // Build a small inline selector listing all saved sets for quick assignment
                            const list = loadAll();
                            if(!list.length){ alert('No saved sets to assign.'); return; }
                            const existing = new Set(Array.isArray(f.items)?f.items:[]);
                            const choices = list.map((it, idx)=>{
                                const mark = existing.has(it.id) ? '✓' : ' ';
                                return `${idx+1}. [${mark}] ${(it.title||'Untitled')}`;
                            }).join('\n');
                            const input = prompt(`Assign saved set to folder "${f.name||'Folder'}".\nEnter number to toggle membership; separate multiple with commas.\n(Current: ✓ = in folder)\n\n${choices}`);
                            if(input==null) return;
                            const partsSel = String(input).split(/[,\s]+/).map(s=>parseInt(s,10)).filter(n=>n>=1 && n<=list.length);
                            if(!partsSel.length) return;
                            f.items = Array.isArray(f.items)?f.items:[];
                            const setItems = new Set(f.items);
                            partsSel.forEach(n=>{
                                const it = list[n-1]; if(!it || !it.id) return;
                                if(setItems.has(it.id)) setItems.delete(it.id); else setItems.add(it.id);
                            });
                            f.items = Array.from(setItems);
                            saveFolders(fs); render();
                        }
                    } else {
                        // click on folder body -> toggle this folder as current filter
                        const fs2 = loadFolders();
                        const f2 = fs2.find(x=>String(x.id)===String(fid));
                        if(!f2) return;
                        const wasActive = el.classList.contains('active-folder');
                        // bump lastSelected for MRU sort and persist
                        try{ f2.lastSelected = Date.now(); saveFolders(fs2); }catch(e){}

                        // Re-render so folders are re-sorted by lastSelected
                        render();

                        // After re-render, re-find the list and apply filter state
                        const newList = document.getElementById('savedList');
                        if(!newList) return;
                        const folderNodes = newList.querySelectorAll('.saved-folder');
                        const itemNodes = newList.querySelectorAll('.saved-item[data-i]');

                        if(wasActive){
                            // second click on same folder: clear filter and show everything
                            folderNodes.forEach(n=>{
                                n.classList.remove('active-folder');
                                n.style.display = '';
                            });
                            itemNodes.forEach(node=>{ node.style.display = ''; });
                        } else {
                            // first click: activate this folder and filter to its items
                            const currentFolderEl = Array.from(folderNodes).find(n=>n.getAttribute('data-folder-id') === String(fid));
                            const idSet = new Set((f2.items||[]));

                            folderNodes.forEach(n=>{
                                if(n === currentFolderEl){
                                    n.classList.add('active-folder');
                                    n.style.display = '';
                                } else {
                                    n.classList.remove('active-folder');
                                    n.style.display = 'none';
                                }
                            });

                            itemNodes.forEach(node=>{
                                const idx2 = Number(node.getAttribute('data-i'));
                                const it2 = arr[idx2];
                                if(!it2 || !it2.id){ node.style.display = 'none'; return; }
                                node.style.display = idSet.has(it2.id) ? '' : 'none';
                            });
                        }
                    }
                    e.preventDefault(); e.stopPropagation();
                });
            });

            const addFolderBtn = document.getElementById('addFolderBtn');
            if(addFolderBtn){
                addFolderBtn.onclick = ()=>{
                    const name = prompt('Folder name:') || 'Folder';
                    const fs = loadFolders();
                    const nowTs = Date.now();
                    fs.push({ id: nowTs.toString(36)+Math.random().toString(36).slice(2,6), name, items: [], createdAt: nowTs, lastSelected: nowTs });
                    saveFolders(fs); render();
                };
            }

            // Wire saved MCQ item rows
            savedList.querySelectorAll('.saved-item[data-i]').forEach(el=>{
                // Inline title editing (editable span only)
                const titleEl = el.querySelector('.si-title-text');
                const idx = Number(el.getAttribute('data-i'));
                function commitTitle(newTitle){
                    const arr2 = loadAll(); const itm = arr2[idx]; if(!itm) return;
                    // Sanitize and default
                    const t = String(newTitle || '').replace(/[\r\n]+/g,' ').trim() || 'Untitled';
                    itm.title = t; saveAll(arr2);
                    // Re-render to ensure consistency and to escape HTML
                    render();
                }
                titleEl && titleEl.addEventListener('keydown', (e)=>{
                    if(e.key==='Enter'){
                        e.preventDefault(); titleEl.blur();
                    } else if(e.key==='Escape'){
                        e.preventDefault();
                        const arr2 = loadAll(); const itm = arr2[idx]; if(itm){ titleEl.textContent = itm.title || 'Untitled'; }
                        titleEl.blur();
                    }
                    e.stopPropagation();
                });
                titleEl && titleEl.addEventListener('blur', ()=>{ commitTitle(titleEl.textContent||''); });

                // Item click actions: clicking the main area loads/pastes the item; buttons (delete) remain functional
                el.addEventListener('click', (e)=>{
                    const i = Number(el.getAttribute('data-i'));
                    const idAttr = el.getAttribute('data-id');
                    const arr = loadAll();
                    const item = idAttr ? arr.find(x=>String(x.id)===String(idAttr)) : arr[i];
                    if(!item) return;
                    const btn = (e.target && e.target.closest) ? e.target.closest('[data-act]') : null;
                    if(btn){
                        const act = btn.getAttribute('data-act');
                        if(act==='delete'){
                            if(confirm('Delete this saved set?')){
                                let removed = null;
                                const arr2 = loadAll();
                                let deletedId = null;
                                if(idAttr){
                                    const idx2 = arr2.findIndex(x=>String(x.id)===String(idAttr));
                                    if(idx2>=0){
                                        removed = arr2.splice(idx2,1)[0];
                                        deletedId = removed && removed.id;
                                    }
                                } else {
                                    removed = arr2.splice(i,1)[0];
                                    deletedId = removed && removed.id;
                                }
                                saveAll(arr2);

                                // Also prune this MCQ id from any folders' item lists so set counts stay accurate
                                try{
                                    if(deletedId){
                                        const fs = loadFolders();
                                        let changed = false;
                                        fs.forEach(f=>{
                                            if(Array.isArray(f.items) && f.items.includes(deletedId)){
                                                f.items = f.items.filter(x=>x!==deletedId);
                                                changed = true;
                                            }
                                        });
                                        if(changed) saveFolders(fs);
                                    }
                                }catch(e){ console.warn('folder prune failed', e); }
                                // If the deleted item was the one currently providing source hints, clear them
                                try{
                                    if(removed && removed.meta && removed.meta.sourceHints && window.__aiMcqSourceHints === removed.meta.sourceHints){
                                        window.__aiMcqSourceHints = undefined;
                                    }
                                }catch(e){}
                                render();
                            }
                        } else if(act==='export'){
                            try{
                                const item = idAttr ? arr.find(x=>String(x.id)===String(idAttr)) : arr[i]; if(!item) return;
                                const text = item.text || '';
                                const filename = sanitizeFilenameLocal((item.title||shortTitle(text))) + '.txt';
                                const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
                                const a = document.createElement('a'); const url = URL.createObjectURL(blob); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); try{ a.remove(); }catch{} }, 3000);
                            }catch(e){ console.error('export failed', e); alert('Export failed: ' + (e?.message||e)); }
                        }
                    } else {
                        // if click happened inside the editable title, allow editing (do not load)
                        if(e.target && e.target.closest && e.target.closest('.si-title')){
                            // let the click focus the editable title
                            return;
                        }
                        // Move the clicked item to the front (most-recently-used)
                        try{
                            // remove the item at index i and unshift it to front
                            arr.splice(i, 1);
                            arr.unshift(item);
                            saveAll(arr);
                            // re-render on next tick to avoid re-entrancy while iterating
                            setTimeout(render, 0);
                        }catch(e){ console.warn('Could not bump saved item to front', e); }

                        // perform load/paste; restore any saved per-question source hints before parsing
                        if(pasteEl){
                            pasteEl.value = item.text||'';
                            try{
                                // Reset global hints so they are always scoped to this load
                                window.__aiMcqSourceHints = undefined;
                                if(item.meta && item.meta.sourceHints && typeof item.meta.sourceHints === 'object'){
                                    window.__aiMcqSourceHints = item.meta.sourceHints;
                                }
                            }catch(e){}
                            try{ document.getElementById('parseBtn')?.click(); }catch{}
                        }
                        try{ window.scrollTo({ top: document.getElementById('setup').offsetTop, behavior: 'smooth' }); }catch(e){}
                    }
                    e.preventDefault(); e.stopPropagation();
                });

                // Tagging removed for Phase 1
            });
        }

        // --- Expose helpers for quiz-tag exports ---
        try{
            window.__copyTaggedToClipboard = function(){
                try{
                    const st = window.__quizState;
                    if(!st || !st.items || !st.items.length || !st.tags || !st.tags.size){ alert('No tagged questions in this session.'); return; }
                    const parts = [];
                    const keyLines = [];
                    const letters = ['A','B','C','D','E','F','G'];
                    Array.from(st.tags).sort((a,b)=>a-b).forEach(idx=>{
                        const it = st.items[idx]; if(!it) return;
                        const qNum = it.num || (idx+1);
                        parts.push(`Q${qNum}. ${it.q||''}`);
                        if(Array.isArray(it.choices)){
                            it.choices.forEach((c)=>{ parts.push(`- ${c}`); });
                        }
                        if(typeof it.correctIdx === 'number' && it.correctIdx >= 0){
                            const letter = letters[it.correctIdx] || String(it.correctIdx + 1);
                            keyLines.push(`${qNum}. ${letter}`);
                        }
                        parts.push('');
                    });

                    if(keyLines.length){
                        parts.push('ANSWER KEY');
                        keyLines.forEach(l=>parts.push(l));
                    }

                    const text = parts.join('\n');
                    if(!text.trim()){ alert('Tagged questions are empty.'); return; }
                    if(navigator.clipboard && navigator.clipboard.writeText){ navigator.clipboard.writeText(text).then(()=>{ alert('Tagged questions copied to clipboard.'); }).catch(()=>{ fallbackCopy(text); }); }
                    else{ fallbackCopy(text); }

                    function fallbackCopy(t){
                        try{
                            const ta = document.createElement('textarea');
                            ta.value = t; ta.style.position='fixed'; ta.style.left='-9999px'; document.body.appendChild(ta); ta.select();
                            document.execCommand('copy');
                            document.body.removeChild(ta);
                            alert('Tagged questions copied to clipboard.');
                        }catch(e){ alert('Could not copy tagged questions.'); }
                    }
                }catch(e){ console.error('copy tagged failed', e); alert('Copy tagged failed.'); }
            };

            window.__exportTaggedToSavedMcqs = function(){
                try{
                    const st = window.__quizState;
                    if(!st || !st.items || !st.items.length || !st.tags || !st.tags.size){ alert('No tagged questions in this session.'); return; }
                    const parts = [];
                    const keyLines = [];
                    const letters = ['A','B','C','D','E','F','G'];
                    Array.from(st.tags).sort((a,b)=>a-b).forEach(idx=>{
                        const it = st.items[idx]; if(!it) return;
                        const qNum = it.num || (idx+1);
                        parts.push(`Q${qNum}. ${it.q||''}`);
                        if(Array.isArray(it.choices)){
                            it.choices.forEach((c,i)=>{
                                const isCorrect = (typeof it.correctIdx==='number' && i===it.correctIdx);
                                const mark = isCorrect ? ' *' : '';
                                parts.push(`- ${c}${mark}`);
                            });
                        }
                        if(typeof it.correctIdx === 'number' && it.correctIdx >= 0){
                            const letter = letters[it.correctIdx] || String(it.correctIdx + 1);
                            keyLines.push(`${qNum}. ${letter}`);
                        }
                        parts.push('');
                    });

                    if(keyLines.length){
                        parts.push('ANSWER KEY');
                        keyLines.forEach(l=>parts.push(l));
                    }

                    const text = parts.join('\n');
                    if(!text.trim()){ alert('Tagged questions are empty.'); return; }

                    const d = new Date();
                    const ts = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
                    const rec = { id: Date.now().toString(36), title: `Tagged Questions ${ts}`, text, date: ts };
                    const arr = loadAll();
                    arr.unshift(rec);
                    saveAll(arr);
                    try{ render(); }catch(e){}
                    alert('Tagged questions saved into Saved Sets.');
                }catch(e){ console.error('export tagged failed', e); alert('Save tagged failed.'); }
            };
        }catch(e){}

        indexBtn && indexBtn.addEventListener('click', ()=>{
            const txt = (pasteEl && pasteEl.value)||''; if(!txt.trim()){ alert('Paste your questions first.'); return; }
            const arr = loadAll();
            // If AI-generated per-question source hints (refs) exist, persist them alongside this saved set.
            // This fixes the case where a generated quiz was Inserted (not saved from the preview modal)
            // and then later saved via the main "Save Set" button.
            let meta = undefined;
            try{
                const hints = window.__aiMcqSourceHints;
                if(hints && typeof hints === 'object'){
                    const keys = Object.keys(hints);
                    if(keys.length){
                        // Clone so future mutations to the global hints do not alter the saved record.
                        const cloned = JSON.parse(JSON.stringify(hints));
                        meta = { sourceHints: cloned };
                    }
                }
            }catch(e){ meta = undefined; }

            // Fallback: if refs aren't in-memory (e.g., after reload), try the draft refs store.
            if(!meta){
                try{
                    const draft = window.__mcqRefsDraftGet ? window.__mcqRefsDraftGet(txt) : null;
                    if(draft && typeof draft === 'object' && Object.keys(draft).length){
                        const cloned = JSON.parse(JSON.stringify(draft));
                        meta = { sourceHints: cloned };
                    }
                }catch(e){}
            }

            arr.unshift({ id: Date.now().toString(36), date: now(), title: shortTitle(txt), text: txt, meta });
            saveAll(arr); render();

            // Once saved, delete any draft refs for this exact content.
            try{ if(window.__mcqRefsDraftDel) window.__mcqRefsDraftDel(txt); }catch(e){}

            indexBtn.classList.add('saved'); indexBtn.textContent = 'Saved';
            setTimeout(()=>{ indexBtn.classList.remove('saved'); indexBtn.textContent = 'Save Set'; }, 1800);
        });

        // Positioning + portal helpers
        const savedCard = byId('savedMcqs');
        let portalPlaceholder = null;
        function ensurePortaled(){
            if(!savedMenu) return;
            if(savedMenu.parentNode === document.body) return;
            try{
                portalPlaceholder = document.createComment('saved-menu-portal');
                savedMenu.parentNode.insertBefore(portalPlaceholder, savedMenu);
                document.body.appendChild(savedMenu);
            }catch{}
        }
        function restorePortal(){
            try{
                if(portalPlaceholder && portalPlaceholder.parentNode){
                    portalPlaceholder.parentNode.insertBefore(savedMenu, portalPlaceholder);
                    portalPlaceholder.remove();
                }else if(savedCard){
                    savedCard.appendChild(savedMenu);
                }
            }catch{}
        }
        function positionSavedMenu(){
            try{
                if(!savedMenu.classList.contains('open')) return;
                // Match the width and left edge of the parent card
                const parentEl = (byId('savedMcqs') || toggleBtn);
                const parentRect = parentEl.getBoundingClientRect();
                // Use the bottom of the parent card so the dropdown clearly separates from the card
                const margin = 12; // visible separation between card and dropdown
                const menuW = Math.ceil(parentRect.width);
                // Use viewport coordinates (parentRect is relative to the viewport) and place
                // the menu using fixed positioning so it escapes ancestor clipping/stacks.
                // Do NOT add scroll offsets here because position:fixed expects viewport coords.
                const top = Math.round(parentRect.bottom + margin);
                let left = Math.round(parentRect.left);
                const maxLeft = Math.max(0, window.innerWidth - menuW - 8);
                if(left > maxLeft) left = maxLeft;
                savedMenu.style.top = top + 'px';
                savedMenu.style.left = left + 'px';
                savedMenu.style.width = menuW + 'px';
            }catch{}
        }
        let onScrollOrResize = null;
        function bindReposition(){
            if(onScrollOrResize) return;
            onScrollOrResize = ()=> positionSavedMenu();
            // On scroll/resize, recompute absolute page coordinates
            window.addEventListener('scroll', onScrollOrResize, true);
            window.addEventListener('resize', onScrollOrResize);
        }
        function unbindReposition(){
            if(!onScrollOrResize) return;
            window.removeEventListener('scroll', onScrollOrResize, true);
            window.removeEventListener('resize', onScrollOrResize);
            onScrollOrResize = null;
        }

        toggleBtn && toggleBtn.addEventListener('click', ()=>{
            const opening = !savedMenu.classList.contains('open');
            if(opening){
                ensurePortaled();
                // Refresh the dropdown contents each time it is shown so it reflects latest saves/deletes
                try{ renderResults(); }catch(e){}
            }
            const open = savedMenu.classList.toggle('open');
            toggleBtn.textContent = open ? 'Hide' : 'Show';
            toggleBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
            if(open){ positionSavedMenu(); bindReposition(); }
            else { unbindReposition(); restorePortal(); }
        });
        // Close on outside click or Escape
        document.addEventListener('mousedown', (e)=>{
            try{
                if(!savedMenu.classList.contains('open')) return;
                if(e.target.closest('#savedMenu') || e.target.closest('#toggleSavedBtn')) return;
                savedMenu.classList.remove('open');
                toggleBtn.textContent = 'Show';
                toggleBtn.setAttribute('aria-expanded', 'false');
                unbindReposition();
                restorePortal();
            }catch{}
        });
        document.addEventListener('keydown', (e)=>{
            if(e.key === 'Escape' && savedMenu.classList.contains('open')){
                savedMenu.classList.remove('open');
                toggleBtn.textContent = 'Show';
                toggleBtn.setAttribute('aria-expanded', 'false');
                unbindReposition();
                restorePortal();
            }
        });
        refreshBtn && refreshBtn.addEventListener('click', render);
        clearBtn && clearBtn.addEventListener('click', ()=>{ if(confirm('Clear all saved sets?')){ saveAll([]); render(); } });

    // initial render
    render();
    // Expose a simple refresh function for other modules (e.g., AI preview save) so
    // they can refresh the saved MCQ list without relying on a DOM button that
    // may not exist in some builds.
    try{ window.refreshLocalSaved = render; }catch(e){}

        // Bulk export for localStorage saved MCQs (zips each saved item into .txt files)
        async function exportAllLocalSaved(){ try{
            const btn = document.getElementById('exportAllSavedBtn'); if(btn){ btn.disabled = true; const old = btn.textContent; btn.textContent = 'Preparing…'; }
            const items = loadAll(); if(!items || !items.length){ alert('No saved sets to export.'); if(btn){ btn.disabled=false; btn.textContent = 'Export all'; } return; }
            // ensure JSZip
            await loadJSZip(); const zip = new window.JSZip();
            for(let i=0;i<items.length;i++){
                try{
                    const it = items[i]; const title = it.title || (`saved-${i+1}`);
                    const fname = sanitizeFilenameLocal(title) + '.txt';
                    const content = String(it.text || it.payload || '');
                    zip.file(fname, content);
                }catch(e){ console.warn('skipping item during zip', e); }
            }
            const blob = await zip.generateAsync({ type: 'blob' });
            const zipName = `saved-sets-${(new Date()).toISOString().replace(/[:.]/g,'-')}.zip`;
            const a = document.createElement('a'); const url = URL.createObjectURL(blob); a.href = url; a.download = zipName; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); try{ a.remove(); }catch{} }, 5000);
            if(btn){ btn.disabled=false; btn.textContent = 'Export all'; }
        }catch(e){ console.error('exportAllLocalSaved failed', e); alert('Export all failed: ' + (e?.message||e)); try{ const b = document.getElementById('exportAllSavedBtn'); if(b){ b.disabled=false; b.textContent='Export all'; } }catch{} }
        }
        // Expose and ensure binding: attach a delegated click handler so the button works
        try{
            window.exportAllLocalSaved = exportAllLocalSaved;
            if(!window.__exportAllSavedDelegatedBound){
                document.addEventListener('click', function(e){
                    try{
                        const t = e.target && e.target.closest ? e.target.closest('#exportAllSavedBtn') : null;
                        if(!t) return;
                        e.preventDefault(); if(t.disabled) return; window.exportAllLocalSaved && window.exportAllLocalSaved();
                    }catch(err){}
                });
                window.__exportAllSavedDelegatedBound = true;
            }
        }catch(e){}
    })();
    /* === end Saved MCQs === */
    </script>
    <script>
    /* === Saved Quiz Results: storage + UI wiring === */
    (function(){
        const LS_KEY_RESULTS = 'quiz.results.v1';
        const LS_KEY_LAST = 'quiz.lastAttempt.v1';
        const byId = (id)=> document.getElementById(id);
        const savedList = byId('savedQuizList');
        const savedCount = byId('savedQuizCount');
        const savedMenu = byId('savedQuizMenu');
        const toggleBtn = byId('toggleSavedQuizBtn');
        const clearBtn = byId('clearSavedQuizBtn');
        const compileBtn = byId('compileMissedBtn');

        function loadAllResults(){ try{ return JSON.parse(localStorage.getItem(LS_KEY_RESULTS)||'[]'); }catch{ return []; } }
        function saveAllResults(arr){ try{ localStorage.setItem(LS_KEY_RESULTS, JSON.stringify(arr)); }catch(e){ alert('Could not save results to local storage.'); } }
        function now(){ const d=new Date(); return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`; }
        
        // Helper: persist a snapshot as the "last attempted" quiz
        function setLastAttemptFromState(customTitle){
            try{
                const state = window.__quizState;
                if(!state || !state.items || !state.items.length) return;
                const d = now();
                const title = customTitle || `Last attempt`;
                const skippedArr = Array.from(state.skipped || []);
                const qCount = Array.isArray(state.items) ? state.items.length : 0;
                // attempts/time formatting mirrors saved results subtext
                let attemptsCount = 1;
                let durationMs = 0;
                if (state.attempts && Array.isArray(state.attempts) && state.attempts.length > 0) {
                    attemptsCount = state.attempts.length;
                    durationMs = state.attempts.reduce((acc, att) => acc + (att.durationMs || 0), 0);
                } else if (state.quizEndTime && state.quizStartTime) {
                    durationMs = state.quizEndTime - state.quizStartTime;
                }
                const seconds = Math.floor(durationMs / 1000);
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                const timeStr = `${m}:${s.toString().padStart(2, '0')}`;
                // Use safe separators without NUL characters for portability
                const meta = `${d} • #Q: ${qCount} • Attempts: ${attemptsCount} • Time: ${timeStr}`;
                const snap = {
                    id: Date.now().toString(36),
                    title,
                    date: d,
                    meta,
                    state: {
                        items: state.items,
                        score: state.score,
                        answered: state.answered,
                        skipped: skippedArr,
                        quizStartTime: state.quizStartTime,
                        quizEndTime: state.quizEndTime,
                        attempts: state.attempts,
                        currentAttempt: state.currentAttempt,
                        mode: state.mode
                    }
                };
                localStorage.setItem(LS_KEY_LAST, JSON.stringify(snap));
                // Refresh UI label if panel already rendered
                try{ renderResults(); }catch(e){}
            }catch(e){ console.error('setLastAttemptFromState failed', e); }
        }
        window.__setLastAttemptFromState = setLastAttemptFromState;

        // Expose save function globally
        window.saveQuizResult = function(){
            const state = window.__quizState;
            if(!state || !state.items || !state.items.length) return;
            const title = prompt('Enter a name for this result:', `Result ${now()}`);
            if(!title) return;
            
            // Serialize Set to Array for storage
            const skippedArr = Array.from(state.skipped || []);
            
            const result = {
                id: Date.now().toString(36),
                title: title,
                date: now(),
                state: {
                    items: state.items,
                    score: state.score,
                    answered: state.answered,
                    skipped: skippedArr,
                    quizStartTime: state.quizStartTime,
                    quizEndTime: state.quizEndTime,
                    attempts: state.attempts,
                    currentAttempt: state.currentAttempt,
                    mode: state.mode
                }
            };
            
            const arr = loadAllResults();
            arr.unshift(result);
            saveAllResults(arr);

            // also remember this as the last attempted quiz specs (using same snapshot shape)
            try{ localStorage.setItem(LS_KEY_LAST, JSON.stringify(result)); }catch(e){}
            renderResults();
            
            const btn = byId('saveResultBtn');
            if(btn){
                const oldText = btn.textContent;
                btn.textContent = 'Saved!';
                btn.disabled = true;
                setTimeout(()=>{ btn.textContent = oldText; btn.disabled = false; }, 2000);
            }
        };

        function loadResult(id){
            const arr = loadAllResults();
            const res = arr.find(r => r.id === id);
            if(!res) return;
            
            if(!confirm('Load this saved result? Current progress will be lost.')) return;
            
            const state = window.__quizState;
            if(!state) return;

            // Restore state
            state.items = res.state.items;
            state.score = res.state.score;
            state.answered = res.state.answered;
            state.skipped = new Set(res.state.skipped);
            state.quizStartTime = res.state.quizStartTime;
            state.quizEndTime = res.state.quizEndTime;
            state.attempts = res.state.attempts;
            state.currentAttempt = res.state.currentAttempt;
            state.mode = res.state.mode;
            state.started = true;
            // Mark context: this session originated from loading a saved result; suppress focus-mode re-enables
            try{ state._loadedFromSaved = true; }catch(e){}
            
            // Switch UI
            const setup = byId('setup');
            const quiz = byId('quiz');
            const preview = byId('preview');
            
            if(setup) setup.classList.add('hidden');
            if(preview) preview.classList.add('hidden');
            if(quiz) quiz.classList.remove('hidden');
            try{ document.body.classList.add('quiz-running'); }catch{}
            // Suppress any automatic focus-mode enable behavior while viewing a saved result summary
            try{ window.__suppressFocus = true; }catch(e){}

            // Hide the Content Library while viewing a saved result (match quiz view behavior)
            try{ document.getElementById('textbook-lib')?.classList.add('hidden'); }catch{}
            // Show the reset/Return to Main Menu bar like normal quiz sessions
            try{ const rb = document.getElementById('resetBar'); if(rb) rb.style.display = 'block'; }catch{}
            
            // Force focus mode OFF for saved-result viewing without changing user preference
            try{ document.body.classList.remove('focus-mode-active'); }catch(e){}
            // Show summary
            // Persist a "lastRevisited" timestamp for this saved result so users can track when they last loaded it
            try{
                const all = loadAllResults();
                const idx = all.findIndex(r => r.id === id);
                if(idx !== -1){ all[idx].lastRevisited = now(); saveAllResults(all); }
            }catch(e){}
            if(window.showSummary) window.showSummary();
            
            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function renderResults(){
            if(!savedList || !savedCount) return;
            const arr = loadAllResults();

            // compute per-entry sizes (UTF-8 bytes) and total size
            let totalBytes = 0;

            if(!arr.length){ savedList.innerHTML = '<div class="hint">No saved results yet. Finish a quiz to save results.</div>'; try{ const countEl = document.getElementById('savedQuizCount') || document.getElementById('savedCount'); const totalEl = document.getElementById('savedQuizTotal') || document.getElementById('savedQuizTotalAlt'); if(countEl) countEl.textContent = String(arr.length); if(totalEl) totalEl.textContent = 'Total: 0.0 KB'; }catch(e){} return; }

            // Build list with titles being editable elements (but not editable until activated)
            savedList.innerHTML = arr.map((it, i)=>{
                const rawTitle = it.title || 'Untitled';
                const safeTitle = String(rawTitle).replace(/&/g,'&amp;').replace(/</g,'&lt;');
                const date = it.date || '';

                // Calculate question count, attempts and time
                const qCount = (it.state && Array.isArray(it.state.items)) ? it.state.items.length : 0;
                // Calculate attempts and time
                let attemptsCount = 1;
                let durationMs = 0;

                if (it.state.attempts && Array.isArray(it.state.attempts) && it.state.attempts.length > 0) {
                    attemptsCount = it.state.attempts.length;
                    durationMs = it.state.attempts.reduce((acc, att) => acc + (att.durationMs || 0), 0);
                } else if (it.state.quizEndTime && it.state.quizStartTime) {
                    durationMs = it.state.quizEndTime - it.state.quizStartTime;
                }

                const seconds = Math.floor(durationMs / 1000);
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                const timeStr = `${m}:${s.toString().padStart(2, '0')}`;

                // Compute size of this saved entry (bytes of its JSON representation)
                let sizeBytes = 0;
                try{
                    const serial = JSON.stringify(it);
                    if(typeof TextEncoder !== 'undefined'){
                        sizeBytes = new TextEncoder().encode(serial).length;
                    } else {
                        // fallback for very old environments
                        sizeBytes = unescape(encodeURIComponent(serial)).length;
                    }
                }catch(e){ sizeBytes = 0; }
                totalBytes += (sizeBytes || 0);
                const sizeText = sizeBytes ? ` • ${(sizeBytes/1024).toFixed(1)} KB` : '';

                // Show optional lastRevisited timestamp next to the title when available
                const lastRev = it.lastRevisited ? String(it.lastRevisited) : '';
                const lastRevHtml = lastRev ? ` <span class="muted si-lastrev">• Last Revisited: ${lastRev}</span>` : '';

                return `<div class="saved-item" data-id="${it.id}">
                    <div class="si-main">
                        <div class="si-title"><span class="si-title-text" role="textbox" tabindex="0" data-id="${it.id}" title="Click to edit">${safeTitle}</span>${lastRevHtml}</div>
                        <div class="si-meta">${date} • #Q: ${qCount} • Attempts: ${attemptsCount} • Time: ${timeStr}${sizeText}</div>
                    </div>
                    <div class="si-actions">
                        <button class="btn small" data-act="delete">Delete</button>
                    </div>
                </div>`;
            }).join('');

            // Attach click handlers to each item (for load/delete) but keep title clicks separate
            savedList.querySelectorAll('.saved-item').forEach(el=>{
                el.addEventListener('click', (e)=>{
                    const id = el.getAttribute('data-id');
                    const btn = (e.target && e.target.closest) ? e.target.closest('[data-act]') : null;

                    // If user clicked the title text, start edit instead of loading
                    if(e.target && e.target.classList && e.target.classList.contains('si-title-text')){
                        e.stopPropagation();
                        startEditTitle(e.target);
                        return;
                    }

                    if(btn){
                        const act = btn.getAttribute('data-act');
                        if(act==='delete'){
                            if(confirm('Delete this saved result?')){
                                const arr2 = loadAllResults().filter(r => r.id !== id);
                                saveAllResults(arr2);
                                renderResults();
                            }
                        }
                    } else {
                        loadResult(id);
                    }
                });
            });

            // Helper: begin editing a title using contentEditable so appearance stays the same
            function startEditTitle(titleEl){
                try{
                    const id = titleEl.getAttribute('data-id');
                    const arrNow = loadAllResults();
                    const item = arrNow.find(x => x.id === id);
                    if(!item) return;

                    const raw = item.title || 'Untitled';

                    // If already editing, focus
                    if(titleEl.getAttribute('contenteditable') === 'true'){
                        titleEl.focus();
                        return;
                    }

                    // Store original text so Escape can restore it
                    titleEl.dataset.orig = raw;

                    // Make editable without changing visual styles
                    titleEl.setAttribute('contenteditable', 'true');
                    titleEl.classList.add('editing');
                    titleEl.focus();

                    // Place caret at end
                    const range = document.createRange();
                    range.selectNodeContents(titleEl);
                    range.collapse(false);
                    const sel = window.getSelection();
                    sel.removeAllRanges();
                    sel.addRange(range);

                    function commit(){
                        // Trim and default
                        const newVal = (titleEl.textContent||'').trim() || 'Untitled';
                        // Update storage
                        const arr2 = loadAllResults();
                        const idx = arr2.findIndex(x => x.id === id);
                        if(idx !== -1){ arr2[idx].title = newVal; saveAllResults(arr2); }
                        // Clean up
                        titleEl.textContent = newVal;
                        titleEl.removeAttribute('contenteditable');
                        titleEl.classList.remove('editing');
                        delete titleEl.dataset.orig;
                    }

                    function cancel(){
                        const orig = titleEl.dataset.orig || raw;
                        titleEl.textContent = orig;
                        titleEl.removeAttribute('contenteditable');
                        titleEl.classList.remove('editing');
                        delete titleEl.dataset.orig;
                    }

                    // Handle Enter (commit) and Escape (cancel). Prevent Enter inserting newline.
                    const keyHandler = (ev)=>{
                        if(ev.key === 'Enter'){
                            ev.preventDefault();
                            commit();
                            titleEl.removeEventListener('keydown', keyHandler);
                        } else if(ev.key === 'Escape'){
                            ev.preventDefault();
                            cancel();
                            titleEl.removeEventListener('keydown', keyHandler);
                        }
                    };

                    titleEl.addEventListener('keydown', keyHandler);
                    // Commit on blur
                    const blurHandler = ()=>{ commit(); titleEl.removeEventListener('blur', blurHandler); };
                    titleEl.addEventListener('blur', blurHandler);
                }catch(e){ console.error(e); }
            }

            // Update header: set numeric count and a separate total-KB label (query at write time to avoid stale/cached nodes)
            try{
                const countEl = document.getElementById('savedQuizCount') || document.getElementById('savedCount');
                const totalEl = document.getElementById('savedQuizTotal') || document.getElementById('savedQuizTotalAlt');
                if(countEl) countEl.textContent = String(arr.length);
                if(totalEl) totalEl.textContent = `Total: ${(totalBytes/1024).toFixed(1)} KB`;
            }catch(e){}

            // Enable/disable Compile Missed button based on presence of any first-attempt misses
            try{
                if(compileBtn){
                    let hasMissed = false;
                    for(const r of arr){
                        const atts = r?.state?.attempts;
                        if(Array.isArray(atts) && atts[0] && Array.isArray(atts[0].missed) && atts[0].missed.length){ hasMissed = true; break; }
                    }
                    compileBtn.disabled = !hasMissed;
                }
            }catch(e){ console.warn('compile button state error', e); }

            // hydrate "Last Attempted Quiz" block from LS_KEY_LAST
            try{
                const raw = localStorage.getItem(LS_KEY_LAST);
                const labelEl = document.getElementById('lastAttemptLabel');
                const copyBtn = document.getElementById('lastAttemptCopyBtn');
                const saveBtn = document.getElementById('lastAttemptSaveBtn');
                const openBtn = document.getElementById('lastAttemptOpenBtn');
                if(!labelEl || !copyBtn || !saveBtn || !openBtn) return;
                if(!raw){
                    labelEl.textContent = 'None yet';
                    copyBtn.disabled = true; saveBtn.disabled = true; openBtn.disabled = true;
                } else {
                    const obj = JSON.parse(raw);
                    const tTitle = obj.title || 'Last attempt';
                    let meta = obj.meta || '';
                    // If stored meta contains nulls or artifact markers, rebuild from state
                    try{
                        const hasNull = /\u0000/.test(meta) || meta.indexOf('b7') !== -1;
                        if(!meta || hasNull){
                            const st = obj.state || {};
                            const qCount = Array.isArray(st.items) ? st.items.length : 0;
                            let attemptsCount = 1;
                            let durationMs = 0;
                            if (st.attempts && Array.isArray(st.attempts) && st.attempts.length > 0) {
                                attemptsCount = st.attempts.length;
                                durationMs = st.attempts.reduce((acc, att) => acc + (att.durationMs || 0), 0);
                            } else if (st.quizEndTime && st.quizStartTime) {
                                durationMs = st.quizEndTime - st.quizStartTime;
                            }
                            const seconds = Math.floor(durationMs / 1000);
                            const m = Math.floor(seconds / 60);
                            const s = seconds % 60;
                            const timeStr = `${m}:${s.toString().padStart(2, '0')}`;
                            const dStr = obj.date || now();
                            meta = `${dStr} • #Q: ${qCount} • Attempts: ${attemptsCount} • Time: ${timeStr}`;
                        }
                    }catch(e){ meta = obj.meta || ''; }
                    labelEl.textContent = meta ? `${tTitle}  ${meta}` : tTitle;
                    copyBtn.disabled = false; saveBtn.disabled = false; openBtn.disabled = false;
                }
            }catch(e){}
        }

        // Positioning + portal helpers (reused logic pattern)
        const savedCard = byId('savedQuizzes');
        let portalPlaceholder = null;
        function ensurePortaled(){
            if(!savedMenu) return;
            if(savedMenu.parentNode === document.body) return;
            try{
                portalPlaceholder = document.createComment('saved-quiz-menu-portal');
                savedMenu.parentNode.insertBefore(portalPlaceholder, savedMenu);
                document.body.appendChild(savedMenu);
            }catch{}
        }
        function restorePortal(){
            try{
                if(portalPlaceholder && portalPlaceholder.parentNode){
                    portalPlaceholder.parentNode.insertBefore(savedMenu, portalPlaceholder);
                    portalPlaceholder.remove();
                }else if(savedCard){
                    savedCard.appendChild(savedMenu);
                }
            }catch{}
        }
        function positionSavedMenu(){
            try{
                if(!savedMenu.classList.contains('open')) return;
                const parentEl = (byId('savedQuizzes') || toggleBtn);
                const parentRect = parentEl.getBoundingClientRect();
                const margin = 12;
                const menuW = Math.ceil(parentRect.width);
                const top = Math.round(parentRect.bottom + margin);
                let left = Math.round(parentRect.left);
                const maxLeft = Math.max(0, window.innerWidth - menuW - 8);
                if(left > maxLeft) left = maxLeft;
                savedMenu.style.top = top + 'px';
                savedMenu.style.left = left + 'px';
                savedMenu.style.width = menuW + 'px';
            }catch{}
        }
        let onScrollOrResize = null;
        function bindReposition(){
            if(onScrollOrResize) return;
            onScrollOrResize = ()=> positionSavedMenu();
            window.addEventListener('scroll', onScrollOrResize, true);
            window.addEventListener('resize', onScrollOrResize);
        }
        function unbindReposition(){
            if(!onScrollOrResize) return;
            window.removeEventListener('scroll', onScrollOrResize, true);
            window.removeEventListener('resize', onScrollOrResize);
            onScrollOrResize = null;
        }

        toggleBtn && toggleBtn.addEventListener('click', ()=>{
            const opening = !savedMenu.classList.contains('open');
            if(opening){ ensurePortaled(); }
            const open = savedMenu.classList.toggle('open');
            toggleBtn.textContent = open ? 'Hide' : 'Show';
            toggleBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
            if(open){ positionSavedMenu(); bindReposition(); }
            else { unbindReposition(); restorePortal(); }
        });
        
        // Close on outside click or Escape
        document.addEventListener('mousedown', (e)=>{
            try{
                if(!savedMenu.classList.contains('open')) return;
                if(e.target.closest('#savedQuizMenu') || e.target.closest('#toggleSavedQuizBtn')) return;
                savedMenu.classList.remove('open');
                toggleBtn.textContent = 'Show';
                toggleBtn.setAttribute('aria-expanded', 'false');
                unbindReposition();
                restorePortal();
            }catch{}
        });
        document.addEventListener('keydown', (e)=>{
            if(e.key === 'Escape' && savedMenu.classList.contains('open')){
                savedMenu.classList.remove('open');
                toggleBtn.textContent = 'Show';
                toggleBtn.setAttribute('aria-expanded', 'false');
                unbindReposition();
                restorePortal();
            }
        });
        
        clearBtn && clearBtn.addEventListener('click', ()=>{ if(confirm('Clear all saved quiz results?')){ saveAllResults([]); renderResults(); } });

        // Compile all first-attempt missed questions into a new aggregated quiz
        function compileAllFirstAttemptMissed(){
            try{
                const results = loadAllResults();
                const aggregated = [];
                const sourceHints = {};
                let seq = 1;
                for(const r of results){
                    const title = r?.title || 'Untitled Result';
                    const atts = r?.state?.attempts;
                    if(!Array.isArray(atts) || !atts.length) continue;
                    const first = atts[0];
                    if(!first || !Array.isArray(first.missed) || !first.missed.length) continue;
                    for(const m of first.missed){
                        // m has q, choices, correctIdx
                        const qText = (m?.q||'').replace(/\r?\n+/g,' ').trim();
                        const choices = Array.isArray(m?.choices)? m.choices.slice(): [];
                        aggregated.push({ num: seq, q: qText, choices, correctIdx: (typeof m.correctIdx === 'number'? m.correctIdx : null), __src: title });
                        // Build a source hint attributing original quiz result and attempt
                        sourceHints[String(seq)] = `Missed • ${title} • attempt 1`;
                        seq++;
                    }
                }
                if(!aggregated.length){ alert('No first-attempt missed questions found across saved results.'); return; }
                // Build MCQ text
                const letters = ['A','B','C','D','E','F','G'];
                const lines = [];
                for(const it of aggregated){
                    lines.push(`Q${it.num}. ${it.q}`);
                    it.choices.forEach(c=>{ lines.push(`- ${c}`); });
                    lines.push('');
                }
                // Answer key
                lines.push('ANSWER KEY');
                for(const it of aggregated){
                    const letter = (typeof it.correctIdx === 'number' && it.correctIdx>=0 && letters[it.correctIdx]) ? letters[it.correctIdx] : 'A';
                    lines.push(`${it.num}. ${letter}`);
                }
                const finalText = lines.join('\n');
                // Push into paste area and assign source hints for parsing
                try{
                    window.__aiMcqSourceHints = sourceHints; // attach attribution
                }catch(e){ console.warn('could not set source hints', e); }
                const paste = document.getElementById('paste');
                if(paste){ paste.value = finalText; }
                // auto-parse
                try{ document.getElementById('parseBtn')?.click(); }catch(e){ console.warn('auto-parse failed', e); }
                // Scroll to setup for visibility
                try{ const setupEl = document.getElementById('setup'); if(setupEl) window.scrollTo({ top: setupEl.offsetTop, behavior:'smooth' }); }catch(e){}
            }catch(e){ console.error('compile missed failed', e); alert('Compile missed failed: ' + (e?.message||e)); }
        }
        compileBtn && compileBtn.addEventListener('click', compileAllFirstAttemptMissed);

        // Last Attempted Quiz buttons
        const copyLastBtn = byId('lastAttemptCopyBtn');
        const saveLastBtn = byId('lastAttemptSaveBtn');
        const openLastBtn = byId('lastAttemptOpenBtn');

        copyLastBtn && copyLastBtn.addEventListener('click', ()=>{
            try{
                const raw = localStorage.getItem(LS_KEY_LAST);
                if(!raw) return;
                const obj = JSON.parse(raw);
                const text = JSON.stringify(obj.state || {}, null, 2);
                navigator.clipboard && navigator.clipboard.writeText(text).catch(()=>{});
            }catch(e){ console.error('copy last attempt failed', e); }
        });

        saveLastBtn && saveLastBtn.addEventListener('click', ()=>{
            try{
                const raw = localStorage.getItem(LS_KEY_LAST);
                if(!raw) return;
                const obj = JSON.parse(raw);
                const arr = loadAllResults();
                // avoid duplicate id; re-use stored snapshot but new id
                const clone = {
                    id: Date.now().toString(36),
                    title: obj.title || 'Last Attempt',
                    date: obj.date || now(),
                    state: obj.state
                };
                arr.unshift(clone);
                saveAllResults(arr);
                renderResults();
            }catch(e){ console.error('save last attempt failed', e); }
        });

        openLastBtn && openLastBtn.addEventListener('click', ()=>{
            try{
                const raw = localStorage.getItem(LS_KEY_LAST);
                if(!raw) return;
                const obj = JSON.parse(raw);
                if(!obj || !obj.state) return;

                const state = window.__quizState;
                if(!state) return;

                // Restore state snapshot
                state.items = obj.state.items || [];
                state.score = obj.state.score || 0;
                state.answered = obj.state.answered || 0;
                state.skipped = new Set(obj.state.skipped || []);
                state.quizStartTime = obj.state.quizStartTime || Date.now();
                state.quizEndTime = obj.state.quizEndTime || Date.now();
                state.attempts = obj.state.attempts || [];
                state.currentAttempt = obj.state.currentAttempt || null;
                state.mode = obj.state.mode || state.mode;
                state.started = true;
                try{ state._loadedFromSaved = true; }catch(e){}

                // Switch into quiz/results view
                const setup = byId('setup');
                const quiz = byId('quiz');
                const preview = byId('preview');
                if(setup) setup.classList.add('hidden');
                if(preview) preview.classList.add('hidden');
                if(quiz) quiz.classList.remove('hidden');
                try{ document.body.classList.add('quiz-running'); }catch{}
                try{ document.getElementById('textbook-lib')?.classList.add('hidden'); }catch{}
                try{ const rb = document.getElementById('resetBar'); if(rb) rb.style.display = 'block'; }catch{}
                try{ document.body.classList.remove('focus-mode-active'); }catch{}

                if(window.showSummary) window.showSummary();
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }catch(e){ console.error('open last attempt failed', e); }
        });

        // Initial render
        renderResults();
    })();
    </script>
    <script>
    // AI: Reformat & Assign Answers — writes results back to #paste
    (function(){
        const $ = (id)=>document.getElementById(id);
        const btn = $('aiFixBtn'); const stat = $('aiFixStatus'); const paste = $('paste');
        function setStatus(msg){ if(stat) stat.textContent = msg || ''; }
        function isEnabled(){ return !!document.getElementById('globalGemEnable')?.checked; }
        function keyVal(){ return (document.getElementById('globalGemKey')?.value||'').trim(); }
        // Mirror global key state into this panel's badge/button
        function sync(){ try{
            const ok = !!keyVal() && isEnabled();
            const badge = document.getElementById('fixKeyBadge');
            if(badge){ badge.classList.toggle('ok', ok); badge.classList.toggle('missing', !ok); const h=badge.querySelector('.hint'); if(h) h.textContent = ok ? 'Key set' : 'No key set'; }
            if(btn) btn.disabled = !ok;
        }catch{} }
        document.getElementById('globalGemKey')?.addEventListener('input', sync);
        document.getElementById('globalGemEnable')?.addEventListener('change', sync);
        sync();

        async function reformatWithAI(raw){
            const key = keyVal(); if(!key || !isEnabled()) throw new Error('API key disabled or missing.');
            if(!window.GoogleGenerativeAI){ try{ const mod = await import('https://esm.run/@google/generative-ai'); window.GoogleGenerativeAI = mod.GoogleGenerativeAI; }catch(e){ throw new Error('Could not load Gemini SDK.'); } }
            const client = new window.GoogleGenerativeAI(key);
            const model = client.getGenerativeModel({ model: 'gemini-2.5-flash' });
            const prompt = `You are a strict formatter for multiple-choice question sets.
Input may be messy, partial, or missing an ANSWER KEY. Your job:
1) Ensure every question starts with "Qn." where n is a sequential integer starting at 1.
2) Each option must be on its own line, prefixed with a hyphen and a space ("- "). Keep 4 options when possible; if more/less exist, keep what's present.
3) Ensure there is a final block titled exactly "ANSWER KEY" followed by lines "n. X" where X is the correct letter.
4) If an answer is not provided in the input for any question, infer a SINGLE best answer from the options and include it in the ANSWER KEY.
5) Do NOT add explanations or extra commentary. Output ONLY the cleaned MCQ set in the target format.

 IMPORTANT: Preserve all Unicode characters exactly, including Greek letters and symbols (e.g., α β γ δ ε θ μ π σ φ Ω). Do not transliterate to Latin or replace with names. If an input character cannot be determined, leave it unchanged rather than substituting placeholder glyphs.

Target format example:
Q1. Example question text?
- Option one
- Option two
- Option three
- Option four
Q2. ...
...
ANSWER KEY
1. B
2. D
...

Now reformat the following exactly into that target format:
-----
${raw}
-----`;
            const resp = await model.generateContent({ contents: [{ role:'user', parts:[{ text: prompt }] }] });
            const text = resp?.response?.text?.() || resp?.response?.candidates?.[0]?.content?.parts?.map(p=>p.text||'').join('') || '';
            if(!text.trim()) throw new Error('Empty response from model.');
            return text.trim();
        }

        btn && btn.addEventListener('click', async ()=>{
            const origLabel = btn ? btn.innerHTML : '';
            try{
                const src = (paste?.value||'').trim(); if(!src){ alert('Paste your MCQs first.'); return; }
                setStatus('Contacting Gemini 2.5…');
                if(btn){ try{ btn.disabled = true; btn.innerHTML = '<span class="spinner" aria-hidden="true"></span> Contacting…'; btn.setAttribute('aria-busy','true'); }catch(e){} }
                const out = await reformatWithAI(src);
                paste.value = normalizeGreek(out); setStatus('Reformatted. Re-parsing…');
                document.getElementById('parseBtn')?.click();
                setTimeout(()=> setStatus(''), 1200);
            }catch(err){ console.warn('AI fix failed', err); setStatus('AI error: ' + (err?.message||err)); alert('AI error: ' + (err?.message||err)); }
            finally{ try{ if(btn){ btn.disabled = false; btn.innerHTML = origLabel; btn.removeAttribute('aria-busy'); } }catch(e){} }
        });
    })();
    </script>
        <script>
    // Make any "Back to Setup" button return to setup WITHOUT reloading (preserves radio playback)
    (function(){
        const $ = (id)=>document.getElementById(id);
        function goToSetupPreserveAudio(){
            try{
                const setup = $('setup'); const preview = $('preview'); const quiz = $('quiz');
                if(setup) setup.classList.remove('hidden');
                if(preview) preview.classList.add('hidden');
                const resetBar = $('resetBar'); if(resetBar) resetBar.style.display = 'none';
                // Hide and reset Results + Analyze sections
                try{
                    const results = document.getElementById('results-card');
                    if(results){
                        results.classList.add('hidden');
                        const sum = document.getElementById('resultsSummary'); if(sum) sum.innerHTML = '';
                        const stat = document.getElementById('resultsAiStatus'); if(stat) stat.textContent = '';
                            try{ if(typeof window.stopAiOutput === 'function'){ window.stopAiOutput(); } else { const out = document.getElementById('resultsAiOutput'); if(out) out.textContent = ''; } }catch{}
                        const sel = document.getElementById('attemptSelect'); if(sel) sel.innerHTML = '';
                        const miss = document.getElementById('attemptMissedList'); if(miss) miss.innerHTML = '';
                    }
                    // Clear attempt tracking
                    try{ state.attempts = []; state.currentAttempt = null; }catch{}
                }catch{}
                // Ensure AI panels (Validate and Like Questions) reappear on Setup
        // Auto mode UI is managed by initAiFileGenNew(); do not rebind here.
                try{ document.getElementById('ai-likeq')?.classList.remove('hidden'); }catch{}
                try{ document.getElementById('ai-likeq-copy')?.classList.remove('hidden'); }catch{}
                try{ document.querySelector('.ai-file-panel')?.classList.remove('hidden'); }catch{}
                // Mark as not parsed so init code won't auto-hide these until the next parse
                try{ window.__parsed = false; }catch{}
                // Ensure the textbook library is visible and refreshed when returning to setup
                try{ document.getElementById('textbook-lib')?.classList.remove('hidden'); }catch{}
                try{ if(window.refreshTextbookLibrary) window.refreshTextbookLibrary(); }catch{}
                // Do not touch the radio/audio state; just navigate views.
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }catch(e){ console.warn('Back to setup (no-reload) failed', e); }
        }
        document.addEventListener('click', function (e) {
            const btn = e.target.closest('#backSetup');
            if (!btn) return;
            e.preventDefault();
            // Avoid bubbling to any legacy handlers that might reload
            e.stopPropagation();
            goToSetupPreserveAudio();
        });
    })();
    </script>
    <script id="embedded-dev-tools">
    // Embedded temp_check.js (migrated from external file)
    (function(){
        const OUT_ID = 'resultsAiOutput';
        function ensureWrapper(){
            const existing = document.getElementById('aiTextbookOutput');
            if(existing) return existing;
            const out = document.getElementById(OUT_ID);
            if(!out) return null;
            if(out.dataset && out.dataset.textbook === '1') return out;
        const outEl = out;
        outEl.classList.add('aiTextbookOutput');
        const page = document.createElement('div'); page.className='page'; page.setAttribute('role','status'); page.setAttribute('aria-live','polite');
        page.style.flex = '1 1 auto'; page.style.minHeight = '0'; page.style.overflow = 'auto';
        const faceRow = document.createElement('div'); faceRow.className='ascii-face';
        const faceInner = document.createElement('div'); faceInner.className = 'face-inner';
        const faceBox = document.createElement('div'); faceBox.className='face'; faceBox.style.fontFamily='monospace'; faceBox.style.fontSize='20px';
        faceBox.innerHTML = "<span class='eyes'>(<span class='eye left'><span class='lash'>&quot;&quot;</span><span class='dot'>•</span></span><span class='mouth'></span><span class='eye right'><span class='lash'>&quot;&quot;</span><span class='dot'>•</span></span>)</span>";
        const mouthSpan = faceBox.querySelector('.mouth');
        mouthSpan.textContent = '___';
        faceInner.appendChild(faceBox);
        faceRow.appendChild(faceInner);
        try{
            const LASH_KEY = 'ai.face.lashed';
            const saved = localStorage.getItem(LASH_KEY) === '1';
            if(saved) faceBox.classList.add('lashed');
            faceBox.setAttribute('role','button'); faceBox.setAttribute('tabindex','0'); faceBox.title = 'Toggle lashes';
            function setLash(on){ try{ faceBox.classList.toggle('lashed', !!on); localStorage.setItem(LASH_KEY, on ? '1':'0'); faceBox.classList.add('lash-toggle'); setTimeout(()=>{ try{}catch(e){} }, 380); }catch(e){} }
            faceBox.addEventListener('click', ()=> setLash(!faceBox.classList.contains('lashed')));
            faceBox.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); setLash(!faceBox.classList.contains('lashed')); }});
        }catch(e){}
        const controls = document.createElement('div'); controls.className='controls';
            const stopBtn = document.createElement('button'); stopBtn.type='button'; stopBtn.className='btn small'; stopBtn.textContent='Stop'; stopBtn.title='Stop animated output';
            const audioToggle = document.createElement('button'); audioToggle.type='button'; audioToggle.className='btn small'; audioToggle.title='Toggle audio effects';
            const audioEnabled = (localStorage.getItem('ai.audio.enabled') === '1');
            audioToggle.textContent = audioEnabled ? 'Audio: On' : 'Audio: Off';
            audioToggle.dataset.enabled = audioEnabled ? '1' : '0';
            controls.appendChild(stopBtn); controls.appendChild(audioToggle);
        try{ controls.style.display = 'none'; }catch(e){}
        try{ outEl.style.display = 'flex'; outEl.style.flexDirection = 'column'; outEl.style.gap = '8px'; outEl.style.height = outEl.style.height || '100%'; outEl.style.boxSizing = 'border-box'; }catch{}
        outEl.appendChild(page); outEl.appendChild(faceRow); outEl.appendChild(controls);
        outEl.dataset.textbook='1';
        outEl._page = page; outEl._faceBox = faceBox; outEl._mouthSpan = faceBox.querySelector('.mouth'); outEl._controls = controls; outEl._stopBtn = stopBtn; outEl._audioToggle = audioToggle;

        // Auto-scroll state: follow output while generating unless user scrolls up
        try{
            outEl._autoScrollPinned = true;
            outEl._autoScrollQueued = false;
            if(!page.dataset.aiAutoscroll){
                page.dataset.aiAutoscroll = '1';
                page.addEventListener('scroll', ()=>{
                    try{
                        const threshold = 48;
                        const nearBottom = (page.scrollTop + page.clientHeight) >= (page.scrollHeight - threshold);
                        outEl._autoScrollPinned = !!nearBottom;
                    }catch(e){}
                }, { passive: true });
            }
        }catch(e){}

        (function startEyeIdle(wrap){
            try{
                const out = wrap; if(!out) return;
                const faceBox = wrap._faceBox; if(!faceBox) return;
                const eyes = faceBox.querySelectorAll('.eye'); if(!eyes || !eyes.length) return;
                if(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

                let moveTimer = null, blinkTimer = null;
                function rand(min, max){ return min + Math.random()*(max-min); }

                function setEyeTranslate(e, x, y){ try{ e.style.setProperty('--ex', x + 'px'); e.style.setProperty('--ey', y + 'px'); }catch(e){} }

                function doMove(){ try{ if(out.classList.contains('ai-active')){} else {} }catch(e){} scheduleMove(); }
                function scheduleMove(){ moveTimer && clearTimeout(moveTimer); moveTimer = setTimeout(doMove, rand(700, 2200)); }

                function doBlink(){ try{ if(out.classList.contains('ai-active')){} eyes.forEach(e=> e.classList.add('blink')); setTimeout(()=>{}, 90 + Math.random()*80); }catch(e){} scheduleBlink(); }
                function scheduleBlink(){ blinkTimer && clearTimeout(blinkTimer); blinkTimer = setTimeout(doBlink, rand(2400, 7600)); }

                scheduleMove(); scheduleBlink();
                wrap._clearEyeIdle = function(){ try{ moveTimer && clearTimeout(moveTimer); blinkTimer && clearTimeout(blinkTimer); eyes.forEach(e=>{}); }catch(e){} };
            }catch(e){}
        })(outEl);

        let currentController = null;
        stopBtn.addEventListener('click', ()=>{ try{ if(currentController) currentController.abort(); }catch{} });
        audioToggle.addEventListener('click', ()=>{ try{ const en = audioToggle.dataset.enabled === '1' ? false : true; audioToggle.dataset.enabled = en ? '1' : '0'; audioToggle.textContent = en ? 'Audio: On' : 'Audio: Off'; localStorage.setItem('ai.audio.enabled', en ? '1' : '0'); }catch{} });

        try{ if(localStorage.getItem('ai.audio.enabled') === null){ localStorage.setItem('ai.audio.enabled', '1'); audioToggle.dataset.enabled = '1'; audioToggle.textContent = 'Audio: On'; } }catch(e){}

        let __aiAudioCtx = null; let __aiAudioAllowed = false;
        function ensureAiAudio(){ try{ if(__aiAudioCtx) return __aiAudioCtx; const C = window.AudioContext || window.webkitAudioContext; if(!C) return null; __aiAudioCtx = new C(); if(__aiAudioCtx.state === 'suspended' && typeof __aiAudioCtx.resume === 'function'){ __aiAudioCtx.resume().then(()=>{ __aiAudioAllowed = true; }).catch(()=>{ __aiAudioAllowed = false; }); } else { __aiAudioAllowed = true; } return __aiAudioCtx; }catch(e){ return null; } }

        function animateAudioBarsOnce(wrap, intensity){ try{ const bars = wrap._faceBox.querySelectorAll('.audio-bars .bar'); if(!bars || !bars.length) return; bars.forEach(b => { const h = 4 + Math.round((Math.random() * (intensity||8))); b.style.height = h + 'px'; }); }catch(e){} }

        outEl._setController = (c)=>{ currentController = c; };

        try{
                const descriptor = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent') || Object.getOwnPropertyDescriptor(Element.prototype, 'textContent');
                Object.defineProperty(outEl, 'textContent', {
                    configurable: true,
                    enumerable: false,
                    get: function(){ return page.textContent; },
                    set: function(v){ try{ if(!v){ if(window.stopAiOutput) page.textContent = ''; return; } if(window.showAiOutput) { window.showAiOutput(String(v)); } else { page.textContent = String(v); } }catch(e){ page.textContent = String(v); } }
                });
                Object.defineProperty(outEl, 'innerText', {
                    configurable: true,
                    enumerable: false,
                    get: function(){ return page.innerText; },
                    set: function(v){ try{ if(window.showAiOutput) window.showAiOutput(String(v)); else page.innerText = String(v); }catch(e){ page.innerText = String(v); } }
                });
            }catch(e){}

            return outEl;
        }

        function createNoiseEngine(){
            let ctx = null;
            try{ const AudioCtx = window.AudioContext || window.webkitAudioContext; ctx = new AudioCtx(); }catch(e){ return { pulse:()=>{} }; }

        const master = ctx.createGain(); master.gain.value = 0.4; master.connect(ctx.destination);

            function pulse(vol, opts){ try{ opts = opts || {}; const voiced = !!opts.voiced; const now = ctx.currentTime; const dur = Math.max(0.04, (opts.dur || (voiced ? 0.10 : 0.055)) + (Math.random()*0.04)); const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, now); const peak = Math.max(0.005, Math.min(0.16, (vol||0.04) * (voiced ? 1.2 : 1.0))); g.gain.linearRampToValueAtTime(peak, now + 0.008); g.gain.exponentialRampToValueAtTime(0.0001, now + dur + 0.02); g.connect(master);

                if(voiced){ const osc = ctx.createOscillator(); osc.type = Math.random() < 0.5 ? 'triangle' : 'sawtooth'; const baseHz = opts.pitch || (120 + Math.random()*240); osc.frequency.setValueAtTime(baseHz, now); const glideTo = baseHz * (0.85 + Math.random()*0.35); osc.frequency.exponentialRampToValueAtTime(Math.max(60, glideTo), now + dur * (0.6 + Math.random()*0.3)); const bp = ctx.createBiquadFilter(); bp.type = 'bandpass'; bp.frequency.value = 500 + Math.random()*1600; bp.Q.value = 6 + Math.random()*6; osc.connect(bp); bp.connect(g); osc.start(now); osc.stop(now + dur + 0.03);

                    const noiseBuf = ctx.createBuffer(1, Math.floor(ctx.sampleRate * dur), ctx.sampleRate); const ndata = noiseBuf.getChannelData(0); for(let i=0;i<ndata.length;i++) ndata[i] = (Math.random()*2 - 1) * (Math.random()*0.6); const nsrc = ctx.createBufferSource(); nsrc.buffer = noiseBuf; const nlp = ctx.createBiquadFilter(); nlp.type = 'lowpass'; nlp.frequency.value = 4000 + Math.random()*3000; nsrc.connect(nlp); nlp.connect(g); nsrc.start(now); nsrc.stop(now + dur + 0.02);

                    setTimeout(()=>{}, (dur + 0.06)*1000);

                } else {
                    const buffer = ctx.createBuffer(1, Math.floor(ctx.sampleRate * dur), ctx.sampleRate); const data = buffer.getChannelData(0); for(let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (Math.random()*0.9); const src = ctx.createBufferSource(); src.buffer = buffer; const hp = ctx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = 1200 + Math.random()*3000; const bp = ctx.createBiquadFilter(); bp.type = 'bandpass'; bp.frequency.value = 2500 + Math.random()*3000; bp.Q.value = 2 + Math.random()*3; src.connect(hp); hp.connect(bp); bp.connect(g); src.start(now); src.stop(now + dur + 0.02);

                    setTimeout(()=>{}, (dur + 0.06)*1000);
                }
            }catch(e){}
            }

            return { pulse, ctx };
        }

        function typeWithMouth(text, opts, controller){
            const wrap = ensureWrapper(); if(!wrap) return Promise.resolve();
            const page = wrap._page; const mouth = wrap._mouthSpan; const audioToggle = wrap._audioToggle;
            const audioAllowed = audioToggle && audioToggle.dataset.enabled === '1';
            page.textContent = '';
            return new Promise((resolve)=>{
                let i=0; let charDelay = opts && opts.delay || 18; const audio = audioAllowed ? createNoiseEngine() : null;
                try{ if(audio && controller){ controller._onAbort = function(){}; } }catch(e){}
                if(audioAllowed){ try{ ensureAiAudio(); }catch{} }
                function setMouth(open){ try{ mouth.textContent = open ? '▂' : '___'; }catch(e){} }
                function requestScrollToBottom(force){
                    try{
                        const pinned = force || (wrap && wrap._autoScrollPinned !== false);
                        if(!pinned) return;
                        if(wrap._autoScrollQueued) return;
                        wrap._autoScrollQueued = true;
                        requestAnimationFrame(()=>{
                            try{ wrap._autoScrollQueued = false; page.scrollTop = page.scrollHeight; }catch(e){}
                        });
                    }catch(e){}
                }
                function done(){ try{ setMouth(false); requestScrollToBottom(true); }catch{}; resolve(); }
                function step(){
                    if(controller && controller.aborted){ page.textContent = text; requestScrollToBottom(true); done(); return; }
                    if(i>=text.length){ done(); return; }
                    const ch = text[i++]; page.textContent += ch; try{ requestScrollToBottom(false); }catch(e){}
                    const isLetter = /[A-Za-z0-9]/.test(ch);
                    const isVowel = /[aeiouAEIOU]/.test(ch);
                    const open = isLetter || isVowel || ch === ',' || ch === '-';
                    setMouth(open);
                    try{ animateAudioBarsOnce(wrap, open ? 10 : 3); }catch(e){}
                    if(audio && open){ try{}catch{} }
                    let delay = charDelay;
                    if(/[.?!]\s$/.test(page.textContent)){ setMouth(false); delay = 520; }
                    if(ch === '\n'){ setMouth(false); delay = 240; }
                    setTimeout(step, delay);
                }
                step();
            });
        }

        window.showAiOutput = async function(text){
            const wrap = ensureWrapper(); if(!wrap) return;
            if(window.__aiOutputController && typeof window.__aiOutputController.abort === 'function'){ try{ window.__aiOutputController.abort(); }catch{} }
        const controller = { aborted:false, _onAbort: null, abort: function(){ try{ if(this.aborted) return; this.aborted = true; if(typeof this._onAbort === 'function'){ try{}catch(e){} } }catch(e){} } };
            window.__aiOutputController = controller; wrap._setController && wrap._setController(controller);
            const page = wrap._page; try{ wrap._autoScrollPinned = true; }catch(e){} page.scrollTop = 0; page.textContent = '';
            const outEl = document.getElementById(OUT_ID);
            try{ if(outEl) outEl.classList.add('ai-active'); }catch{}
            try{ await typeWithMouth(String(text||''), { delay: 16 }, controller); }catch(e){ page.textContent = text; }
            try{ setTimeout(()=>{ try{ const el = wrap._page || wrap; window.renderMathIn && window.renderMathIn(el); }catch(e){} }, 60); }catch(e){}
            if(window.__aiOutputController === controller) window.__aiOutputController = null;
            try{ if(outEl) outEl.classList.remove('ai-active'); }catch{}
        };

        window.stopAiOutputSoft = function(){ try{ if(window.__aiOutputController) window.__aiOutputController.abort(); }catch{} };
        window.stopAiOutput = function(){ try{ if(window.__aiOutputController) window.__aiOutputController.abort(); }catch{} try{ window.__resultsAnalysisRequestCounter = (window.__resultsAnalysisRequestCounter||0) + 1; }catch{} };
    })();

    // Embedded, browser-adapted script parser (migrated from js_parse_scripts.js)
    (function(){
      // Scans all <script> blocks on the page and attempts a non-executing syntax check
      // for non-module scripts by constructing a Function. Module scripts that contain
      // import/export are skipped for safety; scripts without content are ignored.
      function parseScriptsInPage(){
        const scripts = document.querySelectorAll('script');
        const results = [];
        scripts.forEach((s, idx) => {
          const code = s.textContent || '';
          if(!code.trim()){ results.push({index: idx+1, empty: true}); return; }
          const attrType = (s.getAttribute('type')||'').toLowerCase();
          const looksLikeModule = attrType === 'module' || /\bimport\b|\bexport\b/.test(code);
          try{
            if(looksLikeModule){
              if(/\b(import|export)\b/.test(code)){
                results.push({index: idx+1, module: true, checked: false, message: 'contains import/export — skipped safe parse'});
              } else {
                new Function(code);
                results.push({index: idx+1, module: true, checked: true});
              }
            } else {
              new Function(code);
              results.push({index: idx+1, checked: true});
            }
          }catch(e){
            results.push({index: idx+1, error: String(e)});
          }
        });
        console.group('Script parse results'); console.table(results); console.groupEnd();
        return results;
      }
      window.runScriptParser = parseScriptsInPage;
    })();
    </script>
    </body>
    <script>
    (function(){
        function encodeHTML(s){ return String(s||'').replace(/[&<>"']/g, function(c){ return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[c]; }); }
        function buildPrintable(highlight){
            // Build consistent printable HTML: uniform font-size, remove button-like visuals,
            // and optionally highlight correct choices (green) both in questions and in the Answer Key.
            try{
                const see = document.getElementById('seeAllContent');
                if(see && see.textContent && see.textContent.trim()){
                    const style = '<style>.export-root{font-family:Arial,Helvetica,sans-serif;color:#111;font-size:14px;line-height:1.4}.export-root *{background:transparent!important;border:none!important;box-shadow:none!important}.export-root .q{margin-bottom:12px}.export-root .choice{margin:6px 0;padding:0}.export-root .choice strong{display:inline-block;width:28px}.export-root .export-correct{color:#167f3a;font-weight:700}.export-root hr{border:none;border-top:1px solid #ccc;margin:18px 0}.answer-key{font-size:14px; page-break-before:always; break-before:page;}</style>';
                    return style + '<div class="export-root"><pre style="white-space:pre-wrap;font-family:inherit">'+encodeHTML(see.textContent)+'</pre><hr/>' + '<h2>Answer Key</h2><div class="answer-key">(answers not available)</div></div>';
                }
            }catch(e){}
            try{
                const preview = document.getElementById('previewList');
                if(preview && preview.innerHTML && preview.innerHTML.trim()){
                    // If previewList is present, prefer to extract structured items if available
                    const items = (window.__quizState && window.__quizState.items) || (window.state && window.state.items) || null;
                    if(items && items.length){
                        const style = '<style>.export-root{font-family:Arial,Helvetica,sans-serif;color:#111;font-size:14px;line-height:1.4}.export-root *{background:transparent!important;border:none!important;box-shadow:none!important}.export-root .q{margin-bottom:12px}.export-root .choice{margin:6px 0;padding:0}.export-root .choice strong{display:inline-block;width:28px}.export-root .export-correct{color:#167f3a;font-weight:700}.export-root hr{border:none;border-top:1px solid #ccc;margin:18px 0}.answer-key{font-size:14px; page-break-before:always; break-before:page;}</style>';
                        const letters = ['A','B','C','D','E','F','G'];
                        var qhtml = style + '<div class="export-root">';
                        var ak = [];
                        items.forEach(function(it, ix){
                            const num = it.num || (ix+1);
                            const type = String(it.type || 'mcq').toLowerCase();
                            const q = encodeHTML(it.q || it.text || '');
                            qhtml += '<div class="q"><div><strong>Q'+num+'.</strong> '+q+'</div>';

                            if(type === 'matching' || type === 'match'){
                                const pairs = Array.isArray(it.pairs) ? it.pairs : [];
                                const rightOptions = Array.isArray(it.rightOptions) ? it.rightOptions : [];
                                if(pairs.length){
                                    qhtml += '<div class="choice"><strong>L.</strong> '+encodeHTML(pairs.map(function(p){ return (p && p.left) ? String(p.left) : ''; }).filter(Boolean).join(' | '))+'</div>';
                                }
                                if(rightOptions.length){
                                    qhtml += '<div class="choice"><strong>R.</strong> '+encodeHTML(rightOptions.map(function(x){ return String(x||''); }).filter(Boolean).join(' | '))+'</div>';
                                }
                                const mapping = pairs.map(function(p){
                                    const L = p && p.left != null ? String(p.left) : '';
                                    const R = p && p.right != null ? String(p.right) : '';
                                    return (L && R) ? (L + ' → ' + R) : '';
                                }).filter(Boolean).join(' ; ');
                                if(highlight && mapping){
                                    qhtml += '<div class="choice"><strong>Ans.</strong> <span class="export-correct">'+encodeHTML(mapping)+'</span></div>';
                                }
                                ak.push({ num: num, ans: mapping || '?' });
                            }else if(type === 'fillblank' || type === 'fib' || type === 'fill-in-the-blank'){
                                const answers = Array.isArray(it.answers) ? it.answers : (it.answer != null ? [it.answer] : []);
                                const ansText = answers.map(function(a){ return String(a||'').trim(); }).filter(Boolean).join(' | ');
                                if(highlight && ansText){
                                    qhtml += '<div class="choice"><strong>Ans.</strong> <span class="export-correct">'+encodeHTML(ansText)+'</span></div>';
                                }
                                ak.push({ num: num, ans: ansText || '?' });
                            }else if(type === 'truefalse' || type === 'tf' || type === 't/f'){
                                const correctIdx = (typeof it.correctIdx === 'number') ? it.correctIdx : (it.answer === false ? 1 : 0);
                                const tfAns = (correctIdx === 0) ? 'True' : 'False';
                                const choices = Array.isArray(it.choices) ? it.choices : ['True','False'];
                                choices.forEach(function(c,i){
                                    const isCorrect = (i === correctIdx);
                                    if(highlight && isCorrect){
                                        qhtml += '<div class="choice"><strong>'+ (letters[i]|| (i+1)) +'.</strong> <span class="export-correct">'+encodeHTML(c)+'</span></div>';
                                    }else{
                                        qhtml += '<div class="choice"><strong>'+ (letters[i]|| (i+1)) +'.</strong> '+encodeHTML(c)+'</div>';
                                    }
                                });
                                ak.push({ num: num, ans: tfAns });
                            }else{
                                const choices = Array.isArray(it.choices) ? it.choices : [];
                                var correctIdx = (typeof it.correctIdx === 'number') ? it.correctIdx : (typeof it.correct === 'number' ? it.correct : null);
                                choices.forEach(function(c,i){
                                    const isCorrect = (i === correctIdx);
                                    if(highlight && isCorrect){
                                        qhtml += '<div class="choice"><strong>'+ (letters[i]|| (i+1)) +'.</strong> <span class="export-correct">'+encodeHTML(c)+'</span></div>';
                                    }else{
                                        qhtml += '<div class="choice"><strong>'+ (letters[i]|| (i+1)) +'.</strong> '+encodeHTML(c)+'</div>';
                                    }
                                });
                                ak.push({ num: num, ans: letters[correctIdx] || (correctIdx!==null? String(correctIdx+1): '?') });
                            }
                            qhtml += '</div>';
                        });
                        qhtml += '<hr/>';
                        qhtml += '<h2>Answer Key</h2><ol class="answer-key" style="padding-left:18px">';
                        ak.forEach(function(a){ qhtml += '<li style="margin:6px 0"><strong>Q'+a.num+':</strong> <span class="ans-letter"'+(highlight? ' style="color:#167f3a;font-weight:700"':'')+ '>'+encodeHTML(a.ans)+'</span></li>'; });
                        qhtml += '</ol>';
                        qhtml += '</div>';
                        return qhtml;
                    }
                    // Fallback: strip interactive elements and return the preview markup
                    const clone = preview.cloneNode(true);
                    clone.querySelectorAll && clone.querySelectorAll('button,input,textarea,select').forEach(function(n){ try{ n.remove(); }catch(e){} });
                    const style = '<style>.export-root{font-family:Arial,Helvetica,sans-serif;color:#111;font-size:14px;line-height:1.4}.export-root *{background:transparent!important;border:none!important;box-shadow:none!important}.export-root hr{border:none;border-top:1px solid #ccc;margin:18px 0}</style>';
                    return style + '<div class="export-root">'+clone.innerHTML+'</div>';
                }
            }catch(e){}
            try{
                const items = (window.__quizState && window.__quizState.items) || (window.state && window.state.items) || [];
                if(!items || !items.length) return '<div class="hint">No parsed items.</div>';
                const style = '<style>.export-root{font-family:Arial,Helvetica,sans-serif;color:#111;font-size:14px;line-height:1.4}.export-root *{background:transparent!important;border:none!important;box-shadow:none!important}.export-root .q{margin-bottom:12px}.export-root .choice{margin:6px 0;padding:0}.export-root .choice strong{display:inline-block;width:28px}.export-root .export-correct{color:#167f3a;font-weight:700}.export-root hr{border:none;border-top:1px solid #ccc;margin:18px 0}.answer-key{font-size:14px; page-break-before:always; break-before:page;}</style>';
                const letters = ['A','B','C','D','E','F','G'];
                var qhtml = style + '<div class="export-root">';
                var ak = [];
                items.forEach(function(it, ix){
                    const num = it.num || (ix+1);
                    const type = String(it.type || 'mcq').toLowerCase();
                    const q = encodeHTML(it.q || it.text || '');
                    qhtml += '<div class="q"><div><strong>Q'+num+'.</strong> '+q+'</div>';

                    if(type === 'matching' || type === 'match'){
                        const pairs = Array.isArray(it.pairs) ? it.pairs : [];
                        const rightOptions = Array.isArray(it.rightOptions) ? it.rightOptions : [];
                        if(pairs.length){
                            qhtml += '<div class="choice"><strong>L.</strong> '+encodeHTML(pairs.map(function(p){ return (p && p.left) ? String(p.left) : ''; }).filter(Boolean).join(' | '))+'</div>';
                        }
                        if(rightOptions.length){
                            qhtml += '<div class="choice"><strong>R.</strong> '+encodeHTML(rightOptions.map(function(x){ return String(x||''); }).filter(Boolean).join(' | '))+'</div>';
                        }
                        const mapping = pairs.map(function(p){
                            const L = p && p.left != null ? String(p.left) : '';
                            const R = p && p.right != null ? String(p.right) : '';
                            return (L && R) ? (L + ' → ' + R) : '';
                        }).filter(Boolean).join(' ; ');
                        if(highlight && mapping){
                            qhtml += '<div class="choice"><strong>Ans.</strong> <span class="export-correct">'+encodeHTML(mapping)+'</span></div>';
                        }
                        ak.push({ num: num, ans: mapping || '?' });
                    }else if(type === 'fillblank' || type === 'fib' || type === 'fill-in-the-blank'){
                        const answers = Array.isArray(it.answers) ? it.answers : (it.answer != null ? [it.answer] : []);
                        const ansText = answers.map(function(a){ return String(a||'').trim(); }).filter(Boolean).join(' | ');
                        if(highlight && ansText){
                            qhtml += '<div class="choice"><strong>Ans.</strong> <span class="export-correct">'+encodeHTML(ansText)+'</span></div>';
                        }
                        ak.push({ num: num, ans: ansText || '?' });
                    }else if(type === 'truefalse' || type === 'tf' || type === 't/f'){
                        const correctIdx = (typeof it.correctIdx === 'number') ? it.correctIdx : (it.answer === false ? 1 : 0);
                        const tfAns = (correctIdx === 0) ? 'True' : 'False';
                        const choices = Array.isArray(it.choices) ? it.choices : ['True','False'];
                        choices.forEach(function(c,i){
                            const isCorrect = (i === correctIdx);
                            if(highlight && isCorrect){
                                qhtml += '<div class="choice"><strong>'+ (letters[i]|| (i+1)) +'.</strong> <span class="export-correct">'+encodeHTML(c)+'</span></div>';
                            }else{
                                qhtml += '<div class="choice"><strong>'+ (letters[i]|| (i+1)) +'.</strong> '+encodeHTML(c)+'</div>';
                            }
                        });
                        ak.push({ num: num, ans: tfAns });
                    }else{
                        const choices = Array.isArray(it.choices) ? it.choices : [];
                        var correctIdx = (typeof it.correctIdx === 'number') ? it.correctIdx : (typeof it.correct === 'number' ? it.correct : null);
                        choices.forEach(function(c,i){
                            const isCorrect = (i === correctIdx);
                            if(highlight && isCorrect){
                                qhtml += '<div class="choice"><strong>'+ (letters[i]|| (i+1)) +'.</strong> <span class="export-correct">'+encodeHTML(c)+'</span></div>';
                            }else{
                                qhtml += '<div class="choice"><strong>'+ (letters[i]|| (i+1)) +'.</strong> '+encodeHTML(c)+'</div>';
                            }
                        });
                        ak.push({ num: num, ans: letters[correctIdx] || (correctIdx!==null? String(correctIdx+1): '?') });
                    }
                    qhtml += '</div>';
                });
                qhtml += '<hr/>';
                qhtml += '<h2>Answer Key</h2><ol class="answer-key" style="padding-left:18px">';
                ak.forEach(function(a){ qhtml += '<li style="margin:6px 0"><strong>Q'+a.num+':</strong> <span class="ans-letter"'+(highlight? ' style="color:#167f3a;font-weight:700"':'')+ '>'+encodeHTML(a.ans)+'</span></li>'; });
                qhtml += '</ol>';
                qhtml += '</div>';
                return qhtml;
            }catch(e){ return '<div class="hint">No parsed items.</div>'; }
        }

        // Utility to dynamically load a script and return a Promise
        function loadScript(src){ return new Promise(function(res, rej){ try{ var s = document.createElement('script'); s.src = src; s.async = true; s.onload = function(){ res(); }; s.onerror = function(err){ rej(err); }; document.head.appendChild(s); }catch(e){ rej(e); } }); }

        async function exportToPdfProgrammatic(title, htmlContent){
            try{
                // Ensure libraries
                if(!window.html2canvas){ try{ await loadScript('https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js'); }catch(e){ console.warn('html2canvas load failed', e); } }
                if(!window.jspdf){ try{ await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js'); }catch(e){ console.warn('jsPDF load failed', e); } }

                // If html2canvas not available, bail
                if(!window.html2canvas) return false;
                // Build wrapper offscreen
                const wrapper = document.createElement('div'); wrapper.style.position='fixed'; wrapper.style.left='-5000px'; wrapper.style.top='0'; wrapper.style.width='900px'; wrapper.style.background='#fff'; wrapper.style.color='#111'; wrapper.innerHTML = '<div style="padding:18px">' + htmlContent + '</div>';
                document.body.appendChild(wrapper);

                // Render
                const canvas = await window.html2canvas(wrapper, { scale: 2, useCORS: true, logging: false });
                const imgData = canvas.toDataURL('image/jpeg', 0.95);
                // jsPDF UMD exposes window.jspdf.jsPDF or window.jspdf
                var jsPDFCtor = null;
                try{ jsPDFCtor = (window.jspdf && window.jspdf.jsPDF) ? window.jspdf.jsPDF : (window.jspdf ? window.jspdf : null); }catch(e){}
                if(!jsPDFCtor && window.jspdf && window.jspdf.jsPDF) jsPDFCtor = window.jspdf.jsPDF;
                if(!jsPDFCtor){ try{ wrapper.remove(); }catch(e){} return false; }
                const pdf = new (jsPDFCtor)({ unit: 'pt', format: 'a4' });
                const pageW = pdf.internal.pageSize.getWidth(); const pageH = pdf.internal.pageSize.getHeight();
                const iw = canvas.width; const ih = canvas.height; const ratio = Math.min(pageW / iw, pageH / ih);
                const imgW = iw * ratio; const imgH = ih * ratio;
                pdf.addImage(imgData, 'JPEG', 20, 20, imgW - 40, imgH - 40);
                const fname = (title || 'export').replace(/[^a-zA-Z0-9-_ ]/g,'').slice(0,120) + '.pdf';
                pdf.save(fname);
                try{ wrapper.remove(); }catch(e){}
                return true;
            }catch(e){ console.warn('programmatic export failed', e); try{ /* try to clean up */ }catch(_){} return false; }
        }
        function openPrintable(title, bodyHtml){
            try{
                const win = window.open('', '_blank');
                if(!win){ alert('Popup blocked. Allow popups or use the browser Print dialog.'); return; }
                const css = '<style>body{font-family:Arial,Helvetica,sans-serif;color:#111;padding:18px;max-width:900px;margin:0 auto} h1{font-size:20px;margin-bottom:12px} .export-correct{color:#167f3a;font-weight:700}</style>';
                win.document.write('<!doctype html><html><head><meta charset="utf-8"><title>'+encodeHTML(title)+'</title>'+css+'</head><body>');
                win.document.write('<h1>' + encodeHTML(title) + '</h1>');
                win.document.write(bodyHtml || '<div>(no content)</div>');
                win.document.write('</body></html>');
                win.document.close();
                setTimeout(function(){ try{ win.focus(); win.print(); }catch(e){ console.warn('print failed', e); } }, 400);
            }catch(e){ console.error('print preview failed', e); alert('Export failed: ' + (e && e.message ? e.message : e)); }
        }

        document.addEventListener('DOMContentLoaded', function(){
            try{
                var btn = document.getElementById('exportPdfBtn');
                if(!btn) return;
                btn.addEventListener('click', async function(ev){
                    try{
                        ev && ev.preventDefault && ev.preventDefault();
                        var highlight = !!(document.getElementById('exportPdfHighlight') && document.getElementById('exportPdfHighlight').checked);
                        var html = buildPrintable(highlight);
                        // Try programmatic PDF generation first (auto-download). If it fails, fall back to print preview.
                        const ok = await exportToPdfProgrammatic('Preview — All Questions', html);
                        if(!ok){ openPrintable('Preview — All Questions', html); }
                    }catch(e){ console.error('export click failed', e); try{ var html = buildPrintable(false); openPrintable('Preview — All Questions', html); }catch(_){} }
                });
            }catch(e){ console.error('export binder failed', e); }

            // Wire the visual label for the "highlight" toggle so it glows green when enabled
            try{
                (function(){
                    var cb = document.getElementById('exportPdfHighlight');
                    var lbl = document.getElementById('exportPdfHighlightLabel');
                    // Ensure CSS rule exists (inject if needed)
                    try{
                        var id = 'export-highlight-style';
                        if(!document.getElementById(id)){
                            var s = document.createElement('style');
                            s.id = id;
                            s.textContent = '.export-highlight-on{ color: #167f3a !important; text-shadow: 0 0 10px rgba(22,127,58,0.65); transition: color .12s ease, text-shadow .12s ease; }';
                            document.head.appendChild(s);
                        }
                    }catch(e){}
                    function updateLabel(){
                        if(!lbl) return;
                        if(cb && cb.checked){ lbl.classList.add('export-highlight-on'); }
                        else { lbl.classList.remove('export-highlight-on'); }
                    }
                    if(cb){ cb.addEventListener('change', updateLabel); }
                    // initialize state
                    setTimeout(updateLabel, 0);
                })();
            }catch(e){ console.warn('highlight label binder failed', e); }
        });
    })();
    </script>
<script>
    (async function aiLikeInit() {
        // Try to load Gemini SDK if not present (safe no-op if already loaded)
        if (!window.GoogleGenerativeAI) {
            try {
                const mod = await import("https://esm.run/@google/generative-ai");
                window.GoogleGenerativeAI = mod.GoogleGenerativeAI;
            } catch (e) {
                console.warn("Gemini SDK load failed (will retry on click).", e);
            }
        }

        const $ = id => document.getElementById(id);
        const wrap = $("ai-likeq");
        const btn = $("aiLikeBtn");
        // Use the global Gemini API key bar instead of a separate key input
        const stat = $("aiLikeStatus");

        // Ensure buttons reflect the current global key AND enable toggle (safe local updater)
        function updateKeyState(){
            try{
                const val = (document.getElementById('globalGemKey')?.value||'').trim();
                const enabled = !!document.getElementById('globalGemEnable')?.checked;
                const ok = !!val && enabled;
                const badge = document.getElementById('globalKeyBadge');
                if(badge){ badge.classList.toggle('ok', ok); badge.classList.toggle('missing', !ok); const h=badge.querySelector('.hint'); if(h) h.textContent = ok ? 'Key set' : 'No key set'; }
                if(btn) btn.disabled = !ok;
                // also update the results card key badge and analyze button
                const rBadge = document.getElementById('resultsKeyBadge');
                if(rBadge){ rBadge.classList.toggle('ok', ok); rBadge.classList.toggle('missing', !ok); const h=rBadge.querySelector('.hint'); if(h) h.textContent = ok ? 'Key set' : 'No key set'; }
                const analyze = document.getElementById('analyzeMissedBtn'); if(analyze) analyze.disabled = !ok;
            }catch{}
        }
        // run once on init
        updateKeyState();
    // also watch for changes to the global key and enable toggle
    document.getElementById('globalGemKey')?.addEventListener('input', updateKeyState);
    document.getElementById('globalGemEnable')?.addEventListener('change', updateKeyState);

    // Hide this whole card once quiz has actually had a successful parse + start
    function hideAiLike() { try{ if(window.__parsed) { if(wrap){ wrap.classList.add('hidden'); } } }catch{} }
    document.getElementById("startBtn")?.addEventListener("click", hideAiLike);
    document.getElementById("beginFromPreview")?.addEventListener("click", hideAiLike);

    // Prevent double-binding across duplicate initializers
    if(btn && btn.dataset.boundLike === '1') return;
    if(btn) btn.dataset.boundLike = '1';
    btn?.addEventListener("click", async () => {
            const paste = document.getElementById("paste");
            if (!paste || !paste.value.trim()) { alert("Paste your questions first."); return; }

            // Ensure SDK
            if (!window.GoogleGenerativeAI) {
                try {
                    const mod = await import("https://esm.run/@google/generative-ai");
                    window.GoogleGenerativeAI = mod.GoogleGenerativeAI;
                } catch (e) {
                    alert("Could not load Gemini SDK. Check your connection and try again.");
                    return;
                }
            }

            // Read key + check enable toggle from global top bar
            const key = (document.getElementById('globalGemKey')?.value || '').trim();
            const enabled = !!document.getElementById('globalGemEnable')?.checked;
            if (!key || !enabled) { alert('Enable the API key (toggle in the key bar) and enter your Gemini API key.'); stat.textContent = 'API key disabled or missing.'; return; }

            // Build strict, structure-preserving prompt
            const original = paste.value;
            const prompt =
                `You are to conservatively rewrite the following MCQ set into LIKE-QUESTIONS for practice.
You MUST preserve:
- The exact document structure and formatting.
- The SAME number of questions.
- Each question prefixed "Q<number>. " on its own line.
- Each option on its own line, prefixed with "- ".
- Do NOT label options with letters or numbers. Do not prefix options with "A.", "B)", "(C)", "1.", "a)", etc. The ONLY identifier for an option line is the leading "- ".
- A final "ANSWER KEY" section with one line per question in the form "<number>. <LETTER>".
- Exactly ONE correct option per question; options must be mutually exclusive and plausible.
- Domain and difficulty should be similar; small surface changes are preferred (synonyms, numerics, contexts).
- Do NOT include any extra commentary, JSON, or Markdown. Output ONLY the rewritten text.

Also:
- Ensure correctness: internally verify each keyed answer truly matches the best option.
- Keep language clear and unambiguous; avoid clues that trivially reveal the answer.
- If any item is malformed, repair it conservatively to follow the rules above.

Rewrite this set now:

${original}`;

            btn.disabled = true;
            const orig = btn.textContent;
            btn.innerHTML = '<span class="spinner" aria-hidden="true"></span> Contacting…';
            stat.textContent = "Contacting Gemini 2.5…";
            try {
                const AI = window.GoogleGenerativeAI;
                const client = new AI(key);
                const model = client.getGenerativeModel({ model: "gemini-2.5-flash" });

                const resp = await model.generateContent({
                    contents: [{ role: "user", parts: [{ text: prompt }] }]
                });

                const text = (await resp?.response?.text?.())?.trim();
                if (!text) throw new Error("Empty response from model.");

                // Very basic sanity checks to reduce surprises
                if (!/^\s*Q\s*\d+\./mi.test(text) || !/^\s*ANSWER\s+KEY\s*$/mi.test(text)) {
                    if (!confirm("The AI output didn't clearly match the expected structure. Insert anyway?")) {
                        stat.textContent = "Cancelled.";
                        try{
                            // Restore label reliably
                            const live = document.getElementById(btn?.id) || btn;
                            live.disabled = false;
                            live.innerHTML = orig;
                        }catch{}
                        return;
                    }
                }

                // Show preview modal so user can Insert, Save, or Cancel. Propagate any source tag
                try{
                    window.showPreviewModal(text, ( !/^\s*Q\s*\d+/mi.test(text) || /\bANSWER\s+KEY\b/mi.test(text) ) ? 'AI output may not match expected MCQ format' : '', function(choice){
                        try{
                            if(!choice) { stat.textContent = 'Cancelled.'; return; }
                            if(choice === true || (choice && choice.action === 'insert')){
                                paste.value = normalizeGreek(text);
                                document.getElementById('parseBtn')?.click();
                                stat.textContent = 'Inserted like-questions.';
                                // tag propagation removed
                                return;
                            }
                            if(choice && choice.action === 'save'){
                                try{
                                    const key = 'mcq.pastes.v1';
                                    const existing = (function(){ try{ return JSON.parse(localStorage.getItem(key)||'[]'); }catch(e){ return []; } })();
                                    const title = (text||'').split('\n').map(l=>l.trim()).filter(Boolean)[0] || 'Untitled';
                                    const savedText = (window.sanitizeMCQText ? window.sanitizeMCQText(text) : text);
                                    const item = { id: Date.now().toString(36), date: (new Date()).toISOString().slice(0,16).replace('T',' '), title: String(title).slice(0,200), text: savedText };
                                    existing.unshift(item);
                                    try{ localStorage.setItem(key, JSON.stringify(existing)); }catch(e){ console.warn('Could not save generated item', e); }
                                    stat.textContent = 'Saved generated questions.';
                                    try{ window.refreshLocalSaved && window.refreshLocalSaved(); }catch(e){}
                                }catch(e){ console.error('save generated failed', e); stat.textContent = 'Save failed.'; }
                                // tag propagation removed
                                return;
                            }
                            stat.textContent = 'Cancelled.';
                            // tag propagation removed
                        }catch(e){ console.error('preview callback failed', e); stat.textContent = 'Error during preview action.'; }
                    });
                }catch(e){ console.error('showPreviewModal failed', e); paste.value = normalizeGreek(text); document.getElementById('parseBtn')?.click(); stat.textContent = 'Inserted like-questions.'; }
            } catch (err) {
                console.error(err);
                stat.textContent = "AI generation failed.";
                alert("Gemini error: " + (err?.message || err));
            } finally {
                try{
                    const live = document.getElementById(btn?.id) || btn;
                    live.disabled = false;
                    live.innerHTML = orig;
                }catch{}
            }
        });
    })();
    (function resultsAnalysisInit(){
        const $ = id=>document.getElementById(id);
        // Keep analyze button in sync with key state using existing updater via input/change events
        function syncFromGlobalKey(){ try{
            const val = (document.getElementById('globalGemKey')?.value||'').trim();
            const enabled = !!document.getElementById('globalGemEnable')?.checked;
            const ok = !!val && enabled; const analyze = $('analyzeMissedBtn'); if(analyze) analyze.disabled = !ok;
            const rBadge = $('resultsKeyBadge'); if(rBadge){ rBadge.classList.toggle('ok', ok); rBadge.classList.toggle('missing', !ok); const h=rBadge.querySelector('.hint'); if(h) h.textContent = ok ? 'Key set' : 'No key set'; }
        }catch{} }
        document.getElementById('globalGemKey')?.addEventListener('input', syncFromGlobalKey);
        document.getElementById('globalGemEnable')?.addEventListener('change', syncFromGlobalKey);
    // Initialize state on load so Analyze button/key badge are correct
    try{ syncFromGlobalKey(); }catch{}

    const btn = $('analyzeMissedBtn');
    // Define runner first so both direct and delegated bindings can use it
    async function runResultsAnalysis(targetBtn){
            try{
                // Track a per-request id so late responses are ignored if a newer analysis starts
                try{ window.__resultsAnalysisRequestCounter = (window.__resultsAnalysisRequestCounter||0) + 1; }catch{};
                const _requestId = window.__resultsAnalysisRequestCounter;
                const state = (window.__quizState || window.state || window.__STATE__);
                if(!state){
                    const s = document.getElementById('resultsAiStatus'); if(s) s.textContent = 'Internal error: quiz state unavailable.';
                    return;
                }
                const key = (document.getElementById('globalGemKey')?.value||'').trim();
                const enabled = !!document.getElementById('globalGemEnable')?.checked;
                if(!key || !enabled){ alert('Enable the API key and enter your Gemini API key.'); return; }
                // Ensure SDK
                if(!window.GoogleGenerativeAI){ try{ const mod = await import('https://esm.run/@google/generative-ai'); window.GoogleGenerativeAI = mod.GoogleGenerativeAI; }catch(e){ alert('Could not load Gemini SDK.'); return; } }
    // Show immediate feedback that click is captured
    try{ const s = document.getElementById('resultsAiStatus'); if(s) s.textContent = 'Preparing analysis…'; try{ if(typeof window.stopAiOutputSoft === 'function'){ window.stopAiOutputSoft(); } else if(typeof window.stopAiOutput === 'function'){ window.stopAiOutput(); } else { const o = document.getElementById('resultsAiOutput'); if(o) o.textContent = ''; } }catch{} }catch{}
                // Helper: resolve selected attempt id reliably (prefer dropdown, then button dataset)
                function getSelectedAttemptId(){
                    try{
                        const sel = document.getElementById('attemptSelect');
                        if(sel && sel.value){ return String(sel.value); }
                    }catch{}
                    try{
                        const ab = document.getElementById('analyzeMissedBtn');
                        const did = ab?.dataset?.selAttemptId; if(did!=null && did!==''){ return String(did); }
                    }catch{}
                    // fallback: use most recent attempt id
                    try{
                        const atts = Array.isArray(state.attempts) ? state.attempts : [];
                        if(atts.length){ return String(atts[atts.length-1].id); }
                    }catch{}
                    return null;
                }
                function findAttemptById(attempts, idStr){
                    if(!idStr) return null; return attempts.find(z => String(z.id) === String(idStr)) || null;
                }
                // Collect missed questions for the selected attempt, or aggregate across ALL attempts if none selected
                function collectMissed(){
                    try{
                        const attempts = Array.isArray(state.attempts) ? state.attempts : [];
                        if(!attempts.length){
                            // fallback to current state if attempts missing
                            const res = [];
                            (state.items||[]).forEach((it, ix)=>{
                                const r = state.answered[ix]; const wasWrong = !r || !r.submitted || !r.correct;
                                if(wasWrong){ res.push({ num: it.num, q: it.q, choices: it.choices.slice(), correctIdx: it.correctIdx, user: r && r.selected!=null ? r.selected : null, attemptId: 0 }); }
                            });
                            return res;
                        }
                        // Resolve selected attempt and use that snapshot if available
                        const selIdStr = getSelectedAttemptId();
                        if(selIdStr!=null){
                            const a = findAttemptById(attempts, selIdStr);
                            if(a){
                                return (a.missed||[]).map(m => ({ num: m.num, q: m.q, choices: (m.choices||[]).slice(), correctIdx: m.correctIdx, user: m.user, attemptId: a.id, mode: a.mode }));
                            }
                        }
                        // Otherwise aggregate across all attempts
                        const out = [];
                        attempts.forEach(a=>{ (a.missed||[]).forEach(m=>{ out.push({ num: m.num, q: m.q, choices: (m.choices||[]).slice(), correctIdx: m.correctIdx, user: m.user, attemptId: a.id, mode: a.mode }); }); });
                        return out;
                    }catch(e){ return []; }
                }
                const selectedAttemptId = getSelectedAttemptId();
                const attemptsArr = Array.isArray(state.attempts) ? state.attempts : [];
                const selectedAttempt = selectedAttemptId ? findAttemptById(attemptsArr, selectedAttemptId) : null;
                let missedItems = collectMissed();
                const status = $('resultsAiStatus'); const output = $('resultsAiOutput');
                // Early feedback so users see the click did something
                try{ if(missedItems.length && selectedAttempt){ status.textContent = `Preparing analysis for attempt ${selectedAttempt.id} — ${missedItems.length} missed.`; } }catch{}
                // If selected attempt has zero misses, auto-fallback to most recent attempt with misses
                if(selectedAttempt && (!selectedAttempt.missed || selectedAttempt.missed.length===0)){
                    const fallback = attemptsArr.slice().reverse().find(a=>a.missed && a.missed.length);
                    if(fallback){
                        missedItems = (fallback.missed||[]).map(m => ({ num: m.num, q: m.q, choices: (m.choices||[]).slice(), correctIdx: m.correctIdx, user: m.user, attemptId: fallback.id, mode: fallback.mode }));
                        try{ const sel = document.getElementById('attemptSelect'); if(sel){ sel.value = String(fallback.id); } }catch{}
                        try{ status.textContent = `Preparing analysis for attempt ${fallback.id} — ${missedItems.length} missed.`; }catch{}
                    }
                }
                    if(!missedItems.length){
                    // Clarify scope in status message with selected attempt id
                    if(selectedAttempt){ status.textContent = `No missed questions in the selected attempt (id ${selectedAttempt.id}) to analyze.`; }
                    else {
                        try{ const sel = document.getElementById('attemptSelect'); if(sel && sel.value){ status.textContent = `No missed questions in the selected attempt to analyze.`; } else { status.textContent = 'No missed questions across attempts to analyze.'; } }catch{ status.textContent = 'No missed questions to analyze.'; }
                    }
                    try{ if(typeof window.stopAiOutputSoft === 'function'){ window.stopAiOutputSoft(); } else if(typeof window.stopAiOutput === 'function'){ window.stopAiOutput(); } else { output.textContent=''; } }catch{} return; }
                // Build text block of missed Qs in simple structure
                const letters = ['A','B','C','D','E','F'];
                const block = missedItems.map(it=>{
                    const userLine = (it.user==null? 'None' : `${letters[it.user]}. ${it.choices[it.user]}`);
                    const att = it.attemptId ? `Attempt: ${it.attemptId}${it.mode? ' ('+it.mode+')':''}` : '';
                    return `${att}\nQ${it.num}. ${it.q}\n${it.choices.map((c,i)=>`- ${letters[i]}. ${c}`).join('\n')}\nUser selected: ${userLine}\nCorrect answer: ${letters[it.correctIdx]}. ${it.choices[it.correctIdx]}`;
                }).join('\n\n');

                // Mention scope (selected attempt vs all attempts)
                let scope = 'across all attempts';
                if(selectedAttempt){ scope = `for attempt ${selectedAttempt.id}`; }
                const prompt = `You are a precise tutor. Analyze the missed MCQs ${scope}. For each missed item, give a 1-2 sentence explanation of the correct reasoning and why the chosen answer was wrong. Then summarize trends/patterns across mistakes and give concise, actionable study tips. Output plain text only (no Markdown).\n\nMISSED QUESTIONS (with user selections and correct keys):\n\n${block}`;

                const AI = window.GoogleGenerativeAI; const client = new AI(key);
                const model = client.getGenerativeModel({ model: 'gemini-2.5-flash' });
                const liveBtn = document.getElementById('analyzeMissedBtn') || targetBtn;
                liveBtn.disabled = true; const orig = liveBtn.textContent; liveBtn.innerHTML = '<span class="spinner" aria-hidden="true"></span> Analyzing…';
                status.textContent = 'Contacting Gemini 2.5…'; try{ if(typeof window.stopAiOutputSoft === 'function'){ window.stopAiOutputSoft(); } else if(typeof window.stopAiOutput === 'function'){ window.stopAiOutput(); } else { output.textContent=''; } }catch{}
                try{
                    const resp = await model.generateContent({ contents: [{ role:'user', parts:[{ text: prompt }] }] });
                    const text = (await resp?.response?.text?.())?.trim();
                    // Before writing, ensure this request is still the latest (ignore late responses)
                    if(window.__resultsAnalysisRequestCounter !== _requestId){
                        console.log('Results analysis response ignored due to newer request.');
                        try{ status.textContent = 'Analysis cancelled (newer request).'; }catch{};
                        return;
                    }
                    // animated textbook-style output (typewriter + ASCII face + noise)
                    try{
                        if(typeof window.showAiOutput === 'function'){
                            // showAiOutput registers a global controller; ensure controller is current when writing
                            window.showAiOutput(text || 'No analysis returned.');
                        } else {
                            // fallback: only write if still current
                            if(window.__resultsAnalysisRequestCounter === _requestId) output.textContent = text || 'No analysis returned.';
                        }
                    }catch(e){
                        if(window.__resultsAnalysisRequestCounter === _requestId) output.textContent = text || 'No analysis returned.';
                    }
                    try{ if(window.__resultsAnalysisRequestCounter === _requestId) status.textContent = 'Done.'; }catch{}
                }catch(e){
                    console.error('Results AI error', e);
                    if(window.__resultsAnalysisRequestCounter === _requestId) status.textContent = 'AI analysis failed.';
                    if(window.__resultsAnalysisRequestCounter === _requestId) output.textContent = (e?.message || String(e||'')).toString();
                }finally{
                    try{ if(window.__resultsAnalysisRequestCounter === _requestId){ liveBtn.disabled = false; liveBtn.textContent = orig; } }
                    catch(e){ }
                }
            }catch(err){ console.error(err); }
        }
        // Direct binding when button is present
        try{
            if(btn && btn.dataset.bound !== '1'){
                btn.dataset.bound = '1';
                btn.addEventListener('click', (e)=>{ e.preventDefault(); if(btn.disabled) return; runResultsAnalysis(btn); });
            }
        }catch{}
        // Delegated binding (aligns with other button logic) so clicks are caught even if button was added later
        try{
            if(!window.__resultsAnalysisDelegatedBound){
                document.addEventListener('click', function(e){ const t = e.target && e.target.closest ? e.target.closest('#analyzeMissedBtn') : null; if(!t) return; e.preventDefault(); if(t.disabled) return; runResultsAnalysis(t); });
                window.__resultsAnalysisDelegatedBound = true;
            }
        }catch{}
    })();
    (async function aiLikeInit2() {
        // Second copy initializer for the duplicated like-questions module
        if (!window.GoogleGenerativeAI) {
            try {
                const mod = await import("https://esm.run/@google/generative-ai");
                window.GoogleGenerativeAI = mod.GoogleGenerativeAI;
            } catch (e) { /* ignore - will retry on click */ }
        }
    const $ = id => document.getElementById(id);
    const wrap = $("ai-likeq-copy");
    const btn = $("aiLikeBtn2");
    const stat = $("aiLikeStatus2");
    // Local helpers to avoid ReferenceErrors from other modules
    const letters = ['A','B','C','D','E','F'];
    const esc = s => (String(s||'')).replace(/[&<>"']/g, c => ({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]));
    const decodeNumericEntities = (s)=> String(s||'').replace(/&#(x?)([0-9A-Fa-f]+);/g, (m, x, code) => { try{ const cp = x?parseInt(code,16):parseInt(code,10); if(!isFinite(cp)||cp<0||cp>0x10FFFF) return m; return String.fromCodePoint(cp); }catch{ return m; } });
    const GREEK_MAP = { '&alpha;':'α','&beta;':'β','&gamma;':'γ','&delta;':'δ','&epsilon;':'ε','&zeta;':'ζ','&eta;':'η','&theta;':'θ','&iota;':'ι','&kappa;':'κ','&lambda;':'λ','&mu;':'μ','&nu;':'ν','&xi;':'ξ','&omicron;':'ο','&pi;':'π','&rho;':'ρ','&sigma;':'σ','&tau;':'τ','&upsilon;':'υ','&phi;':'φ','&chi;':'χ','&psi;':'ψ','&omega;':'ω','&Alpha;':'Α','&Beta;':'Β','&Gamma;':'Γ','&Delta;':'Δ','&Epsilon;':'Ε','&Zeta;':'Ζ','&Eta;':'Η','&Theta;':'Θ','&Iota;':'Ι','&Kappa;':'Κ','&Lambda;':'Λ','&Mu;':'Μ','&Nu;':'Ν','&Xi;':'Ξ','&Omicron;':'Ο','&Pi;':'Π','&Rho;':'Ρ','&Sigma;':'Σ','&Tau;':'Τ','&Upsilon;':'Υ','&Phi;':'Φ','&Chi;':'Χ','&Psi;':'Ψ','&Omega;':'Ω','&sigmaf;':'ς','&thetasym;':'ϑ','&upsih;':'ϒ','&varphi;':'ϕ' };
    const decodeGreekNamed = (s)=> String(s||'').replace(/&(alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Alpha|Beta|Gamma|Delta|Epsilon|Zeta|Eta|Theta|Iota|Kappa|Lambda|Mu|Nu|Xi|Omicron|Pi|Rho|Sigma|Tau|Upsilon|Phi|Chi|Psi|Omega|sigmaf|thetasym|upsih|varphi);/g, (m)=> GREEK_MAP[m]||m);
    const safeText = (s)=> esc(decodeGreekNamed(decodeNumericEntities(s)));

        function updateKeyState(){
            try{
                const val = (document.getElementById('globalGemKey')?.value||'').trim();
                const enabled = !!document.getElementById('globalGemEnable')?.checked;
                const ok = !!val && enabled;
                const badge = document.getElementById('globalKeyBadge2');
                if(badge){ badge.classList.toggle('ok', ok); badge.classList.toggle('missing', !ok); const h=badge.querySelector('.hint'); if(h) h.textContent = ok ? 'Key set' : 'No key set'; }
                if(btn) btn.disabled = !ok;
            }catch{}
        }
        updateKeyState();
    document.getElementById('globalGemKey')?.addEventListener('input', updateKeyState);
    document.getElementById('globalGemEnable')?.addEventListener('change', updateKeyState);

    function hideAiLike() { try{ if(window.__parsed) { if(wrap){ wrap.classList.add('hidden'); } } }catch{} }
    document.getElementById("startBtn")?.addEventListener("click", hideAiLike);
    document.getElementById("beginFromPreview")?.addEventListener("click", hideAiLike);

    // Prevent double-binding across duplicate initializers
    if(btn && btn.dataset.boundLike === '1') return;
    if(btn) btn.dataset.boundLike = '1';
    btn?.addEventListener("click", async () => {
            const paste = document.getElementById("paste");
            if (!paste || !paste.value.trim()) { alert("Paste your questions first."); return; }

            if (!window.GoogleGenerativeAI) {
                try { const mod = await import("https://esm.run/@google/generative-ai"); window.GoogleGenerativeAI = mod.GoogleGenerativeAI; } catch (e) { alert("Could not load Gemini SDK. Check your connection and try again."); return; }
            }

            const key = (document.getElementById('globalGemKey')?.value || '').trim();
            const enabled = !!document.getElementById('globalGemEnable')?.checked;
            if (!key || !enabled) { alert('Enable the API key (toggle in the key bar) and enter your Gemini API key.'); stat.textContent = 'API key disabled or missing.'; return; }

            const original = paste.value;
            const extraCtx = (window.__tbValidateCtx?.pieces||[]).map(p=> p.text).join('\n\n');
            const prompt = `You are an expert MCQ grader. You will receive a full MCQ set with an ANSWER KEY at the end. Ignore the key when choosing answers. Use the textbook context only as background knowledge.\n\nTASK: For EACH question, independently select the single best option letter from its choices.\n\nSTRICT OUTPUT FORMAT (no prose, no summary, no blanks):\nQ<N>: <LETTER>\n\n- Output one line per question, in order, covering ALL questions.\n- LETTER must be one of A-F and must exist among the options for that question.\n- Do not include the ANSWER KEY in your reasoning or output.\n- Output nothing else.\n\nBackground context (do not quote):\n${extraCtx}\n\nDocument:\n${original}`;

            btn.disabled = true; const orig = btn.textContent; btn.innerHTML = '<span class="spinner" aria-hidden="true"></span> Contacting…';
            stat.textContent = "Contacting Gemini 2.5…";
            try {
                const AI = window.GoogleGenerativeAI;
                const client = new AI(key);
                const model = client.getGenerativeModel({ model: "gemini-2.5-flash" });

                const resp = await model.generateContent({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
                const text = (await resp?.response?.text?.())?.trim();
                if (!text) throw new Error("Empty response from model.");

                    // Parse predictions from Pass 1 and render confirmed mismatches
                const dst = document.getElementById('aiValidateOutput2');
                try{
                    const full = (text||'').split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
                    const pass1 = {}; // qnum -> predictedLetter
                    for(const line of full){
                        const m = line.match(/^Q\s*(\d+)\s*:\s*([A-F])/i);
                        if(m){ pass1[m[1]] = m[2].toUpperCase(); }
                    }

                    // Parse the original document into items and compute pass-1 mismatches locally
                    const parser = (typeof window !== 'undefined' && window.parseDoc) ? window.parseDoc : (typeof parseDoc === 'function' ? parseDoc : null);
                    const items = parser ? parser(original || '') : [];
                    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
                    const pass1Mismatches = {}; // qnum -> letter
                    const initialMismatchedItems = [];
                    for(const it of items){
                        const p = (pass1[String(it.num)]||'').toUpperCase();
                        if(!p) continue;
                        const currentKey = letters[it.correctIdx] || 'A';
                        if(p !== currentKey){ pass1Mismatches[String(it.num)] = p; initialMismatchedItems.push(it); }
                    }

                    // Second pass: confirm only mismatches; keep only reaffirmed ones
                    let cleanedMismatches = { ...pass1Mismatches };
                    let mismatchedItems = initialMismatchedItems.slice();
                    if(Object.keys(pass1Mismatches).length){
                        stat.textContent = 'Double-checking mismatches…';
                        const subsetBlock = initialMismatchedItems.map(it=>{
                            const opts = it.choices.map((c,i)=>`- ${(letters[i]||'?')}. ${c}`).join('\n');
                            return `Q${it.num}. ${it.q}\n${opts}`;
                        }).join('\n\n');
                        const prompt2 = `Re-evaluate ONLY these questions and provide your FINAL best answer. If you cannot confidently pick one option, output '?' for that question.\n\nSTRICT OUTPUT: one line per question, no prose, format exactly:\nQ<N>: <LETTER or ?>\n\nQuestions:\n${subsetBlock}`;
                        try{
                            const resp2 = await model.generateContent({ contents: [{ role: 'user', parts: [{ text: prompt2 }] }] });
                            const text2 = (await resp2?.response?.text?.())?.trim();
                            const confirm = {};
                            if(text2){
                                text2.split(/\r?\n/).map(l=>l.trim()).filter(Boolean).forEach(l=>{
                                    const m2 = l.match(/^Q\s*(\d+)\s*:\s*([A-F\?])/i);
                                    if(m2){ confirm[m2[1]] = m2[2].toUpperCase(); }
                                });
                            }
                            const finalMap = {};
                            const finalItems = [];
                            for(const it of initialMismatchedItems){
                                const q = String(it.num);
                                const p1 = pass1Mismatches[q];
                                const p2 = confirm[q] || '';
                                const currentKey = letters[it.correctIdx] || 'A';
                                if(p2 && p2 !== '?' && p2 === p1 && p2 !== currentKey){ finalMap[q] = p2; finalItems.push(it); }
                            }
                            cleanedMismatches = finalMap; mismatchedItems = finalItems;
                        }catch(e){ console.warn('Second-pass confirm failed; using first pass', e); }
                    }

                        // rendering helpers (show current Key and AI-correct letter side by side)
                    const renderItemHTML = it => {
                        const currentKey = letters[it.correctIdx] || 'A';
                        const aiKey = (cleanedMismatches[String(it.num)] || '').toUpperCase();
                        const choicesHtml = it.choices.map((c,i)=>{
                            const L = (letters[i]||'?');
                            let cls = 'validator-choice';
                            if(L === aiKey) cls += ' correct';
                            if(L === currentKey && L !== aiKey) cls += ' wrong';
                            return `<div class="${cls}" style="margin:0"><span class="tag">${L}.</span> ${safeText(c)}</div>`;
                        }).join('');
                        return `<div class="qcard"><div><strong>Q${esc(it.num)}.</strong> ${safeText(it.q)}</div><div style="margin-top:6px">${choicesHtml}</div><div class="hint" style="margin-top:6px; display:flex; align-items:center; justify-content:space-between; gap:12px"><div>Key: <span class="tag">${currentKey}</span></div><div>Correct: <span class="tag">${aiKey || '?'}</span></div></div></div>`;
                    };
                    const renderListHTML = list => list.map(renderItemHTML).join('');

                    const globalApply = document.getElementById('validatorApplyBtnGlobal');
                    if(globalApply){ globalApply.classList.add('hidden'); globalApply.style.display = 'none'; globalApply.disabled = false; globalApply.textContent = 'Apply corrections to text'; globalApply._mismatches = null; }
                        // Recompute counts from our cleaned mismatches to avoid model-side drift
                        const derivedMismatchCount = mismatchedItems.length;
                        const derivedOkCount = items.length ? (items.length - derivedMismatchCount) : 0;

                        if(!dst) {
                        stat.textContent = 'Validation complete.';
                        } else if(derivedMismatchCount === 0){
                        dst.innerHTML = `<div><strong>Summary:</strong> ${derivedOkCount} CORRECT, 0 INCORRECT</div><div class="hint">All answers appear correct.</div>`;
                        if(globalApply) { globalApply.classList.add('hidden'); globalApply.style.display = 'none'; globalApply._mismatches = null; }
                        try{ window.hideValidatorApplyButton && window.hideValidatorApplyButton(); }catch(e){}
                        stat.textContent = 'Validation complete.';
                    } else {
                        // collapsed / expanded UI with show more / show less
                            const collapsedN = Math.min(3, mismatchedItems.length);
                            const collapsedHTML = `<div><strong>Summary:</strong> ${derivedOkCount} CORRECT, ${derivedMismatchCount} INCORRECT</div>` + renderListHTML(mismatchedItems.slice(0, collapsedN)) + (mismatchedItems.length>collapsedN ? `<div style="margin-top:8px"><button type="button" id="validator-show-more" class="btn small">Show more</button></div>` : '');
                            const expandedHTML = `<div><strong>Summary:</strong> ${derivedOkCount} CORRECT, ${derivedMismatchCount} INCORRECT</div>` + renderListHTML(mismatchedItems) + `<div style="margin-top:8px"><button type="button" id="validator-show-less" class="btn small">Show less</button></div>`;

                        dst.innerHTML = collapsedHTML;
                        dst.style.cursor = 'auto';
                        // The apply button will render under the Validate button via window.showValidatorApplyButton

                        const attachShowMore = () => {
                            const a = dst.querySelector('#validator-show-more');
                            if(!a) return;
                            if(a._attached) return; a._attached = true;
                            a.addEventListener('click', e=>{
                                e.preventDefault();
                                dst.innerHTML = expandedHTML;
                                const less = dst.querySelector('#validator-show-less');
                                if(less){
                                    if(!less._attached){ less._attached = true; less.addEventListener('click', e2=>{ e2.preventDefault(); dst.innerHTML = collapsedHTML; attachShowMore(); }); }
                                }
                            });
                        };

                        // initial attachments
                        attachShowMore();

                        try{ window.showValidatorApplyButton && window.showValidatorApplyButton(cleanedMismatches); }catch(e){ console.error(e); }
                        // Fallback placement to ensure visibility right under the output
                        try{
                            const actions = document.getElementById('aiValidateActions');
                            if(actions){
                                let applyBtn = document.getElementById('validatorApplyBtnGlobal');
                                if(!applyBtn){
                                    applyBtn = document.createElement('button');
                                    applyBtn.id = 'validatorApplyBtnGlobal';
                                    applyBtn.className = 'btn primary';
                                    applyBtn.textContent = 'Apply corrections to text';
                                }
                                applyBtn._mismatches = cleanedMismatches;
                                applyBtn.classList.remove('hidden');
                                applyBtn.style.display = 'inline-block';
                                if(applyBtn.parentNode !== actions){ actions.appendChild(applyBtn); }
                                if(!applyBtn._attached){
                                    applyBtn._attached = true;
                                    applyBtn.addEventListener('click', function(e){ e.preventDefault(); try{ window.applyValidationCorrections && window.applyValidationCorrections(applyBtn._mismatches||{}); applyBtn.textContent = 'Incorrect Answers Corrected'; applyBtn.disabled = true; }catch(err){ console.error('Apply corrections failed', err); } });
                                }
                            }
                        }catch(e){ console.error('fallback apply placement failed', e); }

                        stat.textContent = 'Validation complete.';
                    }
                }catch(e){
                    console.error('Render validator output failed', e);
                    if(dst) dst.textContent = (text||'');
                    stat.textContent = 'Validation complete.';
                }
            } catch (err) {
                console.error(err);
                stat.textContent = "AI validation failed.";
                // fallback to local validator if available
                try{
                    // Use local validator to find mismatches and render same UI
                    const txt = paste.value || '';
                    const res = window.answerValidator.validate(txt);
                    const dst = document.getElementById('aiValidateOutput2');
                    if(!dst){ stat.textContent = res.ok ? 'Local validation CORRECT.' : 'Local validation found issues.'; }
                    // If local found issues, try to extract which questions are missing/incorrect
                    const parser2 = (typeof window !== 'undefined' && window.parseDoc) ? window.parseDoc : (typeof parseDoc === 'function' ? parseDoc : null);
                    const items = parser2 ? parser2(txt) : [];
                    const badNums = new Set();
                    if(!res.ok){
                        res.issues.forEach(i=>{
                            const m = (i||'').match(/Q(\d+)/); if(m) badNums.add(m[1]);
                            const m2 = (i||'').match(/Missing answer for Q(\d+)/i); if(m2) badNums.add(m2[1]);
                        });
                    }
                    const mismatchedItems = items.filter(it=>badNums.has(it.num));
                    const globalApply = document.getElementById('validatorApplyBtnGlobal');
                    if(mismatchedItems.length===0){
                        if(dst) dst.innerHTML = `<div><strong>Summary:</strong> ${res.ok ? `${res.questions} CORRECT, 0 INCORRECT` : 'Issues detected'}</div><div class="hint">All answers appear correct.</div>`;
                        if(globalApply){ globalApply.classList.add('hidden'); globalApply._mismatches = null; }
                        try{ window.hideValidatorApplyButton && window.hideValidatorApplyButton(); }catch(e){}
                    } else {
                        const renderItemHTML = it => {
                            const currentKey = letters[it.correctIdx] || 'A';
                            const aiKey = (mismatchesMap && mismatchesMap[String(it.num)]) ? mismatchesMap[String(it.num)] : '?';
                            const choicesHtml = it.choices.map((c,i)=>{
                                const L = (letters[i]||'?');
                                let cls = 'validator-choice';
                                if(L === aiKey) cls += ' correct';
                                if(L === currentKey && L !== aiKey) cls += ' wrong';
                                return `<div class="${cls}" style="margin:0"><span class="tag">${L}.</span> ${safeText(c)}</div>`;
                            }).join('');
                            return `<div class="qcard"><div><strong>Q${esc(it.num)}.</strong> ${safeText(it.q)}</div><div style="margin-top:6px">${choicesHtml}</div><div class="hint" style="margin-top:6px; display:flex; align-items:center; justify-content:space-between; gap:12px"><div>Key: <span class="tag">${currentKey}</span></div><div>Correct: <span class="tag">${aiKey}</span></div></div></div>`;
                        };
                        const collapsedHTML = `<div><strong>Summary:</strong> Local issues: ${mismatchedItems.length} INCORRECT</div>` + mismatchedItems.slice(0,3).map(renderItemHTML).join('') + (mismatchedItems.length>3?`<div style="margin-top:8px"><button type="button" id="validator-show-more" class="btn small">Show more</button></div>`:'');
                        const expandedHTML = `<div><strong>Summary:</strong> Local issues: ${mismatchedItems.length} INCORRECT</div>` + mismatchedItems.map(renderItemHTML).join('') + `<div style="margin-top:8px"><button type="button" id="validator-show-less" class="btn small">Show less</button></div>`;
                        dst.innerHTML = collapsedHTML;
                        if(mismatchedItems.length>3){ const a = dst.querySelector('#validator-show-more'); if(a) a.addEventListener('click', e=>{ e.preventDefault(); dst.innerHTML = expandedHTML; const less = dst.querySelector('#validator-show-less'); if(less) less.addEventListener('click', e2=>{ e2.preventDefault(); dst.innerHTML = collapsedHTML; }); }); }
                        try{ const mismatchesMap = {}; mismatchedItems.forEach(it=>{ mismatchesMap[String(it.num)] = (letters[it.correctIdx]||'A'); }); window.showValidatorApplyButton && window.showValidatorApplyButton(mismatchesMap); }catch(e){ console.error(e); }
                    }
                }catch(ex){ alert("Gemini error: " + (err?.message || err)); }
            } finally {
                try{
                    const liveBtn = document.getElementById(btn?.id);
                    if(liveBtn) { liveBtn.disabled = false; try{ liveBtn.innerHTML = orig; }catch{} }
                    else if(btn) { btn.disabled = false; try{ btn.innerHTML = orig; }catch{} }
                }catch{}
            }
        });
    })();
    (async function aiLikeInit() {
        // Try to load Gemini SDK if not present (safe no-op if already loaded)
        if (!window.GoogleGenerativeAI) {
            try {
                const mod = await import("https://esm.run/@google/generative-ai");
                window.GoogleGenerativeAI = mod.GoogleGenerativeAI;
            } catch (e) {
                console.warn("Gemini SDK load failed (will retry on click).", e);
            }
        }

        const $ = id => document.getElementById(id);
        const wrap = $("ai-likeq");
        const btn = $("aiLikeBtn");
        // Use the global Gemini API key bar instead of a separate key input
        const stat = $("aiLikeStatus");

        // Ensure buttons reflect the current global key (safe local updater)
        function updateKeyState(){
            try{
                const val = (document.getElementById('globalGemKey')?.value||'').trim();
                const ok = !!val;
                const badge = document.getElementById('globalKeyBadge');
                if(badge){ badge.classList.toggle('ok', ok); badge.classList.toggle('missing', !ok); badge.querySelector('.hint').textContent = ok ? 'Key set' : 'No key set'; }
                if(btn) btn.disabled = !ok;
            }catch{}
        }
        // run once on init
        updateKeyState();
        // also watch for changes to the global key
        document.getElementById('globalGemKey')?.addEventListener('input', updateKeyState);

    // Hide this whole card once quiz begins
    function hideAiLike() { try{ if(window.__parsed) { if(wrap){ wrap.classList.add('hidden'); } } }catch{} }
    document.getElementById("startBtn")?.addEventListener("click", hideAiLike);
    document.getElementById("beginFromPreview")?.addEventListener("click", hideAiLike);

    // Prevent double-binding across duplicate initializers
    if(btn && btn.dataset.boundLike === '1') return;
    if(btn) btn.dataset.boundLike = '1';
    btn?.addEventListener("click", async () => {
            const paste = document.getElementById("paste");
            if (!paste || !paste.value.trim()) { alert("Paste your questions first."); return; }

            // Ensure SDK
            if (!window.GoogleGenerativeAI) {
                try {
                    const mod = await import("https://esm.run/@google/generative-ai");
                    window.GoogleGenerativeAI = mod.GoogleGenerativeAI;
                } catch (e) {
                    alert("Could not load Gemini SDK. Check your connection and try again.");
                    return;
                }
            }

            // Read key from global top bar
            const key = (document.getElementById('globalGemKey')?.value || '').trim();
            if (!key) { alert('Enter your Gemini API key in the top "Gemini API Key" bar.'); return; }

            // Build strict, structure-preserving prompt
            const original = paste.value;
            const prompt =
                `You are to conservatively rewrite the following MCQ set into LIKE-QUESTIONS for practice.
You MUST preserve:
- The exact document structure and formatting.
- The SAME number of questions.
- Each question prefixed "Q<number>. " on its own line.
- Each option on its own line, prefixed with "- ".
- A final "ANSWER KEY" section with one line per question in the form "<number>. <LETTER>".
- Exactly ONE correct option per question; options must be mutually exclusive and plausible.
- Domain and difficulty should be similar; small surface changes are preferred (synonyms, numerics, contexts).
- Do NOT include any extra commentary, JSON, or Markdown. Output ONLY the rewritten text.

Also:
- Ensure correctness: internally verify each keyed answer truly matches the best option.
- Keep language clear and unambiguous; avoid clues that trivially reveal the answer.
- If any item is malformed, repair it conservatively to follow the rules above.

Rewrite this set now:

${original}`;

            btn.disabled = true;
            const orig = btn.textContent;
            btn.innerHTML = '<span class="spinner" aria-hidden="true"></span> Contacting…';
            stat.textContent = "Contacting Gemini 2.5…";
            try {
                const AI = window.GoogleGenerativeAI;
                const client = new AI(key);
                const model = client.getGenerativeModel({ model: "gemini-2.5-flash" });

                const resp = await model.generateContent({
                    contents: [{ role: "user", parts: [{ text: prompt }] }]
                });

                const text = (await resp?.response?.text?.())?.trim();
                if (!text) throw new Error("Empty response from model.");

                // Very basic sanity checks to reduce surprises
                if (!/^\s*Q\s*\d+\./mi.test(text) || !/^\s*ANSWER\s+KEY\s*$/mi.test(text)) {
                    if (!confirm("The AI output didn't clearly match the expected structure. Insert anyway?")) {
                        stat.textContent = "Cancelled.";
                        try{
                            const live = document.getElementById(btn?.id) || btn;
                            live.disabled = false;
                            live.innerHTML = orig;
                        }catch{}
                        return;
                    }
                }

                // Show preview modal so user can Insert, Save, or Cancel. Propagate any source tag
                try{
                    window.showPreviewModal(text, ( !/^\s*Q\s*\d+/mi.test(text) || !/\bANSWER\s+KEY\b/mi.test(text) ) ? 'AI output may not match expected MCQ format' : '', function(choice){
                        try{
                            if(!choice) { stat.textContent = 'Cancelled.'; return; }
                            if(choice === true || (choice && choice.action === 'insert')){
                                paste.value = text;
                                document.getElementById('parseBtn')?.click();
                                stat.textContent = 'Inserted like-questions.';
                                // tag propagation removed
                                return;
                            }
                            if(choice && choice.action === 'save'){
                                try{
                                    const key = 'mcq.pastes.v1';
                                    const existing = (function(){ try{ return JSON.parse(localStorage.getItem(key)||'[]'); }catch(e){ return []; } })();
                                    const title = (text||'').split('\n').map(l=>l.trim()).filter(Boolean)[0] || 'Untitled';
                                    const savedText = (window.sanitizeMCQText ? window.sanitizeMCQText(text) : text);
                                    const item = { id: Date.now().toString(36), date: (new Date()).toISOString().slice(0,16).replace('T',' '), title: String(title).slice(0,200), text: savedText };
                                    existing.unshift(item);
                                    try{ localStorage.setItem(key, JSON.stringify(existing)); }catch(e){ console.warn('Could not save generated item', e); }
                                    stat.textContent = 'Saved generated questions.';
                                    try{ window.refreshLocalSaved && window.refreshLocalSaved(); }catch(e){}
                                }catch(e){ console.error('save generated failed', e); stat.textContent = 'Save failed.'; }
                                // tag propagation removed
                                return;
                            }
                            stat.textContent = 'Cancelled.';
                            // tag propagation removed
                        }catch(e){ console.error('preview callback failed', e); stat.textContent = 'Error during preview action.'; }
                    });
                }catch(e){ console.error('showPreviewModal failed', e); paste.value = text; document.getElementById('parseBtn')?.click(); stat.textContent = 'Inserted like-questions.'; }
            } catch (err) {
                console.error(err);
                stat.textContent = "AI generation failed.";
                alert("Gemini error: " + (err?.message || err));
            } finally {
                try{
                    const live = document.getElementById(btn?.id) || btn;
                    live.disabled = false;
                    live.innerHTML = orig;
                }catch{}
            }
        });
    })();
</script>
<script>
/* Avoid static ESM imports here so this script runs even under file://. */

const $ = (id)=>document.getElementById(id);

/* Global key persistence */
(function setupGlobalKey(){
  const keyI = $('globalGemKey');
  const chk = $('globalGemRemember');
    const en  = $('globalGemEnable');
    const badge = document.getElementById('globalKeyBadge');
    function isEnabled(){ return !!(en ? en.checked : true); }
    function updateKeyUI(){
            let rawVal = (keyI?.value||'').trim();
            // If input is empty, consider stored keys (two storage keys used across the app)
            if(!rawVal){ try{ rawVal = localStorage.getItem('gemini.key') || localStorage.getItem('gemKeyGlobal') || ''; }catch(e){} }
            const ok = !!rawVal && isEnabled();
        try{
            // update all badges with these ids (handles duplicate-id copies)
            const badgeIds = ['globalKeyBadge','globalKeyBadge2','validateKeyBadge','validateKeyBadgeCopy','fileGenKeyBadge'];
            badgeIds.forEach(id => {
                const nodes = document.querySelectorAll('#' + id);
                nodes.forEach(b => {
                    b.classList.toggle('ok', ok); b.classList.toggle('missing', !ok);
                    const h = b.querySelector('.hint'); if(h) h.textContent = ok ? 'Key set' : 'No key set';
                });
            });

            // update all buttons with these ids (include the Daily Random Quiz button so it is disabled when no key)
            const btnIds = ['aiLikeBtn','aiLikeBtn2','aiFileGenBtn','validateAnswersBtn','aiValidateBtn','dailyQuizBtn','randomQuizBtn'];
            btnIds.forEach(id => {
                const nodes = document.querySelectorAll('#' + id);
                nodes.forEach(n => {
                    try{ n.disabled = !ok; }catch{};
                    try{ if(!ok) n.setAttribute('aria-disabled', 'true'); else n.removeAttribute('aria-disabled'); }catch{};
                });
            });
            // top-left single dot
            const topDot = document.getElementById('globalKeyDot'); if(topDot){ topDot.classList.toggle('ok', ok); topDot.classList.toggle('missing', !ok); }
            // daily button dot (left side of Daily Random Quiz)
            const dailyDot = document.getElementById('dailyKeyDot'); if(dailyDot){ dailyDot.classList.toggle('ok', ok); dailyDot.classList.toggle('missing', !ok); }
            // random button dot (left side of Random Quiz)
            const randomDot = document.getElementById('randomKeyDot'); if(randomDot){ randomDot.classList.toggle('ok', ok); randomDot.classList.toggle('missing', !ok); }
            // AI Explanation header dot
            const aiDot = document.getElementById('aiExplanationKeyDot');
            if(aiDot){
                aiDot.classList.toggle('ok', ok); aiDot.classList.toggle('missing', !ok);
                try{ aiDot.title = ok ? 'API key enabled' : 'API key disabled'; }catch(e){}
            }
            // Drive a persistent root-level class so the dot color survives re-renders
            try{ document.documentElement.classList.toggle('ai-key-ok', !!ok); document.documentElement.classList.toggle('ai-key-missing', !ok); }catch(e){}
            // switch label
            const lab = document.getElementById('globalGemEnableLabel'); if(lab){ lab.textContent = isEnabled() ? 'enabled' : 'disabled'; }
        }catch{}
    }
    // Shared helper used by various AI flows to resolve the effective Gemini key
    window.getEffectiveGemKey = function(){
        try{
            const input = document.getElementById('globalGemKey');
            const enable = document.getElementById('globalGemEnable');
            const remember = document.getElementById('globalGemRemember');
            if(enable && enable.checked === false) return null;
            if(input && String(input.value||'').trim()){
                const v = String(input.value).trim();
                try{ if(remember && remember.checked) localStorage.setItem('gemini.key', v); }catch(e){}
                return v;
            }
            try{ const stored = localStorage.getItem('gemini.key'); if(stored) return stored; }catch(e){}
            return null;
        }catch(e){ return null; }
    };
  try{
    const k = localStorage.getItem('gemKeyGlobal');
    if(k){ keyI.value = k; chk.checked = true; }
  }catch{}
    // update UI after restoring stored key and reflect default toggle OFF
    updateKeyUI();
    chk?.addEventListener('change', ()=>{
    try{
      if(chk.checked) localStorage.setItem('gemKeyGlobal', keyI.value||'');
      else localStorage.removeItem('gemKeyGlobal');
    }catch{}
  });
    en?.addEventListener('change', ()=>{
        // toggling does not destroy stored key; it only affects whether features treat it as present
        updateKeyUI();
    });
    // Watch storage events so badges update across tabs
    window.addEventListener('storage', (ev)=>{ if(ev.key && (ev.key==='gemini.key' || ev.key==='gemKeyGlobal')){ updateKeyUI(); } });
    keyI?.addEventListener('input', ()=>{
        if(chk.checked){ try{ localStorage.setItem('gemKeyGlobal', keyI.value||''); }catch{} }
        updateKeyUI();
    });
    keyI?.addEventListener('change', updateKeyUI);
})();

/* ---------- AI Output Preview helper (global) ---------- */
// sanitize MCQ text for saving/export: strip HTML, normalize whitespace, and append ANSWER KEY if missing
window.sanitizeMCQText = function(raw){
    try{
        let s = String(raw||'');
        // convert simple <br> to newline
        s = s.replace(/<br\s*\/?>/gi, '\n');
        // strip all tags
        s = s.replace(/<[^>]+>/g, '');
        // normalize spaces/newlines
        s = s.replace(/\r\n?/g, '\n');
        s = s.replace(/\u00A0/g, ' ');
        s = s.replace(/\t+/g, ' ');
        // collapse multiple blank lines to single
        s = s.replace(/\n{3,}/g, '\n\n');
        s = s.replace(/[ \t]+\n/g, '\n');
        s = (window.normalizeGreek ? normalizeGreek(s) : s).trim();
        // Ensure ANSWER KEY exists; if not, try to use parseDoc to build one
        if(!/\bANSWER\s+KEY\b/i.test(s)){
            try{
                const parser = (typeof window.parseDoc === 'function') ? window.parseDoc : (window.parseDoc || null);
                if(parser){
                    const items = parser(s) || [];
                    if(items && items.length){
                        const letters = ['A','B','C','D','E','F','G'];
                        const rows = items.map(it=>{ const n = it.num || ''; const idx = (typeof it.correctIdx === 'number') ? it.correctIdx : (it.key ? ('ABCDEF'.indexOf(String(it.key).toUpperCase())):-1); const letter = (idx!=null && idx>=0) ? (letters[idx]||'A') : '?'; return `${n}. ${letter}`; });
                        s = s + '\n\nANSWER KEY\n' + rows.join('\n');
                    }
                }
            }catch(e){ /* ignore */ }
        }
        return s;
    }catch(e){ return String(raw||''); }
};
window.showPreviewModal = function(previewText, warningText, cb){
    try{
        const modal = document.getElementById('aiPreviewModal');
        const content = document.getElementById('aiPreviewContent');
        const hint = document.getElementById('aiPreviewHint');
        const insertBtn = document.getElementById('aiPreviewInsert');
        const cancelBtn = document.getElementById('aiPreviewCancel');
        const closeBtn = document.getElementById('aiPreviewClose');
    const saveBtn = document.getElementById('aiPreviewSave');
        if(!modal || !content || !insertBtn) { if(cb) cb({ action: 'insert' }); return; }
        // fill
        content.textContent = previewText || '';
        hint.textContent = warningText || '';
    // tags input removed; nothing to clear
        modal.classList.remove('hidden'); modal.setAttribute('aria-hidden','false');

        function cleanup(){
            modal.classList.add('hidden'); modal.setAttribute('aria-hidden','true');
            insertBtn.removeEventListener('click', onInsert);
            cancelBtn.removeEventListener('click', onCancel);
            closeBtn.removeEventListener('click', onCancel);
            if(saveBtn) saveBtn.removeEventListener('click', onSave);
        }
        function onInsert(){ cleanup(); if(cb) cb({ action: 'insert' }); }
        function onCancel(){ cleanup(); if(cb) cb({ action: 'cancel' }); }
        function onSave(){ cleanup(); if(cb) cb({ action: 'save' }); }
        insertBtn.addEventListener('click', onInsert);
        cancelBtn.addEventListener('click', onCancel);
        closeBtn.addEventListener('click', onCancel);
    if(saveBtn) saveBtn.addEventListener('click', onSave);
    }catch(e){ console.error(e); if(cb) cb({ action: 'insert' }); }
};

/* ---------- AI refs draft persistence (for Inserted-but-not-yet-saved generated quizzes) ---------- */
// The generate-from-file flow can attach per-question source hints via `window.__aiMcqSourceHints`.
// If the user clicks "Insert full output" (instead of "Save generated"), we still persist those refs
// keyed to the inserted text so later "Save MCQ" can carry them into Saved MCQs (even after a reload).
(function(){
    const DRAFT_KEY = 'mcq.refsDraft.v1';

    function fnv1a32(str){
        // 32-bit FNV-1a
        let h = 0x811c9dc5;
        for(let i=0;i<str.length;i++){
            h ^= str.charCodeAt(i);
            // h *= 16777619 (use bit ops)
            h = (h + ((h<<1) + (h<<4) + (h<<7) + (h<<8) + (h<<24))) >>> 0;
        }
        return ('00000000' + h.toString(16)).slice(-8);
    }
    function fingerprint(text){
        try{
            const t = (window.normalizeGreek ? window.normalizeGreek(String(text||'')) : String(text||''));
            return `${t.length}:${fnv1a32(t)}`;
        }catch(e){
            const t = String(text||'');
            return `${t.length}:${fnv1a32(t)}`;
        }
    }
    function loadArr(){
        try{ return JSON.parse(localStorage.getItem(DRAFT_KEY)||'[]'); }catch(e){ return []; }
    }
    function saveArr(arr){
        try{ localStorage.setItem(DRAFT_KEY, JSON.stringify(arr||[])); }catch(e){}
    }

    window.__mcqRefsDraftPut = function(text, sourceHints, extra){
        try{
            if(!sourceHints || typeof sourceHints !== 'object') return false;
            const keys = Object.keys(sourceHints);
            if(!keys.length) return false;
            const fp = fingerprint(text);
            const cloned = JSON.parse(JSON.stringify(sourceHints));
            let arr = loadArr();
            // replace existing entry for same fingerprint
            arr = (arr||[]).filter(r => r && r.fp !== fp);
            arr.unshift({ fp, t: Date.now(), sourceHints: cloned, extra: extra || null });
            // cap growth
            arr = arr.slice(0, 8);
            saveArr(arr);
            return true;
        }catch(e){ return false; }
    };

    window.__mcqRefsDraftGet = function(text){
        try{
            const fp = fingerprint(text);
            const arr = loadArr();
            const rec = (arr||[]).find(r => r && r.fp === fp);
            return rec && rec.sourceHints && typeof rec.sourceHints === 'object' ? rec.sourceHints : null;
        }catch(e){ return null; }
    };

    window.__mcqRefsDraftDel = function(text){
        try{
            const fp = fingerprint(text);
            const arr = loadArr();
            const next = (arr||[]).filter(r => r && r.fp !== fp);
            if(next.length !== (arr||[]).length) saveArr(next);
            return true;
        }catch(e){ return false; }
    };
})();

// Apply validator corrections into the pasted document's ANSWER KEY and reparse
window.applyValidationCorrections = function(mismatches){
    try{
        if(!mismatches || typeof mismatches !== 'object') return;
        const paste = document.getElementById('paste');
        if(!paste) return;
    const text = normalizeGreek(paste.value || '');
        const lines = text.replace(/\r\n?/g,'\n').split('\n');
        const keyIdx = lines.findIndex(l => /^\s*ANSWER\s+KEY\s*$/i.test(l));
        // build a map of existing answers
        const answerLines = [];
        if(keyIdx !== -1){
            for(let k = keyIdx+1; k < lines.length; k++){
                if(!/^\s*\d+/i.test(lines[k])) break;
                answerLines.push(lines[k]);
            }
        }

        // create or replace answer key section
        const maxQ = Object.keys(mismatches).reduce((m,n)=> Math.max(m, parseInt(n,10)||0), 0);
        const items = [];
        // If parsed items exist, we prefer to use their numbering; fallback to mismatches keys
        try{ const parsed = window.parseDoc && window.parseDoc(paste.value || ''); parsed && parsed.forEach(it=> items.push(it.num)); }catch{};

        // Build replacement lines: keep other lines intact, replace or append ANSWER KEY
        const newLines = [];
        if(keyIdx === -1){
            // append ANSWER KEY at end
            newLines.push(...lines);
            newLines.push('');
            newLines.push('ANSWER KEY');
            // if we have parsed items, use those numbers; otherwise use mismatch keys
            const qnums = items.length ? items : Object.keys(mismatches).map(n=>parseInt(n,10)).sort((a,b)=>a-b);
            qnums.forEach(n=>{
                const k = String(n);
                const letter = mismatches[k] || '';
                newLines.push(`${n}. ${letter}`);
            });
        } else {
            // copy until ANSWER KEY header
            newLines.push(...lines.slice(0, keyIdx+1));
            // build a map of existing answers to preserve non-mismatched ones
            const existing = {};
            for(let k = keyIdx+1; k < lines.length; k++){
                const m = lines[k].match(/^(\d+)\s*\.?\s*([A-F])/i);
                if(!m) break;
                existing[m[1]] = m[2].toUpperCase();
            }
            // compute full set of question numbers to write
            const qnums = Array.from(new Set([ ...Object.keys(existing).map(n=>parseInt(n,10)), ...Object.keys(mismatches).map(n=>parseInt(n,10)) ])).filter(Boolean).sort((a,b)=>a-b);
            qnums.forEach(n=>{
                const k = String(n);
                const letter = (mismatches[k] || existing[k] || '').toUpperCase();
                newLines.push(`${n}. ${letter}`);
            });
        }

        // commit and reparse
    paste.value = normalizeGreek(newLines.join('\n'));
        // trigger parse
        const btn = document.getElementById('parseBtn'); if(btn) btn.click();
    }catch(e){ console.error('applyValidationCorrections', e); }
};

// UI helpers to show/hide the global Apply Corrections button under the validator output
window.showValidatorApplyButton = function(mismatches){
    try{
        let btn = document.getElementById('validatorApplyBtnGlobal');
        // If the button isn't in the DOM for any reason, create it
        if(!btn){
            btn = document.createElement('button');
            btn.id = 'validatorApplyBtnGlobal';
            btn.className = 'btn primary';
            btn.textContent = 'Apply corrections to text';
        }
        btn._mismatches = mismatches || null;
        btn.classList.remove('hidden');
        btn.style.display = 'inline-block';
        btn.style.marginTop = '8px';
        btn.disabled = false;
        btn.textContent = 'Apply corrections to text';
        if(!btn._attached){
            btn._attached = true;
            btn.addEventListener('click', function onValidatorApply(e){
                e.preventDefault();
                try{
                    window.applyValidationCorrections && window.applyValidationCorrections(btn._mismatches);
                    btn.textContent = 'Incorrect Answers Corrected';
                    btn.disabled = true;
                }catch(err){ console.error('Apply corrections failed', err); btn.textContent = 'Apply failed'; }
            });
        }
        // Place the button directly under the validator output area
        try{
            const dst = document.getElementById('aiValidateOutput2');
            const actions = document.getElementById('aiValidateActions');
            if((actions || dst) && (actions?.parentNode || dst?.parentNode)){
                // Ensure margin reset suitable for below-output placement
                btn.style.marginLeft = '0px';
                btn.style.marginTop = '8px';
                // Preferred: actions container just beneath output
                if(actions){
                    if(btn.parentNode !== actions){ actions.appendChild(btn); }
                } else if(dst){
                    // Fallback: insert after output element
                    if(btn.parentNode !== dst.parentNode || btn.previousElementSibling !== dst){
                        dst.parentNode.insertBefore(btn, dst.nextSibling);
                    }
                }
                try{ btn.scrollIntoView({behavior:'smooth', block:'center'}); }catch(e){}
            } else {
                // Fallback to floating position near output rect if present
                try{ window.showFloatingApply && window.showFloatingApply(mismatches, dst); }catch(_){ }
            }
        }catch(e){ console.error('showValidatorApplyButton placement error', e); }
    }catch(e){ console.error(e); }
};

window.hideValidatorApplyButton = function(){
    try{
        const btn = document.getElementById('validatorApplyBtnGlobal');
        if(!btn) return;
        btn._mismatches = null;
        btn.disabled = false;
        btn.textContent = 'Apply corrections to text';
        btn.style.display = 'none';
        btn.classList.add('hidden');
    }catch(e){ console.error(e); }
};

// Floating apply button: create a visible floating button positioned under the validator output
window.showFloatingApply = function(mismatches, dstElement){
    try{
        // create container if not present
        let wrap = document.getElementById('validatorApplyFloating');
        if(!wrap){
            wrap = document.createElement('div'); wrap.id = 'validatorApplyFloating';
            wrap.style.position = 'fixed'; wrap.style.zIndex = 99999; wrap.style.display = 'none';
            wrap.style.pointerEvents = 'auto';
            const btn = document.createElement('button'); btn.id = 'validatorApplyFloatingBtn'; btn.className = 'btn primary';
            btn.style.padding = '';
            btn.style.borderRadius = '';
            btn.textContent = 'Apply corrections to text';
            wrap.appendChild(btn);
            document.body.appendChild(wrap);
            btn.addEventListener('click', function(e){ e.preventDefault(); try{ window.applyValidationCorrections && window.applyValidationCorrections(wrap._mismatches||{}); btn.textContent = 'Incorrect Answers Corrected'; btn.disabled = true; }catch(err){ console.error(err); btn.textContent = 'Apply failed'; } });
        }
        // attach mismatches
        wrap._mismatches = mismatches || {};
        // position under dstElement if provided
        let left = 20, top = window.innerHeight - 80;
        if(dstElement && dstElement.getBoundingClientRect){
            const r = dstElement.getBoundingClientRect();
            left = Math.max(8, r.left + window.scrollX);
            top = r.bottom + window.scrollY + 8;
            // if off screen at bottom, clamp
            if(top + 48 > window.scrollY + window.innerHeight) top = window.scrollY + window.innerHeight - 64;
        }
        wrap.style.left = left + 'px'; wrap.style.top = top + 'px'; wrap.style.display = 'block';
        // ensure visible
    try{ wrap.scrollIntoView({behavior:'smooth', block:'center'}); }catch(e){}
    }catch(e){ console.error('showFloatingApply', e); }
};

window.hideFloatingApply = function(){ try{ const w = document.getElementById('validatorApplyFloating'); if(w) w.style.display = 'none'; }catch(e){ } };

/* ---------- Answer validator (client-side; placeholder for server-side integration) ---------- */
window.answerValidator = {
    parseQuestions(text){
        const lines = (text||'').replace(/\r\n?/g,'\n').split('\n');
        const qre = /^Q\s*(\d+)\.\s*(.+)$/i;
        const items = [];
        for(let i=0;i<lines.length;i++){
            const m = lines[i].match(qre);
            if(m) items.push({num: parseInt(m[1],10), text: m[2].trim(), line: i+1});
        }
        return items;
    },
    parseAnswerKey(text){
        const lines = (text||'').replace(/\r\n?/g,'\n').split('\n');
        const keyIdx = lines.findIndex(l => /^\s*ANSWER\s+KEY\s*$/i.test(l));
        if(keyIdx === -1) return {keyMap:{}, startLine:-1};
        const keyMap = {};
        for(let k=keyIdx+1;k<lines.length;k++){
            const m = lines[k].match(/^(\d+)\s*\.?\s*([A-F])/i);
            if(m) keyMap[parseInt(m[1],10)] = m[2].toUpperCase();
        }
        return {keyMap, startLine: keyIdx+1};
    },
    validate(text){
        const qs = this.parseQuestions(text);
        const {keyMap, startLine} = this.parseAnswerKey(text);
        const issues = [];
        if(qs.length === 0) issues.push('No questions found (expect lines starting `Q1. ` etc).');
        // check numbering sequence
        const nums = qs.map(q=>q.num).sort((a,b)=>a-b);
        for(let i=0;i<nums.length;i++){
            if(nums[i] !== i+1) { issues.push(`Question numbering gap or mismatch: expected Q${i+1} but found Q${nums[i]||'?'}`); break; }
        }
        // Check answer key presence
        if(Object.keys(keyMap).length === 0) issues.push('No ANSWER KEY found or no valid entries under ANSWER KEY.');
        // Compare counts
        if(qs.length && Object.keys(keyMap).length && qs.length !== Object.keys(keyMap).length) issues.push(`Question count (${qs.length}) and ANSWER KEY entries (${Object.keys(keyMap).length}) differ.`);
        // Missing answers
        qs.forEach(q=>{ if(!(q.num in keyMap)) issues.push(`Missing answer for Q${q.num}`); });
        // Out-of-range letters and duplicates
        const seen = {};
        Object.entries(keyMap).forEach(([n,ch])=>{
            if(!/^[A-F]$/.test(ch)) issues.push(`Answer for Q${n} uses invalid letter '${ch}'. Use A-F.`);
            if(seen[n]) issues.push(`Duplicate key entry for Q${n}`);
            seen[n]=ch;
        });
        return {ok: issues.length===0, issues, questions: qs.length, answers: Object.keys(keyMap).length, keyStartLine: startLine};
    }
};

// The old runValidateAnswers handler was removed. A functional AI-like validator initializer is added below.

/* === AI: Generate MCQs from .docx/.pdf (new approach: client-side extraction) === */
(function initAiFileGenNew(){
    function bind(){
    const $ = (id) => document.getElementById(id);
    const fileInput = $('aiFile');
        const btn = $('aiFileGenBtn');
        const statusEl = $('aiFileStatus');
    const qCountEl = $('aiQCount');
    const optCountEl = $('aiOptCount');
    const autoBtn = $('aiAutoBtn');
    const typeMcqEl = $('aiTypeMcq');
    const typeTfEl = $('aiTypeTf');
    const typeFibEl = $('aiTypeFib');
    const typeMatchEl = $('aiTypeMatch');
    let autoMode = false;
        if(!fileInput || !btn || !statusEl) return false;

        // Lock button width to its initial rendered width to avoid layout reflow on label changes
        try{
            if(!btn.dataset.widthLocked){
                const w = Math.ceil(btn.getBoundingClientRect().width);
                if(w && isFinite(w)){
                    btn.style.width = w + 'px';
                    btn.style.maxWidth = w + 'px';
                    btn.style.flex = `0 0 ${w}px`;
                    btn.dataset.widthLocked = '1';
                }
            }
        }catch(e){}

        // Helper to lock/unlock the AI file row widths during processing
        function lockAiFileRow(lock){
            try{
                const row = document.querySelector('.ai-file-panel .ai-file-row');
                if(!row) return;
                const fileWrap = row.querySelector('.file-input');
                const badge = document.getElementById('fileGenKeyBadge');
                const fname = fileWrap ? fileWrap.querySelector('.filename') : null;
                const targets = [fileWrap, btn, badge, statusEl, fname].filter(Boolean);
                if(lock){
                    row.dataset.locked = '1';
                    targets.forEach(el=>{
                        const rect = el.getBoundingClientRect();
                        const w = Math.ceil(rect.width);
                        el.style.width = w + 'px';
                        el.style.maxWidth = w + 'px';
                        el.style.flex = `0 0 ${w}px`;
                    });
                } else {
                    delete row.dataset.locked;
                    targets.forEach(el=>{
                        el.style.width = '';
                        el.style.maxWidth = '';
                        el.style.flex = '';
                    });
                }
            }catch(e){}
        }

    function setStatus(msg, isError){ try{ statusEl.textContent = msg||''; statusEl.style.color = isError ? 'var(--bad)' : ''; }catch(e){} }
    function stripHtml(html){ return (html||'').replace(/<[^>]+>/g, ' ').replace(/\s+/g,' ').trim(); }
        function debugLog(...args){ try{ const p = document.getElementById('aiFileDebug'); if(!p) return; const t = args.map(a=>{ try{ return (typeof a==='string'?a:JSON.stringify(a)); }catch(e){ return String(a); } }).join(' '); p.textContent = (new Date()).toLocaleTimeString() + ' ' + t + '\n' + p.textContent; }catch(e){ console.log.apply(console, args); } }
        function loadScript(url){
            return new Promise((resolve,reject)=>{
                try{
                    const s = document.createElement('script');
                    s.src = url; s.async = true; s.onload = ()=>resolve(); s.onerror = ()=>reject(new Error('Failed to load '+url));
                    document.head.appendChild(s);
                }catch(e){ reject(e); }
            });
        }

        // Cache extracted text so changing question-type params doesn't re-extract/OCR the same document.
        // Keyed by file signature(s) + OCR toggle.
        const __aiFileExtractCache = (function(){
            try{
                if(window.__aiFileExtractCache && window.__aiFileExtractCache instanceof Map) return window.__aiFileExtractCache;
                const m = new Map();
                window.__aiFileExtractCache = m;
                return m;
            }catch(e){
                // Fallback: no cache
                return null;
            }
        })();

        function aiFileSig(f){
            try{
                if(!f) return '';
                return [f.name||'', String(f.size||0), String(f.lastModified||0), f.type||''].join('|');
            }catch(e){ return String(f && f.name || ''); }
        }

        function aiExtractCacheKey(files, ocrEnabled){
            try{
                const sig = (files||[]).map(aiFileSig).join('||');
                return `v1|ocr=${ocrEnabled?1:0}|files=${sig}`;
            }catch(e){ return null; }
        }

    // Load saved prefs
    try{
        if(qCountEl){ const savedQ = parseInt(localStorage.getItem('ai.mcq.qCount')||'30',10); if(isFinite(savedQ)) qCountEl.value = String(Math.max(1, Math.min(50, savedQ))); }
        if(optCountEl){ const savedO = parseInt(localStorage.getItem('ai.mcq.optCount')||'4',10); if(isFinite(savedO)) optCountEl.value = String(Math.max(2, Math.min(6, savedO))); }
        autoMode = localStorage.getItem('ai.mcq.auto') === '1';
        if(typeMcqEl){ typeMcqEl.checked = (localStorage.getItem('ai.qtypes.mcq') ?? '1') === '1'; }
        if(typeTfEl){ typeTfEl.checked = (localStorage.getItem('ai.qtypes.tf') ?? '0') === '1'; }
        if(typeFibEl){ typeFibEl.checked = (localStorage.getItem('ai.qtypes.fib') ?? '0') === '1'; }
        if(typeMatchEl){ typeMatchEl.checked = (localStorage.getItem('ai.qtypes.match') ?? '0') === '1'; }
    }catch{}

    function getSelectedTypes(){
        const types = [];
        if(typeMcqEl?.checked) types.push('mcq');
        if(typeTfEl?.checked) types.push('truefalse');
        if(typeFibEl?.checked) types.push('fillblank');
        if(typeMatchEl?.checked) types.push('matching');
        return types;
    }

    function enforceAtLeastOneType(){
        try{
            if(getSelectedTypes().length) return;
            if(typeMcqEl){ typeMcqEl.checked = true; }
        }catch(e){}
    }

    function persistTypes(){
        try{
            if(typeMcqEl) localStorage.setItem('ai.qtypes.mcq', typeMcqEl.checked ? '1' : '0');
            if(typeTfEl) localStorage.setItem('ai.qtypes.tf', typeTfEl.checked ? '1' : '0');
            if(typeFibEl) localStorage.setItem('ai.qtypes.fib', typeFibEl.checked ? '1' : '0');
            if(typeMatchEl) localStorage.setItem('ai.qtypes.match', typeMatchEl.checked ? '1' : '0');
        }catch(e){}
    }

    function syncTypeUI(){
        try{
            const mcqOn = !!typeMcqEl?.checked;
            if(optCountEl){
                if(!mcqOn){ optCountEl.disabled = true; }
                else { optCountEl.disabled = !!autoMode; }
            }
        }catch(e){}
    }

    // Auto mode UI sync and toggle
    function syncAutoUI(){
        try{
            if(autoBtn){ autoBtn.classList.toggle('primary', !!autoMode); autoBtn.setAttribute('aria-pressed', autoMode ? 'true' : 'false'); }
            if(qCountEl) qCountEl.disabled = !!autoMode;
            if(optCountEl){ if(autoMode){ optCountEl.value = '4'; } }
            syncTypeUI();
        }catch(e){}
    }
    syncAutoUI();

    // Wire type toggles
    [typeMcqEl, typeTfEl, typeFibEl, typeMatchEl].filter(Boolean).forEach(el=>{
        try{
            if(el.dataset.wired) return;
            el.addEventListener('change', ()=>{ enforceAtLeastOneType(); persistTypes(); syncTypeUI(); });
            el.dataset.wired = '1';
        }catch(e){}
    });
    enforceAtLeastOneType();
    persistTypes();
    syncTypeUI();
    if(autoBtn && !autoBtn.dataset.wired){
        autoBtn.addEventListener('click', (e)=>{
            e.preventDefault();
            autoMode = !autoMode;
            try{ localStorage.setItem('ai.mcq.auto', autoMode ? '1' : '0'); }catch{}
            syncAutoUI();
        });
        autoBtn.dataset.wired = '1';
    }

    btn.addEventListener('click', async (ev)=>{
        ev.preventDefault();
        console.log('[aiFileGenNew] click'); debugLog('click');
        setStatus('Starting...'); debugLog('starting');

        // Read and validate counts
    let qCount = parseInt(qCountEl?.value||'30',10); if(!isFinite(qCount)) qCount = 30; qCount = Math.max(1, Math.min(50, qCount));
    let optCount = parseInt(optCountEl?.value||'4',10); if(!isFinite(optCount)) optCount = 4; optCount = Math.max(2, Math.min(6, optCount));
    if(autoMode){ optCount = 4; }
    const selectedTypes = getSelectedTypes();
    if(!selectedTypes.length){ setStatus('Select at least one question type.', true); alert('Select at least one question type (MCQ, T/F, Fill blank, Matching).'); return; }
    const mixedTypes = !(selectedTypes.length === 1 && selectedTypes[0] === 'mcq');
    // If MCQ is not selected, optCount is irrelevant but keep persisted value for later
    try{ localStorage.setItem('ai.mcq.qCount', String(qCount)); localStorage.setItem('ai.mcq.optCount', String(optCount)); }catch{}

    // OCR preference (user-controlled)
    const ocrEnabled = document.getElementById('aiOcrToggle') ? (document.getElementById('aiOcrToggle').checked === true) : true;

        const key = $('globalGemKey')?.value?.trim();
        const enabled = !!document.getElementById('globalGemEnable')?.checked;
        if(!key || !enabled){ setStatus('API key disabled or missing. Enable and enter your key at the top.', true); alert('Enable the API key (toggle in the key bar) and enter your Gemini API key.'); return; }

    const files = Array.from(fileInput.files || []);
    // If no files selected, allow using the selected saved content (generator context) as the source
    let usingSavedOnly = false;
    if(files.length === 0){
        const tbTexts = (window.__tbGenCtx?.pieces || []).map(p=> p.text).filter(Boolean);
        if(tbTexts.length){
            // use the saved content as the extracted source
            usingSavedOnly = true;
            // we'll assign to `extracted` later (before sending to model)
            // show helpful status to the user
            setStatus(`Using selected source: ${window.__tbGenCtx.pieces[0]?.title || 'saved content'}`);
        } else {
            setStatus('No files selected. Choose .docx, .pdf, .pptx, or image files, or select saved content as the source.', true);
            alert('Choose .docx, .pdf, .pptx, or image files (.png, .jpg, .webp, .gif), or first select a saved content chapter and click its Generate button to set it as the source.');
            return;
        }
    }

    // Freeze row widths while we mutate labels to avoid layout jitter
    lockAiFileRow(true);
    try{ fileInput.disabled = true; }catch{}
    btn.disabled = true; btn.setAttribute('aria-busy','true'); const orig = btn.textContent; btn.innerHTML = '<span class="spinner" aria-hidden="true"></span> Contacting…';
        // Prevent changing counts while generating
    try{ if(qCountEl) qCountEl.disabled = true; if(optCountEl) optCountEl.disabled = true; }catch(e){}
        setStatus('Contacting Gemini…');
            try{
                setStatus('Reading file(s) in browser...');
                let extracted = '';
                // Reuse extraction when only generation parameters change (e.g., question types)
                let cacheKey = null;
                let cacheHit = false;

                async function extractFromFile(f){
                    const name = f?.name || 'file';
                    const lower = name.toLowerCase();
                    const isDocx = /\.docx$/i.test(lower);
                    const isPdf = /\.pdf$/i.test(lower);
                    const isPptx = /\.pptx$/i.test(lower);
                    const isImage = (f?.type && f.type.startsWith('image/')) || /\.(png|jpe?g|webp|gif)$/i.test(lower);
                    if(isDocx){
                        setStatus(`Extracting text from ${name} (.docx via mammoth)...`);
                        const ab = await f.arrayBuffer();
                        setStatus('Extracting text from .docx (mammoth)...');
                        try{
                            debugLog('loading mammoth UMD...');
                            if(!(window.mammoth && window.mammoth.convertToHtml)){
                                await loadScript('https://unpkg.com/mammoth@1.6.0/mammoth.browser.min.js');
                            }
                            if(!(window.mammoth && window.mammoth.convertToHtml)) throw new Error('mammoth not available');
                            const res = await window.mammoth.convertToHtml({ arrayBuffer: ab });
                            const text = normalizeGreek(stripHtml(res && res.value || ''));
                            debugLog('docx extracted length', text.length);
                            return text;
                        }catch(e1){
                            console.warn('[aiFileGenNew] mammoth failed', e1); debugLog('mammoth failed', e1?.message||e1);
                            // Fallback: use JSZip to read word/document.xml
                            try{
                                setStatus(`Mammoth failed for ${name}, falling back to basic .docx extraction...`);
                                debugLog('loading JSZip and extracting word/document.xml');
                                if(!(window.JSZip)){
                                    await loadScript('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js');
                                }
                                if(!window.JSZip) throw new Error('JSZip not available');
                                const zip = await window.JSZip.loadAsync(ab);
                                const entry = zip.file('word/document.xml');
                                if(!entry) throw new Error('document.xml not found in docx');
                                const xml = await entry.async('string');
                                // very naive XML -> text: keep text nodes and spaces for paragraph breaks
                                const txt = normalizeGreek(xml.replace(/<w:p[^>]*>/g, '\n')
                                                             .replace(/<w:tab\b[^>]*\/>/g, ' ')
                                                             .replace(/<w:t[^>]*>(.*?)<\/w:t>/g, '$1')
                                                             .replace(/<[^>]+>/g, ' ')
                                                             .replace(/\s+/g, ' ')
                                                             .trim());
                                debugLog('docx extracted length (fallback)', txt.length);
                                return txt;
                            }catch(e2){
                                console.warn('[aiFileGenNew] JSZip fallback failed', e2); debugLog('docx fallback failed', e2?.message||e2);
                                throw new Error('Failed to extract .docx text');
                            }
                        }
                    } else if(isPdf) {
                setStatus(`Extracting text from ${name} (PDF via pdfjs)...`);
                        const ab = await f.arrayBuffer();
                        try{
                            debugLog('loading pdfjs UMD (robust)...');
                            // Try multiple CDN candidates for pdf.js
                            const pdfCandidates = [
                                'https://cdn.jsdelivr.net/npm/pdfjs-dist@2.16.105/build/pdf.min.js',
                                'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js',
                                'https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.min.js'
                            ];
                            let pdfjs = window.pdfjsLib || window.pdfjs || null;
                            if(!(pdfjs && pdfjs.getDocument)){
                                let loaded = false;
                                for(const c of pdfCandidates){
                                    try{ await loadScript(c); debugLog('loaded pdfjs candidate', c); pdfjs = window.pdfjsLib || window['pdfjs-dist/build/pdf'] || window.pdfjsLib || window.pdfjs || window['pdfjs']; if(pdfjs && pdfjs.getDocument){ loaded = true; try{ pdfjs.GlobalWorkerOptions.workerSrc = c.replace(/pdf.min.js$/, 'pdf.worker.min.js'); }catch(e){} break; } }catch(e){ debugLog('candidate failed', c, e?.message||e); }
                                }
                                if(!pdfjs || !pdfjs.getDocument) throw new Error('pdfjsLib not available after trying CDNs');
                            }
                            try{ if(pdfjs.GlobalWorkerOptions) pdfjs.GlobalWorkerOptions.workerSrc = (pdfjs.GlobalWorkerOptions && pdfjs.GlobalWorkerOptions.workerSrc) || pdfjs.GlobalWorkerOptions.workerSrc; }catch(e){}
                            const loadingTask = pdfjs.getDocument({ data: ab });
                            const pdf = await loadingTask.promise;
                            const maxPages = pdf.numPages; let texts = [];
                            // helper to render page to PNG blob for OCR
                            async function renderPageToBlob(page, scale){
                                try{
                                    const viewport = page.getViewport({ scale: scale || 2 });
                                    const canvas = document.createElement('canvas');
                                    canvas.width = Math.round(viewport.width);
                                    canvas.height = Math.round(viewport.height);
                                    const ctx = canvas.getContext('2d');
                                    const renderTask = page.render({ canvasContext: ctx, viewport });
                                    if(renderTask && renderTask.promise) await renderTask.promise; else await new Promise(r=> setTimeout(r,250));
                                    return await new Promise(res=> canvas.toBlob(res, 'image/png'));
                                }catch(e){ debugLog('renderPageToBlob failed', e?.message||e); return null; }
                            }

                            // Load Tesseract only if we encounter pages that need OCR
                            let tesseractLoaded = false;
                            async function ensureTesseract(){
                                if(tesseractLoaded) return true;
                                try{
                                    if(!window.Tesseract) await loadScript('https://unpkg.com/tesseract.js@4.1.1/dist/tesseract.min.js');
                                    tesseractLoaded = !!(window.Tesseract && (window.Tesseract.recognize || window.Tesseract.createWorker));
                                    return tesseractLoaded;
                                }catch(e){ debugLog('tesseract load failed', e?.message||e); return false; }
                            }

                            for(let p=1;p<=maxPages;p++){
                                try{
                                    const page = await pdf.getPage(p);
                                    // try text extraction first
                                    let pageText = '';
                                    try{ const content = await page.getTextContent({ normalizeWhitespace:true, disableCombineTextItems:false, includeMarkedContent:true }); pageText = (content && Array.isArray(content.items)) ? content.items.map(it=> String(it.str||'')).join(' ').replace(/\s+/g,' ').trim() : ''; }catch(e){ pageText = ''; }

                                    // If page text is very short, attempt OCR on the rendered page to capture embedded image text
                                    if((!pageText || pageText.length < 40)){
                                        try{
                                            const ok = await ensureTesseract();
                                            if(ok && ocrEnabled){
                                                const blob = await renderPageToBlob(page, 2);
                                                if(blob){
                                                    try{
                                                        const url = URL.createObjectURL(blob);
                                                        const res = await window.Tesseract.recognize(url, 'eng', { logger: m => { if(m && m.status){ debugLog('tesseract', m.status, (m.progress!=null)? ((m.progress*100)|0)+'%':'' ); } } });
                                                        const ocrText = (res && res.data && res.data.text) ? String(res.data.text).trim() : (res && res.text? String(res.text).trim() : '');
                                                        if(ocrText) pageText = (pageText ? (pageText + '\n[OCR]\n' + ocrText) : ocrText);
                                                        try{ URL.revokeObjectURL(url); }catch{}
                                                    }catch(e){ debugLog('tesseract page recognize failed', e?.message||e); }
                                                }
                                            }
                                        }catch(e){ debugLog('page OCR failed', e?.message||e); }
                                    }

                                    texts.push(pageText);
                                    if(texts.join(' ').length > 200000) break; // stop early if huge
                                }catch(e){ debugLog('page loop failed', e?.message||e); texts.push(''); }
                            }
                            const text = normalizeGreek(texts.join('\n'));
                            debugLog('pdf extracted length', text.length);
                            return text;
                        }catch(e){ console.warn('[aiFileGenNew] pdfjs robust loader failed', e); debugLog('pdfjs failed', e?.message||e); throw new Error('Failed to extract PDF text'); }
            } else if(isPptx){
                setStatus(`Extracting text from ${name} (.pptx via JSZip)...`);
                const ab = await f.arrayBuffer();
                try{
                    debugLog('loading JSZip for pptx...');
                    if(!(window.JSZip)){
                        await loadScript('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js');
                    }
                    if(!window.JSZip) throw new Error('JSZip not available');
                    const zip = await window.JSZip.loadAsync(ab);

                    // helper: minimal ensure for Tesseract when OCR is requested
                    async function ensureTesseractForPptx(){
                        if(!ocrEnabled) return false;
                        if(window.Tesseract && window.Tesseract.recognize) return true;
                        try{ await loadScript('https://unpkg.com/tesseract.js@4.1.1/dist/tesseract.min.js'); }catch(e){ debugLog('tesseract load failed', e?.message||e); return false; }
                        return !!(window.Tesseract && window.Tesseract.recognize);
                    }

                    // gather slide XML files in numeric order
                    const slideNames = Object.keys(zip.files)
                        .filter(n => /^ppt\/slides\/slide\d+\.xml$/i.test(n))
                        .sort((a,b)=>{
                            const na = parseInt((a.match(/slide(\d+)\.xml/i)||[])[1]||'0',10);
                            const nb = parseInt((b.match(/slide(\d+)\.xml/i)||[])[1]||'0',10);
                            return na - nb;
                        });
                    if(slideNames.length === 0) throw new Error('No slides found in PPTX');

                    // helper: resolve a rel Target to a zip path (e.g., ../media/image1.png -> ppt/media/image1.png)
                    function resolveRelTarget(slideName, target){
                        // slideName like 'ppt/slides/slide1.xml' -> rels at 'ppt/slides/_rels/slide1.xml.rels'
                        let p = String(target || '');
                        // remove leading './' and '../'
                        p = p.replace(/^\.\//, '');
                        while(p.startsWith('../')) p = p.slice(3);
                        if(!/^ppt\//i.test(p)) p = 'ppt/' + p;
                        return p;
                    }
                    function guessMimeFromName(n){
                        const ext = (n||'').toLowerCase().split('.').pop();
                        switch(ext){
                            case 'jpg': case 'jpeg': return 'image/jpeg';
                            case 'png': return 'image/png';
                            case 'gif': return 'image/gif';
                            case 'webp': return 'image/webp';
                            case 'bmp': return 'image/bmp';
                            case 'tif': case 'tiff': return 'image/tiff';
                            default: return 'application/octet-stream';
                        }
                    }

                    const parts = [];
                    let totalOcrImages = 0; // soft telemetry
                    for(const sName of slideNames){
                        const xml = await zip.file(sName).async('string');
                        // Extract text from <a:t> nodes; treat <a:br/> and paragraph boundaries as breaks
                        let slideText = xml
                            .replace(/<a:br\s*\/>/gi, '\n')
                            .replace(/<a:p[^>]*>/gi, '\n')
                            .replace(/<a:t[^>]*>([\s\S]*?)<\/a:t>/gi, '$1')
                            .replace(/<[^>]+>/g, ' ')
                            .replace(/\s+/g, ' ')
                            .trim();

                        let ocrAppend = '';
                        if(ocrEnabled){
                            // find any r:embed="rIdX" references on the slide
                            const rids = Array.from(xml.matchAll(/r:embed="([^"]+)"/gi)).map(m=>m[1]);
                            if(rids.length){
                                // load rels to map rId -> Target
                                const relsPath = sName.replace(/slides\/(slide\d+)\.xml$/i, 'slides/_rels/$1.xml.rels');
                                const relsEntry = zip.file(relsPath);
                                let relsXml = '';
                                if(relsEntry){ try{ relsXml = await relsEntry.async('string'); }catch(e){ relsXml=''; } }
                                const map = new Map();
                                if(relsXml){
                                    const rx = /<Relationship[^>]*Id="([^"]+)"[^>]*Target="([^"]+)"/gi;
                                    let m; while((m = rx.exec(relsXml))){ map.set(m[1], m[2]); }
                                }
                                const okTess = await ensureTesseractForPptx();
                                let slideOcrTexts = [];
                                if(okTess){
                                    for(const rid of rids){
                                        const tgt = map.get(rid);
                                        if(!tgt) continue;
                                        const imgPath = resolveRelTarget(sName, tgt);
                                        const imgFile = zip.file(imgPath);
                                        if(!imgFile) continue;
                                        try{
                                            const u8 = await imgFile.async('uint8array');
                                            const mime = guessMimeFromName(imgPath);
                                            const blob = new Blob([u8], { type: mime });
                                            // IMPORTANT: pass the Blob directly. Using a temporary blob: URL can fail to fetch
                                            // inside Tesseract's worker (shows as "Failed to fetch").
                                            debugLog('tesseract recognizing slide image', imgPath);
                                            const res = await window.Tesseract.recognize(blob, 'eng', {
                                                logger: m => {
                                                    if(m && m.status){
                                                        debugLog('tesseract', m.status, (m.progress!=null)? ((m.progress*100)|0)+'%':'' );
                                                    }
                                                }
                                            });
                                            const txt = (res && res.data && res.data.text) ? String(res.data.text).trim() : '';
                                            if(txt) slideOcrTexts.push(txt);
                                            totalOcrImages++;
                                        }catch(e){ debugLog('ocr on pptx image failed', imgPath, e?.message||e); }
                                        // safety: avoid runaway OCR on decks with huge numbers of images
                                        if(slideOcrTexts.join(' ').length > 10000) break;
                                        if(totalOcrImages > 50) break;
                                    }
                                }
                                if(slideOcrTexts.length){ ocrAppend = '\n[OCR]\n' + slideOcrTexts.join('\n'); }
                                if(slideOcrTexts.length){ debugLog('pptx slide images OCR text chars', slideOcrTexts.join('\n').length); }
                            }
                        }

                        const combined = (slideText || '') + (ocrAppend || '');
                        if(combined.trim()) parts.push(combined.trim());
                        if(parts.join(' ').length > 200000) break; // safety cap
                    }

                    const text = normalizeGreek(parts.join('\n\n'));
                    debugLog('pptx extracted length', text.length, 'slides', slideNames.length);
                    return text;
                }catch(e){ console.warn('[aiFileGenNew] pptx extraction failed', e); debugLog('pptx extraction failed', e?.message||e); throw new Error('Failed to extract PPTX text'); }
            } else if(isImage){
                // Respect user OCR preference
                if(typeof ocrEnabled !== 'undefined' && !ocrEnabled){
                    setStatus(`OCR disabled; skipping image ${name}`);
                    return '';
                }
                setStatus(`OCR (Tesseract) on ${name}…`);
                try{
                    if(!window.Tesseract){
                        await loadScript('https://unpkg.com/tesseract.js@4.1.1/dist/tesseract.min.js');
                    }
                    if(!window.Tesseract || !window.Tesseract.recognize) throw new Error('Tesseract not available');
                    const url = URL.createObjectURL(f);
                    try{
                        const res = await window.Tesseract.recognize(url, 'eng', { logger: m => { if(m && m.status){ debugLog('tesseract', m.status, (m.progress!=null)? ((m.progress*100)|0)+'%':'' ); } } });
                        const text = normalizeGreek((res && res.data && res.data.text) ? res.data.text : '');
                        debugLog('tesseract text length', text.length);
                        return text;
                    } finally { try{ URL.revokeObjectURL(url); }catch(e){} }
                }catch(e){ console.warn('[aiFileGenNew] OCR failed', e); debugLog('ocr failed', e?.message||e); throw new Error('Failed to OCR image'); }
            } else {
                throw new Error('Unsupported file type: ' + name);
            }
                }

                // Extract from all selected files, concatenating results. If using saved-only, skip file extraction.
                let parts = [];
                if(!usingSavedOnly){
                    try{ cacheKey = aiExtractCacheKey(files, ocrEnabled); }catch(e){ cacheKey = null; }
                    if(cacheKey && __aiFileExtractCache && __aiFileExtractCache.has(cacheKey)){
                        try{
                            const cached = __aiFileExtractCache.get(cacheKey);
                            if(cached && typeof cached.extracted === 'string' && cached.extracted.trim()){
                                extracted = cached.extracted;
                                cacheHit = true;
                                setStatus('Using cached extraction (no reprocessing)…');
                                debugLog('cache hit', (files[0] && files[0].name) || 'file(s)', 'len', extracted.length);
                            }
                        }catch(e){ cacheHit = false; }
                    }
                    if(!cacheHit){
                        for(let i=0;i<files.length;i++){
                            const f = files[i];
                            try{
                                setStatus(`Processing (${i+1}/${files.length}): ${f.name}`);
                                const text = await extractFromFile(f);
                                if(text && text.trim()){
                                    parts.push(text.trim());
                                }
                            }catch(e){
                                console.warn('Extraction failed for', f?.name, e);
                                // continue with others, but record that this one failed
                            }
                        }
                        extracted = normalizeGreek(parts.join('\n\n'));
                    }
                } else {
                    // use the selected saved content pieces as the extracted source
                    try{
                        extracted = normalizeGreek((window.__tbGenCtx?.pieces||[]).map(p=> p.text || '').join('\n\n'));
                    }catch(e){ extracted = '' }
                }

            if(!extracted || !extracted.trim()) throw new Error('No text could be extracted from the file.');

            // Truncate to a safe prompt size (approx chars). Adjust as needed.
            const maxChars = 120000; // conservative cap
            if(extracted.length > maxChars){ extracted = extracted.slice(0, maxChars) + '\n\n[TRUNCATED]'; debugLog('extracted text truncated'); }

            // Store the exact prompt-source text so subsequent regenerations keep the same extracted length.
            try{
                if(!usingSavedOnly && !cacheHit && cacheKey && __aiFileExtractCache){
                    __aiFileExtractCache.set(cacheKey, { extracted, ts: Date.now() });
                    debugLog('cache stored', (files[0] && files[0].name) || 'file(s)', 'len', extracted.length);
                }
            }catch(e){}

            setStatus(`Sending document to Gemini for ${mixedTypes ? 'question' : 'MCQ'} generation...`); debugLog('sending to Gemini, length', extracted.length);
            // dynamic import of Gemini SDK if needed
            if(!window.GoogleGenerativeAI){
                try{ const mod = await import('https://esm.run/@google/generative-ai'); window.GoogleGenerativeAI = mod.GoogleGenerativeAI; }catch(e){ console.warn('[aiFileGenNew] import generative-ai failed', e); }
            }
            if(!window.GoogleGenerativeAI) throw new Error('Generative AI SDK unavailable (could not import).');

            const client = new window.GoogleGenerativeAI(key);
            const model = client.getGenerativeModel({ model: 'gemini-2.5-flash' });

                        // Build the prompt with strict formatting requirements.
                        // MCQ-only uses the legacy structured MCQ JSON (converted to MCQ text + ANSWER KEY).
                        // Mixed types use a JSON bank matching parseDoc()'s { items: [...] } schema.
                        const tbCtx = (window.__tbGenCtx?.pieces||[]).map(p=> p.text).join('\n\n');
                        const docName = (files[0]?.name) || (usingSavedOnly && window.__tbGenCtx?.pieces?.[0]?.title) || 'Source document';
                        const mcqPrompt = `You are given the extracted plain text contents of a document. From this content${tbCtx ? ' and the supplemental textbook context below' : ''}, create ${autoMode ? 'the number of' : qCount} high-quality, exam-worthy multiple-choice questions (MCQs) ${autoMode ? 'that best fit the material (choose the count yourself, do not exceed 50, and prefer quality over quantity)' : 'if the source supports it (fewer if necessary to maintain quality)' }.

Return your answer as a single JSON object with this exact shape (no extra keys, no comments, no surrounding text):
{
    "docName": string,              // the human-readable name of the document (e.g., "${docName}")
    "questions": [
        {
            "q": string,               // the question stem
            "options": [string, ...],  // exactly ${optCount} options
            "correctIndex": number,    // 0-based index into options
            "page": number|null,       // page number in the source (1-based). If unknown, use null.
            "sourcePhrase": string     // short exact phrase from the source text that best matches the concept
        }, ...
    ]
}

Rules for questions/options:
- Exactly ${optCount} options per question. If the source does not support ${optCount} strong distractors for a given question, rewrite or drop the question; do NOT produce fewer options.
- Exactly one correct option per question.
- Return at most ${autoMode ? 50 : qCount} questions.

Character handling requirements:
- Preserve all Unicode characters from the source text exactly in both questions and options, especially Greek letters/symbols (e.g., α β γ δ ε θ μ π σ φ Ω). Do not transliterate or spell out names. If a glyph is unclear, leave it as-is; never replace with �.

Content selection constraints (very important):
- Prioritize technical, non-trivial, domain-specific material that requires understanding, discrimination, or reasoning.
- Avoid general/common knowledge or boilerplate content even if present (e.g., course logistics, introductions, obvious definitions, historical trivia, generic study tips, reading lists, or broad non-technical overview statements).
- Ignore preliminary outlines, headings, or meta/administrative text not suitable for assessment.
- If a concept appears in both general and technical forms, prefer the technically precise version and craft distractors that are plausible but incorrect.
- If insufficient technical material exists for 30 good questions, generate fewer rather than padding with trivial items.

Use only information from the provided document text${tbCtx ? ' and the provided textbook context' : ''} (do not add external facts). When inferring the page field, use an approximate page based on where in the text the concept appears (1 = beginning of the document).

Document text:
"""
${ (tbCtx ? (tbCtx + '\n\n') : '') + extracted }
"""`;

                                                const typeLabel = (selectedTypes||[]).map(t=> (t==='mcq'?'MCQ':t==='truefalse'?'True/False':t==='fillblank'?'Fill-in-the-Blank':'Matching')).join(', ');
                                                const bankPrompt = `You are given the extracted plain text contents of a document. From this content${tbCtx ? ' and the supplemental textbook context below' : ''}, create ${autoMode ? 'a set of' : qCount} high-quality, exam-worthy questions using ONLY these question types: ${typeLabel}.

Return your answer as a single JSON object with this exact shape (no extra keys, no comments, no surrounding text):
{
    "docName": string,              // the human-readable name of the document (e.g., "${docName}")
    "items": [
        // ${autoMode ? 'choose the count yourself (max 50)' : 'exactly '+qCount+' items'}
    ]
}

Each item must use ONE of these exact schemas (use these exact keys):

// IMPORTANT: Every item MUST include evidence fields so the app can show per-question refs.
// - "sourcePhrase" must be a short EXACT phrase copied from the provided text (8–20 words is ideal). Do not paraphrase.
// - "page" is an approximate page index (1-based) based on where in the provided text the evidence occurs; use null only if truly unknown.

- MCQ: { "type":"mcq", "num":"1", "q":"...", "choices":[...], "correctIdx": 0, "page": null, "sourcePhrase": "..." }  // choices must be exactly ${optCount} strings
- True/False: { "type":"truefalse", "num":"2", "q":"...", "answer": true, "page": null, "sourcePhrase": "..." }
- Fill-in-the-Blank: { "type":"fillblank", "num":"3", "q":"... ____ ...", "answers": ["answer1", "answer2"], "page": null, "sourcePhrase": "..." }
- Matching: { "type":"matching", "num":"4", "q":"Match ...", "pairs": [{"left":"...","right":"..."}, ...], "rightExtras": ["distractor1"], "page": null, "sourcePhrase": "..." }

Rules:
- Total questions: ${autoMode ? 'choose the count yourself, max 50, prefer quality over quantity.' : 'exactly '+qCount+'.'} If the source cannot support that many high-quality questions, return fewer rather than padding.
- If multiple types are selected, distribute questions as evenly as possible across selected types.
- MCQ: exactly ${optCount} choices; exactly one correct; correctIdx is 0-based.
- Matching: 3–6 pairs per item; include 0–3 rightExtras to add plausible distractors.
- Fill blank: provide 1–3 acceptable answers.

Character handling requirements:
- Preserve all Unicode characters from the source text exactly (especially Greek letters/symbols). Do not transliterate.

Content selection constraints (very important):
- Prioritize technical, non-trivial, domain-specific material that requires understanding or discrimination.
- Avoid boilerplate content (course logistics, intros, trivia).
- Use only information from the provided text${tbCtx ? ' and the provided textbook context' : ''}; do not add external facts.

Evidence requirements (non-negotiable):
- For EVERY item, set "sourcePhrase" to a non-empty exact quote from the provided text that directly supports the question.
- Do not reuse the same "sourcePhrase" for unrelated questions; choose the best-matching evidence each time.
- "sourcePhrase" must appear verbatim in the provided text block (copy/paste a short substring).
- If you cannot find strong evidence for a candidate question in the text, drop the question and generate a different one.

When inferring the page field, use an approximate page based on where in the text the evidence appears (1 = beginning of the document).

Document text:
"""
${ (tbCtx ? (tbCtx + '\n\n') : '') + extracted }
"""`;

                                                const prompt = mixedTypes ? bankPrompt : mcqPrompt;

            console.log('[aiFileGenNew] prompt length', prompt.length);
            debugLog('prompt length', prompt.length);
            btn.innerHTML = '<span class="spinner" aria-hidden="true"></span> Generating…';
            setStatus('Generating questions…');

            const resp = await model.generateContent({ contents: [{ role: 'user', parts: [{ text: prompt }] }] });
            const rawFull = (await resp?.response?.text?.())?.trim();
            debugLog('received response; length', rawFull ? rawFull.length : 0);
            if(!rawFull) throw new Error('Empty response from Gemini.');

            // Gemini may wrap JSON in markdown fences or prose; try to extract pure JSON
            let raw = rawFull;
            // Common case: ```json ... ``` or ``` ... ```
            const fenceMatch = rawFull.match(/```(?:json)?\s*([\s\S]*?)```/i);
            if(fenceMatch && fenceMatch[1]){
                raw = fenceMatch[1].trim();
            }

            // Parse JSON and build MCQ text (legacy) or a JSON bank (mixed types)
            let parsed;
            try{ parsed = JSON.parse(raw); }catch(e){
                debugLog('JSON parse failed', e?.message||e);
                throw new Error('AI did not return valid JSON.');
            }

            // Always clear prior hint channel to avoid accidental carryover
            try{ window.__aiMcqSourceHints = {}; }catch(e){}

            const docLabel = String(parsed?.docName || docName || 'Source document');

            function normalizeAiItems(arr){
                try{
                    const out = [];
                    const toStr = (v)=> (v==null ? '' : String(v));
                    const normType = (t)=> toStr(t).toLowerCase().trim();
                    for(let i=0;i<(arr||[]).length;i++){
                        const it = arr[i] || {};
                        const t = normType(it.type || it.kind || it.questionType);
                        const rawNum = toStr(it.num || it.id || (i+1));
                        const num = (function(){
                            const m = rawNum.match(/\d+/);
                            return (m && m[0]) ? m[0] : String(i+1);
                        })();
                        const q = toStr(it.q || it.prompt || it.question || it.text).trim();
                        if(!q) continue;
                        const page = (function(){
                            try{
                                if(typeof it.page === 'number' && isFinite(it.page) && it.page > 0) return Math.round(it.page);
                                if(typeof it.page === 'string'){
                                    const n = parseInt(it.page.trim(), 10);
                                    if(isFinite(n) && n > 0) return n;
                                }
                            }catch(e){}
                            return null;
                        })();
                        const sourcePhrase = toStr(it.sourcePhrase || it.source || it.source_hint || it.sourceHint || it.evidence || it.quote || it.ref || '').trim();
                        if(t === 'truefalse' || t === 'tf' || t === 't/f'){
                            const a = (typeof it.answer === 'boolean') ? it.answer : (/^(true|t|yes|y|1)$/i.test(toStr(it.answer).trim()));
                            out.push({ type:'truefalse', num, q, answer: !!a, page, sourcePhrase });
                            continue;
                        }
                        if(t === 'fillblank' || t === 'fib' || t === 'fill-in-the-blank'){
                            const answers = Array.isArray(it.answers) ? it.answers : (it.answer != null ? [it.answer] : []);
                            out.push({ type:'fillblank', num, q, answers: answers.map(x=>toStr(x)).filter(Boolean), page, sourcePhrase });
                            continue;
                        }
                        if(t === 'matching' || t === 'match'){
                            const pairs = Array.isArray(it.pairs) ? it.pairs : (Array.isArray(it.matches) ? it.matches : []);
                            const cleanPairs = pairs.map(p=>({ left: toStr(p?.left ?? p?.l ?? p?.a).trim(), right: toStr(p?.right ?? p?.r ?? p?.b).trim() })).filter(p=>p.left && p.right);
                            const rightExtras = Array.isArray(it.rightExtras) ? it.rightExtras.map(x=>toStr(x)).filter(Boolean) : [];
                            out.push({ type:'matching', num, q, pairs: cleanPairs, rightExtras, page, sourcePhrase });
                            continue;
                        }
                        // default MCQ
                        const choices = Array.isArray(it.choices) ? it.choices : (Array.isArray(it.options) ? it.options : (Array.isArray(it.choicesList) ? it.choicesList : []));
                        const cleanChoices = (choices||[]).map(x=>toStr(x)).filter(Boolean);
                        const ciRaw = (typeof it.correctIdx === 'number') ? it.correctIdx : ((typeof it.correctIndex === 'number') ? it.correctIndex : ((typeof it.answerIndex === 'number') ? it.answerIndex : null));
                        const ci = (ciRaw==null) ? 0 : Math.max(0, Math.min(cleanChoices.length-1, (ciRaw|0)));
                        out.push({ type:'mcq', num, q, choices: cleanChoices, correctIdx: ci, page, sourcePhrase });
                    }
                    return out;
                }catch(e){ return []; }
            }

            function itemsToPlainText(itemsArr){
                const itms = Array.isArray(itemsArr) ? itemsArr : [];
                const outLines = [];
                const keyLines = [];
                const letters = ['A','B','C','D','E','F'];
                for(const it of itms){
                    const t = String(it?.type || 'mcq').toLowerCase();
                    const num = String(it?.num ?? '').trim() || String(outLines.length + 1);
                    const q = String(it?.q ?? '').trim();
                    if(!q) continue;

                    // Attach sourceHint metadata for ALL item types (MCQ/TF/FIB/Matching)
                    try{
                        window.__aiMcqSourceHints = window.__aiMcqSourceHints || {};
                        const page = (typeof it.page === 'number' && isFinite(it.page) && it.page > 0) ? Math.round(it.page) : null;
                        const phrase = (it.sourcePhrase || '').toString().trim();
                        const hintParts = [];
                        if(phrase){ hintParts.push(`“${phrase}”`); }
                        if(page){ hintParts.push(`p.${page}`); }
                        if(docLabel){ hintParts.push(docLabel); }
                        const hint = hintParts.length ? hintParts.join(' • ') : '';
                        if(hint){ window.__aiMcqSourceHints[String(num)] = hint; }
                    }catch(e){}

                    if(t === 'matching'){
                        outLines.push(`Q${num}. [MATCH] ${q}`);
                        const pairs = Array.isArray(it.pairs) ? it.pairs : [];
                        pairs.forEach(p=>{
                            const left = String(p?.left ?? '').trim();
                            const right = String(p?.right ?? '').trim();
                            if(left && right) outLines.push(`- ${left} -> ${right}`);
                        });
                        const extras = Array.isArray(it.rightExtras) ? it.rightExtras.map(x=>String(x||'').trim()).filter(Boolean) : [];
                        if(extras.length) outLines.push(`- Extras: ${extras.join(' | ')}`);
                        outLines.push('');
                        continue;
                    }

                    if(t === 'truefalse'){
                        outLines.push(`Q${num}. [TF] ${q}`);
                        outLines.push('');
                        const ans = (typeof it.answer === 'boolean') ? it.answer : (/^(true|t|yes|y|1)$/i.test(String(it.answer||'').trim()));
                        keyLines.push(`${num}. ${ans ? 'True' : 'False'}`);
                        continue;
                    }

                    if(t === 'fillblank'){
                        outLines.push(`Q${num}. [FIB] ${q}`);
                        outLines.push('');
                        const answers = Array.isArray(it.answers) ? it.answers.map(x=>String(x||'').trim()).filter(Boolean) : (it.answer!=null ? [String(it.answer).trim()].filter(Boolean) : []);
                        if(answers.length) keyLines.push(`${num}. ${answers.join(' | ')}`);
                        continue;
                    }

                    // MCQ
                    outLines.push(`Q${num}. ${q}`);
                    const choices = Array.isArray(it.choices) ? it.choices : [];
                    choices.forEach(c=>{ const s = String(c||'').trim(); if(s) outLines.push(`- ${s}`); });
                    outLines.push('');
                    const ci = (typeof it.correctIdx === 'number' && isFinite(it.correctIdx)) ? it.correctIdx : 0;
                    keyLines.push(`${num}. ${letters[Math.max(0, Math.min(letters.length-1, ci|0))] || 'A'}`);
                }
                if(keyLines.length){
                    outLines.push('ANSWER KEY');
                    outLines.push(...keyLines);
                }
                return normalizeGreek(outLines.join('\n')).trim();
            }

            let out = '';
            if(!mixedTypes){
                const qArr = Array.isArray(parsed?.questions) ? parsed.questions : [];
                if(!qArr.length) throw new Error('AI returned no questions.');
                const keyLines = [];
                qArr.slice(0, autoMode ? 50 : qCount).forEach((q, idx)=>{
                    try{
                        if(!q || !q.q || !Array.isArray(q.options) || q.options.length < 2) return;
                        const num = idx + 1;
                        out += `Q${num}. ${q.q}\n`;
                        q.options.forEach(opt=>{ out += `- ${opt}\n`; });
                        out += '\n';
                        const ci = (typeof q.correctIndex === 'number' && q.correctIndex >= 0 && q.correctIndex < q.options.length) ? q.correctIndex : 0;
                        const letter = String.fromCharCode(65 + ci);
                        keyLines.push(`${num}. ${letter}`);

                        // Attach sourceHint metadata into a side channel for later parseDoc -> state.items mapping
                        try{
                            window.__aiMcqSourceHints = window.__aiMcqSourceHints || {};
                            const page = (typeof q.page === 'number' && isFinite(q.page) && q.page > 0) ? Math.round(q.page) : null;
                            const phrase = (q.sourcePhrase || '').toString().trim();
                            const hintParts = [];
                            if(phrase){ hintParts.push(`“${phrase}”`); }
                            if(page){ hintParts.push(`p.${page}`); }
                            if(docLabel){ hintParts.push(docLabel); }
                            const hint = hintParts.length ? hintParts.join(' • ') : '';
                            if(hint){ window.__aiMcqSourceHints[String(num)] = hint; }
                        }catch(e){}
                    }catch(e){}
                });
                if(keyLines.length){ out += 'ANSWER KEY\n' + keyLines.join('\n'); }
            } else {
                const itemsRaw = Array.isArray(parsed) ? parsed : (parsed && Array.isArray(parsed.items) ? parsed.items : []);
                if(!itemsRaw.length) throw new Error('AI returned no items.');
                const norm = normalizeAiItems(itemsRaw);
                if(!norm.length) throw new Error('AI returned items but none could be normalized.');
                out = itemsToPlainText(norm.slice(0, autoMode ? 50 : qCount));
            }

            // Show preview modal to allow the user to Insert, Save, or Cancel
            const paste = $('paste'); if(!paste) throw new Error('Could not find paste textarea.');
            window.showPreviewModal(out, '', function(choice){
                try{
                    if(!choice) { setStatus('Cancelled by user.'); return; }
                    // backward-compat: if caller returned boolean true, treat as insert
                    if(choice === true || (choice && choice.action === 'insert')){
                        paste.value = normalizeGreek(out);
                        // Persist refs immediately so an Inserted (not saved) generated quiz still retains them.
                        try{
                            if(window.__mcqRefsDraftPut && window.__aiMcqSourceHints && typeof window.__aiMcqSourceHints === 'object' && Object.keys(window.__aiMcqSourceHints).length){
                                window.__mcqRefsDraftPut(paste.value, window.__aiMcqSourceHints, { doc: docLabel });
                            }
                        }catch(e){}
                        setStatus('Inserted. Parsing…');
                        debugLog('inserted into #paste; triggering parse');
                        $('parseBtn')?.click();
                        setStatus('Done.');
                        console.log('[aiFileGenNew] finished successfully');
                        return;
                    }
                    if(choice && choice.action === 'save'){
                        // persist into local saved MCQs (including optional per-question source hints)
                        try{
                            const key = 'mcq.pastes.v1';
                            const existing = (function(){ try{ return JSON.parse(localStorage.getItem(key)||'[]'); }catch(e){ return []; } })();
                            const title = mixedTypes ? (`AI Generated (${docLabel})`) : ((out||'').split('\n').map(l=>l.trim()).filter(Boolean)[0] || 'Untitled');
                            // For JSON banks, do NOT run MCQ sanitizer; it can destroy JSON.
                            const savedText = mixedTypes ? normalizeGreek(out) : (window.sanitizeMCQText ? sanitizeMCQText(out) : normalizeGreek(out));
                            let meta = undefined;
                            try{
                                if(window.__aiMcqSourceHints && typeof window.__aiMcqSourceHints === 'object' && Object.keys(window.__aiMcqSourceHints).length){
                                    meta = { sourceHints: window.__aiMcqSourceHints };
                                }
                            }catch(e){}
                            const item = { id: Date.now().toString(36), date: (new Date()).toISOString().slice(0,16).replace('T',' '), title: String(title).slice(0,200), text: savedText, meta };
                            existing.unshift(item);
                            try{ localStorage.setItem(key, JSON.stringify(existing)); }catch(e){ console.warn('Could not save generated item', e); }
                            // If there was a draft refs entry for this content, clear it (now persisted in Saved MCQs).
                            try{ if(window.__mcqRefsDraftDel) window.__mcqRefsDraftDel(savedText); }catch(e){}
                            setStatus(mixedTypes ? 'Saved generated questions.' : 'Saved generated MCQs.');
                            // refresh saved UI if present
                            try{ window.refreshLocalSaved && window.refreshLocalSaved(); }catch(e){}
                        }catch(e){ console.error('save generated failed', e); setStatus('Save failed: '+(e?.message||e)); }
                        return;
                    }
                    setStatus('Cancelled by user.');
                }catch(e){ console.error('preview callback failed', e); setStatus('Error during preview action.'); }
            });

                } catch(err){
                    console.error('[aiFileGenNew] error', err);
                    debugLog('error', err?.message || err);
                    setStatus('Error: ' + (err?.message || err), true);
                    alert('AI generation failed: ' + (err?.message || String(err)));
                } finally{
                    try{ btn.disabled = false; btn.removeAttribute('aria-busy'); btn.innerHTML = orig; }catch(e){}
                    // Restore controls to reflect current auto mode
                    try{ syncAutoUI(); }catch(e){}
                    // Unfreeze widths after processing completes
                    lockAiFileRow(false);
                    try{ fileInput.disabled = false; }catch{}
                }
        });
            return true;
        }

        // Try immediate bind; if DOM not ready, bind on DOMContentLoaded
        if(!bind()){
            document.addEventListener('DOMContentLoaded', bind, { once: true });
            // Safety retry shortly after load in case of dynamic DOM
            setTimeout(bind, 300);
        }
})();

</script>

</html>

        <script>
// Resilient UI sync for global key -> badges/buttons
(function(){
    // ASCII BG toggle button wiring (under theme capsule)
    try{
        var btn = document.getElementById('asciiBgToggle');
        if(btn){
            // initialize label from preference
            var pref = 'on'; try{ pref = localStorage.getItem('__asciiBg')||'on'; }catch(e){}
            btn.textContent = (pref==='off') ? 'Turn on animated background' : 'Turn off animated background';
            btn.addEventListener('click', function(){
                var running = window.__asciiBg && window.__asciiBg.isRunning();
                if(running){
                    // stop and hide
                    try{ window.__asciiBg.stop(); }catch(e){}
                    try{ var layer = document.querySelector('.ascii-watermark'); if(layer) layer.style.display='none'; }catch(e){}
                    btn.textContent = 'Turn on animated background';
                }else{
                    // show and start
                    try{ var layer = document.querySelector('.ascii-watermark'); if(layer) layer.style.display=''; }catch(e){}
                    try{ window.__asciiBg.start(); }catch(e){}
                    btn.textContent = 'Turn off animated background';
                }
            });
        }
    }catch(e){}
    function updateAll(){
        try{
            const keyInput = document.getElementById('globalGemKey');
            const en = document.getElementById('globalGemEnable');
            const ok = !!(keyInput && keyInput.value && keyInput.value.trim() && (!en || en.checked));
            const badgeIds = ['validateKeyBadge','validateKeyBadgeCopy','globalKeyBadge'];
            badgeIds.forEach(id=>{
                const nodes = document.querySelectorAll('#' + id);
                nodes.forEach(el=>{
                    el.classList.toggle('ok', ok);
                    el.classList.toggle('missing', !ok);
                    const hint = el.querySelector('.hint'); if(hint) hint.textContent = ok ? 'Key set' : 'No key set';
                });
            });
            const btnIds = ['aiLikeBtn','aiFileGenBtn','validateAnswersBtn','aiValidateBtn'];
            btnIds.forEach(id=>{ document.querySelectorAll('#'+id).forEach(b=>b.disabled = !ok); });
            // also update top-left dot
            const topDot = document.getElementById('globalKeyDot'); if(topDot){ topDot.classList.toggle('ok', ok); topDot.classList.toggle('missing', !ok); }
        }catch(e){ console.warn('updateAll failed', e); }
    }
    document.addEventListener('input', function(e){ if(e.target && e.target.id==='globalGemKey') updateAll(); });
    document.addEventListener('change', function(e){ if(!e.target) return; if(e.target.id==='globalGemKey' || e.target.id==='globalGemEnable') updateAll(); });
    window.addEventListener('load', updateAll);
    // run once now
    setTimeout(updateAll, 100);
})();
</script>

<style>
/* Overrides and additions for sticky notes UX */
.sticky-note{ min-width: 300px; }
.sticky-resize{ width:14px; height:14px; position:absolute; right:6px; bottom:6px; cursor:se-resize; border-radius:3px; background:
    repeating-linear-gradient(135deg,
        rgba(255,255,255,0.55) 0, rgba(255,255,255,0.55) 2px,
        rgba(0,0,0,0) 2px, rgba(0,0,0,0) 4px);
    opacity:0.6;
}
.sticky-resize:hover{ opacity:0.95; }

/* Title above dock: bare ASCII (no box), larger size, non-selectable */
#stickyTitleBox{ position:fixed; top: calc(env(safe-area-inset-top) + var(--topSafeArea) + var(--stickyTopGap)); right:12px; z-index:210; padding:0; border:none; background:transparent; box-shadow:none; -webkit-backdrop-filter:none; backdrop-filter:none }
#stickyTitleBox pre{ margin:0 0 0px 0; line-height:1.0; font-family: "Courier New", Consolas, monospace; font-weight:700; letter-spacing:0.35px; color:#dfe7ff; text-shadow:0 1px 0 #000; font-size: 12px; -webkit-user-select:none; user-select:none }
#stickyTitleBox{ -webkit-user-select:none; user-select:none }
/* Boot overlay ASCII title: make non-selectable */
#bootAscii{ -webkit-user-select:none; user-select:none }
/* Also make the watermark ASCII non-selectable */
#asciiWatermark{ -webkit-user-select:none; user-select:none }

/* Anchor dock right beneath title */
/* Dock beneath the title; positioned dynamically via JS to avoid overlap */
#stickyDock{ position:fixed; right:12px; z-index:210; }
#stickyPanel{ position:fixed; right:12px; z-index:210; }

/* Panel list delete button */
.sticky-item{ display:flex; align-items:center; gap:10px; justify-content:space-between; }
.sticky-item .si-main{ display:flex; align-items:center; gap:10px; }
.sticky-del{ margin-left:10px; color:#ffd1d1; background:rgba(255,0,0,0.08); border:1px solid rgba(255,0,0,0.25); border-radius:6px; padding:4px 8px; font-size:12px; cursor:pointer; }
.sticky-del:hover{ background:rgba(255,0,0,0.15); }

/* Unified Delete button styling: apply sticky-note delete theme across interface for common selectors */
.sticky-del,
button[data-act="delete"],
.btn[data-act="delete"],
button[data-del],
button.delete-btn,
#tbDeleteBtn,
button[data-delete]{
    color: #ffd1d1;
    background: rgba(255,0,0,0.08);
    border: 1px solid rgba(255,0,0,0.25);
    border-radius: 6px;
    padding: 4px 8px;
    font-size: 12px;
    cursor: pointer;
}
.sticky-del:hover,
button[data-act="delete"]:hover,
.btn[data-act="delete"]:hover,
button[data-del]:hover,
button.delete-btn:hover,
#tbDeleteBtn:hover,
button[data-delete]:hover{
    background: rgba(255,0,0,0.15);
}

/* Clear buttons: same shape but blue */
button[data-act="clear"],
.btn[data-act="clear"],
button.clear-btn,
#tbClearBtn,
button[data-clear]{
    color: #dfeeff;
    background: rgba(30,110,220,0.08);
    border: 1px solid rgba(60,120,220,0.25);
    border-radius: 6px;
    padding: 4px 8px;
    font-size: 12px;
    cursor: pointer;
}
button[data-act="clear"]:hover,
.btn[data-act="clear"]:hover,
button.clear-btn:hover,
#tbClearBtn:hover,
button[data-clear]:hover{
    background: rgba(30,110,220,0.14);
}
</style>

<div id="stickyTitleBox" aria-hidden="false">
    <pre>
.dP"Y8 888888 88b 88 88      dP"Yb   dP""b8 
`Ybo."   88   88Yb88 88     dP   Yb dP   `" 
o.`Y8b   88   88 Y88 88  .o Yb   dP Yb  "88 
8bodP'   88   88  Y8 88ood8  YbodP   YboodP 
    </pre>
</div>

<!-- Elevated stacking for quiz answer interface above sticky notes -->
<style id="quizLayerZFix">
/* Sticky notes use z-index ~190-210 (windows ~195, dock/panel ~210, panel open 9999). Ensure quiz answers sit above notes but below open panels/modals. */
#quiz { position: relative; z-index: 230; }
/* If any answer cards rely on their own stacking contexts, keep them within quiz scope */
#quiz .qcard { position: relative; }
</style>

<script>
// Sticky Notes: dock + windows with localStorage persistence
(function(){
    const storeKey = 'sticky.notes.v1';
    const calStoreKey = 'calendar.dayNotes.v1';
    const $ = id => document.getElementById(id);
            const dock = $('stickyDock'); const panel = $('stickyPanel');
            const calPanel = $('calendarPanel');
            const titleBox = $('stickyTitleBox');
            const rail = document.getElementById('stickyRail');
            /**
             * Make sticky UI inert (non-focusable, no pointer events) but still visible.
             * This is used during the boot sequence so sticky controls stay in the background.
             */
            function setStickyInert(inert){
                try{
                    const root = document.documentElement;
                    // visual containers: set aria-hidden/pointer-events and temporarily lower z-index so overlay remains on top
                    [dock, panel, calPanel, rail, titleBox].forEach(el=>{
                        if(!el) return;
                            if(inert){ 
                            // save previous z-index
                            try{ el.dataset._oldZ = el.style.zIndex || ''; }catch{};
                            el.setAttribute('aria-hidden', 'true'); el.style.pointerEvents = 'none'; el.style.zIndex = '10';
                        }
                        else { 
                            el.removeAttribute('aria-hidden'); el.style.pointerEvents = ''; 
                            try{ if(el.dataset._oldZ !== undefined) { el.style.zIndex = el.dataset._oldZ || ''; delete el.dataset._oldZ; } }catch{};
                        }
                    });
                    // individual note windows: make inputs non-focusable while inert
                    document.querySelectorAll('.sticky-note').forEach(win=>{
                        const inputs = win.querySelectorAll('input,textarea,button');
                        inputs.forEach(i=>{
                            if(inert){ i.dataset._oldTab = i.getAttribute('tabindex') || ''; i.setAttribute('tabindex','-1'); i.setAttribute('aria-hidden','true'); }
                            else { if(i.dataset._oldTab!=='') i.setAttribute('tabindex', i.dataset._oldTab); else i.removeAttribute('tabindex'); i.removeAttribute('aria-hidden'); delete i.dataset._oldTab; }
                        });
                        // pointer-events for the whole window and temporarily lower z-index so boot overlay remains above notes
                        if(inert){ try{ win.dataset._oldZ = win.style.zIndex || ''; }catch{}; win.style.pointerEvents = 'none'; win.style.zIndex = '12'; }
                        else { win.style.pointerEvents = ''; try{ if(win.dataset._oldZ!==undefined){ win.style.zIndex = win.dataset._oldZ || ''; delete win.dataset._oldZ; } }catch{} }
                    });
                    // If restoring interactivity, ensure layout is recomputed
                    if(!inert){ try{ if(typeof layoutAllSlots === 'function') layoutAllSlots(); }catch(e){} }
                }catch(e){}
            }
    function computeMinWidthFor(el){
        try{
            const actions = el.querySelector('.sticky-actions');
            const actionsW = actions ? actions.getBoundingClientRect().width : 0;
            // space for title input + padding + actions
            const needed = Math.ceil(actionsW + 140);
            return Math.max(300, needed);
        }catch{ return 300; }
    }

    const btnNew = $('sdNew'), btnList = $('sdList'), btnClose = $('sdClose');
    const btnCal = $('sdCalendar');
    const btnClearAll = $('sdClearAll');
    const listWrap = $('sdListWrap'); const search = $('sdSearch'); const countEl = $('sdCount');
    const colors = ['yellow','green','pink','sky','lav'];

    // Calendar elements
    const cal = {
        btn: btnCal,
        panel: calPanel,
        grid: $('calGrid'),
        monthLabel: $('calMonthLabel'),
        hint: $('calHint'),
        prev: $('calPrev'),
        next: $('calNext'),
        todayBtn: $('calToday'),
        close: $('calClose'),
        selectedLabel: $('calSelected'),
        title: $('calTitle'),
        note: $('calNote'),
        clearDay: $('calClearDay')
    };
    const calState = {
        viewY: null,
        viewM: null,
        selectedKey: null,
        _renderRaf: 0,
        _renderDebounce: 0
    };

    function pad2(n){ return String(n).padStart(2,'0'); }
    function dateKeyFromParts(y,m,d){ return `${y}-${pad2(m+1)}-${pad2(d)}`; }
    function todayKey(){ const t = new Date(); return dateKeyFromParts(t.getFullYear(), t.getMonth(), t.getDate()); }
    function loadCalNotes(){
        try{
            const raw = localStorage.getItem(calStoreKey);
            const obj = raw ? JSON.parse(raw) : {};
            return (obj && typeof obj === 'object') ? obj : {};
        }catch(e){ return {}; }
    }
    function saveCalNotes(obj){ try{ localStorage.setItem(calStoreKey, JSON.stringify(obj || {})); }catch(e){} }
    function getCalEntry(key){
        try{
            const o = loadCalNotes();
            const v = o[key];
            if(typeof v === 'string') return { note: v, title: '' };
            if(v && typeof v === 'object') return { note: String(v.note ?? ''), title: String(v.title ?? '') };
            return { note: '', title: '' };
        }catch{ return { note:'', title:'' }; }
    }
    function setCalEntry(key, patch){
        try{
            if(!key) return;
            const o = loadCalNotes();
            const cur = (function(){
                const v = o[key];
                if(typeof v === 'string') return { note: v, title: '' };
                if(v && typeof v === 'object') return { note: String(v.note ?? ''), title: String(v.title ?? '') };
                return { note: '', title: '' };
            })();

            const next = {
                note: (patch && patch.note != null) ? String(patch.note) : cur.note,
                title: (patch && patch.title != null) ? String(patch.title) : cur.title,
            };
            // Delete entry only if BOTH fields are blank/whitespace
            if(!String(next.note||'').trim() && !String(next.title||'').trim()) delete o[key];
            else o[key] = { note: next.note, title: next.title };
            saveCalNotes(o);
        }catch(e){}
    }
    function getCalNote(key){ return getCalEntry(key).note; }
    function setCalNote(key, text){
        try{
            const raw = String(text ?? '');
            // Treat whitespace-only as empty, but preserve internal/trailing spaces while typing
            setCalEntry(key, { note: raw });
        }catch(e){}
    }
    function getCalTitle(key){ return getCalEntry(key).title; }
    function setCalTitle(key, text){
        try{
            const raw = String(text ?? '');
            setCalEntry(key, { title: raw });
        }catch(e){}
    }
    function calDaysInMonth(y,m){ return new Date(y, m+1, 0).getDate(); }
    function calDowOfFirst(y,m){ return new Date(y, m, 1).getDay(); } // 0=Sun
    function calMonthName(y,m){
        try{
            const dt = new Date(y, m, 1);
            return dt.toLocaleString(undefined, { month:'long', year:'numeric' });
        }catch{ return `${y}-${pad2(m+1)}`; }
    }

    function selectCalDay(key){
        try{ calState.selectedKey = key; }catch(e){}
        try{ if(cal.selectedLabel) cal.selectedLabel.textContent = key ? key : 'Select a day…'; }catch(e){}
        try{ if(cal.title){ cal.title.value = key ? (getCalTitle(key) || '') : ''; cal.title.disabled = !key; } }catch(e){}
        try{ if(cal.note){ cal.note.value = key ? (getCalNote(key) || '') : ''; cal.note.disabled = !key; } }catch(e){}
        scheduleRenderCalendar();
    }

    function ensureCalStateInit(){
        if(calState.viewY == null || calState.viewM == null){
            const t = new Date();
            calState.viewY = t.getFullYear();
            calState.viewM = t.getMonth();
        }
        if(!calState.selectedKey){
            calState.selectedKey = todayKey();
        }
        try{ if(cal.title) cal.title.disabled = !calState.selectedKey; }catch{}
        try{ if(cal.note) cal.note.disabled = !calState.selectedKey; }catch{}
    }

    function renderCalendar(){
        try{
            if(!cal.panel || !cal.grid) return;
            ensureCalStateInit();

            const y = calState.viewY, m = calState.viewM;
            const tKey = todayKey();
            const notes = loadCalNotes();
            if(cal.monthLabel) cal.monthLabel.textContent = calMonthName(y, m);
            if(cal.hint) cal.hint.textContent = 'Click a day to add a note';

            const dow = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
            const firstDow = calDowOfFirst(y,m);
            const dim = calDaysInMonth(y,m);

            const parts = [];
            // DOW header
            for(let i=0;i<7;i++){
                parts.push(`<div class="cal-dow" role="columnheader" aria-label="${dow[i]}">${dow[i]}</div>`);
            }
            // leading blanks
            for(let i=0;i<firstDow;i++){
                parts.push('<div class="cal-empty" aria-hidden="true"></div>');
            }
            for(let d=1; d<=dim; d++){
                const key = dateKeyFromParts(y,m,d);
                const entry = (function(){
                    const v = notes[key];
                    if(typeof v === 'string') return { note: v, title: '' };
                    if(v && typeof v === 'object') return { note: String(v.note ?? ''), title: String(v.title ?? '') };
                    return { note: '', title: '' };
                })();
                const note = entry.note;
                const title = entry.title;
                const hasNote = !!(note && note.trim());
                const hasTitle = !!(title && title.trim());
                const preview = hasNote ? note.replace(/\s+/g,' ').slice(0, 54) : '—';
                const cls = [
                    'cal-day',
                    hasNote ? 'has-note' : '',
                    (key === tKey) ? 'today' : '',
                    (key === calState.selectedKey) ? 'selected' : ''
                ].filter(Boolean).join(' ');
                const safeTitle = hasTitle ? title.replace(/[&<>]/g, ch=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[ch])) : '';
                const ariaTitle = hasTitle
                    ? title.replace(/\s+/g,' ').trim().slice(0, 40).replace(/["&<>]/g, ch=>({'"':'&quot;','&':'&amp;','<':'&lt;','>':'&gt;'}[ch]))
                    : '';
                parts.push(
                    `<button class="${cls}" type="button" role="gridcell" data-cal-key="${key}" aria-label="${key}${hasTitle ? ': ' + ariaTitle : ''}${hasNote ? ': has note' : ''}">`+
                    `<div class="n">${d}</div>`+
                    (hasTitle ? `<div class="cal-title" aria-hidden="true">${safeTitle}</div>` : ``)+
                    `<div class="p">${preview.replace(/[&<>]/g, ch=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[ch]))}</div>`+
                    `</button>`
                );
            }
            cal.grid.innerHTML = parts.join('');

            // Click handlers
            cal.grid.querySelectorAll('[data-cal-key]').forEach(btn=>{
                btn.addEventListener('click', ()=>{
                    const key = btn.getAttribute('data-cal-key');
                    selectCalDay(key);
                    try{ if(cal.note) cal.note.focus(); }catch{}
                });
            });

            // Keep label synced; do NOT overwrite textarea while typing (it breaks cursor/spaces)
            try{ if(cal.selectedLabel) cal.selectedLabel.textContent = calState.selectedKey ? calState.selectedKey : 'Select a day…'; }catch(e){}
        }catch(e){
            try{ console.warn('Calendar render failed', e); }catch(_){}
        }
    }

    function scheduleRenderCalendar(){
        try{
            if(calState._renderRaf) return;
            calState._renderRaf = requestAnimationFrame(()=>{
                calState._renderRaf = 0;
                renderCalendar();
            });
        }catch(e){ renderCalendar(); }
    }

    function toggleCalendar(show){
        if(!cal.panel) return;
        positionDockAndPanel();
        // keep one panel open at a time for clarity
        try{ panel && panel.classList.add('hidden'); panel && (panel.style.zIndex = '210'); }catch(e){}
        cal.panel.classList.toggle('hidden', !show);
        cal.panel.style.zIndex = cal.panel.classList.contains('hidden') ? '210' : '9999';
        if(show){
            ensureCalStateInit();
            try{ selectCalDay(calState.selectedKey); }catch(e){}
            scheduleRenderCalendar();
            try{ if(cal.note) cal.note.focus(); }catch(e){}
        }
    }

    function uid(){ return Math.random().toString(36).slice(2,9); }
    function now(){ return Date.now(); }
    function load(){ try{ const raw = localStorage.getItem(storeKey); return raw ? JSON.parse(raw) : []; }catch(e){ return []; } }
    function save(arr){ try{ localStorage.setItem(storeKey, JSON.stringify(arr||[])); updateCount(); }catch(e){} }
    function updateCount(){ try{ const arr = load(); countEl.textContent = String(arr.length); }catch{} }
    // Rail width control: persisted CSS variable
    const railWidthKey = 'sticky.railW.v1';
    function getRailW(){
        try{ const v = localStorage.getItem(railWidthKey); const n = v? parseInt(v,10): NaN; if(!isNaN(n)) return Math.min(520, Math.max(220, n)); }catch{}
        return 280;
    }
    function setRailW(px){
        const v = Math.min(520, Math.max(220, Math.round(px||280)));
        try{ localStorage.setItem(railWidthKey, String(v)); }catch{}
        try{ document.documentElement.style.setProperty('--stickyRailW', v + 'px'); }catch{}
        try{ layoutAllSlots(); }catch{}
        return v;
    }

    // Sticky rail helpers
    const getSlots = () => Array.from(document.querySelectorAll('.clip-slot'));
    function highlightSlot(index){
        try{ getSlots().forEach((s,i)=> s.classList.toggle('slot-hover', i===index)); }catch{}
    }
    function setOccupiedFlags(){
        try{
            const arr = load();
            getSlots().forEach((s,i)=>{
                const notes = arr.filter(n=> n.open!==false && n.clippedSlot===i).sort((a,b)=> (b.updatedAt||0)-(a.updatedAt||0));
                const count = notes.length;
                s.classList.toggle('occupied', count>0);
                // remove previous color classes
                s.classList.remove('c-yellow','c-green','c-pink','c-sky','c-lav');
                if(count>0){
                    const top = notes[0]; const col = top.color || 'yellow'; s.classList.add('c-'+col);
                }
            });
        }catch{}
    }
    function layoutSlot(i){
        try{
            const slots = getSlots(); const sEl = slots[i]; if(!sEl) return;
            const rect = sEl.getBoundingClientRect();
            const pad = 6, gap = 6;
            const width = Math.max(40, Math.floor(rect.width - pad*2));
            const arr = load().filter(n=> n.open!==false && n.clippedSlot===i).sort((a,b)=> (b.updatedAt||0)-(a.updatedAt||0));
            if(arr.length===0){ sEl.classList.remove('occupied'); return; }
            const availH = Math.max(40, Math.floor(rect.height - pad*2 - gap*(arr.length-1)));
            const minH = 56;
            const height = Math.max(minH, Math.floor(availH / arr.length));
            let top = Math.floor(rect.top + pad);
            const left = Math.floor(rect.left + pad);
            arr.forEach((note)=>{
                const win = document.querySelector(`[data-sticky-id="${note.id}"]`);
                if(!win) return;
                // Allow shrinking below normal min when clipped
                win.style.minWidth = '0px';
                win.style.left = left + 'px';
                win.style.top = top + 'px';
                win.style.width = width + 'px';
                win.style.height = height + 'px';
                // Demote clipped note to rail plane so it never sits above quiz/radios
                try{ win.style.zIndex = (i===4 ? '188' : '189'); win.setAttribute('data-sticky-slot', String(i)); }catch{}
                updateNote(note.id, { x: left, y: top, w: width, h: height });
                top += height + gap;
            });
            sEl.classList.add('occupied');
        }catch{}
    }
    function layoutAllSlots(){ try{ const slots = getSlots(); slots.forEach((_,i)=> layoutSlot(i)); setOccupiedFlags(); }catch{} }

    // Helpers to assign notes into empty clip slots
    function getSlotCounts(){
        try{
            const slots = getSlots(); const arr = load();
            return slots.map((s,i)=> arr.filter(n=> n.open!==false && n.clippedSlot===i).length);
        }catch{ return []; }
    }
    function findFirstEmptySlot(){
        try{
            const counts = getSlotCounts(); for(let i=0;i<counts.length;i++){ if(counts[i] === 0) return i; } return -1;
        }catch{ return -1; }
    }
    function assignNoteToFirstEmptySlot(noteId){
        try{
            const slot = findFirstEmptySlot(); if(slot < 0) return false;
            const arr = load(); const n = arr.find(x=> x.id===noteId); if(!n) return false;
            // persist clippedSlot and pre-size if possible
            updateNote(noteId, { clippedSlot: slot, preW: n.w || 300, preH: n.h || 220 });
            try{ layoutSlot(slot); setOccupiedFlags(); }catch{}
            return true;
        }catch{ return false; }
    }
    function assignOpenNotesToSlots(){
        try{
            const slots = getSlots(); if(!slots.length) return;
            const arr = load().filter(n=> n.open!==false && n.clippedSlot==null);
            if(!arr.length) return;
            for(let i=0;i<slots.length && arr.length;i++){
                const count = load().filter(n=> n.open!==false && n.clippedSlot===i).length;
                if(count === 0){ const note = arr.shift(); updateNote(note.id, { clippedSlot: i, preW: note.w||300, preH: note.h||220 }); try{ layoutSlot(i); }catch{} }
            }
            try{ setOccupiedFlags(); }catch{}
        }catch{}
    }

    // Keep pinned notes centered and sized within viewport when layout changes (news toggle, resize, tabs move)
    function centerPinnedNotes(topDock, dockH){
        try{
            const M = 12; // outer margin
            const arr = load().filter(n=> n.pinned);
            if(!arr || !arr.length) return;
            arr.forEach(n=>{
                const el = document.querySelector(`[data-sticky-id="${n.id}"]`);
                if(!el) return;
                // compute dynamic minimum width so actions aren't clipped
                const dynMin = computeMinWidthFor(el);
                const maxW = Math.max(dynMin, window.innerWidth - 2*M);
                let desiredW = Math.min(el.offsetWidth || (n.w||300), maxW);
                if(desiredW < dynMin) desiredW = dynMin;
                el.style.width = desiredW + 'px';
                // center horizontally
                const left = Math.max(M, Math.min(window.innerWidth - desiredW - M, Math.round((window.innerWidth - desiredW)/2)));
                // position vertically just under the dock/title if provided, otherwise keep current top
                const top = (typeof topDock === 'number' ? Math.max(M, Math.round(topDock + (dockH||0) + 12)) : Math.max(M, el.offsetTop || M));
                el.style.left = left + 'px';
                el.style.top = top + 'px';
                // persist
                updateNote(n.id, { x: left, y: top, w: desiredW, h: el.offsetHeight });
            });
        }catch{}
    }

        function createNote(data){
        const id = data?.id || uid();
        const note = {
            id,
            title: data?.title || 'Untitled',
            text: data?.text || '',
            color: data?.color || 'yellow',
                // spawn below the dock
                x: data?.x ?? (function(){ const r = dock?.getBoundingClientRect(); const w = data?.w ?? 300; return (window.innerWidth - (w + 24)); })(),
                y: data?.y ?? (function(){ const r = dock?.getBoundingClientRect(); return (r ? (r.bottom + 12) : 100); })(),
                w: data?.w ?? 300,
            h: data?.h ?? 220,
            z: data?.z ?? 195,
                clippedSlot: (data?.clippedSlot ?? null),
                preW: data?.preW,
                preH: data?.preH,
                minimized: false,
                pinned: false,
                open: data?.open ?? true,
            createdAt: data?.createdAt || now(),
            updatedAt: data?.updatedAt || now()
        };
        const arr = load();
        const ix = arr.findIndex(n => n.id===id);
        if(ix>=0) arr[ix] = note; else arr.push(note);
        save(arr);
        renderNoteWindow(note);
        return note;
    }

    function updateNote(id, patch){
        const arr = load();
        const ix = arr.findIndex(n=>n.id===id);
        if(ix<0) return;
        arr[ix] = { ...arr[ix], ...patch, updatedAt: now() };
        save(arr);
        return arr[ix];
    }

    function deleteNote(id){
        const arr = load().filter(n=>n.id!==id); save(arr);
        const win = document.querySelector(`[data-sticky-id="${id}"]`); if(win && win.parentNode) win.parentNode.removeChild(win);
        renderList(); try{ layoutAllSlots(); }catch{}
    }

    function bringToFront(el){
        try{
            const wins = document.querySelectorAll('.sticky-note');
            let top = 195; wins.forEach(w => { const z = parseInt(w.style.zIndex||'195',10)||195; if(z>top) top = z; });
            const z = top + 1; el.style.zIndex = String(z);
            const id = el.getAttribute('data-sticky-id'); updateNote(id, { z });
        }catch{}
    }

    function renderNoteWindow(n){
        let el = document.querySelector(`[data-sticky-id="${n.id}"]`);
        if(!el){ el = document.createElement('div'); el.className = `sticky-note c-${n.color||'yellow'}`; el.setAttribute('data-sticky-id', n.id); document.body.appendChild(el); }
            // layout: flex so body area always fills and is editable
            el.style.display = 'flex';
            el.style.flexDirection = 'column';
            const MIN_H = 140;
    // Clamp starting position within viewport with margins
    const vw = window.innerWidth, vh = window.innerHeight; const M = 8;
    const startX = Math.max(M, Math.min(vw - (n.w||300) - M, (n.x||20)));
    const startY = Math.max(M, Math.min(vh - (n.h||220) - M, (n.y||80)));
    el.style.left = startX + 'px';
    el.style.top = startY + 'px';
            el.style.minWidth = '300px';
            el.style.width = Math.max(300, n.w||300) + 'px';
            el.style.height = Math.max(MIN_H, Math.min(vh - 2*M, n.h||220)) + 'px';
        // If clipped into a slot, keep its z-index demoted to the rail plane; otherwise use stored z
        if(n.clippedSlot != null){ el.style.zIndex = (n.clippedSlot===4 ? '188' : '189'); el.setAttribute('data-sticky-slot', String(n.clippedSlot)); }
        else { el.style.zIndex = String(n.z||195); el.removeAttribute('data-sticky-slot'); }
        el.innerHTML = `
                <div class="sticky-head" style="flex:0 0 auto;">
                <input class="sticky-title" value="${(n.title||'').replace(/"/g,'&quot;')}" placeholder="Title" />
                <div class="sticky-actions">
                    <div class="sticky-color">
                        ${colors.map(c=>`<span class="dot c-${c}" data-color="${c}" title="${c}"></span>`).join('')}
                    </div>
                        <button class="sa" data-act="close" title="Close" aria-label="Close">×</button>
                </div>
            </div>
                <div class="sticky-body" style="flex:1 1 auto; min-height:0; display:flex;">
                    <textarea class="sticky-text" style="flex:1 1 auto; min-height:0; width:100%; height:100%; resize:none;" placeholder="Write anything…">${(n.text||'').replace(/</g,'&lt;')}</textarea>
            </div>
            <div class="sticky-resize" aria-hidden="true"></div>
        `;
            // After DOM built, enforce dynamic minimum width so actions never cut off
            try{
                const dynMin = computeMinWidthFor(el);
                el.style.minWidth = dynMin + 'px';
                // If current width is less than required, bump it up
                const curW = el.getBoundingClientRect().width;
                if(curW < dynMin){ el.style.width = dynMin + 'px'; }
            }catch{}
            // If this note is already clipped, lay it out inside its slot
            try{ if(n.clippedSlot != null){ requestAnimationFrame(()=>{ try{ layoutSlot(n.clippedSlot); setOccupiedFlags(); }catch{} }); } }catch{}
            // Apply color theme independent of global palette
            const COLOR_MAP = {
                yellow: { accent:'#f2cc60', border:'#6b5c20' },
                green:  { accent:'#5bd6a6', border:'#2a6e5c' },
                pink:   { accent:'#f29ac2', border:'#7a3158' },
                sky:    { accent:'#7cc7ff', border:'#2f5b7a' },
                lav:    { accent:'#bda3ff', border:'#5b4a8c' }
            };
            function applyNoteVisuals(color){
                const theme = COLOR_MAP[color] || COLOR_MAP.yellow;
                // base neutrals to avoid palette coupling
                const head = el.querySelector('.sticky-head');
                const body = el.querySelector('.sticky-body');
                el.style.background = '#0b1220';
                el.style.border = `1px solid ${theme.border}`;
                head.style.background = 'linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.22))';
                body.style.background = '#0e1624';
                // subtle accent outline and resize handle
                el.style.boxShadow = `0 10px 28px rgba(0,0,0,0.45), 0 0 0 1px ${theme.border}`;
            }
            applyNoteVisuals(n.color||'yellow');
            // wire interactions
        const title = el.querySelector('.sticky-title');
        const text = el.querySelector('.sticky-text');
        title.addEventListener('input', ()=>{ updateNote(n.id, { title: title.value }); renderList(); });
        text.addEventListener('input', ()=>{ updateNote(n.id, { text: text.value }); });
        // actions
            el.querySelectorAll('.sticky-actions .sa').forEach(btn=>{
                // prevent header drag from activating on button press
                btn.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); });
            btn.addEventListener('click', (e)=>{
                    const act = btn.getAttribute('data-act');
                    if(act==='close'){
                        updateNote(n.id, { open:false });
                        const win = document.querySelector(`[data-sticky-id="${n.id}"]`);
                        if(win && win.parentNode) win.parentNode.removeChild(win);
                        renderList();
                        // Recompute slot layout/occupied flags so any clip-slot perimeter is cleared
                        try{ layoutAllSlots(); }catch{}
                    }
            });
        });
        // color dots
            el.querySelectorAll('.sticky-color .dot').forEach(dot=>{
            const c = dot.getAttribute('data-color');
                dot.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); });
                dot.addEventListener('click', ()=>{ n = updateNote(n.id, { color: c }) || n; el.className = `sticky-note c-${c}`; applyNoteVisuals(c); renderList(); });
        });
        // dragging
        const head = el.querySelector('.sticky-head');
        let dragging=false, start={x:0,y:0,left:0,top:0};
            const isInteractive = (t)=> !!(t && (t.closest('.sticky-actions') || t.closest('.sticky-color') || t.closest('.sticky-title') || t.closest('button') || t.closest('input') || t.closest('textarea')));
            head.addEventListener('pointerdown', (e)=>{
                if(isInteractive(e.target)) return;
                // If clipped, unclip and restore pre-size
                if(n.clippedSlot != null){
                    const prevSlot = n.clippedSlot;
                    const prevW = Math.max(300, n.preW || el.offsetWidth || 300);
                    const prevH = Math.max(140, n.preH || el.offsetHeight || 220);
                    n = updateNote(n.id, { clippedSlot: null, w: prevW, h: prevH }) || n;
                    el.style.width = prevW + 'px';
                    el.style.height = prevH + 'px';
                    // restore dynamic min width for freeform
                    try{ const dynMin = computeMinWidthFor(el); el.style.minWidth = dynMin + 'px'; if(prevW < dynMin){ el.style.width = dynMin + 'px'; } }catch{}
                    try{ layoutSlot(prevSlot); setOccupiedFlags(); }catch{}
                }
                dragging=true; head.setPointerCapture(e.pointerId); bringToFront(el); start={x:e.clientX,y:e.clientY,left:el.offsetLeft,top:el.offsetTop}; el.style.transition='none';
            });
        head.addEventListener('pointermove', (e)=>{ if(!dragging) return; const dx=e.clientX-start.x, dy=e.clientY-start.y; let L = start.left+dx, T=start.top+dy; const vw=window.innerWidth, vh=window.innerHeight; const M=4; L=Math.max(M, Math.min(vw - el.offsetWidth - M, L)); T=Math.max(M, Math.min(vh - el.offsetHeight - M, T)); el.style.left=L+'px'; el.style.top=T+'px';
            // slot hover highlight under center
            let hovered=-1; const cx=L+el.offsetWidth/2, cy=T+el.offsetHeight/2;
            try{ getSlots().forEach((s,i)=>{ const r=s.getBoundingClientRect(); if(cx>=r.left && cx<=r.right && cy>=r.top && cy<=r.bottom){ hovered=i; } }); }catch{}
            highlightSlot(hovered>=0?hovered:null);
        });
        head.addEventListener('pointerup', (e)=>{ if(!dragging) return; dragging=false; head.releasePointerCapture(e.pointerId);
            // snap to slot if released over one
            let target=-1; const cx=el.offsetLeft+el.offsetWidth/2, cy=el.offsetTop+el.offsetHeight/2;
            try{ getSlots().forEach((s,i)=>{ const r=s.getBoundingClientRect(); if(cx>=r.left && cx<=r.right && cy>=r.top && cy<=r.bottom){ target=i; } }); }catch{}
            highlightSlot(null);
            if(target>=0){ n = updateNote(n.id, { preW: el.offsetWidth, preH: el.offsetHeight, clippedSlot: target }) || n; try{ layoutSlot(target); setOccupiedFlags(); }catch{} }
            else{ updateNote(n.id, { x: el.offsetLeft, y: el.offsetTop }); }
            el.style.transition='';
        });
        // resize
            const res = el.querySelector('.sticky-resize');
        let resizing=false, rs={x:0,y:0,w:0,h:0};
            res.addEventListener('pointerdown', (e)=>{ if(n.clippedSlot!=null) return; e.preventDefault(); resizing=true; res.setPointerCapture(e.pointerId); bringToFront(el); rs={x:e.clientX,y:e.clientY,w:el.offsetWidth,h:el.offsetHeight}; });
            res.addEventListener('pointermove', (e)=>{ if(!resizing) return; const dx=e.clientX-rs.x, dy=e.clientY-rs.y; const dynMin = computeMinWidthFor(el); const vw=window.innerWidth, vh=window.innerHeight; const M=8; const maxW = Math.max(dynMin, vw - el.offsetLeft - M); const maxH = Math.max(MIN_H, vh - el.offsetTop - M); const W=Math.max(dynMin, Math.min(maxW, rs.w+dx)); const H=Math.max(MIN_H, Math.min(maxH, rs.h+dy)); el.style.width=W+'px'; el.style.height=H+'px'; });
        res.addEventListener('pointerup', (e)=>{ if(!resizing) return; resizing=false; res.releasePointerCapture(e.pointerId); updateNote(n.id, { w: el.offsetWidth, h: el.offsetHeight, x: el.offsetLeft, y: el.offsetTop }); });
        el.addEventListener('mousedown', ()=> bringToFront(el));
    }

    function renderList(){
        const q = (search?.value||'').toLowerCase();
        const arr = load().slice().sort((a,b)=> (b.updatedAt||0) - (a.updatedAt||0));
        const vis = q ? arr.filter(n=> (n.title||'').toLowerCase().includes(q) || (n.text||'').toLowerCase().includes(q)) : arr;
            if(listWrap){ listWrap.innerHTML = vis.map(n=>{
            const dt = new Date(n.updatedAt||n.createdAt||now()).toLocaleString();
            const snip = (n.text||'').replace(/\s+/g,' ').slice(0,80);
                return `<div class="sticky-item" data-open="${n.id}">
                    <div class="si-main">
                        <span class="sticky-dot c-${n.color||'yellow'}"></span>
                        <div>
                            <div><strong>${(n.title||'Untitled').replace(/[&<>]/g, ch=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[ch]))}</strong></div>
                            <div class="sticky-meta">${dt} — ${snip}</div>
                        </div>
                    </div>
                    <button class="sticky-del" data-del="${n.id}">Delete</button>
                </div>`;
        }).join('');
                listWrap.querySelectorAll('.sticky-item').forEach(it=> it.addEventListener('click', (ev)=>{
                    // ignore if delete was clicked
                    if((ev.target).closest && (ev.target).closest('.sticky-del')) return;
                const id = it.getAttribute('data-open');
                    const arr2 = load(); const n = arr2.find(x=>x.id===id); if(n){
                        updateNote(id, { open:true });
                        renderNoteWindow(n);
                        const el = document.querySelector(`[data-sticky-id="${id}"]`);
                        if(el) bringToFront(el);
                        // Auto-assign this opened note to the first empty slot (top-to-bottom)
                        try{ assignNoteToFirstEmptySlot(id); }catch{}
                    }
            }));
                listWrap.querySelectorAll('.sticky-del').forEach(btn=> btn.addEventListener('click', (e)=>{ e.stopPropagation(); const id = btn.getAttribute('data-del'); if(confirm('Delete this note permanently?')) deleteNote(id); }));
        }
        updateCount();
    }

        function positionDockAndPanel(){
            try{
                const GAP_TITLE_TO_DOCK = 6;   // px gap between title and dock
                const GAP_DOCK_TO_PANEL = 8;  // px gap between dock and panel top
                const GAP_DOCK_TO_RAIL  = 8;  // px gap between dock and rail top

                const r = titleBox?.getBoundingClientRect();
                const topDock = r ? Math.round(r.bottom + GAP_TITLE_TO_DOCK) : 40;
                const dockH = Math.round(dock?.getBoundingClientRect()?.height || 40);

                if(dock){
                    dock.style.top = `${topDock}px`;
                    dock.style.zIndex = '210';
                }
                if(panel){
                    panel.style.top = `${topDock + dockH + GAP_DOCK_TO_PANEL}px`;
                    // Keep panel above everything when visible
                    panel.style.zIndex = panel.classList.contains('hidden') ? '210' : '9999';
                }
                if(calPanel){
                    calPanel.style.top = `${topDock + dockH + GAP_DOCK_TO_PANEL}px`;
                    calPanel.style.zIndex = calPanel.classList.contains('hidden') ? '210' : '9999';
                }
                if(rail){
                    // Place rail under the dock; compute height to visually reach bottom even when scaled
                    const topRail = topDock + dockH + GAP_DOCK_TO_RAIL;
                    rail.style.top = `${topRail}px`;
                    // Clear bottom so explicit height can be applied
                    rail.style.bottom = '';
                    const cs = getComputedStyle(document.documentElement);
                    const scaleStr = (cs.getPropertyValue('--stickyScale') || '1').trim();
                    const s = Math.max(0.5, Math.min(1.5, parseFloat(scaleStr) || 1));
                    const paddingBottom = 8; // keep a small visual gutter at bottom
                    const avail = Math.max(0, Math.floor(window.innerHeight - topRail - paddingBottom));
                    // Account for scaleY: set pre-scale height so the scaled visual fills to bottom
                    const targetH = Math.ceil(avail / s);
                    rail.style.height = `${targetH}px`;
                    // Re-layout any clipped notes now that the rail position/height changed
                    try{ layoutAllSlots(); }catch{}
                }
                // Position the left magnet tab between top controls and the radio player
                try{
                    const leftTab = document.getElementById('leftMagnet');
                    const hzL = document.getElementById('leftTabHoverzone');
                    const resL = document.getElementById('leftTabResizer');
                    const controls = document.getElementById('bgToggles');
                    const radio = document.getElementById('radioPlayer');
                    if(leftTab && controls && radio){
                        // IMPORTANT: #bgToggles can end up with an inflated bounding box due to
                        // non-visual or out-of-flow descendants. Anchor the magnet to the
                        // last visible control row (prefer the focus row) so spacing below the
                        // Focus button stays tight.
                        const getControlsAnchorRect = ()=>{
                            try{
                                const focusRow = document.getElementById('focusInlineContainer');
                                if(focusRow && focusRow.offsetParent !== null){
                                    const fr = focusRow.getBoundingClientRect();
                                    if(fr && fr.height > 0) return fr;
                                }
                            }catch(e){}
                            try{
                                const kids = Array.from(controls.children || []);
                                for(let i = kids.length - 1; i >= 0; i--){
                                    const el = kids[i];
                                    if(!el || !el.tagName) continue;
                                    const tag = String(el.tagName || '').toUpperCase();
                                    if(tag === 'SCRIPT' || tag === 'STYLE') continue;
                                    if(el.offsetParent === null) continue;
                                    const r = el.getBoundingClientRect();
                                    if(r && r.height > 0) return r;
                                }
                            }catch(e){}
                            return controls.getBoundingClientRect();
                        };

                        const cRect = getControlsAnchorRect();
                        const rRect = radio.getBoundingClientRect();
                        const gapTop = 12, gapBottom = 12;
                        const initialTop = Math.round(cRect.bottom + gapTop);

                        // The left magnet's height is independent of the radio module. Record
                        // an initial fixed height (from CSS or current offset) on first run and
                        // preserve it thereafter so the radio cannot affect the tab height.
                        if(!leftTab.dataset.initialH){
                            const cs = getComputedStyle(leftTab);
                            const hFromCss = parseInt(cs.getPropertyValue('height')) || leftTab.offsetHeight || 450;
                            leftTab.dataset.initialH = String(Math.max(450, hFromCss));
                        }
                        const initialH = parseInt(leftTab.dataset.initialH, 10) || 240;

                        // Compute a height that always ends at the TOP of the HIDDEN radio module,
                        // independent of whether the radio is currently expanded/collapsed. This
                        // makes the magnet responsive to zoom changes while remaining stable across
                        // show/hide toggles.
                        let desiredH = initialH;
                        try{
                            const SEPARATION = 8; // px gap between magnet bottom and hidden radio top
                            // Determine the hidden/minimized radio height once and cache it
                            if(!radio.dataset.minH){
                                let minH = radio.offsetHeight || 0;
                                try{
                                    if(!radio.classList.contains('min')){
                                        radio.classList.add('min');
                                        minH = radio.offsetHeight || minH;
                                        radio.classList.remove('min');
                                    }
                                }catch{ /* ignore */ }
                                if(!minH || minH < 40) minH = 72;
                                radio.dataset.minH = String(Math.round(minH));
                            }
                            const radioMinH = parseInt(radio.dataset.minH, 10) || 72;
                            // Include the radio's dynamic raise (from the ASCII clock) set via --rpRaise
                            let rpRaise = 0;
                            try{ const csR = getComputedStyle(radio); const v = csR.getPropertyValue('--rpRaise'); if(v) rpRaise = parseInt(v) || 0; }catch{}
                            const bottomInset = gapBottom; // matches radio CSS 12px bottom padding
                            const hiddenRadioTop = Math.round(window.innerHeight - rpRaise - bottomInset - radioMinH);
                            // Target height so magnet bottom ends at the hidden radio top minus separation
                            const target = Math.round(hiddenRadioTop - initialTop - SEPARATION);
                            desiredH = Math.max(120, target);
                        }catch{ desiredH = Math.max(120, initialH); }

                        // Anchor the top to the controls and apply the responsive height
                        leftTab.style.top = initialTop + 'px';
                        leftTab.style.height = desiredH + 'px';
                        leftTab.style.display = '';

                        // Center resizer/hoverzone on this span
                        const cy = Math.round(initialTop + desiredH/2);
                        if(hzL){ hzL.style.top = cy + 'px'; }
                        if(resL){ resL.style.top = cy + 'px'; }

                        // Critical: slot-4 notes were being laid out before the left magnet moved/resized.
                        // Re-layout only slot 4 here so the clipped note stays perfectly affixed.
                        try{ if(typeof layoutSlot === 'function') layoutSlot(4); }catch{}
                        try{ if(typeof setOccupiedFlags === 'function') setOccupiedFlags(); }catch{}
                    }
                }catch{}
                // Keep resizer/hoverzone aligned with current rail width and vertically centered on the rail
                try{
                    const handle = document.getElementById('stickyRailResizer');
                    const hz = document.getElementById('stickyRailHoverzone');
                    if(handle || hz){
                        const rr = rail?.getBoundingClientRect();
                        const cy = rr ? Math.round(rr.top + rr.height/2) : Math.round(window.innerHeight/2);
                        if(handle){ handle.style.top = `${cy}px`; }
                        if(hz){ hz.style.top = `${cy}px`; }
                    }
                }catch{}
                // Keep any pinned notes centered under the dock/title
                try{ centerPinnedNotes(topDock, dockH); }catch{}
            }catch{}
        }

        function togglePanel(show){
            if(!panel) return;
            positionDockAndPanel();
            panel.classList.toggle('hidden', !show);
            // Apply topmost z-index when shown
            panel.style.zIndex = panel.classList.contains('hidden') ? '210' : '9999';
            // Only one panel open at a time
            try{ if(!panel.classList.contains('hidden')){ calPanel && calPanel.classList.add('hidden'); calPanel && (calPanel.style.zIndex = '210'); } }catch(e){}
        }

    // Dock wiring
        btnNew?.addEventListener('click', ()=>{
            const n = createNote({ title: 'Untitled', text: '' });
            renderList();
            const el = document.querySelector(`[data-sticky-id="${n.id}"]`);
            if(el) bringToFront(el);
            // Try to place into first empty slot automatically
            try{ if(assignNoteToFirstEmptySlot(n.id)) { /* placed into slot */ } else { /* left floating */ } }catch{}
        });
        btnList?.addEventListener('click', ()=>{
            // Toggle the panel and render list
            const wasHidden = panel.classList.contains('hidden');
            togglePanel(wasHidden);
            renderList();
            // If opening the panel, assign any open notes to empty slots
            if(wasHidden){ try{ assignOpenNotesToSlots(); }catch{} }
        });
        btnCal?.addEventListener('click', ()=>{
            const wasHidden = calPanel ? calPanel.classList.contains('hidden') : true;
            toggleCalendar(wasHidden);
        });
    btnClose?.addEventListener('click', ()=> togglePanel(false));
    search?.addEventListener('input', renderList);

        // Calendar wiring
        try{
            cal.close && cal.close.addEventListener('click', ()=> toggleCalendar(false));
            cal.prev && cal.prev.addEventListener('click', ()=>{ ensureCalStateInit(); calState.viewM -= 1; if(calState.viewM < 0){ calState.viewM = 11; calState.viewY -= 1; } scheduleRenderCalendar(); });
            cal.next && cal.next.addEventListener('click', ()=>{ ensureCalStateInit(); calState.viewM += 1; if(calState.viewM > 11){ calState.viewM = 0; calState.viewY += 1; } scheduleRenderCalendar(); });
            cal.todayBtn && cal.todayBtn.addEventListener('click', ()=>{ const t = new Date(); calState.viewY = t.getFullYear(); calState.viewM = t.getMonth(); selectCalDay(todayKey()); });
            cal.clearDay && cal.clearDay.addEventListener('click', ()=>{
                if(!calState.selectedKey) return;
                if(!confirm('Clear title and note for this day?')) return;
                setCalEntry(calState.selectedKey, { title: '', note: '' });
                try{ if(cal.title) cal.title.value = ''; }catch(e){}
                try{ if(cal.note) cal.note.value = ''; }catch(e){}
                scheduleRenderCalendar();
            });
            // Save title on input
            if(cal.title){
                cal.title.addEventListener('input', ()=>{
                    if(!calState.selectedKey) return;
                    setCalTitle(calState.selectedKey, cal.title.value);
                    // Debounce grid refresh to avoid jank while typing
                    try{ if(calState._renderDebounce) clearTimeout(calState._renderDebounce); }catch(e){}
                    calState._renderDebounce = setTimeout(()=>{ calState._renderDebounce = 0; scheduleRenderCalendar(); }, 120);
                });
            }
            // Save on input (brief notes)
            if(cal.note){
                cal.note.addEventListener('input', ()=>{
                    if(!calState.selectedKey) return;
                    setCalNote(calState.selectedKey, cal.note.value);
                    // Debounce grid refresh to avoid jank while typing
                    try{ if(calState._renderDebounce) clearTimeout(calState._renderDebounce); }catch(e){}
                    calState._renderDebounce = setTimeout(()=>{ calState._renderDebounce = 0; scheduleRenderCalendar(); }, 120);
                });
            }
        }catch(e){}

    // Clear all sticky notes — confirm then wipe storage and DOM
    btnClearAll?.addEventListener('click', ()=>{
        try{
            if(!confirm('Delete ALL sticky notes? This cannot be undone.')) return;
            // Clear storage
            save([]);
            // Remove any rendered note windows
            document.querySelectorAll('.sticky-note').forEach(el=>{ if(el && el.parentNode) el.parentNode.removeChild(el); });
            // Refresh UI
            renderList();
            try{ layoutAllSlots(); }catch{};
        }catch(e){ console.log('sdClearAll failed', e); }
    });

    // Load existing notes on startup
    setRailW(getRailW());
    positionDockAndPanel();
    try{ load().filter(n=> n.open!==false).forEach(renderNoteWindow); }catch{}
    try{ layoutAllSlots(); }catch{}
    renderList();

    // Calendar init (render lazily; but prime state)
    try{ ensureCalStateInit(); if(cal.title) cal.title.disabled = !calState.selectedKey; if(cal.note) cal.note.disabled = !calState.selectedKey; }catch(e){}

    // Try to avoid covering the current notepad; nudge dock below it
                // Keep dock top-right anchored under title; also keep notes on-screen when viewport changes (zoom/resize)
                window.addEventListener('resize', function(){
                    positionDockAndPanel();
                    // also re-position the left magnet tab after viewport changes
                    try{ const _=document.getElementById('leftMagnet'); if(_) {/* noop; work done in positionDockAndPanel */} }catch{}
                    try{
                        const vw = window.innerWidth, vh = window.innerHeight; const M=8;
                        document.querySelectorAll('.sticky-note').forEach(function(el){
                            // Clamp size to viewport
                            const w = Math.min(parseInt(el.style.width||el.offsetWidth)||300, vw - 2*M);
                            const h = Math.min(parseInt(el.style.height||el.offsetHeight)||220, vh - 2*M);
                            el.style.width = Math.max(300, w) + 'px';
                            el.style.height = Math.max(140, h) + 'px';
                            // Clamp position to viewport
                            let L = Math.max(M, Math.min(vw - el.offsetWidth - M, el.offsetLeft));
                            let T = Math.max(M, Math.min(vh - el.offsetHeight - M, el.offsetTop));
                            el.style.left = L + 'px';
                            el.style.top = T + 'px';
                            const id = el.getAttribute('data-sticky-id'); if(id) updateNote(id, { x: L, y: T, w: el.offsetWidth, h: el.offsetHeight });
                        });
                        try{ layoutAllSlots(); }catch{}
                        try{ centerPinnedNotes(); }catch{}
                    }catch{}
                });
                window.addEventListener('load', positionDockAndPanel);

                // Reposition when the news header changes (height/visibility/content)
                try{
                    const newsBar = document.getElementById('newsBar');
                    if(window.ResizeObserver && newsBar){
                        const ro = new ResizeObserver(()=> positionDockAndPanel());
                        ro.observe(newsBar);
                    }
                    if(window.MutationObserver && newsBar){
                        const mo = new MutationObserver(()=> positionDockAndPanel());
                        mo.observe(newsBar, { childList:true, subtree:true, attributes:true, characterData:true });
                    }
                    const newsToggle = document.getElementById('newsToggle');
                    newsToggle && newsToggle.addEventListener('click', ()=>{
                        // call twice to cover immediate display:none changes and ensuing layout
                        positionDockAndPanel();
                        setTimeout(positionDockAndPanel, 60);
                        try{ centerPinnedNotes(); }catch{}
                        // Also re-layout clipped notes after the toggle settles
                        setTimeout(()=>{ try{ layoutAllSlots(); }catch{} }, 120);
                    });
                }catch{}

                // Track changes in the top controls area and radio show/hide to keep left tab reflexive
                try{
                    const controls = document.getElementById('bgToggles');
                    const radio = document.getElementById('radioPlayer');
                    if(window.ResizeObserver && controls){
                        const ro2 = new ResizeObserver(()=> positionDockAndPanel());
                        ro2.observe(controls);
                    }
                    // Radio toggle button updates class; observe class changes
                    const rpTog = document.getElementById('rpToggle');
                    rpTog && rpTog.addEventListener('click', ()=> setTimeout(positionDockAndPanel, 120));
                    if(window.MutationObserver && radio){
                        const mo2 = new MutationObserver(()=> positionDockAndPanel());
                        mo2.observe(radio, { attributes:true, attributeFilter:['class','style'] });
                    }
                }catch{}

                // Rail resizer wiring
                (function(){
                    const handle = document.getElementById('stickyRailResizer');
                    if(!handle) return;
                    let dragging=false; let startX=0; let startW=getRailW();
                    handle.addEventListener('pointerdown', (e)=>{
                        dragging=true; startX = e.clientX; startW = getRailW();
                        handle.classList.add('dragging');
                        try{ handle.setPointerCapture(e.pointerId); }catch{}
                        e.preventDefault();
                    });
                    window.addEventListener('pointermove', (e)=>{
                        if(!dragging) return; const dx = startX - e.clientX; setRailW(startW + dx);
                    });
                    window.addEventListener('pointerup', (e)=>{
                        if(!dragging) return; dragging=false; handle.classList.remove('dragging');
                        try{ handle.releasePointerCapture(e.pointerId); }catch{}
                    });
                    // Keyboard support
                    handle.setAttribute('tabindex','0');
                    handle.addEventListener('keydown', (e)=>{
                        const step = e.shiftKey ? 20 : 10;
                        if(e.key==='ArrowLeft'){ e.preventDefault(); setRailW(getRailW()+step); }
                        else if(e.key==='ArrowRight'){ e.preventDefault(); setRailW(getRailW()-step); }
                        else if(e.key==='Home'){ e.preventDefault(); setRailW(220); }
                        else if(e.key==='End'){ e.preventDefault(); setRailW(520); }
                    });
                    // Keep above when panel open
                    const mo = new MutationObserver(()=>{
                        try{ handle.style.zIndex = panel && !panel.classList.contains('hidden') ? '10000' : '211'; }catch{}
                    });
                    panel && mo.observe(panel, { attributes:true, attributeFilter:['class'] });
                })();

                // Left magnet tab resizer wiring (mirrors sticky rail behavior)
                (function(){
                    const handle = document.getElementById('leftTabResizer');
                    const KEY = '__leftTabW';
                    let __raf = 0;
                    function relayoutLeft(){
                        try{
                            if(__raf) return;
                            __raf = requestAnimationFrame(()=>{
                                __raf = 0;
                                try{ if(typeof layoutSlot === 'function') layoutSlot(4); }catch{}
                                try{ if(typeof setOccupiedFlags === 'function') setOccupiedFlags(); }catch{}
                            });
                        }catch{}
                    }
                    function getW(){ try{ const v = parseInt(localStorage.getItem(KEY)||'',10); if(isFinite(v) && v>=120 && v<=720) return v; }catch{} try{ const cs = getComputedStyle(document.documentElement); const w = parseInt(cs.getPropertyValue('--leftTabW')||'260',10); return isFinite(w)?w:260; }catch{} return 260; }
                    function setW(px){
                        const min = parseInt(handle?.dataset.min||'180',10);
                        const max = parseInt(handle?.dataset.max||'520',10);
                        const v = Math.max(min, Math.min(max, Math.round(px)));
                        document.documentElement.style.setProperty('--leftTabW', v+'px');
                        try{ localStorage.setItem(KEY, String(v)); }catch{}
                        // Important: resizing the left magnet changes the slot rect, but clipped notes won't update unless we relayout.
                        relayoutLeft();
                    }
                    // initialize width from storage
                    setW(getW());
                    if(!handle) return;
                    let dragging=false, startX=0, startW=getW();
                    handle.addEventListener('pointerdown', (e)=>{ dragging=true; startX=e.clientX; startW=getW(); try{ handle.setPointerCapture(e.pointerId); }catch{} e.preventDefault(); });
                    window.addEventListener('pointermove', (e)=>{ if(!dragging) return; const dx = e.clientX - startX; setW(startW + dx); });
                    window.addEventListener('pointerup', (e)=>{ if(!dragging) return; dragging=false; try{ handle.releasePointerCapture(e.pointerId); }catch{} });
                    // keyboard support
                    handle.setAttribute('tabindex','0');
                    handle.addEventListener('keydown', (e)=>{ const step = e.shiftKey?20:10; if(e.key==='ArrowLeft'){ e.preventDefault(); setW(getW()-step); } else if(e.key==='ArrowRight'){ e.preventDefault(); setW(getW()+step); } else if(e.key==='Home'){ e.preventDefault(); setW(parseInt(handle.dataset.min||'180',10)); } else if(e.key==='End'){ e.preventDefault(); setW(parseInt(handle.dataset.max||'520',10)); } });
                    // keep resizer aligned vertically with left magnet tab span on panel/dock movement
                    const sync = ()=>{ try{ const lm = document.getElementById('leftMagnet'); const hz = document.getElementById('leftTabHoverzone'); if(lm && (handle||hz)){ const r = lm.getBoundingClientRect(); const cy = Math.round(r.top + r.height/2); if(handle) handle.style.top = cy + 'px'; if(hz) hz.style.top = cy + 'px'; } }catch{} };
                    window.addEventListener('resize', sync);
                    setTimeout(sync, 0);
                })();

                // Track title box position changes (caused by --topSafeArea updates) and realign
                try{
                    let __lastTop = -1;
                    const watch = ()=>{
                        try{
                            const rb = titleBox?.getBoundingClientRect();
                            const t = rb ? Math.round(rb.top) : -1;
                            if(t !== __lastTop){ __lastTop = t; positionDockAndPanel(); }
                        }catch{}
                        requestAnimationFrame(watch);
                    };
                    requestAnimationFrame(watch);
                }catch{}
})();
</script>
<style>
/* Textbook-style AI output box (ID variant) */
#aiTextbookOutput{ background: linear-gradient(180deg,#fafaf6,#f3efe8); color:#111; border:1px solid rgba(0,0,0,0.08); padding:18px; border-radius:10px; font-family: 'Georgia', 'Times New Roman', serif; font-size:15px; line-height:1.6; box-shadow: 0 6px 18px rgba(0,0,0,0.06); color-scheme: light; }
#aiTextbookOutput .page{ background: linear-gradient(180deg,#fff,#f9f7f2); padding:14px; border-radius:6px; min-height:220px; max-height: calc(100vh - 240px); white-space:pre-wrap; overflow:auto; }
#aiTextbookOutput .ascii-face{ font-family: monospace; font-size:12px; color:#333; margin-top:10px; display:flex; align-items:center; justify-content:flex-start; gap:8px }
#aiTextbookOutput .ascii-face .face{ background:#fff; border-radius:6px; padding:6px 10px; border:1px solid rgba(0,0,0,0.06); box-shadow: inset 0 1px 0 rgba(255,255,255,0.6); }
#aiTextbookOutput .ascii-face .mouth{ display:inline-block; min-width:28px; text-align:center; }
#aiTextbookOutput .controls{ margin-top:8px; display:flex; gap:8px; justify-content:flex-end }

/* Textbook-style AI output box (class variant when we augment existing element) */
.aiTextbookOutput{
    /* Dark-mode variant: match other panels */
    background: linear-gradient(180deg, rgba(14,21,34,.65), rgba(9,15,26,.6)) !important;
    color: var(--ink) !important;
    border: 1px solid var(--stroke) !important;
    padding: 12px !important;
    border-radius: 8px !important;
    font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial !important;
    font-size: 13px !important;
    line-height: 1.5 !important;
    box-shadow: var(--depth) !important;
}
.aiTextbookOutput .page{
    background: linear-gradient(180deg, rgba(10,16,24,.55), rgba(8,12,20,.55));
    padding: 10px; border-radius: 6px; /* the page will flex to available space */
    flex: 1 1 auto; min-height: 220px; max-height: calc(100vh - 240px); /* increase height so parent module grows, keep top/bottom gaps */
    white-space: pre-wrap; overflow: auto;
    color: var(--ink);
}
.aiTextbookOutput .ascii-face{
    font-family: monospace; font-size:12px; color:var(--ink); margin-top:6px; display:flex; align-items:center; justify-content:center; gap:8px; width:100%;
    flex: 0 0 auto; /* face should not grow; remain a fixed row below the page */
}
.aiTextbookOutput .ascii-face .face{
    background: linear-gradient(180deg, rgba(12,18,28,.6), rgba(8,12,18,.6));
    border-radius:6px; padding:8px 12px; border:1px solid rgba(255,255,255,0.03); box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
    color: var(--ink); font-size:20px; line-height:1; font-family: monospace;
}
.aiTextbookOutput .ascii-face .mouth{ display:inline-block; min-width:28px; text-align:center; position:relative; font-family: monospace }
.aiTextbookOutput .controls{ margin-top:8px; display:flex; gap:8px; justify-content:flex-end }
.aiTextbookOutput .face-inner{ display:flex; align-items:center; justify-content:center; gap:8px }
</style>

<script>
// Textbook output + typewriter + ASCII face + lightweight audio with controls + cancellation
(function(){
    const OUT_ID = 'resultsAiOutput';
    function ensureWrapper(){
        // If we've already created the textbook wrapper, return it
        const existing = document.getElementById('aiTextbookOutput');
        if(existing) return existing;
        const out = document.getElementById(OUT_ID);
        if(!out) return null;
        if(out.dataset && out.dataset.textbook === '1') return out;
    // augment the existing output element in-place so external code that references
    // `document.getElementById('resultsAiOutput')` continues to work
    const outEl = out;
    outEl.classList.add('aiTextbookOutput');
    const page = document.createElement('div'); page.className='page'; page.setAttribute('role','status'); page.setAttribute('aria-live','polite');
    // Ensure the page is the only scrollable area and can shrink properly inside flex containers
    page.style.flex = '1 1 auto'; page.style.minHeight = '0'; page.style.overflow = 'auto';
    const faceRow = document.createElement('div'); faceRow.className='ascii-face';
    const faceInner = document.createElement('div'); faceInner.className = 'face-inner';
    const faceBox = document.createElement('div'); faceBox.className='face'; faceBox.style.fontFamily='monospace'; faceBox.style.fontSize='20px';
    // Create eyes + mouth container; include optional lash spans inside each eye
    faceBox.innerHTML = '<span class="eyes">(<span class="eye left"><span class="lash">""</span><span class="dot">•</span></span><span class="mouth"></span><span class="eye right"><span class="lash">""</span><span class="dot">•</span></span>)</span>';
    const mouthSpan = faceBox.querySelector('.mouth');
    // Put a simple underscore mouth; we'll toggle it open/closed while speaking
    mouthSpan.textContent = '___';
    faceInner.appendChild(faceBox);
    faceRow.appendChild(faceInner);
    // Lashes toggle (persisted)
    try{
        const LASH_KEY = 'ai.face.lashed';
        const saved = localStorage.getItem(LASH_KEY) === '1';
        if(saved) faceBox.classList.add('lashed');
        faceBox.setAttribute('role','button'); faceBox.setAttribute('tabindex','0'); faceBox.title = 'Toggle lashes';
        const setLash = (on) => { try{ faceBox.classList.toggle('lashed', !!on); localStorage.setItem(LASH_KEY, on ? '1':'0'); faceBox.classList.add('lash-toggle'); setTimeout(()=>{ try{ faceBox.classList.remove('lash-toggle'); }catch(e){} }, 380); }catch(e){} };
        faceBox.addEventListener('click', ()=> setLash(!faceBox.classList.contains('lashed')));
        faceBox.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); setLash(!faceBox.classList.contains('lashed')); }});
    }catch(e){}
    const controls = document.createElement('div'); controls.className='controls';
        // Stop button
        const stopBtn = document.createElement('button'); stopBtn.type='button'; stopBtn.className='btn small'; stopBtn.textContent='Stop'; stopBtn.title='Stop animated output';
        // Audio toggle
        const audioToggle = document.createElement('button'); audioToggle.type='button'; audioToggle.className='btn small'; audioToggle.title='Toggle audio effects';
        const audioEnabled = (localStorage.getItem('ai.audio.enabled') === '1');
        audioToggle.textContent = audioEnabled ? 'Audio: On' : 'Audio: Off';
        audioToggle.dataset.enabled = audioEnabled ? '1' : '0';
        controls.appendChild(stopBtn); controls.appendChild(audioToggle);
    // hide controls UI per user's request (Stop / Audio buttons removed)
    try{ controls.style.display = 'none'; }catch(e){}

    // Apply flex layout to the output container so the page fills available vertical space up to the face
    try{ outEl.style.display = 'flex'; outEl.style.flexDirection = 'column'; outEl.style.gap = '8px'; outEl.style.height = outEl.style.height || '100%'; outEl.style.boxSizing = 'border-box'; }catch{}
    outEl.appendChild(page); outEl.appendChild(faceRow); outEl.appendChild(controls);
    outEl.dataset.textbook='1';
    outEl._page = page; outEl._faceBox = faceBox; outEl._mouthSpan = faceBox.querySelector('.mouth'); outEl._controls = controls; outEl._stopBtn = stopBtn; outEl._audioToggle = audioToggle;

    // Auto-scroll state: follow output while generating unless user scrolls up
    try{
        outEl._autoScrollPinned = true;
        outEl._autoScrollQueued = false;
        if(!page.dataset.aiAutoscroll){
            page.dataset.aiAutoscroll = '1';
            page.addEventListener('scroll', ()=>{
                try{
                    const threshold = 48;
                    const nearBottom = (page.scrollTop + page.clientHeight) >= (page.scrollHeight - threshold);
                    outEl._autoScrollPinned = !!nearBottom;
                }catch(e){}
            }, { passive: true });
        }
    }catch(e){}

    // Start semi-random eye movement and blinking when idle. This uses CSS variables
    // (--ex, --ey) to set small translations so blink (scaleY) composes with current translate.
    (function startEyeIdle(wrap){
        try{
            const out = wrap; if(!out) return;
            const faceBox = wrap._faceBox; if(!faceBox) return;
            const eyes = faceBox.querySelectorAll('.eye'); if(!eyes || !eyes.length) return;
            // Respect prefers-reduced-motion
            if(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

            let moveTimer = null, blinkTimer = null;
            function rand(min, max){ return min + Math.random()*(max-min); }

            function setEyeTranslate(e, x, y){
                try{ e.style.setProperty('--ex', x + 'px'); e.style.setProperty('--ey', y + 'px'); }catch(e){}
            }

            function doMove(){
                try{
                    // If typing is active, leave eyes neutral
                    if(out.classList.contains('ai-active')){
                        eyes.forEach(e=> setEyeTranslate(e, 0, 0));
                    } else {
                        // move both eyes in sequence (synchronously) using the same translation
                        const dx = Math.round(rand(-4, 6));
                        const dy = Math.round(rand(-2, 2));
                        eyes.forEach(e => setEyeTranslate(e, dx, dy));
                    }
                }catch(e){}
                scheduleMove();
            }

            function scheduleMove(){ moveTimer && clearTimeout(moveTimer); moveTimer = setTimeout(doMove, rand(700, 2200)); }

            function doBlink(){
                try{
                    if(out.classList.contains('ai-active')){ scheduleBlink(); return; }
                    eyes.forEach(e=> e.classList.add('blink'));
                    // quick blink close then open
                    setTimeout(()=>{ eyes.forEach(e=> e.classList.remove('blink')); }, 90 + Math.random()*80);
                }catch(e){}
                scheduleBlink();
            }

            function scheduleBlink(){ blinkTimer && clearTimeout(blinkTimer); blinkTimer = setTimeout(doBlink, rand(2400, 7600)); }

            // Start initial timers
            scheduleMove(); scheduleBlink();

            // expose cleanup so callers can cancel if needed
            wrap._clearEyeIdle = function(){ try{ moveTimer && clearTimeout(moveTimer); blinkTimer && clearTimeout(blinkTimer); eyes.forEach(e=>{ e.classList.remove('blink'); setEyeTranslate(e,0,0); }); }catch(e){} };
        }catch(e){}
    })(outEl);

    // control behaviour
    let currentController = null;
    stopBtn.addEventListener('click', ()=>{ try{ if(currentController) currentController.abort(); }catch{} });
    audioToggle.addEventListener('click', ()=>{
            try{
                const en = audioToggle.dataset.enabled === '1' ? false : true;
                audioToggle.dataset.enabled = en ? '1' : '0'; audioToggle.textContent = en ? 'Audio: On' : 'Audio: Off';
                localStorage.setItem('ai.audio.enabled', en ? '1' : '0');
            }catch{}
        });

    // Auto-enable audio by default for the textbook output if not explicitly set
    try{
        if(localStorage.getItem('ai.audio.enabled') === null){
            localStorage.setItem('ai.audio.enabled', '1');
            audioToggle.dataset.enabled = '1'; audioToggle.textContent = 'Audio: On';
        }
    }catch(e){}

    // Lightweight shared audio context and pulse engine (reuse across invocations)
    let __aiAudioCtx = null; let __aiAudioAllowed = false;
    function ensureAiAudio(){
        try{
            if(__aiAudioCtx) return __aiAudioCtx;
            const C = window.AudioContext || window.webkitAudioContext;
            if(!C) return null;
            __aiAudioCtx = new C();
            // Attempt to resume on user gesture if suspended
            if(__aiAudioCtx.state === 'suspended' && typeof __aiAudioCtx.resume === 'function'){
                // try to resume now; if blocked, caller gesture (Stop/Audio toggle) will resume
                __aiAudioCtx.resume().then(()=>{ __aiAudioAllowed = true; }).catch(()=>{ __aiAudioAllowed = false; });
            } else {
                __aiAudioAllowed = true;
            }
            return __aiAudioCtx;
        }catch(e){ return null; }
    }

    // visual audio bars animator: set random heights to show speaking activity
    function animateAudioBarsOnce(wrap, intensity){
        try{
            const bars = wrap._faceBox.querySelectorAll('.audio-bars .bar');
            if(!bars || !bars.length) return;
            bars.forEach(b => {
                const h = 4 + Math.round((Math.random() * (intensity||8)));
                b.style.height = h + 'px';
            });
        }catch(e){}
    }

        // expose helper to let showAiOutput set controller
        outEl._setController = (c)=>{ currentController = c; };

        // override textContent/innerText setters so older code that writes directly still
        // triggers the animated output rather than wiping our structure
        try{
            const descriptor = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent') || Object.getOwnPropertyDescriptor(Element.prototype, 'textContent');
            Object.defineProperty(outEl, 'textContent', {
                configurable: true,
                enumerable: false,
                get: function(){ return page.textContent; },
                set: function(v){
                    try{
                        // empty string => clear and stop
                        if(!v){ if(window.stopAiOutput) window.stopAiOutput(); page.textContent = ''; return; }
                        // otherwise, animate as spoken output
                        if(window.showAiOutput) { window.showAiOutput(String(v)); } else { page.textContent = String(v); }
                    }catch(e){ page.textContent = String(v); }
                }
            });
            Object.defineProperty(outEl, 'innerText', {
                configurable: true,
                enumerable: false,
                get: function(){ return page.innerText; },
                set: function(v){ try{ if(window.showAiOutput) window.showAiOutput(String(v)); else page.innerText = String(v); }catch(e){ page.innerText = String(v); } }
            });
        }catch(e){}

        return outEl;
    }

    function createNoiseEngine(){
        let ctx = null;
        try{ const AudioCtx = window.AudioContext || window.webkitAudioContext; ctx = new AudioCtx(); }catch(e){
            return { pulse:()=>{} };
        }

    // Master gain to control overall loudness
    const master = ctx.createGain(); master.gain.value = 0.4; /* lowered global volume (was high by default) */ master.connect(ctx.destination);

        // Create a short voiced/unvoiced pulse that combines an oscillator (voiced)
        // and filtered noise (unvoiced). The sound is intentionally noisy and
        // simplified — not real TTS — but with pitch glides and bandpass shaping
        // it approximates speech-like textures.
        function pulse(vol, opts){ try{
            opts = opts || {};
            const voiced = !!opts.voiced;
            const now = ctx.currentTime;
            // base duration (voiced tends to be a little longer)
            const dur = Math.max(0.04, (opts.dur || (voiced ? 0.10 : 0.055)) + (Math.random()*0.04));

            // per-pulse gain node (envelope)
            const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, now);
            const peak = Math.max(0.005, Math.min(0.16, (vol||0.04) * (voiced ? 1.2 : 1.0)));
            g.gain.linearRampToValueAtTime(peak, now + 0.008);
            g.gain.exponentialRampToValueAtTime(0.0001, now + dur + 0.02);
            g.connect(master);

            if(voiced){
                // Voiced: oscillator -> bandpass -> gain
                const osc = ctx.createOscillator();
                // use triangle or sawtooth for richer harmonic content
                osc.type = Math.random() < 0.5 ? 'triangle' : 'sawtooth';
                const baseHz = opts.pitch || (120 + Math.random()*240); // male-ish to mid range
                osc.frequency.setValueAtTime(baseHz, now);
                // gentle pitch glide for naturalness
                const glideTo = baseHz * (0.85 + Math.random()*0.35);
                osc.frequency.exponentialRampToValueAtTime(Math.max(60, glideTo), now + dur * (0.6 + Math.random()*0.3));

                const bp = ctx.createBiquadFilter(); bp.type = 'bandpass';
                bp.frequency.value = 500 + Math.random()*1600; // formant-ish region
                bp.Q.value = 6 + Math.random()*6;

                osc.connect(bp); bp.connect(g);
                osc.start(now); osc.stop(now + dur + 0.03);

                // small layer of noisy aspiration to blend
                const noiseBuf = ctx.createBuffer(1, Math.floor(ctx.sampleRate * dur), ctx.sampleRate);
                const ndata = noiseBuf.getChannelData(0);
                for(let i=0;i<ndata.length;i++) ndata[i] = (Math.random()*2 - 1) * (Math.random()*0.6);
                const nsrc = ctx.createBufferSource(); nsrc.buffer = noiseBuf;
                const nlp = ctx.createBiquadFilter(); nlp.type = 'lowpass'; nlp.frequency.value = 4000 + Math.random()*3000;
                nsrc.connect(nlp); nlp.connect(g);
                nsrc.start(now); nsrc.stop(now + dur + 0.02);

                // cleanup scheduled
                setTimeout(()=>{ try{ bp.disconnect(); osc.disconnect(); nsrc.disconnect(); nlp.disconnect(); g.disconnect(); }catch{} }, (dur + 0.06)*1000);

            } else {
                // Unvoiced: short noise burst shaped by highpass+bandpass to sound like fricatives
                const buffer = ctx.createBuffer(1, Math.floor(ctx.sampleRate * dur), ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for(let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (Math.random()*0.9);
                const src = ctx.createBufferSource(); src.buffer = buffer;
                const hp = ctx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = 1200 + Math.random()*3000;
                const bp = ctx.createBiquadFilter(); bp.type = 'bandpass'; bp.frequency.value = 2500 + Math.random()*3000; bp.Q.value = 2 + Math.random()*3;
                src.connect(hp); hp.connect(bp); bp.connect(g);
                src.start(now); src.stop(now + dur + 0.02);

                setTimeout(()=>{ try{ src.disconnect(); hp.disconnect(); bp.disconnect(); g.disconnect(); }catch{} }, (dur + 0.06)*1000);
            }
        }catch(e){ /* ignore audio errors */ } }

        return { pulse, ctx };
    }

    function typeWithMouth(text, opts, controller){
        const wrap = ensureWrapper(); if(!wrap) return Promise.resolve();
        const page = wrap._page; const mouth = wrap._mouthSpan; const audioToggle = wrap._audioToggle;
        const audioAllowed = audioToggle && audioToggle.dataset.enabled === '1';
        page.textContent = '';
        return new Promise((resolve)=>{
            let i=0; let charDelay = opts && opts.delay || 18; const audio = audioAllowed ? createNoiseEngine() : null;
            // If audio engine exists, attach a cleanup hook so abort can close the AudioContext immediately
            try{ if(audio && controller){ controller._onAbort = function(){ try{ if(audio && audio.ctx && typeof audio.ctx.close === 'function'){ try{ audio.ctx.close(); }catch{} } }catch(e){} }; } }catch(e){}
            // ensure AudioContext exists and try resume on first use
            if(audioAllowed){ try{ ensureAiAudio(); }catch{} }
            if(audio){} // engine created on-demand in pulse
            function setMouth(open){
                try{
                    // simple moving mouth: open glyph while speaking, underscore when closed
                    mouth.textContent = open ? '▂' : '___';
                }catch(e){}
            }
            function requestScrollToBottom(force){
                try{
                    const pinned = force || (wrap && wrap._autoScrollPinned !== false);
                    if(!pinned) return;
                    if(wrap._autoScrollQueued) return;
                    wrap._autoScrollQueued = true;
                    requestAnimationFrame(()=>{
                        try{ wrap._autoScrollQueued = false; page.scrollTop = page.scrollHeight; }catch(e){}
                    });
                }catch(e){}
            }
            function done(){ try{ setMouth(false); requestScrollToBottom(true); }catch{}; resolve(); }
            function step(){
                if(controller && controller.aborted){ // immediate show full text and stop
                    page.textContent = text; requestScrollToBottom(true); done(); return; }
                if(i>=text.length){ done(); return; }
                const ch = text[i++]; page.textContent += ch;
                // keep view pinned to bottom while typing
                try{ requestScrollToBottom(false); }catch(e){}
                // open mouth for letters/punct that are speech-like
                const isLetter = /[A-Za-z0-9]/.test(ch);
                const isVowel = /[aeiouAEIOU]/.test(ch);
                const open = isLetter || isVowel || ch === ',' || ch === '-';
                setMouth(open);
                // animate visual bars and emit light pulse when mouth opens
                try{ animateAudioBarsOnce(wrap, open ? 10 : 3); }catch(e){}
                if(audio && open){ try{
                    // For vowels prefer voiced pulses with pitch glide; for other letters use mixed/short pulses
                    if(isVowel){ audio.pulse(0.035 + (Math.random()*0.02), { voiced:true, pitch: 160 + Math.random()*220, dur: 0.08 + Math.random()*0.06 }); }
                    else { audio.pulse(0.028 + (Math.random()*0.02), { voiced: Math.random() < 0.35, dur: 0.04 + Math.random()*0.04 }); }
                }catch{} }
                // compute delay
                let delay = charDelay;
                // longer pause after sentence end
                if(/[.?!]\s$/.test(page.textContent)){
                    // close mouth during pause
                    setMouth(false);
                    if(audio) try{ audio.pulse(0.008, { voiced:false, dur:0.04 }); }catch{};
                    delay = 520;
                }
                if(ch === '\n'){ setMouth(false); delay = 240; }
                setTimeout(step, delay);
            }
            step();
        });
    }

    window.showAiOutput = async function(text){
        const wrap = ensureWrapper(); if(!wrap) return;
        // cancel any existing output
        if(window.__aiOutputController && typeof window.__aiOutputController.abort === 'function'){
            try{ window.__aiOutputController.abort(); }catch{} }
    const controller = { aborted:false, _onAbort: null, abort: function(){ try{ if(this.aborted) return; this.aborted = true; if(typeof this._onAbort === 'function'){ try{ this._onAbort(); }catch(e){} } }catch(e){} } };
        window.__aiOutputController = controller; wrap._setController && wrap._setController(controller);
        const page = wrap._page; try{ wrap._autoScrollPinned = true; }catch(e){} page.scrollTop = 0; page.textContent = '';
        // mark output as active so idle animations pause while typing
        const outEl = document.getElementById(OUT_ID);
        try{ if(outEl) outEl.classList.add('ai-active'); }catch{}
        try{ await typeWithMouth(String(text||''), { delay: 16 }, controller); }catch(e){ page.textContent = text; }
        // Attempt to render any LaTeX present in the AI output
        try{ setTimeout(()=>{ try{ const el = wrap._page || wrap; window.renderMathIn && window.renderMathIn(el); }catch(e){} }, 60); }catch(e){}
        // clear controller after done
        if(window.__aiOutputController === controller) window.__aiOutputController = null;
        try{ if(outEl) outEl.classList.remove('ai-active'); }catch{}
    };

    // expose stop functions
    // Soft stop: abort any active animated output WITHOUT touching the global
    // results-analysis counter. Use this when starting a results analysis to
    // avoid self-canceling the just-started request.
    window.stopAiOutputSoft = function(){ try{ if(window.__aiOutputController) window.__aiOutputController.abort(); }catch{} };
    // Hard stop: abort animated output AND bump the results-analysis counter so
    // any in-flight responses that check the counter are treated as stale.
    window.stopAiOutput = function(){ try{ if(window.__aiOutputController) window.__aiOutputController.abort(); }catch{} try{ window.__resultsAnalysisRequestCounter = (window.__resultsAnalysisRequestCounter||0) + 1; }catch{} };
})();
</script>
<script>
// Tactile feedback (audio + haptics) — no UI changes. Lightweight, self-contained, and safe.
(function(){
    'use strict';
    if(window.__tactileInstalled) return; window.__tactileInstalled = true;

    // Respect reduced motion (use this as a hint to soften or disable haptics)
    var prefersReduced = false; try{ var mq = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)'); prefersReduced = !!(mq && mq.matches); if(mq && mq.addEventListener){ mq.addEventListener('change', function(e){ prefersReduced = !!e.matches; }); } }catch(e){}

    // Shared AudioContext + tiny tone player
    var AC = (window.AudioContext || window.webkitAudioContext) || null;
    var audioCtx = null;
    function ensureCtx(){
        try{
            if(!AC) return null;
            if(!audioCtx) audioCtx = new AC();
            // try resume on user gesture
            if(audioCtx && typeof audioCtx.resume === 'function' && audioCtx.state === 'suspended') audioCtx.resume().catch(function(){});
            return audioCtx;
        }catch(e){ return null; }
    }
    function playTone(freq, durMs){
        try{
            var ctx = ensureCtx(); if(!ctx) return;
            var now = ctx.currentTime;
            var osc = ctx.createOscillator();
            var gain = ctx.createGain();
            osc.type = 'sine';
            // clamp frequency and duration
            var f = Math.max(80, Math.min(2000, +freq||440));
            var d = Math.max(0.04, Math.min(0.6, (durMs||120)/1000));
            osc.frequency.setValueAtTime(f, now);
            gain.gain.setValueAtTime(0.0001, now);
            gain.gain.exponentialRampToValueAtTime(0.12, now + 0.01);
            // short fade-out to avoid click
            gain.gain.exponentialRampToValueAtTime(0.0001, now + d);
            osc.connect(gain); gain.connect(ctx.destination);
            osc.start(now); osc.stop(now + d + 0.02);
            // cleanup
            setTimeout(function(){ try{ osc.disconnect(); gain.disconnect(); }catch(e){} }, (d*1000)+60);
        }catch(e){}
    }
    function vibrate(pattern){ try{ if(prefersReduced) return; if(navigator.vibrate) navigator.vibrate(pattern); }catch(e){} }

    // Public API (attach to window for optional explicit calls elsewhere)
    var api = {
        correct: function(){ vibrate([28]); playTone(520, 130); },
        wrong: function(){ vibrate([90, 30]); playTone(180, 170); },
        reveal: function(){ vibrate([12]); playTone(320, 90); },
        skip: function(){ vibrate([20, 20, 20]); playTone(260, 80); }
    };
    try{ Object.defineProperty(window, 'tactile', { value: api, writable: false, configurable: false }); }catch(e){ window.tactile = api; }

    // Heuristic wiring: detect interactions and trigger feedback without touching existing UI code
    function onClick(e){
        try{
            // Ensure AudioContext is allowed to start via a user gesture
            ensureCtx();
            var t = e.target || e.srcElement; if(!t) return;
            // 1) Choice clicks — defer a tick so any correctness classes are applied first
            var choice = t.closest && t.closest('.choice');
            if(choice){
                setTimeout(function(){
                    try{
                        if(choice.classList.contains('correct')){ api.correct(); }
                        else if(choice.classList.contains('wrong')){ api.wrong(); }
                    }catch(err){}
                }, 0);
                return;
            }
            // 2) Explicit buttons
            var id = (t.id || (t.closest && t.closest('button, [role="button"]') && t.closest('button, [role="button"]').id) || '').toLowerCase();
            if(id === 'revealbtn'){ api.reveal(); return; }
            if(id === 'skipbtn'){ api.skip(); return; }
            // Optionally, next/back remain silent to avoid noise during navigation
        }catch(err){}
    }

    // Keyboard support: pressing Enter/Space on a focused .choice should also trigger after state update
    function onKey(e){
        try{
            var code = e.key || e.code; if(!code) return;
            if(code === 'Enter' || code === ' ' || code === 'Spacebar'){
                var a = document.activeElement;
                if(a && a.classList && a.classList.contains('choice')){
                    setTimeout(function(){
                        try{
                            if(a.classList.contains('correct')) api.correct();
                            else if(a.classList.contains('wrong')) api.wrong();
                        }catch(err){}
                    }, 0);
                }
            }
        }catch(err){}
    }

    // Attach listeners at capture phase to avoid being blocked; keep extremely cheap
    try{ document.addEventListener('click', onClick, true); }catch(e){}
    try{ document.addEventListener('keydown', onKey, true); }catch(e){}
})();
</script>

<script>
// UX hardening: backup/restore/share, lint, exports, diagnostics, and basic modal a11y.
(function(){
    'use strict';
    if(window.__uxHardeningInstalled) return;
    window.__uxHardeningInstalled = true;

    const $ = (id)=> document.getElementById(id);
    const hasClass = (el, c)=> !!(el && el.classList && el.classList.contains(c));
    const show = (el)=>{ try{ el && el.classList && el.classList.remove('hidden'); }catch(e){} };
    const hide = (el)=>{ try{ el && el.classList && el.classList.add('hidden'); }catch(e){} };

    function setBackupStatus(msg, bad){
        const el = $('backupStatus');
        if(!el) return;
        el.textContent = msg || '';
        try{ el.style.color = bad ? 'var(--bad)' : ''; }catch(e){}
    }

    // ---------- Quick Start (modal; show once) ----------
    (function initQuickStart(){
        const btn = $('quickStartBtn');
        const modal = $('quickStartModal');
        const closeBtn = $('quickStartClose');
        const backdrop = modal ? modal.querySelector('.modal-backdrop') : null;
        if(!btn || !modal) return;

        function open(){ try{ modal.classList.remove('hidden'); }catch(e){} }
        function close(){
            try{ modal.classList.add('hidden'); }catch(e){}
            try{ localStorage.setItem('__quickStartSeen', '1'); }catch(e){}
        }

        try{ btn.addEventListener('click', (e)=>{ e.preventDefault(); if(modal.classList.contains('hidden')) open(); else close(); }); }catch(e){}
        try{ if(closeBtn) closeBtn.addEventListener('click', (e)=>{ e.preventDefault(); close(); }); }catch(e){}
        try{ if(backdrop) backdrop.addEventListener('click', close); }catch(e){}

        // show once
        let seen = false;
        try{ seen = localStorage.getItem('__quickStartSeen') === '1'; }catch(e){}
        if(!seen){ setTimeout(open, 150); }
    })();

    // ---------- Share export ----------
    function downloadBlob(blob, filename){
        try{
            const a = document.createElement('a');
            const url = URL.createObjectURL(blob);
            a.href = url; a.download = filename;
            document.body.appendChild(a);
            a.click();
            setTimeout(()=>{ try{ URL.revokeObjectURL(url); }catch(e){} try{ a.remove(); }catch(e){} }, 8000);
        }catch(e){ console.error('downloadBlob failed', e); }
    }
    function downloadJson(obj, filename){
        const txt = JSON.stringify(obj, null, 2);
        downloadBlob(new Blob([txt], { type:'application/json;charset=utf-8' }), filename);
    }

    function buildSharePayload(){
        const pasteText = String(($('paste') && $('paste').value) || '');
        const options = {
            shuffleQ: !!($('shuffleQ') && $('shuffleQ').checked),
            shuffleA: !!($('shuffleA') && $('shuffleA').checked),
            instant: !!($('instant') && $('instant').checked)
        };
        return { app: 'AI Quizzer Share', version: 1, createdAt: new Date().toISOString(), pasteText, options };
    }

    // ---------- Backup/Restore ----------
    const SENSITIVE_KEYS = new Set(['gemini.key', 'gemKeyGlobal']);
    function isNewsCacheKey(k){
        try{ return k === '__newsCacheV2' || String(k||'').indexOf('__newsCacheV2_') === 0; }catch(e){ return false; }
    }

    function idbOpen(dbName){
        return new Promise((resolve, reject)=>{
            try{
                const req = indexedDB.open(dbName);
                req.onsuccess = ()=> resolve(req.result);
                req.onerror = ()=> reject(req.error || new Error('indexedDB open failed'));
                req.onblocked = ()=> reject(new Error('indexedDB open blocked'));
            }catch(e){ reject(e); }
        });
    }
    function idbOpenV1EnsureBooks(dbName){
        return new Promise((resolve, reject)=>{
            try{
                const req = indexedDB.open(dbName, 1);
                req.onupgradeneeded = ()=>{
                    try{
                        const db = req.result;
                        if(!db.objectStoreNames.contains('books')) db.createObjectStore('books', { keyPath:'id', autoIncrement:true });
                    }catch(e){}
                };
                req.onsuccess = ()=> resolve(req.result);
                req.onerror = ()=> reject(req.error || new Error('indexedDB open failed'));
                req.onblocked = ()=> reject(new Error('indexedDB open blocked'));
            }catch(e){ reject(e); }
        });
    }
    function idbGetAllBooks(dbName){
        return idbOpen(dbName).then((db)=> new Promise((resolve)=>{
            try{
                if(!db.objectStoreNames.contains('books')){ try{ db.close(); }catch(e){}; resolve([]); return; }
                const tx = db.transaction('books','readonly');
                const store = tx.objectStore('books');
                const req = store.getAll();
                req.onsuccess = ()=>{ resolve(req.result || []); try{ db.close(); }catch(e){} };
                req.onerror = ()=>{ console.warn('idbGetAllBooks failed', dbName, req.error); resolve([]); try{ db.close(); }catch(e){} };
            }catch(e){ console.warn('idbGetAllBooks exception', dbName, e); try{ db.close(); }catch(_){ } resolve([]); }
        }));
    }
    function idbDeleteDatabase(dbName){
        return new Promise((resolve)=>{
            try{
                const req = indexedDB.deleteDatabase(dbName);
                req.onsuccess = ()=> resolve(true);
                req.onerror = ()=> resolve(false);
                req.onblocked = ()=> resolve(false);
            }catch(e){ resolve(false); }
        });
    }
    async function idbWriteBooksOverwrite(dbName, books){
        await idbDeleteDatabase(dbName);
        const db = await idbOpenV1EnsureBooks(dbName);
        return await new Promise((resolve, reject)=>{
            try{
                const tx = db.transaction('books','readwrite');
                const store = tx.objectStore('books');
                (books || []).forEach(rec=>{
                    try{ store.put(rec); }catch(e){}
                });
                tx.oncomplete = ()=>{ try{ db.close(); }catch(e){} resolve(true); };
                tx.onerror = ()=>{ const err = tx.error; try{ db.close(); }catch(e){} reject(err || new Error('idb write failed')); };
                tx.onabort = ()=>{ const err = tx.error; try{ db.close(); }catch(e){} reject(err || new Error('idb write aborted')); };
            }catch(e){ try{ db.close(); }catch(_){ } reject(e); }
        });
    }
    async function idbWriteBooksMerge(dbName, books){
        // Adds without preserving ids (avoids overwriting existing). Returns a map oldId->newId.
        const idMap = {};
        let db = null;
        try{ db = await idbOpen(dbName); }catch(e){ db = await idbOpenV1EnsureBooks(dbName); }
        return await new Promise((resolve)=>{
            try{
                if(!db.objectStoreNames.contains('books')){ try{ db.close(); }catch(e){} resolve(idMap); return; }
                const tx = db.transaction('books','readwrite');
                const store = tx.objectStore('books');
                (books || []).forEach(rec=>{
                    try{
                        const oldId = rec && rec.id;
                        const copy = Object.assign({}, rec);
                        try{ delete copy.id; }catch(e){}
                        const req = store.add(copy);
                        req.onsuccess = ()=>{ if(oldId != null) idMap[String(oldId)] = req.result; };
                    }catch(e){}
                });
                tx.oncomplete = ()=>{ try{ db.close(); }catch(e){} resolve(idMap); };
                tx.onerror = ()=>{ console.warn('idb merge write error', tx.error); try{ db.close(); }catch(e){} resolve(idMap); };
                tx.onabort = ()=>{ console.warn('idb merge aborted', tx.error); try{ db.close(); }catch(e){} resolve(idMap); };
            }catch(e){ console.warn('idbWriteBooksMerge exception', e); try{ db && db.close(); }catch(_){ } resolve(idMap); }
        });
    }

    async function buildBackupPayload(){
        const includeKeys = !!($('backupIncludeKeys') && $('backupIncludeKeys').checked);
        const includeNewsCache = !!($('backupIncludeNewsCache') && $('backupIncludeNewsCache').checked);
        const ls = {};
        try{
            for(let i=0;i<localStorage.length;i++){
                const k = localStorage.key(i);
                if(!k) continue;
                if(!includeKeys && SENSITIVE_KEYS.has(k)) continue;
                if(!includeNewsCache && isNewsCacheKey(k)) continue;
                try{ ls[k] = localStorage.getItem(k); }catch(e){}
            }
        }catch(e){ console.warn('localStorage dump failed', e); }

        const idb = {};
        for(const dbName of ['pdf-toc-lib', 'textbook_lib_v1']){
            try{ idb[dbName] = { books: await idbGetAllBooks(dbName) }; }
            catch(e){ idb[dbName] = { books: [], error: String(e && e.message ? e.message : e) }; }
        }
        return { app:'AI Quizzer Backup', version:1, createdAt: new Date().toISOString(), localStorage: ls, indexedDB: idb };
    }

    function readJsonFile(file){
        return file.text().then(t=> JSON.parse(t));
    }

    async function applySharePayload(payload){
        const pasteText = String(payload && payload.pasteText ? payload.pasteText : '');
        try{ const paste = $('paste'); if(paste) paste.value = pasteText; }catch(e){}
        try{ const opt = payload && payload.options ? payload.options : {}; if($('shuffleQ')) $('shuffleQ').checked = !!opt.shuffleQ; if($('shuffleA')) $('shuffleA').checked = !!opt.shuffleA; if($('instant')) $('instant').checked = !!opt.instant; }catch(e){}
        setBackupStatus('Share file loaded into Paste area. Click Parse & Preview to continue.', false);
        // best-effort: run parse immediately so user sees it worked
        try{ if(typeof window.__doParse === 'function') window.__doParse(); else if($('parseBtn')) $('parseBtn').click(); }catch(e){}
    }

    async function applyBackupPayload(payload, mode){
        const restoreMode = (mode === 'overwrite') ? 'overwrite' : 'merge';
        const ls = (payload && payload.localStorage) ? payload.localStorage : {};
        const idb = (payload && payload.indexedDB) ? payload.indexedDB : {};

        // Restore IDB first in merge mode so we can remap idbRef pointers before writing localStorage.
        let pdfIdMap = {};
        if(restoreMode === 'overwrite'){
            try{ if(localStorage && typeof localStorage.clear === 'function') localStorage.clear(); }catch(e){}
            // Overwrite IDBs and preserve ids.
            try{ await idbWriteBooksOverwrite('pdf-toc-lib', (idb['pdf-toc-lib'] && idb['pdf-toc-lib'].books) || []); }catch(e){ console.warn('overwrite pdf-toc-lib failed', e); }
            try{ await idbWriteBooksOverwrite('textbook_lib_v1', (idb['textbook_lib_v1'] && idb['textbook_lib_v1'].books) || []); }catch(e){ console.warn('overwrite textbook_lib_v1 failed', e); }
        } else {
            try{ pdfIdMap = await idbWriteBooksMerge('pdf-toc-lib', (idb['pdf-toc-lib'] && idb['pdf-toc-lib'].books) || []); }catch(e){ pdfIdMap = {}; }
            try{ await idbWriteBooksMerge('textbook_lib_v1', (idb['textbook_lib_v1'] && idb['textbook_lib_v1'].books) || []); }catch(e){}
        }

        // If we remapped IDs, update textbook.lib.v1 pointers accordingly.
        let textbookKey = 'textbook.lib.v1';
        if(restoreMode === 'merge' && ls && ls[textbookKey] && pdfIdMap && Object.keys(pdfIdMap).length){
            try{
                const arr = JSON.parse(ls[textbookKey] || '[]');
                if(Array.isArray(arr)){
                    for(const it of arr){
                        if(it && it.idbRef != null){
                            const mapped = pdfIdMap[String(it.idbRef)];
                            if(mapped != null) it.idbRef = mapped;
                        }
                    }
                    ls[textbookKey] = JSON.stringify(arr);
                }
            }catch(e){}
        }

        // Restore localStorage
        try{
            for(const k of Object.keys(ls || {})){
                try{ localStorage.setItem(k, ls[k]); }catch(e){}
            }
        }catch(e){ console.warn('localStorage restore failed', e); }

        setBackupStatus('Restore complete. If anything looks stale, reload the page.', false);
    }

    (function initBackupUi(){
        const panel = $('backupPanel');
        const openBtn = $('backupPanelBtn');
        const closeBtn = $('backupCloseBtn');
        const exportBtn = $('exportBackupBtn');
        const fileIn = $('importBackupFile');
        const fileName = $('importBackupName');
        const restoreBtn = $('restoreBackupBtn');
        const shareBtn = $('exportShareBtn');

        function open(){ show(panel); }
        function close(){ hide(panel); }

        try{ if(openBtn) openBtn.addEventListener('click', ()=>{ hasClass(panel,'hidden') ? open() : close(); }); }catch(e){}
        try{ if(closeBtn) closeBtn.addEventListener('click', close); }catch(e){}

        try{ if(shareBtn) shareBtn.addEventListener('click', ()=>{
            const payload = buildSharePayload();
            const name = `ai-quizzer-share-${(new Date()).toISOString().replace(/[:.]/g,'-')}.json`;
            downloadJson(payload, name);
            setBackupStatus('Share file exported (no API keys).', false);
        }); }catch(e){}

        try{ if(exportBtn) exportBtn.addEventListener('click', async ()=>{
            exportBtn.disabled = true;
            const old = exportBtn.textContent; exportBtn.textContent = 'Exporting…';
            setBackupStatus('Building backup…', false);
            try{
                const payload = await buildBackupPayload();
                const name = `ai-quizzer-backup-${(new Date()).toISOString().replace(/[:.]/g,'-')}.json`;
                downloadJson(payload, name);
                setBackupStatus('Backup exported.', false);
            }catch(e){
                console.error('backup export failed', e);
                setBackupStatus('Backup export failed: ' + (e && e.message ? e.message : e), true);
            } finally {
                exportBtn.disabled = false; exportBtn.textContent = old || 'Export backup (.json)';
            }
        }); }catch(e){}

        try{ if(fileIn) fileIn.addEventListener('change', ()=>{
            const f = fileIn.files && fileIn.files[0];
            if(fileName) fileName.textContent = f ? f.name : 'No file chosen';
            if(restoreBtn) restoreBtn.disabled = !f;
        }); }catch(e){}

        try{ if(restoreBtn) restoreBtn.addEventListener('click', async ()=>{
            const f = fileIn && fileIn.files && fileIn.files[0];
            if(!f) return;
            restoreBtn.disabled = true;
            const old = restoreBtn.textContent; restoreBtn.textContent = 'Restoring…';
            setBackupStatus('Reading file…', false);
            try{
                const payload = await readJsonFile(f);
                // Accept either Share or Backup files
                if(payload && payload.app === 'AI Quizzer Share'){
                    open();
                    await applySharePayload(payload);
                } else if(payload && payload.app === 'AI Quizzer Backup'){
                    open();
                    const modeEl = document.querySelector('input[name="restoreMode"]:checked');
                    const mode = modeEl ? modeEl.value : 'merge';
                    setBackupStatus('Restoring (' + mode + ')…', false);
                    await applyBackupPayload(payload, mode);
                } else {
                    setBackupStatus('Unrecognized file format. Expected a Backup or Share JSON.', true);
                }
            }catch(e){
                console.error('restore failed', e);
                setBackupStatus('Restore failed: ' + (e && e.message ? e.message : e), true);
            } finally {
                restoreBtn.disabled = false; restoreBtn.textContent = old || 'Restore';
            }
        }); }catch(e){}
    })();

    // ---------- Parser lint + quick fixes ----------
    function computeLint(items){
        const res = { errors: [], warns: [], dupNums: false, nonSequential: false };
        const seenNum = new Set();
        const nums = [];
        (items || []).forEach((it, idx)=>{
            const numRaw = (it && it.num != null) ? String(it.num).trim() : '';
            const num = parseInt(numRaw, 10);
            if(!numRaw){ res.warns.push({ idx, msg: `Q${idx+1}: Missing question number.` }); }
            else if(!isFinite(num)) res.warns.push({ idx, msg: `Q${idx+1}: Non-numeric question number “${numRaw}”.` });
            else {
                nums.push(num);
                if(seenNum.has(numRaw)){ res.dupNums = true; res.errors.push({ idx, msg: `Duplicate question number ${numRaw}.` }); }
                seenNum.add(numRaw);
            }

            const type = (it && it.type) ? String(it.type) : 'mcq';
            if(type === 'mcq' || type === 'truefalse'){
                const choices = (it && Array.isArray(it.choices)) ? it.choices : [];
                if(choices.length < 2) res.errors.push({ idx, msg: `Q${numRaw||idx+1}: Less than 2 answer choices.` });
                const ci = (it && typeof it.correctIdx === 'number') ? it.correctIdx : NaN;
                if(!isFinite(ci) || ci < 0 || ci >= choices.length) res.errors.push({ idx, msg: `Q${numRaw||idx+1}: Correct answer index is invalid.` });
            }
            if(type === 'fillblank'){
                const answers = (it && Array.isArray(it.answers)) ? it.answers : [];
                if(!answers.length) res.warns.push({ idx, msg: `Q${numRaw||idx+1}: No fill-in-the-blank answers found.` });
                const qtxt = String(it && it.q ? it.q : '');
                if(qtxt && qtxt.indexOf('____') === -1) res.warns.push({ idx, msg: `Q${numRaw||idx+1}: Fill-blank question text has no “____” blank.` });
            }
            if(type === 'matching'){
                const pairs = (it && Array.isArray(it.pairs)) ? it.pairs : [];
                if(!pairs.length) res.errors.push({ idx, msg: `Q${numRaw||idx+1}: Matching question has no pairs.` });
            }
        });

        // sequential check for numeric sequences
        if(nums.length >= 2){
            const sorted = nums.slice().sort((a,b)=>a-b);
            for(let i=0;i<sorted.length;i++){
                if(sorted[i] !== (i+1)){ res.nonSequential = true; res.warns.push({ idx: null, msg: 'Question numbering is not sequential (expected 1..N).' }); break; }
            }
        }
        return res;
    }

    function renderLint(lint){
        const panel = $('lintPanel');
        const summary = $('lintSummary');
        const list = $('lintList');
        const renBtn = $('lintRenumberBtn');
        const dupBtn = $('lintRemoveDupesBtn');
        if(!panel || !summary || !list) return;

        const eCount = (lint && lint.errors) ? lint.errors.length : 0;
        const wCount = (lint && lint.warns) ? lint.warns.length : 0;
        summary.textContent = (eCount || wCount) ? (`${eCount} error(s), ${wCount} warning(s).`) : 'No issues found.';

        // Requirement: only show the Parser Check panel when there is an issue.
        if(!(eCount || wCount)){
            try{ list.innerHTML = ''; }catch(e){}
            try{ if(renBtn) renBtn.disabled = true; }catch(e){}
            try{ if(dupBtn) dupBtn.disabled = true; }catch(e){}
            try{ hide(panel); }catch(e){}
            return;
        }

        const rows = [];
        (lint.errors || []).forEach(it=> rows.push({ sev:'error', msg: it.msg }));
        (lint.warns || []).forEach(it=> rows.push({ sev:'warn', msg: it.msg }));
        // rows should always have something here because (eCount||wCount) is true.
        if(!rows.length) rows.push({ sev:'warn', msg:'Lint reported issues but none were renderable.' });

        list.innerHTML = rows.map(r=>{
            const cls = r.sev === 'error' ? 'lint-item error' : (r.sev === 'warn' ? 'lint-item warn' : 'lint-item');
            return `<div class="${cls}">${String(r.msg||'').replace(/[<>&]/g, s=>({ '<':'&lt;','>':'&gt;','&':'&amp;' }[s]))}</div>`;
        }).join('');

        try{ if(renBtn) renBtn.disabled = !(lint && (lint.dupNums || lint.nonSequential)); }catch(e){}
        try{ if(dupBtn) dupBtn.disabled = !(lint && lint.dupNums); }catch(e){}
        show(panel);
    }

    function runLintNow(){
        try{
            const items = (window.state && Array.isArray(window.state.items)) ? window.state.items : [];
            const lint = computeLint(items);
            renderLint(lint);
            try{ window.__lastLint = lint; }catch(e){}
        }catch(e){ console.warn('lint failed', e); }
    }
    try{ window.__runParseLint = runLintNow; }catch(e){}

    // Hook doParse() so lint auto-runs after Parse & Preview.
    (function hookDoParse(){
        try{ if(typeof window.doParse === 'function') window.__doParse = window.doParse; }catch(e){}
        // In this app, doParse is usually scoped; fall back to the button click.
        try{
            const btn = $('parseBtn');
            if(!btn) return;
            btn.addEventListener('click', ()=>{ setTimeout(runLintNow, 0); });
        }catch(e){}
    })();

    (function wireLintButtons(){
        const hideBtn = $('lintHideBtn');
        const renBtn = $('lintRenumberBtn');
        const dupBtn = $('lintRemoveDupesBtn');
        try{ if(hideBtn) hideBtn.addEventListener('click', ()=> hide($('lintPanel'))); }catch(e){}

        try{ if(renBtn) renBtn.addEventListener('click', ()=>{
            if(!(window.state && Array.isArray(window.state.items))) return;
            window.state.items.forEach((it, i)=>{ try{ it.num = String(i+1); }catch(e){} });
            try{ if(typeof window.renderPreview === 'function') window.renderPreview(window.state.items); }catch(e){}
            setTimeout(runLintNow, 0);
        }); }catch(e){}

        try{ if(dupBtn) dupBtn.addEventListener('click', ()=>{
            if(!(window.state && Array.isArray(window.state.items))) return;
            const seen = new Set();
            const next = [];
            for(const it of window.state.items){
                const k = (it && it.num != null) ? String(it.num).trim() : '';
                if(!k) { next.push(it); continue; }
                if(seen.has(k)) continue;
                seen.add(k);
                next.push(it);
            }
            window.state.items = next;
            window.state.order = next.map((_, i)=> i);
            try{ if(typeof window.renderPreview === 'function') window.renderPreview(window.state.items); }catch(e){}
            setTimeout(runLintNow, 0);
        }); }catch(e){}
    })();

    // ---------- Anki export ----------
    function ankiEscape(s){
        try{ return String(s||'').replace(/\t/g,'    ').replace(/\r?\n/g,'<br>'); }catch(e){ return ''; }
    }
    function toAnkiTsv(items){
        const rows = [];
        (items || []).forEach((it, idx)=>{
            const num = (it && it.num != null) ? String(it.num).trim() : String(idx+1);
            const q = String(it && it.q ? it.q : '').trim();
            const type = (it && it.type) ? String(it.type) : 'mcq';
            if(!q) return;

            let front = `Q${num}. ${q}`;
            let back = '';
            if(type === 'mcq' || type === 'truefalse'){
                const choices = (it && Array.isArray(it.choices)) ? it.choices : [];
                const ci = (it && typeof it.correctIdx === 'number') ? it.correctIdx : 0;
                const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                if(choices.length){
                    front += '<br><br>' + choices.map((c,i)=> `${letters[i]}. ${c}`).join('<br>');
                    const ans = choices[ci] != null ? choices[ci] : '';
                    back = `${letters[ci]||''}. ${ans}`.trim();
                } else {
                    back = (ci === 0) ? 'True' : 'False';
                }
            } else if(type === 'fillblank'){
                const answers = (it && Array.isArray(it.answers)) ? it.answers : [];
                back = answers.join(' / ');
            } else if(type === 'matching'){
                const pairs = (it && Array.isArray(it.pairs)) ? it.pairs : [];
                front += '<br><br>' + pairs.map(p=> `• ${p.left}`).join('<br>');
                back = pairs.map(p=> `${p.left} → ${p.right}`).join('<br>');
            } else {
                back = '';
            }

            rows.push(ankiEscape(front) + '\t' + ankiEscape(back));
        });
        return rows.join('\n');
    }

    (function wireAnkiExport(){
        function getParsedItems(){
            try{
                const st = (window.__quizState || window.state || window.__STATE__ || null);
                const items = st && Array.isArray(st.items) ? st.items : [];
                return items;
            }catch(e){ return []; }
        }
        function flashcardsToItems(deck){
            try{
                return (deck || []).map((c, idx)=>{
                    const num = (c && c.id != null) ? c.id : (idx+1);
                    const q = String(c && c.q ? c.q : '').trim();
                    const choices = (c && Array.isArray(c.choices)) ? c.choices.slice() : [];
                    const a = String(c && c.a ? c.a : '').trim();
                    if(choices.length){
                        let ci = choices.findIndex(ch => String(ch||'').trim() === a);
                        if(ci < 0) ci = 0;
                        return { num, q, type: 'mcq', choices, correctIdx: ci };
                    }
                    // If we don't have choices, treat it as a basic front/back card.
                    return { num, q, type: 'fillblank', answers: a ? [a] : [] };
                }).filter(it => it && it.q);
            }catch(e){ return []; }
        }

        window.exportAnkiTsvFromParsed = function(){
            try{
                let items = getParsedItems();
                // Fallback: if the Flashcards deck is loaded, export from it.
                if(!items || !items.length){
                    const deck = window.__flashcardsDeck;
                    if(deck && Array.isArray(deck) && deck.length){
                        items = flashcardsToItems(deck);
                    }
                }
                if(!items || !items.length){ alert('Nothing to export. Parse a document first.'); return; }
                const tsv = toAnkiTsv(items);
                const name = `anki-export-${(new Date()).toISOString().replace(/[:.]/g,'-')}.tsv`;
                downloadBlob(new Blob([tsv], { type:'text/tab-separated-values;charset=utf-8' }), name);
            }catch(e){
                console.error('anki export failed', e);
                alert('Anki export failed: ' + (e && e.message ? e.message : e));
            }
        };

        // Backward compat: if an export button exists elsewhere, wire it.
        const btn = $('exportAnkiBtn');
        if(btn) btn.addEventListener('click', window.exportAnkiTsvFromParsed);
    })();

    // ---------- Self Test diagnostics ----------
    (function wireSelfTest(){
        const btn = $('selfTestBtn');
        const logEl = $('selfTestLog');
        if(!btn || !logEl) return;
        function log(line){
            try{ logEl.style.display = 'block'; }catch(e){}
            const msg = String(line||'');
            try{ logEl.textContent += (msg + '\n'); }catch(e){}
        }
        function clear(){ try{ logEl.textContent = ''; logEl.style.display = 'block'; }catch(e){} }

        btn.addEventListener('click', async ()=>{
            clear();
            log('Self Test — ' + (new Date()).toLocaleString());
            // localStorage
            try{ localStorage.setItem('__selftest', '1'); localStorage.removeItem('__selftest'); log('localStorage: OK'); }catch(e){ log('localStorage: FAIL (' + (e && e.message ? e.message : e) + ')'); }
            // indexedDB
            try{ await idbGetAllBooks('pdf-toc-lib'); log('indexedDB (pdf-toc-lib): OK'); }catch(e){ log('indexedDB (pdf-toc-lib): WARN (' + (e && e.message ? e.message : e) + ')'); }
            // perf/news hook
            // parse + lint
            try{
                const sample = 'Q1. Sample question?\nA. One\nB. Two\nAnswer Key\n1. A';
                const fn = (typeof window.parseDoc === 'function') ? window.parseDoc : null;
                if(!fn){ log('parseDoc: missing'); }
                else {
                    const items = fn(sample);
                    log('parseDoc: OK (' + (items && items.length ? items.length : 0) + ' item(s))');
                    const lint = computeLint(items);
                    log('lint: ' + (lint.errors.length) + ' error(s), ' + (lint.warns.length) + ' warning(s)');
                }
            }catch(e){ log('parse/lint: FAIL (' + (e && e.message ? e.message : e) + ')'); }
        });
    })();

    // ---------- Basic modal accessibility (Escape close + focus trap) ----------
    function getOpenModal(){
        // Prefer explicit modal class, then legacy skipped modal
        try{ const m = document.querySelector('.modal:not(.hidden)'); if(m) return m; }catch(e){}
        try{ const s = $('skippedModal'); if(s && !hasClass(s,'hidden')) return s; }catch(e){}
        return null;
    }
    function focusables(root){
        try{
            const sel = 'a[href], button:not([disabled]), textarea:not([disabled]), input:not([disabled]), select:not([disabled]), [tabindex]:not([tabindex="-1"])';
            return Array.from(root.querySelectorAll(sel)).filter(el=>{
                try{ return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length); }catch(e){ return false; }
            });
        }catch(e){ return []; }
    }
    function closeModal(modal){
        if(!modal) return;
        // Try common close buttons first
        let btn = null;
        try{ btn = modal.querySelector('button[id$="Close"], button[id*="close"], button[aria-label*="Close"], button[aria-label*="close"]'); }catch(e){}
        if(btn){ try{ btn.click(); return; }catch(e){} }
        try{ modal.classList.add('hidden'); }catch(e){}
    }

    document.addEventListener('keydown', (e)=>{
        try{
            const modal = getOpenModal();
            if(!modal) return;

            if(e.key === 'Escape'){
                e.preventDefault();
                closeModal(modal);
                return;
            }
            if(e.key === 'Tab'){
                const els = focusables(modal);
                if(!els.length) return;
                const active = document.activeElement;
                if(active && !modal.contains(active)){
                    els[0].focus();
                    e.preventDefault();
                    return;
                }
                const first = els[0];
                const last = els[els.length - 1];
                if(e.shiftKey && active === first){ last.focus(); e.preventDefault(); return; }
                if(!e.shiftKey && active === last){ first.focus(); e.preventDefault(); return; }
            }
        }catch(err){}
    }, true);

})();
</script>